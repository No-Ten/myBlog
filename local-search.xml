<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>快速搭建个人电子书Gitbook并部署到GitHub Pages和Nginx</title>
    <link href="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/"/>
    <url>/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/</url>
    
    <content type="html"><![CDATA[<h1 id="快速搭建个人电子书Gitbook并部署到GitHub-Pages和Nginx"><a href="#快速搭建个人电子书Gitbook并部署到GitHub-Pages和Nginx" class="headerlink" title="快速搭建个人电子书Gitbook并部署到GitHub Pages和Nginx"></a>快速搭建个人电子书Gitbook并部署到GitHub Pages和Nginx</h1><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul><li><a href="https://nodejs.org/en/">nodejs</a></li><li><a href="https://git-scm.com/">git</a></li><li><a href="https://github.com/">GitHub账号</a></li><li>Markdown编辑器，这里推荐<a href="https://www.typora.net/">Typora</a></li></ul><p>以上准备好之后就可以开始搭建了。</p><h1 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h1><h2 id="全局安装gitbook-cli工具"><a href="#全局安装gitbook-cli工具" class="headerlink" title="全局安装gitbook-cli工具"></a>全局安装gitbook-cli工具</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install gitbook-cli -g</code></pre></div><p>检查版本</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitbook --version</code></pre></div><p>如果出现版本号，说明安装成功。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">CLI version: 2.3.2GitBook version: 3.2.3</code></pre></div><p>如果有报类型找不到的错误，可能是nodejs的版本过高导致的，可以将版本，我这里用的是nodejs 12+的。</p><h2 id="本地初始化一本电子书"><a href="#本地初始化一本电子书" class="headerlink" title="本地初始化一本电子书"></a>本地初始化一本电子书</h2><p>创建目录</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir gitbookcd gitbook</code></pre></div><p>初始化电子书</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitbook init</code></pre></div><p>成功之后会如下</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\temp\gitbook&gt;gitbook initwarn: no summary file in this bookinfo: create README.mdinfo: create SUMMARY.mdinfo: initialization is finishedE:\temp\gitbook&gt;</code></pre></div><p>README.md为简介文档，SUMMARY.md为所要创建的电子书的目录文档，自动生成。</p><h2 id="SUMMARY-md文件的格式"><a href="#SUMMARY-md文件的格式" class="headerlink" title="SUMMARY.md文件的格式"></a>SUMMARY.md文件的格式</h2><p>目录的Markdown语法格式如下</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">* [第一章](doc&#x2F;第一章&#x2F;第一章.md)  * [第一节](doc&#x2F;第一章&#x2F;第一节.md)  * [第二节](doc&#x2F;第一章&#x2F;第二节.md)* [第二章](doc&#x2F;第二章&#x2F;第二章.md)  * [第一节](doc&#x2F;第二章&#x2F;第一节.md)    * [第一节的小节](doc&#x2F;第二章&#x2F;第一节&#x2F;第一节的小节.md)  * [第二节](doc&#x2F;第二章&#x2F;第二节.md)</code></pre></div><p>效果如下</p><p><img src="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/image-20220717161114018.png" alt="目录结构"></p><h2 id="生成电子书"><a href="#生成电子书" class="headerlink" title="生成电子书"></a>生成电子书</h2><p>由于上面我们自定义了电子书的目录，所以现在需要重新初始化一下</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitbook init</code></pre></div><p>如下。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\temp\gitbook&gt;gitbook initinfo: create doc&#x2F;第一章&#x2F;第一章.mdinfo: create doc&#x2F;第一章&#x2F;第一节.mdinfo: create doc&#x2F;第一章&#x2F;第二节.mdinfo: create doc&#x2F;第二章&#x2F;第二章.mdinfo: create doc&#x2F;第二章&#x2F;第一节.mdinfo: create doc&#x2F;第二章&#x2F;第一节&#x2F;第一节的小节.mdinfo: create doc&#x2F;第二章&#x2F;第二节.mdinfo: create SUMMARY.mdinfo: initialization is finishedE:\temp\gitbook&gt;</code></pre></div><p>启动电子书，在本地测试。访问<a href="http://localhost:4000进行测试，如果你想指定端口可以执行">http://localhost:4000进行测试，如果你想指定端口可以执行</a> gitbook serve –port 8888</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gitbook serve</code></pre></div><p>效果如下，到这里一本电子书已经搭建完毕了，剩下的就是尽情挥洒你的文笔了。</p><p><img src="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/image-20220717161552070.png" alt="本地运行效果图"></p><h2 id="文档打包"><a href="#文档打包" class="headerlink" title="文档打包"></a>文档打包</h2><p>可以使用gitbook build打包你的项目</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\temp\gitbook&gt;gitbook buildinfo: 7 plugins are installedinfo: 6 explicitly listedinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 8 pagesinfo: found 7 asset filesinfo: &gt;&gt; generation finished with success in 1.1s !E:\temp\gitbook&gt;</code></pre></div><p>这时会生成一个_book的文件，这个文件就是生成的静态网页，如果是部署到自己的云服务器，直接拿这个文件去部署即可，入口为index.html。</p><h1 id="部署到GitHub-Pages"><a href="#部署到GitHub-Pages" class="headerlink" title="部署到GitHub Pages"></a>部署到GitHub Pages</h1><h2 id="在GitHub上面创建一个repository"><a href="#在GitHub上面创建一个repository" class="headerlink" title="在GitHub上面创建一个repository"></a>在GitHub上面创建一个repository</h2><p>这个仓库主要是存储你的项目和部署项目用到。</p><h2 id="将本地项目推到GitHub"><a href="#将本地项目推到GitHub" class="headerlink" title="将本地项目推到GitHub"></a>将本地项目推到GitHub</h2><p>编写一个.gitignore文件，忽略_book文件</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 忽略gitbook生成的项目目录_book</code></pre></div><p>依次执行下面的代码，将项目推到GitHub</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git initgit add .git commit -m &quot;first commit&quot;git remote add origin https:你自己的仓库地址git push -u origin mastergit initgit add .git commit -m &quot;first commit&quot;git remote add origin git@github.com:No-Ten&#x2F;testGitBook.gitgit push -u origin master</code></pre></div><p>执行完上面的命令之后，你的项目就会在GitHub上面啦</p><h2 id="生成项目并推到GitHub的pages分支上"><a href="#生成项目并推到GitHub的pages分支上" class="headerlink" title="生成项目并推到GitHub的pages分支上"></a>生成项目并推到GitHub的pages分支上</h2><p>这里为了便捷，直接编写了一个脚本deploy.sh执行，也可以手动输入。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;执行命令：gitbook build .&#39;gitbook build .# 进入_book文件echo &quot;执行命令：cd .&#x2F;_book\n&quot;cd .&#x2F;_book# 将_book初始化为git的仓库，方便推送到GitHub上面echo &quot;执行命令：git init&quot;git init# 保存所有的修改echo &quot;执行命令：git add .&quot;git add .# 把修改的文件提交echo &quot;执行命令：git commit -m &#39;deploy&#39;&quot;git commit -m &quot;deploy&quot;# 发布echo &quot;执行命令：git push -f 自己的仓库地址 master:gh-pages&quot;git push -f https:&#x2F;&#x2F;github.com&#x2F;xxxx&#x2F;xxx.git master:gh-pages# 返回上一级目录echo &quot;回到刚才工作目录&quot;cd -</code></pre></div><p>文件保存之后，在终端下面执行，需要再git bash下面执行。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bash deploy.sh</code></pre></div><p>执行成功之后，如果在GitHub上面看到有index.html说明已经成功了。</p><h2 id="设置GitHub-pages访问路径"><a href="#设置GitHub-pages访问路径" class="headerlink" title="设置GitHub pages访问路径"></a>设置GitHub pages访问路径</h2><p>在github网站上的仓库里面点击<code>Settings</code> -&gt; <code>GitHub Pages</code>选项中 -&gt; <code>Source</code>里面选择<code>gh-pages branch</code> 然后点击<code>Save</code>按钮，然后在<code>GitHub Pages</code>下面就会看见一个网址，这个网址就是最终的网站。<br>最终效果如下图所示：</p><p><img src="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/image-20220717165337372.png" alt="image-20220717165337372"></p><p>我这里了的GitHub pages的路径是自动设置好了，所以直接访问即可。到这里属于自己的电子书就搭建完成了，尽情享受吧！！！</p><h1 id="gitbook的一些实用插件"><a href="#gitbook的一些实用插件" class="headerlink" title="gitbook的一些实用插件"></a>gitbook的一些实用插件</h1><p>这里不多说，直接上链接。</p><p><a href="https://segmentfault.com/a/1190000019806829">https://segmentfault.com/a/1190000019806829</a></p><h1 id="利用Nginx部署到本地或者远程服务器"><a href="#利用Nginx部署到本地或者远程服务器" class="headerlink" title="利用Nginx部署到本地或者远程服务器"></a>利用Nginx部署到本地或者远程服务器</h1><p>下载<a href="http://nginx.org/">Nginx</a></p><p>下载好后再Nginx的conf文件夹里面找到nginx.conf文件，在server 添加一个监听</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server&#123;listen       4000;server_name  localhost;location  &#x2F;gitbook &#123;alias  E:&#x2F;temp&#x2F;gitbook&#x2F;_book;index index.html index.html;autoindex on;&#125;&#125;</code></pre></div><p>启动nginx ，双击nginx会闪退，可以在Nginx当前目录打开终端，执行下面的命令</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx.exe</code></pre></div><p>停止Nginx</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nginx -s stop</code></pre></div><p>访问测试，一般的Nginx都是80端口，可以直接访问localhost就可以看到nginx的页面了</p><p><img src="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/image-20220717170420677.png" alt="image-20220717170420677"></p><p>加上我们gitbook的路径localhost:4000/gitbook</p><p><img src="/myBlog/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%94%B5%E5%AD%90%E4%B9%A6Gitbook%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHubPages%E5%92%8CNginx/image-20220717170530050.png" alt="image-20220717170530050"></p><p>到这里，利用Nginx部署就完成了，远程的一样，稍微修改一下即可。</p>]]></content>
    
    
    <categories>
      
      <category>快速搭建个人电子书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速搭建个人电子书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postgresql笔记</title>
    <link href="/myBlog/postgresql%E7%AC%94%E8%AE%B0/"/>
    <url>/myBlog/postgresql%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="postgresql笔记"><a href="#postgresql笔记" class="headerlink" title="postgresql笔记"></a>postgresql笔记</h1><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>postgresql数据库的主要特点如下：</p><ul><li>免费</li><li>速度快</li><li>平台可移植行</li><li>丰富的接口</li><li>面向对象特性</li><li>安全性</li><li>配合的开源软件很多</li></ul><h1 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h1><h1 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h1><p>.run包，直接运行</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps aux | grep postgresql.&#x2F;pg_ctl stop -D &#x2F;PostgreSQL&#x2F;9.3&#x2F;data# 关闭服务.&#x2F;pg_ctl start -D &#x2F;PostgreSQL&#x2F;9.3&#x2F;data -l &#x2F;PostgreSQL&#x2F;9.3&#x2F;data&#x2F;server.log# 启动服务</code></pre></div><h1 id="pgAdmin客户端工具使用"><a href="#pgAdmin客户端工具使用" class="headerlink" title="pgAdmin客户端工具使用"></a>pgAdmin客户端工具使用</h1><h1 id="使用pgAdmin工具操作数据库对象"><a href="#使用pgAdmin工具操作数据库对象" class="headerlink" title="使用pgAdmin工具操作数据库对象"></a>使用pgAdmin工具操作数据库对象</h1><p>略</p><h1 id="利用sql语言操作数据库对象"><a href="#利用sql语言操作数据库对象" class="headerlink" title="利用sql语言操作数据库对象"></a>利用sql语言操作数据库对象</h1><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create database db_pg;create database db_pg1;alter database db_pg rename to db_pg2;alter database db_pg2 connection limit 20;drop database db_pg1;drop database db_pg2;</code></pre></div><p>报错，先断开连接，再修改或者删除</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">ERROR:  database &quot;db_pg&quot; is being accessed by other usersDETAIL:  There are 2 other sessions using the database.SQL 状态: 55006</code></pre></div><h1 id="利用sql语言操作数据表对象"><a href="#利用sql语言操作数据表对象" class="headerlink" title="利用sql语言操作数据表对象"></a>利用sql语言操作数据表对象</h1><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table student(id int,name varchar(10),birthday date,score numeric(5,2));alter table student rename to student1;alter table student1 rename id to bh;alter table student1 alter column name type varchar(30);alter table student1 drop column birthday;alter table student1 add column address varchar(100);drop table student1;drop table if exists student1;</code></pre></div><h1 id="postgresql常用数据类型"><a href="#postgresql常用数据类型" class="headerlink" title="postgresql常用数据类型"></a>postgresql常用数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>整数类型：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SMALLINT &#x2F;&#x2F; 小范围整数，取值范围：-32768~32767INT(INTEGER) &#x2F;&#x2F; 普通大小整数-2147483648~2147483647</code></pre></div><p>任意精度浮点数类型</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">REAL&#x2F;&#x2F; 6位十进制数字精度NUMERIC(m,n) &#x2F;&#x2F; 任意精度类型 m表示字段长度，n表示精度，假如m为5的时候，1000.00会报错，而100.00不会，但是100.888没事，结果显示的是100.89</code></pre></div><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table temp(x smallint,y int,z real,n numeric(5,2));insert into temp values(1,2,4.11,100.00);insert into temp values(1,2,4.11,1000.00);insert into temp values(1,2,4.11,100.888);select * from temp;</code></pre></div><p>ERROR:  numeric field overflow DETAIL:  A field with precision 5, scale 2 must round to an absolute value less than 10^3. SQL 状态: 22003</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522215639687.png" alt="image-20220522215639687"></p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522215916892.png" alt="image-20220522215916892"></p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from concat( &#39;(&#39;, ch, &#39;)&#39;),concat( &#39;(&#39;, vch, &#39;)&#39;),concat( &#39;(&#39;, t, &#39;)&#39;),from temp3;</code></pre></div><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522220245838.png" alt="image-20220522220245838"></p><h2 id="选择正确的数据类型"><a href="#选择正确的数据类型" class="headerlink" title="选择正确的数据类型"></a>选择正确的数据类型</h2><p>主要目的：优化存储区，提高数据库性能</p><ul><li>正确使用整数类型和浮点数类型</li><li>日期与时间类型</li><li>CHAR与VARCHAR之间的特点与选择</li></ul><p>char：固定长度，不足的后面会以空格补齐，检索效率高</p><p>varchar：变长字符串，有长度限制，不足的不会以空格填充。</p><h1 id="postgresql运算符"><a href="#postgresql运算符" class="headerlink" title="postgresql运算符"></a>postgresql运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221142841.png" alt="image-20220522221142841"></p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221052364.png" alt="image-20220522221052364"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221350085.png" alt="image-20220522221350085"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221538254.png" alt="image-20220522221538254"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221812632.png" alt="image-20220522221812632"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522221923167.png" alt="image-20220522221923167"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522222214222.png" alt="image-20220522222214222"></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>NOT 逻辑非</strong></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522222445688.png" alt="image-20220522222445688"></p><p>1：真，y：真，0：假，n：假</p><p><strong>AND 逻辑与</strong></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522222631388.png" alt="image-20220522222631388"></p><p><strong>OR 逻辑或</strong></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522222820019.png" alt="image-20220522222820019"></p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522222926120.png" alt="image-20220522222926120"></p><h1 id="postgresql常用函数"><a href="#postgresql常用函数" class="headerlink" title="postgresql常用函数"></a>postgresql常用函数</h1><h2 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h2><h2 id="常用数值函数"><a href="#常用数值函数" class="headerlink" title="常用数值函数"></a>常用数值函数</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522223548170.png" alt="image-20220522223548170"></p><h2 id="常用的字符串函数"><a href="#常用的字符串函数" class="headerlink" title="常用的字符串函数"></a>常用的字符串函数</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522223746421.png" alt="image-20220522223746421"></p><h2 id="常用的日期和时间函数"><a href="#常用的日期和时间函数" class="headerlink" title="常用的日期和时间函数"></a>常用的日期和时间函数</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522223939888.png"></p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select e_no,e_name,e_hireDate,extract(year from e_hireDate), extract(month from e_hireDate),extract(day from e_hireDate) from employee;</code></pre></div><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>基本语法格式</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create function&#x2F;&#x2F; 声明创建函数add(integer,integer)&#x2F;&#x2F; 定义函数名称，参数类型returns integer &#x2F;&#x2F; 定义函数返回值AS &#39;select $1 + $2&#39;&#x2F;&#x2F; 定义函数体language sql&#x2F;&#x2F; 用以实现函数的语言的名字returns null on null input;&#x2F;&#x2F; 定义参数为null时处理情况</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create function add(integer,integer)returns integer as &#39;select $1 + $2;&#39;language sqlreturns null on null input;select add(1,2);</code></pre></div><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522225552973.png" alt="image-20220522225552973"></p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522225744971.png" alt="image-20220522225744971"></p><p>删除一个函数</p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522225853772.png" alt="image-20220522225853772"></p><h1 id="postgresql数据库索引"><a href="#postgresql数据库索引" class="headerlink" title="postgresql数据库索引"></a>postgresql数据库索引</h1><h2 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h2><p>提高检索的速度，相当于一本书的目录，可以根据目录快速找到想要找的内容。</p><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522230229558.png" alt="image-20220522230229558"></p><h2 id="索引的创建和删除"><a href="#索引的创建和删除" class="headerlink" title="索引的创建和删除"></a>索引的创建和删除</h2><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index emp_name_index on employee(e_name); &#x2F;&#x2F; 默认btree索引drop index emp_name_index;</code></pre></div><h2 id="使用索引的优点和缺点"><a href="#使用索引的优点和缺点" class="headerlink" title="使用索引的优点和缺点"></a>使用索引的优点和缺点</h2><p>优点：</p><ul><li>提高数据的查询速度</li><li>加速表与表之间的连接</li></ul><p>缺点：</p><ul><li>创建和维护索引需要耗费时间</li><li>需要占用磁盘空间</li></ul><h1 id="postgresql数据库视图"><a href="#postgresql数据库视图" class="headerlink" title="postgresql数据库视图"></a>postgresql数据库视图</h1><h2 id="视图的含义"><a href="#视图的含义" class="headerlink" title="视图的含义"></a>视图的含义</h2><p>避免每次多表查询的时候都要编写复杂的SQL语句，可以直接创建视图，下次需要用到的时候直接用创建好的视图即可，不用关注底层的细节。</p><h2 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h2><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522231404341.png" alt="image-20220522231404341"></p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select view v_emp_dev as select e_no, e_name,e_salary,e_hireDate from employee where dept_no &#x3D; 10 order by e_salary desc;&#x2F;&#x2F; 创建视图select * from v_emp_dev;&#x2F;&#x2F; 查看视图</code></pre></div><h2 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h2><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">drop view v_emp_dev;&#x2F;&#x2F; 删除视图</code></pre></div><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><ul><li>简单化</li><li>安全化</li><li>逻辑数据独立性</li></ul><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522232009234.png" alt="image-20220522232009234"></p><h1 id="简单数据插入操作"><a href="#简单数据插入操作" class="headerlink" title="简单数据插入操作"></a>简单数据插入操作</h1><p>向单表中插入数据</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table temp(x smallint,y int,z real,n numeric(5,2));insert into temp values(1,2,4.11,100.00);insert into temp (x,y,z) values (3,4,5.01);select * from temp;</code></pre></div><h1 id="数据批量插入操作"><a href="#数据批量插入操作" class="headerlink" title="数据批量插入操作"></a>数据批量插入操作</h1><p>利用insert批量插入数据</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into temp values(1,2,4.11,100.00),(2,2,4.11,100.00),(3,2,4.11,100.00); </code></pre></div><p>利用select批量插入数据</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into student_new select * from student;&#x2F;&#x2F; 向student_new的表格插入从student表查询出来的所有的内容</code></pre></div><p>利用select批量插入指定的属性</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into student_new (id,name) select id,name from student;</code></pre></div><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522233340471.png" alt="image-20220522233340471"></p><h1 id="数据更新操作"><a href="#数据更新操作" class="headerlink" title="数据更新操作"></a>数据更新操作</h1><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 指定条件更新数据update student set name &#x3D; &#39;zhangsan&#39; where id &#x3D; 1;# 批量更新数据update student set score &#x3D; 0;&#x2F;&#x2F; 将该表的score都改为0# 将指定结果更新到对应的字段update student set score &#x3D; 1.5 + 1 where id  &#x3D; &#39;1&#39;;</code></pre></div><h1 id="数据删除操作"><a href="#数据删除操作" class="headerlink" title="数据删除操作"></a>数据删除操作</h1> <div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">delete from student where id &#x3D; 1;delete from student where between &#39;1999-01-01&#39; and &#39;1999-02-01&#39;;delete from student;truncate table student_new;&#x2F;&#x2F; 清空这个表所有的数据 </code></pre></div><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220522234426234.png" alt="image-20220522234426234"></p><h1 id="postgresql数据表主键和外键"><a href="#postgresql数据表主键和外键" class="headerlink" title="postgresql数据表主键和外键"></a>postgresql数据表主键和外键</h1><h2 id="如何定义主键约束"><a href="#如何定义主键约束" class="headerlink" title="如何定义主键约束"></a>如何定义主键约束</h2><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table temp(id int primary key,&#x2F;&#x2F; 列级约束    name varchar(10),    salary numeric(5,2));</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table temp2(id int,    name varchar(10),    salary numeric(5,2),    constraint pk_temp primary key(id)&#x2F;&#x2F; 表级约束);</code></pre></div><h2 id="如何定义外键约束"><a href="#如何定义外键约束" class="headerlink" title="如何定义外键约束"></a>如何定义外键约束</h2><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table temp2(id int,    name varchar(10),    salary numeric(5,2),    tempId int,    constraint pk_temp foreign key(tempId) references temp(id));</code></pre></div><h2 id="主键约束和外键约束的作用"><a href="#主键约束和外键约束的作用" class="headerlink" title="主键约束和外键约束的作用"></a>主键约束和外键约束的作用</h2><p>主键约束作用：</p><ul><li>唯一标识一条记录</li><li>提高数据的检索效率</li></ul><p>外键约束作用：</p><ul><li>保证数据的完整性</li><li>提高数据的检索效率</li></ul><h1 id="postgresql数据表非空约束、唯一约束、默认值约束介绍"><a href="#postgresql数据表非空约束、唯一约束、默认值约束介绍" class="headerlink" title="postgresql数据表非空约束、唯一约束、默认值约束介绍"></a>postgresql数据表非空约束、唯一约束、默认值约束介绍</h1><p>非空约束：not null</p><p>唯一约束：unique</p><p>默认约束：default</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>维护数据的完整性</li><li>在业务面保证数据正确性</li></ul><h1 id="简单数据查询操作"><a href="#简单数据查询操作" class="headerlink" title="简单数据查询操作"></a>简单数据查询操作</h1><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523213256497.png" alt="image-20220523213256497"></p><h1 id="单表指定条件查询"><a href="#单表指定条件查询" class="headerlink" title="单表指定条件查询"></a>单表指定条件查询</h1><p>in</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from t where t_no in (20,30);</code></pre></div><p>between and </p><p>like</p><h1 id="单表指定条件复杂查询操作"><a href="#单表指定条件复杂查询操作" class="headerlink" title="单表指定条件复杂查询操作"></a>单表指定条件复杂查询操作</h1><p>查询空值内容</p><p>and、or多条件查询</p><p>查询结果集排序</p><p>limit关键字查询</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from t limit 5 offset 5;# 显示前5条，忽略5条，即忽略前5条，从第6条开始显示5条。</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from t limit 5 offset ((页码 -1) * 5);</code></pre></div><h1 id="多表复杂查询操作"><a href="#多表复杂查询操作" class="headerlink" title="多表复杂查询操作"></a>多表复杂查询操作</h1><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523221203068.png" alt="image-20220523221203068"></p><h1 id="子查询操作"><a href="#子查询操作" class="headerlink" title="子查询操作"></a>子查询操作</h1><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523222107785.png" alt="image-20220523222107785"></p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where exists (select d_no from dept where id_name &#x3D; &#39;开发部&#39;);# 如果exists后面的查询为真，则将结果为真传到前面的查询中，返回所有的结果。</code></pre></div><p>|| 拼接</p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523222007019.png" alt="image-20220523222007019"></p><h1 id="查询结果集合并操作"><a href="#查询结果集合并操作" class="headerlink" title="查询结果集合并操作"></a>查询结果集合并操作</h1><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523222220155.png" alt="image-20220523222220155"></p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from e where dept_no in (10,20)union allselect * from e where e_salary &gt; 5000;</code></pre></div><p>上面有重复的值，因为有数据是满足两个查询语句的。</p><p>如何避免？使用union即可。上下两个列需要一致，如果不存在可以用null占位。</p><p><img src="/myBlog/postgresql%E7%AC%94%E8%AE%B0/image-20220523222802433.png" alt="image-20220523222802433"></p>]]></content>
    
    
    <categories>
      
      <category>postgresql笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>postgresql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程</title>
    <link href="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h1 id="JUC-概述"><a href="#JUC-概述" class="headerlink" title="JUC 概述"></a>JUC 概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p><h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><ul><li>计算机中的程序关于某数据集合上的一次运行活动</li><li>进程是线程的容器</li><li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li><li>系统进行资源分配和调度的基本单位，是操作系统结构的基础</li></ul><h3 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h3><ul><li>操作系统能够进行运算调度的最小单位</li><li>被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流</li></ul><p>简单来说就是，进程是一个应用程序而线程就是一个应用程序里面的其他操作，一个应用程序可以包含多个线程。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程有5个状态，分别是NEW（新建）、RUNNABLE（准备就绪）、BLOCKED（阻塞）、WAITING（不见不散，一定得等到，不然不做其他的）、TIME-WAITING（过时不候：超过了时间就过去了）、TERMINATED（终结）。</p><h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><ol><li>sleep是Thead的静态方法，wait是Object里面的方法，wait可以被任意实例后的对象调用。</li><li>sleep不会释放锁，它也不需要占用锁，但是调用他的前提是当前线程占有锁（即需要再synchronize中）</li><li>他们都可以被interrupted中断。</li></ol><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发就是指在很短的一个时间段发生的事情，如到点抢票。</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行就是指在同一时刻发生的事情。</p><h3 id="管程Monitor"><a href="#管程Monitor" class="headerlink" title="管程Monitor"></a>管程Monitor</h3><p>管程Monitor，<strong>监视器</strong>，也就是我们所说的<strong>锁</strong>，它是一种同步机制，保证同一个时间只有一个线程访问被保护数据或者代码，jvm同步基于进入和退出，使用管程对象实现的。</p><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>自定义线程都是用户线程，主线程结束了，用户线程还在，jvm存活。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>系统特定的线程，比如垃圾回收，没有用户线程了，都是守护线程，jvm结束。</p><p><strong>测试用户进程和守护进程的代码</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DaemonAndUserProcess &#123;    public static void main(String[] args) &#123;        Thread aa &#x3D; new Thread(() -&gt; &#123;            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + Thread.currentThread().isDaemon());            while (true) &#123;            &#125;        &#125;, &quot;aa&quot;);        &#x2F;&#x2F; 设置线程为守护线程        aa.setDaemon(true);        aa.start();     &#x2F;&#x2F; 开启线程        System.out.println(Thread.currentThread().getName() + &quot; over&quot;);    &#125;&#125;</code></pre></div><h1 id="LOCK接口"><a href="#LOCK接口" class="headerlink" title="LOCK接口"></a>LOCK接口</h1><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>它是java中的关键字，是一种同步锁，它可以修饰以下几种：</p><ol><li>修改代码块，被修饰的代码块称为同步代码块，其作用范围就是大括号{}括起来的代码，作用对象就是调用这个代码的对象。</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用范围就是整个方法，作用的对象是调用这个方法的对象。</li><li>修饰静态方法</li><li>修饰一个类。</li></ol><h3 id="多线程编程步骤（上）"><a href="#多线程编程步骤（上）" class="headerlink" title="多线程编程步骤（上）"></a>多线程编程步骤（上）</h3><ol><li>创建资源类，编程属性和操作方法</li><li>创建多线程，调用资源类的方法</li></ol><h3 id="售票例子"><a href="#售票例子" class="headerlink" title="售票例子"></a>售票例子</h3><p>三个售票员，卖30张票</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.sync;&#x2F;&#x2F; 第一步：创建资源类，编写属性和操作方法class Ticket&#123;    &#x2F;&#x2F; 定义票的数量    private int number &#x3D; 30;    &#x2F;&#x2F; 定义操作方法：卖票，得加锁synchronized    public synchronized void sale()&#123;        &#x2F;&#x2F; 判断是否有剩余的票        if (number &gt; 0)&#123;            System.out.println(Thread.currentThread().getName() + &quot; : 卖出了：&quot; + (number--) + &quot; 剩余：&quot; + number);        &#125;    &#125;&#125;public class SaleTicket &#123;    &#x2F;&#x2F; 第二部：编写多线程，调用操作资源    public static void main(String[] args) &#123;        Ticket ticket &#x3D; new Ticket();        &#x2F;&#x2F; 创建三个线程，利用匿名内部类        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 编写操作                for (int i &#x3D; 0; i &lt; 40; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,&quot;AA&quot;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 编写操作                for (int i &#x3D; 0; i &lt; 40; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,&quot;BB&quot;).start();        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                &#x2F;&#x2F; 编写操作                for (int i &#x3D; 0; i &lt; 40; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;,&quot;CC&quot;).start();    &#125;&#125;</code></pre></div><h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><h3 id="什么是LOCK"><a href="#什么是LOCK" class="headerlink" title="什么是LOCK"></a>什么是LOCK</h3><p>LOCK锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。LOCK是一个类，可以通过这个类实现同步访问。</p><p><strong>LOCK和synchronized的不同</strong></p><ol><li>LOCK不是java内置的，synchronized是java语言的关键字。</li><li>LOCK需要用户手动去上锁和释放锁，synchronized不用，它会自动帮我们完成。</li><li>LOCK可以让等待的线程响应中断，而synchronized不能，使用synchronized的时候，需要一直等待下去，不能够响应中断</li><li>通过lock可以知道有没有成功上锁，而synchronized不行</li><li>lock可以提高多个线程读操作的效率。</li></ol><h3 id="ReentrantLock可重入锁"><a href="#ReentrantLock可重入锁" class="headerlink" title="ReentrantLock可重入锁"></a>ReentrantLock可重入锁</h3><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;import java.util.concurrent.locks.ReentrantLock;&#x2F;&#x2F; 第一步：创建资源类，别写属性和操作方法class LTicket&#123;    private int number &#x3D; 30;    &#x2F;&#x2F; 卖票：不用synchronized，用ReentrantLock    ReentrantLock lock &#x3D; new ReentrantLock();    public void sale()&#123;        &#x2F;&#x2F; 为了让释放锁无论怎么都执行，所以代码有try finally包裹起来        try &#123;            &#x2F;&#x2F; 上锁            lock.lock();           if(number &gt; 0)&#123;               System.out.println(Thread.currentThread().getName() + &quot; : 卖出了：&quot; + (number--) + &quot; 剩余：&quot; + number);           &#125;        &#125; finally &#123;            &#x2F;&#x2F; 释放锁            lock.unlock();        &#125;    &#125;&#125;public class LSaleTicket &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 第二步：创建多线程，调用操作方法        LTicket lTicket &#x3D; new LTicket();        &#x2F;&#x2F; 使用Lambda        new Thread(() -&gt; &#123;            for (int i &#x3D; 0; i &lt; 40; i++) &#123;                lTicket.sale();            &#125;        &#125;,&quot;AA&quot;).start();        new Thread(() -&gt; &#123;            for (int i &#x3D; 0; i &lt; 40; i++) &#123;                lTicket.sale();            &#125;        &#125;,&quot;BB&quot;).start();        new Thread(() -&gt; &#123;            for (int i &#x3D; 0; i &lt; 40; i++) &#123;                lTicket.sale();            &#125;        &#125;,&quot;CC&quot;).start();    &#125;&#125;</code></pre></div><h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><h2 id="多线程编程步骤（中、下）"><a href="#多线程编程步骤（中、下）" class="headerlink" title="多线程编程步骤（中、下）"></a>多线程编程步骤（中、下）</h2><p>第一步 创建资源类，在资源类中创建属性和编写操作方法</p><p>第二步 在资源类中操作方法</p><ol><li>判断</li><li>干活</li><li>通知</li></ol><p>第三步 创建多个线程，调用资源类的操作方法。</p><p>第四步 <strong>防止虚假唤醒问题</strong></p><h2 id="利用synchronized"><a href="#利用synchronized" class="headerlink" title="利用synchronized"></a>利用synchronized</h2><p>实现如下。</p><p><strong>测试代码</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.sync;&#x2F;&#x2F; 第一步：创建资源类，编写属性和操作方法class Share &#123;    private int number &#x3D; 0;    &#x2F;&#x2F; 定义两个方法，一个加一，一个减一    public synchronized void incr() throws InterruptedException &#123;        &#x2F;&#x2F; 判断        if(number !&#x3D; 0)&#123;            this.wait();    &#x2F;&#x2F; 如果不等于0，则等待，wait特点在哪里等待就在哪里开始执行        &#125;        &#x2F;&#x2F; 干活        &#x2F;&#x2F; 如果等于0了，加一        number++;        System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);        &#x2F;&#x2F; 通知        this.notifyAll();    &#125;    &#x2F;&#x2F; 减一    public synchronized void decr() throws InterruptedException &#123;        &#x2F;&#x2F; 判断        if (number !&#x3D; 1)&#123;            this.wait();        &#125;        &#x2F;&#x2F; 干活        number--;        System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);        &#x2F;&#x2F; 通知        this.notifyAll();    &#125;&#125;public class TheadDemo1 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 第二步：创建多线程，调用操作资源        Share share &#x3D; new Share();        new Thread(() -&gt; &#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;                try &#123;                    share.incr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;AA&quot;).start();        new Thread(() -&gt; &#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;                try &#123;                    share.decr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;BB&quot;).start();    &#125;&#125;</code></pre></div><p><strong>如果把上述的代码的多线程，再加两个CC和DD，则会出现不是1,0的结果。原因就是wait的特点是在哪里开始等待的就在哪里开始，wait需要用到循环中，即把if改成while循环，这个过程就是虚假唤醒。</strong></p><h2 id="用LOCK实现代码"><a href="#用LOCK实现代码" class="headerlink" title="用LOCK实现代码"></a><strong>用LOCK实现代码</strong></h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Share &#123;    private int number &#x3D; 0;    &#x2F;&#x2F; 利用LOCK实现    private Lock lock &#x3D; new ReentrantLock();    private Condition condition &#x3D; lock.newCondition();    &#x2F;&#x2F; +1    public void incr() throws InterruptedException &#123;        &#x2F;&#x2F; 上锁        lock.lock();        try &#123;            &#x2F;&#x2F; 判断 干活 通知            while (number !&#x3D; 0)&#123;                condition.await();            &#125;            number++;            System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);            condition.signalAll();        &#125; finally &#123;            &#x2F;&#x2F; 解锁            lock.unlock();        &#125;    &#125;    &#x2F;&#x2F; -1    public void decr() throws InterruptedException &#123;        &#x2F;&#x2F; 上锁        lock.lock();        try &#123;            &#x2F;&#x2F; 判断 干活 通知            while (number !&#x3D; 1)&#123;                condition.await();            &#125;            number--;            System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);            condition.signalAll();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;public class ThreadDemo2 &#123;    public static void main(String[] args) &#123;        Share share &#x3D; new Share();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;                try &#123;                    share.incr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;AA&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;                try &#123;                    share.decr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;BB&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;                try &#123;                    share.incr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;CC&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;                try &#123;                    share.decr();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;DD&quot;).start();    &#125;&#125;</code></pre></div><h1 id="线程间定制化通信"><a href="#线程间定制化通信" class="headerlink" title="线程间定制化通信"></a>线程间定制化通信</h1><p> <img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304115504390.png" alt="image-20220304115504390"></p><p>实现代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;&#x2F;&#x2F; 第一步：创建资源类class ShareResource &#123;    &#x2F;&#x2F; 标志位    private int flag &#x3D; 1;   &#x2F;&#x2F; 1:AA,2:BB,3:CC    &#x2F;&#x2F; 创建LOCK    private Lock lock &#x3D; new ReentrantLock();    &#x2F;&#x2F; 创建三个condition    private Condition c1 &#x3D;lock.newCondition();    private Condition c2 &#x3D;lock.newCondition();    private Condition c3 &#x3D;lock.newCondition();    &#x2F;&#x2F; 输出5次，loop为轮数    public void print5(int loop) throws InterruptedException &#123;        &#x2F;&#x2F; 上锁        lock.lock();        try &#123;            &#x2F;&#x2F; 判断 干活 通知            while (flag !&#x3D; 1)&#123;                c1.await();            &#125;            for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i+ &quot;: 轮数：&quot; +loop);            &#125;            &#x2F;&#x2F; 通知之前先修改标志位            flag &#x3D; 2;            &#x2F;&#x2F; 通知BB            c2.signal();        &#125; finally &#123;            &#x2F;&#x2F; 解锁            lock.unlock();        &#125;    &#125;    &#x2F;&#x2F; 输出10次，loop为轮数    public void print10(int loop) throws InterruptedException &#123;        lock.lock();        try &#123;            &#x2F;&#x2F; 判断 干活 通知            while (flag !&#x3D; 2)&#123;                c2.await();            &#125;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i + &quot;: 轮数：&quot; +loop);            &#125;            &#x2F;&#x2F; 通知之前先修改标志位            flag &#x3D; 3;            &#x2F;&#x2F; 通知CC            c3.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;    &#x2F;&#x2F; 输出15次，loop为轮数    public void print15(int loop) throws InterruptedException &#123;        lock.lock();        try &#123;            &#x2F;&#x2F; 判断 干活 通知            while (flag !&#x3D; 3)&#123;                c3.await();            &#125;            for (int i &#x3D; 1; i &lt;&#x3D; 15; i++) &#123;                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i + &quot;: 轮数：&quot; +loop);            &#125;            &#x2F;&#x2F; 通知之前先修改标志位            flag &#x3D; 1;            &#x2F;&#x2F; 通知AA            c1.signal();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;public class ThreadDemo3 &#123;    public static void main(String[] args) &#123;        ShareResource shareResource &#x3D; new ShareResource();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;                try &#123;                    shareResource.print5(i);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;AA&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;                try &#123;                    shareResource.print10(i);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;BB&quot;).start();        new Thread(()-&gt;&#123;            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;                try &#123;                    shareResource.print15(i);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,&quot;CC&quot;).start();    &#125;&#125;</code></pre></div><h1 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h1><h2 id="ArrayList异常演示"><a href="#ArrayList异常演示" class="headerlink" title="ArrayList异常演示"></a>ArrayList异常演示</h2><p>下面以list集合演示线程不安全的情况，会出现ConcurrentModificationException并发修改异常。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;import java.util.ArrayList;import java.util.List;import java.util.UUID;&#x2F;** * list线程不安全的演示 *&#x2F;public class ThreadDemo4 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建list集合        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 0; i &lt; 30; i++)&#123;            new Thread(() -&gt;&#123;                &#x2F;&#x2F; 生成随机数并添加到集合                list.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(list);            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>为什么会出现这个异常，通过观察list.add的源码可以发现，list.add方没有synchronized修饰，即没有加锁。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;) *&#x2F;public boolean add(E e) &#123;    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!    elementData[size++] &#x3D; e;    return true;&#125;</code></pre></div><h3 id="解决方案-Vector"><a href="#解决方案-Vector" class="headerlink" title="解决方案-Vector"></a>解决方案-Vector</h3><p>将上述的 List<String> list = new ArrayList&lt;&gt;();换成List<String> list = new Vector&lt;&gt;(); 再次进行测试，就不会报错了。通过观察Vector的源代码可以发现，add方法是有synchronized关键字修饰的，所以可以多线程修改。</String></String></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized void addElement(E obj) &#123;    modCount++;    ensureCapacityHelper(elementCount + 1);    elementData[elementCount++] &#x3D; obj;&#125;</code></pre></div><h3 id="解决方案-Collections"><a href="#解决方案-Collections" class="headerlink" title="解决方案-Collections"></a>解决方案-Collections</h3><p>将list集合换成List<String> list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 再次进行测试也可以实现，但是以上两种都是比较古老的实现方式，实际上不经常用。</String></p><h3 id="解决方案-CopyOnWriteArrayList"><a href="#解决方案-CopyOnWriteArrayList" class="headerlink" title="解决方案-CopyOnWriteArrayList"></a>解决方案-CopyOnWriteArrayList</h3><p>比较常用的多线程数组就是CopyOnWriteArrayList，他的实现的原理就是并发读，写的时候复制旧的数组内容，写完的时候再合并在一起。他的源码如下。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) *&#x2F;public boolean add(E e) &#123;    final ReentrantLock lock &#x3D; this.lock;    lock.lock();&#x2F;&#x2F; 上锁    try &#123;        Object[] elements &#x3D; getArray();&#x2F;&#x2F; 获取数组        int len &#x3D; elements.length;&#x2F;&#x2F; 数组长度        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);&#x2F;&#x2F; 创建新的数组        newElements[len] &#x3D; e;&#x2F;&#x2F; 写入新元素        setArray(newElements);&#x2F;&#x2F; 合并        return true;    &#125; finally &#123;        lock.unlock();&#x2F;&#x2F; 解锁    &#125;&#125;</code></pre></div><p><strong>上述三种方案的所有代码</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;import java.util.*;import java.util.concurrent.CopyOnWriteArrayList;&#x2F;** * list线程不安全的演示 *&#x2F;public class ThreadDemo4 &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建list集合        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; new Vector&lt;&gt;();   &#x2F;&#x2F; 利用Vector解决        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());  &#x2F;&#x2F; 用Collections解决        List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();   &#x2F;&#x2F; 用CopyOnWriteArrayList解决        for (int i &#x3D; 0; i &lt; 30; i++)&#123;            new Thread(() -&gt;&#123;                &#x2F;&#x2F; 生成随机数并添加到集合                list.add(UUID.randomUUID().toString().substring(0,8));                System.out.println(list);            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h2 id="HashSet异常演示"><a href="#HashSet异常演示" class="headerlink" title="HashSet异常演示"></a>HashSet异常演示</h2><p>以下代码也产生了并发修改异常</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 演示HashSet线程不安全问题Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();for (int i &#x3D; 0; i &lt; 30; i++) &#123;    new Thread(() -&gt; &#123;        &#x2F;&#x2F; 生成随机数并添加到集合        set.add(UUID.randomUUID().toString().substring(0, 8));        System.out.println(set);    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><h3 id="解决方案-CopyOnWriteArraySet"><a href="#解决方案-CopyOnWriteArraySet" class="headerlink" title="解决方案-CopyOnWriteArraySet"></a>解决方案-CopyOnWriteArraySet</h3><p>把set集合换成这个Set<String> set = new CopyOnWriteArraySet&lt;&gt;();就可以解决了</String></p><h2 id="HashMap异常演示"><a href="#HashMap异常演示" class="headerlink" title="HashMap异常演示"></a>HashMap异常演示</h2><p>以下代码也产生了并发修改异常</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 演示HashMap线程不安全问题Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();for (int i &#x3D; 0; i &lt; 30; i++) &#123;    String key &#x3D; String.valueOf(i);    new Thread(() -&gt; &#123;        &#x2F;&#x2F; 生成随机数并添加到集合        map.put(key,UUID.randomUUID().toString().substring(0, 8));        System.out.println(map);    &#125;, String.valueOf(i)).start();&#125;</code></pre></div><h3 id="解决方案-ConcurrentHashMap"><a href="#解决方案-ConcurrentHashMap" class="headerlink" title="解决方案-ConcurrentHashMap"></a>解决方案-ConcurrentHashMap</h3><p>将Map&lt;String,String&gt; map = new HashMap&lt;&gt;();换成Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;(); 利用ConcurrentHashMap解决。</p><h1 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>synchronized</strong></p><p>锁的是当前对象this</p><p><strong>static synchronized</strong></p><p>锁的是当前的Class。</p><p><strong>synchronized实现同步的基础</strong>：Java中的每一个对象都可以作为锁，具体表现为以下3中形式。</p><p>对于普通同步方法，锁是当前实例对象。</p><p>对于静态同步方法，锁是当前类的Class对象。</p><p>对于同步方法快，锁是synchronized括号里配置的对象。</p><h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>非公平锁可能会出现线程饿死的情况，它的效率高。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁阳光普照，不会出现线程饿死的情况，但是它每次都要询问是否有人占用资源，所以它的效率较低。</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>通过查看ReentrantLock的源代码可以发现，在创建ReentrantLock的时候传入一个Boolean类型的参数即可，true为公平锁，false为非公平锁。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * Creates an instance of &#123;@code ReentrantLock&#125;. * This is equivalent to using &#123;@code ReentrantLock(false)&#125;. *&#x2F;public ReentrantLock() &#123;    sync &#x3D; new NonfairSync();&#125;&#x2F;** * Creates an instance of &#123;@code ReentrantLock&#125; with the * given fairness policy. * * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy *&#x2F;public ReentrantLock(boolean fair) &#123;    sync &#x3D; fair ? new FairSync() : new NonfairSync();&#125;</code></pre></div><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁也叫做<strong>递归锁</strong>，synchronized和lock都是可重入锁，<strong>synchronized</strong>是<strong>隐式</strong>的，<strong>lock</strong>是<strong>显式</strong>的。</p><h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized的实现代码如下，外层开锁，里面的随便进入。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;public class SyncLockDemo &#123;&#x2F;&#x2F;public synchronized void add()&#123;    &#x2F;&#x2F;    add();   &#x2F;&#x2F; &#125;    public static void main(String[] args) &#123;      &#x2F;&#x2F;  new SyncLockDemo().add();        Object o &#x3D; new Object();        new Thread(() -&gt; &#123;            synchronized (o) &#123;                System.out.println(Thread.currentThread().getName() + &quot;外层&quot;);                synchronized (o) &#123;                    System.out.println(Thread.currentThread().getName() + &quot;中层&quot;);                    synchronized (o) &#123;                        System.out.println(Thread.currentThread().getName() + &quot;内层&quot;);                    &#125;                &#125;            &#125;        &#125;, &quot;t1&quot;).start();    &#125;&#125;</code></pre></div><h3 id="LOCK实现"><a href="#LOCK实现" class="headerlink" title="LOCK实现"></a>LOCK实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SyncLockDemo &#123;    public static void main(String[] args) &#123;        Lock lock &#x3D; new ReentrantLock();        new Thread(()-&gt;&#123;            try &#123;                &#x2F;&#x2F; 上锁                lock.lock();                System.out.println(Thread.currentThread().getName()+&quot;外层&quot;);                try &#123;                    &#x2F;&#x2F; 上锁                    lock.lock();                    System.out.println(Thread.currentThread().getName()+&quot;内层&quot;);                &#125; finally &#123;                    &#x2F;&#x2F; 解锁                    lock.unlock();                &#125;            &#125; finally &#123;                &#x2F;&#x2F; 解锁                lock.unlock();            &#125;        &#125;,&quot;AA&quot;).start();    &#125;&#125;</code></pre></div><p>所有的锁操作都要上锁和解锁，如果上述代码中的内层只上锁，没有解锁，只有他一个线程也可以运行，但是如果再加一个线程就不可以了，原因就是内层的锁没有释放，另一个线程继续等待锁。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>两个或者两个以上的进程在执行过程中，因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，他们无法在继续执行下去。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304150459745.png" alt="image-20220304150459745"></p><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol><li>系统资源不足</li><li>进程推进顺序不合适</li><li>资源分配不当</li></ol><h3 id="验证是否是死锁"><a href="#验证是否是死锁" class="headerlink" title="验证是否是死锁"></a>验证是否是死锁</h3><p>使用以下命令</p><ol><li><strong>jps -l</strong>：查出线程号，类似Linux的 ps -ef</li><li><strong>jstack+线程号</strong>：jvm自带堆栈跟踪工具</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\IdeaProject_code\juc&gt;jps -l11776 sun.tools.jps.Jps8704 com.ten.juc.sync.DeadLock1142014572 org.jetbrains.jps.cmdline.LauncherE:\IdeaProject_code\juc&gt;jstack 87042022-03-04 15:26:01Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):&quot;DestroyJavaVM&quot; #14 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00000000032a2800 nid&#x3D;0x3a88 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE&quot;A&quot; #13 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001aa58000 nid&#x3D;0x368c waiting for monitor entry [0x000000001b43f000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.ten.juc.sync.DeadLock.lambda$main$1(DeadLock.java:35)        - waiting to lock &lt;0x00000000d9560470&gt; (a java.lang.Object)        - locked &lt;0x00000000d9560480&gt; (a java.lang.Object)        at com.ten.juc.sync.DeadLock$$Lambda$2&#x2F;1078694789.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;A&quot; #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001aa51800 nid&#x3D;0x36b8 waiting for monitor entry [0x000000001b33f000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.ten.juc.sync.DeadLock.lambda$main$0(DeadLock.java:22)        - waiting to lock &lt;0x00000000d9560480&gt; (a java.lang.Object)        - locked &lt;0x00000000d9560470&gt; (a java.lang.Object)        at com.ten.juc.sync.DeadLock$$Lambda$1&#x2F;1324119927.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)...........Found one Java-level deadlock:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;A&quot;:  waiting to lock monitor 0x000000000339bd48 (object 0x00000000d9560470, a java.lang.Object),  which is held by &quot;A&quot;&quot;A&quot;:  waiting to lock monitor 0x000000000339e3c8 (object 0x00000000d9560480, a java.lang.Object),  which is held by &quot;A&quot;Java stack information for the threads listed above:&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;A&quot;:        at com.ten.juc.sync.DeadLock.lambda$main$1(DeadLock.java:35)        - waiting to lock &lt;0x00000000d9560470&gt; (a java.lang.Object)        - locked &lt;0x00000000d9560480&gt; (a java.lang.Object)        at com.ten.juc.sync.DeadLock$$Lambda$2&#x2F;1078694789.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)&quot;A&quot;:        at com.ten.juc.sync.DeadLock.lambda$main$0(DeadLock.java:22)        - waiting to lock &lt;0x00000000d9560480&gt; (a java.lang.Object)        - locked &lt;0x00000000d9560470&gt; (a java.lang.Object)        at com.ten.juc.sync.DeadLock$$Lambda$1&#x2F;1324119927.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre></div><h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><h2 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h2><ol><li>继承Thead类</li><li>实现Runnable接口</li><li>实现Callable接口</li><li>线程池</li></ol><h2 id="Runnable和Callable的不同"><a href="#Runnable和Callable的不同" class="headerlink" title="Runnable和Callable的不同"></a>Runnable和Callable的不同</h2><ol><li>是否有返回值，Runnable没有返回值，Callable有返回值</li><li>没有结果是否会出现异常，Runnable不会，Callable会抛出异常</li><li>需要重写的方法不同，Runnable是run方法，Callable是call方法</li></ol><p>Callable不能直接使用，需要寻找一个类来作为中间商，这个中间商就是FutureTask实现类（未来任务）</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304170030914.png" alt="image-20220304170030914"></p><h2 id="创建线程代码"><a href="#创建线程代码" class="headerlink" title="创建线程代码"></a>创建线程代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.callable;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;&#x2F;&#x2F; 用Runnable实现class MyThread1 implements Runnable&#123;    @Override    public void run() &#123;        System.out.println(&quot;MyThread1&quot;);    &#125;&#125;&#x2F;&#x2F; 用Callable实现class MyThread2 implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        return 200;    &#125;&#125;public class CallableDemo &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;&#x2F; 使用Runnable方式        new Thread(new MyThread1(),&quot;AA&quot;).start();        &#x2F;&#x2F; 使用FutureTask 未来任务，返回值只计算一次，后面有用到就直接返回        FutureTask&lt;Integer&gt; futureTask1 &#x3D; new FutureTask&lt;&gt;(new MyThread2());        &#x2F;&#x2F; 使用lombda表达式        FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(()-&gt;&#123;            return 1024;        &#125;);        new Thread(futureTask2,&quot;BB&quot;).start();        while (!futureTask2.isDone())&#123;            System.out.println(&quot;wait...&quot;);        &#125;        System.out.println(futureTask2.get());        System.out.println(futureTask2.get());  &#x2F;&#x2F; 第二次直接返回结果，不用进行计算        System.out.println(Thread.currentThread().getName() + &quot; come over&quot;);    &#125;&#125;</code></pre></div><h1 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h1><h2 id="减少计数CountDownLatch"><a href="#减少计数CountDownLatch" class="headerlink" title="减少计数CountDownLatch"></a>减少计数CountDownLatch</h2><p>CountDownLatch类可以设置一个计算器，通过countDown方法来减一，使用await方法等待计数器不大于0，然后继续执行await方法之后的语句。具体实现代码如下。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;import java.util.concurrent.CountDownLatch;&#x2F;&#x2F; 演示CountDownLatchpublic class CountDownLatchDemo &#123;    &#x2F;&#x2F; 6个同学陆续离开教室之后，班长锁门    public static void main(String[] args) throws InterruptedException &#123;        &#x2F;&#x2F; 创建CountDownLatch对象，设置初始值        CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;            new Thread(() -&gt;&#123;                System.out.println(Thread.currentThread().getName() + &quot; 号 离开了教室&quot;);                &#x2F;&#x2F; 操作一次就减一                countDownLatch.countDown();            &#125;,String.valueOf(i)).start();        &#125;        &#x2F;&#x2F; 如果不为0，就继续等待，如果为0了，就执行下面的输出        countDownLatch.await();        System.out.println(Thread.currentThread().getName() + &quot;  over&quot;);    &#125;&#125;</code></pre></div><h2 id="循环栅栏CyclicBarrier"><a href="#循环栅栏CyclicBarrier" class="headerlink" title="循环栅栏CyclicBarrier"></a>循环栅栏CyclicBarrier</h2><p>CyclicBarrier的意思是循环阻塞的意思，在使用中CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后的语句。可以将CyclicBarrier理解为+1的操作。</p><p>实现代码如下</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;import java.util.concurrent.CyclicBarrier;&#x2F;&#x2F; 演示 CyclicBarrier 循环栅栏public class CyclicBarrierDemo &#123;    &#x2F;&#x2F; 定义常量    private static final int NUMBER &#x3D; 7;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建CyclicBarrier对象        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(NUMBER,()-&gt;&#123;            System.out.println(&quot;******7颗龙珠已集齐！！&quot;);        &#125;);        &#x2F;&#x2F; 收集七颗龙珠过程        for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) &#123;            new Thread(()-&gt;&#123;                try &#123;                    System.out.println(Thread.currentThread().getName() + &quot;星龙珠已经收集了&quot;);                    &#x2F;&#x2F; 等待                    cyclicBarrier.await();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h2 id="信号灯Semaphore"><a href="#信号灯Semaphore" class="headerlink" title="信号灯Semaphore"></a>信号灯Semaphore</h2><p>当我们创建一个可扩展大小的线程池，并且需要在线程池内同时让有限数目的线程并发运行时，就需要用到Semaphore（信号灯机制），Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目，它是一个计数信号量，从概念上讲，信号量维护了一个许可集合，如有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可，每个release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;import java.util.Random;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;&#x2F;&#x2F; 6辆汽车，停3个车位public class SemaphoreDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建Semaphore，设置许可数量        Semaphore semaphore &#x3D; new Semaphore(3);        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;            new Thread(()-&gt;&#123;                try &#123;                    &#x2F;&#x2F; 占位                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + &quot; 抢占了车位&quot;);                    &#x2F;&#x2F; 等待                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));                    System.out.println(Thread.currentThread().getName() + &quot;----------离开了车位&quot;);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    &#x2F;&#x2F; 释放                    semaphore.release();                &#125;            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读写线程，读写互斥，读读共享。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304202147809.png" alt="image-20220304202147809"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.readwrite;import java.util.HashMap;import java.util.Map;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;&#x2F;&#x2F; 创建资源类class MyCatch&#123;    &#x2F;&#x2F; 定义一个map，由于存储数据   因为涉及到取和读的次数比较多，所以用volatile    private volatile Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();    &#x2F;&#x2F; 定义读写锁    private ReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();    &#x2F;&#x2F; 存数据    public void put(String key, Object value) &#123;        &#x2F;&#x2F; 添加写锁        readWriteLock.writeLock().lock();        &#x2F;&#x2F; 暂停一会        try &#123;            System.out.println(Thread.currentThread().getName() + &quot; 正在写数据&quot; + key);            TimeUnit.MILLISECONDS.sleep(300);            &#x2F;&#x2F; 写入            map.put(key, value);            System.out.println(Thread.currentThread().getName() + &quot; 已写完&quot; + key);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 释放写锁            readWriteLock.writeLock().unlock();        &#125;    &#125;    &#x2F;&#x2F; 取数据    public Object get(String key)  &#123;        Object result &#x3D; null;        &#x2F;&#x2F; 添加读锁        readWriteLock.readLock().lock();        &#x2F;&#x2F; 暂停一会        try &#123;            System.out.println(Thread.currentThread().getName() + &quot; 正在读取数据&quot; + key);            TimeUnit.MILLISECONDS.sleep(300);            &#x2F;&#x2F; 取数据            result &#x3D; map.get(key);            System.out.println(Thread.currentThread().getName() + &quot; 已读完&quot; + key);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 释放读锁            readWriteLock.readLock().unlock();        &#125;        return result;    &#125;&#125;public class ReadWriteLockDemo &#123;    public static void main(String[] args) &#123;        MyCatch myCatch &#x3D; new MyCatch();        &#x2F;&#x2F; 先存5个        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;            final int num &#x3D; i;            new Thread(() -&gt;&#123;                myCatch.put(num+&quot;&quot;,num);            &#125;,String.valueOf(i)).start();        &#125;        &#x2F;&#x2F; 读取5个        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;            final int num &#x3D; i;            new Thread(() -&gt;&#123;                myCatch.get(num+&quot;&quot;);            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><h2 id="读写锁的演变"><a href="#读写锁的演变" class="headerlink" title="读写锁的演变"></a>读写锁的演变</h2><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132103446.png" alt="image-20220305132103446"></p><h2 id="读写锁的降级"><a href="#读写锁的降级" class="headerlink" title="读写锁的降级"></a>读写锁的降级</h2><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132643455.png" alt="image-20220305132643455"></p><h2 id="读写锁降级代码演示"><a href="#读写锁降级代码演示" class="headerlink" title="读写锁降级代码演示"></a><strong>读写锁降级代码演示</strong></h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.readwrite;import java.util.concurrent.locks.ReentrantReadWriteLock;&#x2F;&#x2F; 读写锁的降级public class Demotion &#123;    public static void main(String[] args) &#123;        ReentrantReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();        ReentrantReadWriteLock.WriteLock writeLock &#x3D; readWriteLock.writeLock(); &#x2F;&#x2F; 写锁        ReentrantReadWriteLock.ReadLock readLock &#x3D; readWriteLock.readLock();    &#x2F;&#x2F; 读锁        &#x2F;&#x2F; 写锁        writeLock.lock();        System.out.println(&quot;write----------&quot;);        &#x2F;&#x2F; 读锁        readLock.lock();        System.out.println(&quot;read&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F; 释放写锁        writeLock.unlock();        &#x2F;&#x2F; 释放读锁        readLock.unlock();    &#125;&#125;</code></pre></div><h1 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h1><h2 id="概述和架构"><a href="#概述和架构" class="headerlink" title="概述和架构"></a>概述和架构</h2><p>阻塞队列是一个共享队列，先进先出。当队列是空的时候，从队列中取元素会被阻塞，当队列满了，从队列中添加元素会别阻塞。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305134836146.png" alt="image-20220305134836146"></p><h2 id="分类和核心方法介绍"><a href="#分类和核心方法介绍" class="headerlink" title="分类和核心方法介绍"></a>分类和核心方法介绍</h2><h3 id="ArrayBlockiingQueue（常用）"><a href="#ArrayBlockiingQueue（常用）" class="headerlink" title="ArrayBlockiingQueue（常用）"></a>ArrayBlockiingQueue（常用）</h3><p>由数组结构组成的有界阻塞队列</p><h3 id="LinkedBlockingQueue（常用）"><a href="#LinkedBlockingQueue（常用）" class="headerlink" title="LinkedBlockingQueue（常用）"></a>LinkedBlockingQueue（常用）</h3><p>由链表结构组成的阻塞队列。大小默认为integer.MAX_VALUE</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>使用优先级队列实现的延迟无界阻塞队列。</p><h3 id="PrioriityBlockingQueue"><a href="#PrioriityBlockingQueue" class="headerlink" title="PrioriityBlockingQueue"></a>PrioriityBlockingQueue</h3><p>支持优先级排序的无界阻塞队列。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>不存储元素的阻塞队列，也即单个元素的队列。</p><h3 id="LinkedTranferQueue"><a href="#LinkedTranferQueue" class="headerlink" title="LinkedTranferQueue"></a>LinkedTranferQueue</h3><p>由链表组成的无界阻塞队列。</p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>有链表组成的双向阻塞队列。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305164446445.png" alt="image-20220305164446445"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤起。</li></ol><h1 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池 ThreadPool"></a>线程池 ThreadPool</h1><h2 id="概述和架构-1"><a href="#概述和架构-1" class="headerlink" title="概述和架构"></a>概述和架构</h2><p>线程池，是一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护者多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建于销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p><strong>线程池优势</strong>：线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创将后自动启动这些线程任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p><strong>特点：</strong></p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销毁系统资源，还回降低系统的稳定性，使用线程池可以统一的分配，调优和监控。</li><li>java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</li></ul><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305171806962.png" alt="image-20220305171806962"></p><h2 id="使用方式和底层原理"><a href="#使用方式和底层原理" class="headerlink" title="使用方式和底层原理"></a>使用方式和底层原理</h2><h3 id="newFixedThreadPoll（常用）"><a href="#newFixedThreadPoll（常用）" class="headerlink" title="newFixedThreadPoll（常用）"></a>newFixedThreadPoll（常用）</h3><p><strong>作用：</strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。</p><p><strong>特征：</strong></p><ul><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量。</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在。</li><li>超出一定量的线程被提交时候需要在队列中等待。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.pool;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;&#x2F;&#x2F; 常见的创建线程池public class ThreadPoolDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 一池多线程        &#x2F;&#x2F;ExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(5);        &#x2F;&#x2F; 一池一线程        &#x2F;&#x2F;ExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();        &#x2F;&#x2F; 可扩容线程池        ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();        try &#123;            for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;                &#x2F;&#x2F; 执行                threadPool3.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);                &#125;);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 释放资源            threadPool3.shutdown();        &#125;    &#125;&#125;</code></pre></div><p>通过观察这三种创建线程池方式源码可以发现，底层都是由ThreadPoolExecutor创建的。</p><h3 id="ThreadPoolExecutor的7个参数"><a href="#ThreadPoolExecutor的7个参数" class="headerlink" title="ThreadPoolExecutor的7个参数"></a>ThreadPoolExecutor的7个参数</h3><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191058548.png" alt="image-20220305191058548"></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>主线程启动后，执行execute()方法，创建线程池（执行executor()之后才创建），假设最大线程数是5个，常住线程数是2，阻塞队列是3个。当常驻线程数1，2满了，后面来的3,4,5的就被安排到阻塞队列，如果这时还来了第6,7,8个，则启动线程池的其他三个没用的线程，直接给他们用，如果第9个来了，这个时候所有的线程和阻塞队列都满了，则执行handler的拒绝策略。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191838834.png" alt="image-20220305191838834"></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305192917090.png" alt="image-20220305192917090"></p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>实际上都会用自定义线程池。</p><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305193328989.png" alt="image-20220305193328989"></p><p><strong>代码演示</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.pool;import java.util.concurrent.*;&#x2F;&#x2F; 自定义线程池public class ThreadPoolDemo2 &#123;    public static void main(String[] args) &#123;        ExecutorService threadPool &#x3D; new ThreadPoolExecutor(                2,                5,                2L,                TimeUnit.SECONDS,                new ArrayBlockingQueue&lt;&gt;(3),                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.AbortPolicy()        );        try &#123;            for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;                &#x2F;&#x2F; 执行                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);                &#125;);            &#125;        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125; finally &#123;            &#x2F;&#x2F; 释放资源            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre></div><h1 id="Fork-Join-分支合并框架"><a href="#Fork-Join-分支合并框架" class="headerlink" title="Fork/Join 分支合并框架"></a>Fork/Join 分支合并框架</h1><p>Fork/Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork/Join框架要完成两件事情：</p><p>Fork：把一个复杂任务进行分拆，大事化小。</p><p>Join：把拆分任务的结果进行合并</p><p><strong>代码演示</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;&#x2F;&#x2F; 演示分支合并class MyTask extends RecursiveTask&lt;Integer&gt;&#123;    private static final  int VALUE &#x3D; 10;    &#x2F;&#x2F; 定义一个常量，用于判断两个数相加是否大于10    private int begin;  &#x2F;&#x2F; 开始的    private int end;    &#x2F;&#x2F; 结束的    private int result; &#x2F;&#x2F; 返回的结果    &#x2F;&#x2F; 构造方法    public MyTask(int begin,int end)&#123;        this.begin &#x3D; begin;        this.end &#x3D; end;    &#125;    @Override    protected Integer compute() &#123;        &#x2F;&#x2F; 如果他们相减小于10，则直接相加        if((end - begin) &lt;&#x3D; VALUE)&#123;            for (int i &#x3D; begin; i &lt;&#x3D; end; i++)&#123;                result &#x3D; result + i;            &#125;        &#125; else &#123;            &#x2F;&#x2F; 否则拆分            &#x2F;&#x2F; 计算中间的值            int middle &#x3D; (begin + end) &#x2F; 2;            &#x2F;&#x2F; 向左拆分            MyTask task1 &#x3D; new MyTask(begin, middle);            &#x2F;&#x2F; 向右拆分            MyTask task2 &#x3D; new MyTask(middle + 1, end);            &#x2F;&#x2F; 拆分            task1.fork();            task2.fork();            &#x2F;&#x2F; 合并            result &#x3D; task1.join() + task2.join();        &#125;        return result;    &#125;&#125;public class ForkJoinDemo &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;&#x2F; 创建任务对象        MyTask myTask &#x3D; new MyTask(0, 100);        &#x2F;&#x2F; 创建ForkJoinPool对象        ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();        ForkJoinTask&lt;Integer&gt; forkJoinTask &#x3D; forkJoinPool.submit(myTask);        &#x2F;&#x2F; 获取最终合并到的结果        Integer result &#x3D; forkJoinTask.get();        System.out.println(result);        &#x2F;&#x2F; 关闭池对象        forkJoinPool.shutdown();    &#125;&#125;</code></pre></div><h1 id="CompletableFuture-异步回调"><a href="#CompletableFuture-异步回调" class="headerlink" title="CompletableFuture 异步回调"></a>CompletableFuture 异步回调</h1><p>runAsync： 没有返回值</p><p>supplyAsync：有返回值</p><p>代码演示</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.completable;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;&#x2F;&#x2F; 异步调用public class CompletableFutureDemo &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        &#x2F;&#x2F; 异步调用 没有返回值        CompletableFuture&lt;Void&gt; completableFuture1 &#x3D; CompletableFuture.runAsync(()-&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; --- completableFuture1&quot;);        &#125;);        completableFuture1.get();        &#x2F;&#x2F; 异步调用 有返回值        CompletableFuture&lt;Integer&gt; completableFuture2 &#x3D; CompletableFuture.supplyAsync(() -&gt;&#123;            System.out.println(Thread.currentThread().getName() + &quot; --- completableFuture2&quot;);            &#x2F;&#x2F; 模拟异常            int i &#x3D; 1 &#x2F; 0;            return 1024;        &#125;);        completableFuture2.whenComplete((t,u) -&gt; &#123;            System.out.println(&quot;--------t&#x3D;&quot; +t);    &#x2F;&#x2F; 返回值            System.out.println(&quot;--------u&#x3D;&quot; +u);    &#x2F;&#x2F; 异常        &#125;).get();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JUC并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurity笔记</title>
    <link href="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/"/>
    <url>/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringSecurity笔记"><a href="#SpringSecurity笔记" class="headerlink" title="SpringSecurity笔记"></a>SpringSecurity笔记</h1><h1 id="1-SpringSecurity介绍"><a href="#1-SpringSecurity介绍" class="headerlink" title="1 SpringSecurity介绍"></a>1 SpringSecurity介绍</h1><h2 id="1-1-概要"><a href="#1-1-概要" class="headerlink" title="1.1 概要"></a>1.1 概要</h2><p>用户认证（authentication）和用户授权（authorization）</p><p>用户认证指：登录</p><p>用户授权指：是否有权限做某些事件</p><h2 id="1-2-同款产品对比"><a href="#1-2-同款产品对比" class="headerlink" title="1.2 同款产品对比"></a>1.2 同款产品对比</h2><h3 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a><strong>SpringSecurity</strong></h3><ul><li>SpringSecurity 特点：</li><li>和 Spring 无缝整合。 </li><li>全面的权限控制。</li><li>专门为 Web 开发而设计。<ul><li>旧版本不能脱离 Web 环境使用。 </li><li>新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独 引入核心模块就可以脱离 Web 环境。 </li></ul></li><li>重量级。</li></ul><h3 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a><strong>Shiro</strong></h3><p>特点： </p><ul><li>轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求 的互联网应用有更好表现。 </li><li>通用性。 <ul><li>好处：不局限于 Web 环境，可以脱离 Web 环境使用。</li><li>缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制。</li></ul></li></ul><h1 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2 入门案例"></a>2 入门案例</h1><p>创建一个springboot工程，导入依赖，编写一个controller，访问端口号，看到登录页面，账号为user,密码为控制台输出的一串，输入完成后，就可以看到controller返回的内容了。</p><h1 id="SpringSecurity-基本原理"><a href="#SpringSecurity-基本原理" class="headerlink" title="SpringSecurity 基本原理"></a>SpringSecurity 基本原理</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>SpringSecurity 本质是一个<strong>过滤器链</strong>：</p><p>代码底层流程：重点看三个过滤器：</p><p> <strong>FilterSecurityInterceptor</strong>：是一个<strong>方法级的</strong>权限过滤器, 基本位于过滤链的最底部</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126112446542.png" alt="image-20220126112446542"></p><p>super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。</p><p> fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。</p><p><strong>ExceptionTranslationFilter</strong>：是个<strong>异常过滤器</strong>，用来处理在认证授权过程中抛出的异常</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126112801964.png" alt="image-20220126112801964"></p><p><strong>UsernamePasswordAuthenticationFilter</strong> ：对**/login 的 POST 请求做拦截**，校验表单中用户 名，密码。</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126112941523.png" alt="image-20220126112941523"></p><h2 id="过滤器加载过程"><a href="#过滤器加载过程" class="headerlink" title="过滤器加载过程"></a>过滤器加载过程</h2><h3 id="使用SpringSecurity配置过滤器"><a href="#使用SpringSecurity配置过滤器" class="headerlink" title="使用SpringSecurity配置过滤器"></a>使用SpringSecurity配置过滤器</h3><p>DelegatingFilterProxy</p><p>找到doFilter方法，里面有一个初始化initDelegate方法</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126114809938.png" alt="image-20220126114809938"></p><p>点进去，重点在getBean这里，这里就是加载了过滤链，FilterChainProxy</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126114842962.png" alt="image-20220126114842962"></p><p>打开FilterChainProxy类，找到doFilter方法，发现不管怎么样，都调用了doFilterInternal这个方法</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126115128395.png" alt="image-20220126115128395"></p><p>打开doFilterInternal方法，发现这个是List集合的过滤链</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126115238904.png" alt="image-20220126115238904"></p><p>继续进去getFilters，发现这个是迭代器，里面实现了拦截器的获取，并返回</p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126115314168.png" alt="image-20220126115314168"></p><h2 id="两个重要接口"><a href="#两个重要接口" class="headerlink" title="两个重要接口"></a>两个重要接口</h2><h3 id="UserDetailsService接口"><a href="#UserDetailsService接口" class="headerlink" title="UserDetailsService接口"></a>UserDetailsService接口</h3><p>查询数据库用户名和密码过程</p><p>创建类继承<code>UsernamePasswordAuthenticationFilter</code>，重写三个方法<code>attemptAuthentication</code>,<code>successfulAuthentication</code>,</p><p><code>unsuccessfulAuthentication</code>，验证用户名和密码，如果成功就调用成功的方法，失败就调用失败的。后面两个方法在父类<code>AbstractAuthenticationProcessingFilter</code>.</p><p>创建类实现<code>UserDetailsService</code>接口，编写查询数据库的过程，返回User对象，这个User对象是安全框架提供的。</p><h3 id="PasswordEncoder接口"><a href="#PasswordEncoder接口" class="headerlink" title="PasswordEncoder接口"></a>PasswordEncoder接口</h3><p>数据加密接口，用于返回User对象里面密码加密</p><h1 id="web权限方案-用户认证"><a href="#web权限方案-用户认证" class="headerlink" title="web权限方案-用户认证"></a>web权限方案-用户认证</h1><h2 id="方法一：在配置文件添加用户信息"><a href="#方法一：在配置文件添加用户信息" class="headerlink" title="方法一：在配置文件添加用户信息"></a>方法一：在配置文件添加用户信息</h2><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">server.port&#x3D;8111spring.security.user.name&#x3D;atguiguspring.security.user.password&#x3D;atguigu</code></pre></div><h2 id="方法二：编写配置类"><a href="#方法二：编写配置类" class="headerlink" title="方法二：编写配置类"></a>方法二：编写配置类</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.inMemoryAuthentication().withUser(&quot;lucy&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;);    &#125;&#125;</code></pre></div><p>启动的时候，发现报错</p><p>java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”</p><p>加密的时候，需要用到一个接口，否则无法加密</p><p><strong>解决：</strong></p><p>注入一个Bean，<code>PasswordEncoder</code>，返回密码对象</p><p>完整代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        BCryptPasswordEncoder passwordEncoder &#x3D; new BCryptPasswordEncoder();        String password &#x3D; passwordEncoder.encode(&quot;123&quot;);        auth.inMemoryAuthentication().withUser(&quot;lucy&quot;).password(password).roles(&quot;admin&quot;);    &#125;    @Bean    PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;&#125;</code></pre></div><h2 id="方法三：自定义配置类"><a href="#方法三：自定义配置类" class="headerlink" title="方法三：自定义配置类"></a>方法三：自定义配置类</h2><p>第一步：编写一个配置类，设置使用哪个UserDetailsService实现类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SecurityConfigTest extends WebSecurityConfigurerAdapter &#123;    @Autowired    private UserDetailsService userDetailsService;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;       auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());    &#125;    @Bean    PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;&#125;</code></pre></div><p>第二步：创建一个实现类，返回User对象，User对象有用户名密码和操作权限</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123;    @Override    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException &#123;        List&lt;GrantedAuthority&gt; auths &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);        return new User(&quot;mary&quot;,new BCryptPasswordEncoder().encode(&quot;123&quot;),auths);    &#125;&#125;</code></pre></div><h2 id="实现数据库认证来完成用户登录"><a href="#实现数据库认证来完成用户登录" class="headerlink" title="实现数据库认证来完成用户登录"></a>实现数据库认证来完成用户登录</h2><p>创建数据库和对应的表</p><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE demo;CREATE TABLE users( id BIGINT PRIMARY KEY AUTO_INCREMENT,username VARCHAR(20) UNIQUE NOT NULL,PASSWORD VARCHAR(100));INSERT INTO users VALUES(1,&#39;张san&#39;,&#39;$2a$10$2R&#x2F;M6iU3mCZt3ByG7kwYTeeW0w7&#x2F;UqdeXrb27zkBIizBvAven0&#x2F;na&#39;);-- 密码 atguiguINSERT INTO users VALUES(2,&#39;李si&#39;,&#39;$2a$10$2R&#x2F;M6iU3mCZt3ByG7kwYTeeW0w7&#x2F;UqdeXrb27zkBIizBvAven0&#x2F;na&#39;);</code></pre></div><p>导入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;        &lt;scope&gt;test&lt;&#x2F;scope&gt;    &lt;&#x2F;dependency&gt;    &lt;!--mybatis-plus--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.0.5&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--mysql--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--lombok 用来简化实体类--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>在配置文件中添加数据库配置</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 数据库配置spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;demo?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root</code></pre></div><p>编写实体类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Users &#123;    private Integer id;    private String username;    private String password;&#125;</code></pre></div><p>编写mapper</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Repositorypublic interface UsersMapper extends BaseMapper&lt;Users&gt; &#123;&#125;</code></pre></div><p>编写service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Service(&quot;userDetailsService&quot;)public class MyUserDetailsService implements UserDetailsService &#123;    @Autowired    private UsersMapper usersMapper;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        &#x2F;&#x2F; 根据用户名查询数据库        QueryWrapper&lt;Users&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;username&quot;,username);        Users users &#x3D; usersMapper.selectOne(wrapper);        if (users &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 如果user为空，直接抛出异常            throw new UsernameNotFoundException(&quot;用户为空&quot;);        &#125;        List&lt;GrantedAuthority&gt; auths &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;role&quot;);        return new User(users.getUsername(),new BCryptPasswordEncoder().encode(users.getPassword()),auths);    &#125;&#125;</code></pre></div><p>debug测试</p><h2 id="自定义完成登录页面"><a href="#自定义完成登录页面" class="headerlink" title="自定义完成登录页面"></a>自定义完成登录页面</h2><p>在配置类中重写configure方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class SecurityConfigTest extends WebSecurityConfigurerAdapter &#123;    @Autowired    private UserDetailsService userDetailsService;    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;       auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());    &#125;    @Bean    PasswordEncoder passwordEncoder()&#123;        return new BCryptPasswordEncoder();    &#125;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.formLogin()    &#x2F;&#x2F; 自定义编写的登录页面                .loginPage(&quot;&#x2F;login.html&quot;)       &#x2F;&#x2F; 登录页面设置                .loginProcessingUrl(&quot;&#x2F;user&#x2F;login&quot;)  &#x2F;&#x2F; 登录页面访问路径                .defaultSuccessUrl(&quot;&#x2F;text&#x2F;index&quot;).permitAll()   &#x2F;&#x2F; 登录成功跳转到的页面                .and().authorizeRequests()                    .antMatchers(&quot;&#x2F;&quot;,&quot;&#x2F;test&#x2F;hello&quot;,&quot;&#x2F;user&#x2F;login&quot;).permitAll()      &#x2F;&#x2F; 哪些请求可以放行                .anyRequest().authenticated()                .and().csrf().disable();        &#x2F;&#x2F; 关闭csrf防护    &#125;&#125;</code></pre></div><p>编写登录页面</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;form action&#x3D;&quot;&#x2F;user&#x2F;login&quot; method&#x3D;&quot;post&quot;&gt;        用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt;        密码：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot;&gt;        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;login&quot;&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>新增controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;test&quot;)public class testController &#123;    @GetMapping(&quot;hello&quot;)    public String hello()&#123;        return &quot;hello security&quot;;    &#125;    @GetMapping(&quot;index&quot;)    public String index()&#123;        return &quot;hello index&quot;;    &#125;&#125;</code></pre></div><p>测试，先访问/test/hello,再访问/test/index</p><h1 id="web权限方案-用户授权"><a href="#web权限方案-用户授权" class="headerlink" title="web权限方案-用户授权"></a>web权限方案-用户授权</h1><h2 id="基于权限访问控制"><a href="#基于权限访问控制" class="headerlink" title="基于权限访问控制"></a>基于权限访问控制</h2><h3 id="hasAuthority方法和hasAnyAuthority方法"><a href="#hasAuthority方法和hasAnyAuthority方法" class="headerlink" title="hasAuthority方法和hasAnyAuthority方法"></a>hasAuthority方法和hasAnyAuthority方法</h3><p>(type=Forbidden, status=403).没有权限</p><p>在实现类添加权限List<GrantedAuthority> auths = AuthorityUtils.commaSeparatedStringToAuthorityList(“admins”);</GrantedAuthority></p><p>在配置类添加下面的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    http.formLogin()    &#x2F;&#x2F; 自定义编写的登录页面            .loginPage(&quot;&#x2F;login.html&quot;)       &#x2F;&#x2F; 登录页面设置            .loginProcessingUrl(&quot;&#x2F;user&#x2F;login&quot;)  &#x2F;&#x2F; 登录页面访问路径            .defaultSuccessUrl(&quot;&#x2F;text&#x2F;index&quot;).permitAll()   &#x2F;&#x2F; 登录成功跳转到的页面            .and().authorizeRequests()                .antMatchers(&quot;&#x2F;&quot;,&quot;&#x2F;test&#x2F;hello&quot;,&quot;&#x2F;user&#x2F;login&quot;).permitAll()      &#x2F;&#x2F; 哪些请求可以放行            &#x2F;&#x2F; 当前用户登录，只有只有admins权限才可以访问这个路径            &#x2F;&#x2F; hasAuthority方法，只能一个            &#x2F;&#x2F;.antMatchers(&quot;&#x2F;test&#x2F;index&quot;).hasAuthority(&quot;admins&quot;)            &#x2F;&#x2F; hasAnyAuthority方法，可以多个            .antMatchers(&quot;&#x2F;test&#x2F;index&quot;).hasAnyAuthority(&quot;admins,role&quot;)            .anyRequest().authenticated()            .and().csrf().disable();        &#x2F;&#x2F; 关闭csrf防护&#125;</code></pre></div><h2 id="基于角色访问控制"><a href="#基于角色访问控制" class="headerlink" title="基于角色访问控制"></a>基于角色访问控制</h2><h2 id="hasRole和hasAnyRole"><a href="#hasRole和hasAnyRole" class="headerlink" title="hasRole和hasAnyRole"></a>hasRole和hasAnyRole</h2><p>在实现类中添加role的时候要注意格式，需要加上ROLE_前缀，可以通过查看源码发现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;GrantedAuthority&gt; auths &#x3D; AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;admins,ROLE_sale&quot;);</code></pre></div><p>配置类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 3.hasRole.antMatchers(&quot;&#x2F;test&#x2F;index&quot;).hasRole(&quot;sale&quot;)</code></pre></div><p>hasAnyRole和上面的类型，多个角色用逗号隔开就行。</p><h2 id="自定义403页面"><a href="#自定义403页面" class="headerlink" title="自定义403页面"></a>自定义403页面</h2><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126151935413.png" alt="image-20220126151935413"></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    &#x2F;&#x2F; 配置没有权限跳转的页面    http.exceptionHandling().accessDeniedPage(&quot;&#x2F;unauth.html&quot;);</code></pre></div><p>页面</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;h1&gt;没有访问权限！&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126152035554.png" alt="image-20220126152035554"></p><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><p> 使用注解先要开启注解功能！ @EnableGlobalMethodSecurity(securedEnabled=true)</p><h3 id="Secured"><a href="#Secured" class="headerlink" title="@Secured"></a>@Secured</h3><p>需要具有某些角色才可以访问</p><p>判断是否具有角色，另外需要注意的是这里匹配的字符串需要添加前缀“ROLE_“。 使用注解先要开启注解功能！ @EnableGlobalMethodSecurity(securedEnabled=true)</p><h3 id="PreAuthoriz"><a href="#PreAuthoriz" class="headerlink" title="@PreAuthoriz"></a>@PreAuthoriz</h3><p>在方法执行前进行验证权限</p><p>开启注解，@EnableGlobalMethodSecurity(prePostEnabled = true)</p><h3 id="PostAuthorize"><a href="#PostAuthorize" class="headerlink" title="@PostAuthorize"></a>@PostAuthorize</h3><p>方法执行之后再进行权限验证，适合用在有返回值的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;update&quot;)&#x2F;&#x2F;@Secured(&#123;&quot;normal&quot;,&quot;ROLE_sale&quot;&#125;)   &#x2F;&#x2F; 需要拥有这些角色才可以访问&#x2F;&#x2F;@PreAuthorize(&quot;hasAnyAuthority(&#39;admins&#39;)&quot;) &#x2F;&#x2F; 需要拥有这个权限才可以访问,PreAuthorize注解适合进入方法前的权限验证&#x2F;&#x2F;@PostAuthorize(&quot;hasAnyAuthority(&#39;admins1&#39;)&quot;)    &#x2F;&#x2F; 执行方法后再进行权限认证，适合验证带返回值的public String update()&#123;    System.out.println(&quot;update...&quot;);    return &quot;hello update&quot;;&#125;</code></pre></div><h3 id="PostFilter"><a href="#PostFilter" class="headerlink" title="@PostFilter"></a>@PostFilter</h3><p>权限验证之后对数据进行过滤 留下用户名是 admin1 的数据</p><p>表达式中的 filterObject 引用的是方法返回值 List 中的某一个元素</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;getAll&quot;)@PostAuthorize(&quot;hasAnyAuthority(&#39;admins1&#39;)&quot;)@PostFilter(&quot;filterObject.username &#x3D;&#x3D; &#39;admin1&#39;&quot;)        &#x2F;&#x2F; 对数据进行过滤，只留下admin1的public List&lt;Users&gt; getAllUser()&#123;    ArrayList&lt;Users&gt; list &#x3D; new ArrayList&lt;&gt;();    list.add(new Users(1,&quot;admin1&quot;,&quot;6666&quot;));    list.add(new Users(2,&quot;admin2&quot;,&quot;888&quot;));    System.out.println(list);    return list;&#125;</code></pre></div><h3 id="PreFilter"><a href="#PreFilter" class="headerlink" title="@PreFilter"></a>@PreFilter</h3><p> @PreFilter: 进入控制器之前对数据进行过滤，和上面这个注解类似</p><h1 id="web权限方案-用户注销"><a href="#web权限方案-用户注销" class="headerlink" title="web权限方案-用户注销"></a>web权限方案-用户注销</h1><p>编写登录成功的页面</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;p&gt;登录成功&lt;&#x2F;p&gt;    &lt;a href&#x3D;&quot;&#x2F;logout&quot;&gt;退出&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>在配置类添加配置</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Overrideprotected void configure(HttpSecurity http) throws Exception &#123;    &#x2F;&#x2F; 配置退出登录    http.logout().logoutUrl(&quot;&#x2F;logout&quot;).logoutSuccessUrl(&quot;&#x2F;test&#x2F;index&quot;).permitAll();</code></pre></div><p>修改登录成功的页面到上面的页面</p><p><strong>测试</strong></p><p>访问登录页面，登录成功后跳转到成功的页面，再打开一个窗口，访问需要权限的方法，在登录成功的页面退出登录，回到需要权限的方法刷新，看看是否生效。</p><h1 id="web权限方案-自动登录"><a href="#web权限方案-自动登录" class="headerlink" title="web权限方案-自动登录"></a>web权限方案-自动登录</h1><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/11-web%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88-%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%E6%B5%81%E7%A8%8B.png" alt="11-web权限方案-记住用户流程"></p><h2 id="查看源码："><a href="#查看源码：" class="headerlink" title="查看源码："></a><strong>查看源码：</strong></h2><p><strong>上图的1,2,3,4详细流程</strong></p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126174510489.png" alt="image-20220126174510489"></p><p><strong>11,12,13,14详细流程</strong></p><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/image-20220126175934833.png" alt="image-20220126175934833"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在配置类中添加数据源</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Autowiredprivate DataSource dataSource;@BeanPersistentTokenRepository persistentTokenRepository()&#123;    JdbcTokenRepositoryImpl jdbcTokenRepository &#x3D; new JdbcTokenRepositoryImpl();    &#x2F;&#x2F; 赋值数据源    jdbcTokenRepository.setDataSource(dataSource);    &#x2F;&#x2F; 自动创建表,第一次执行会创建，以后要执行就要删除掉！    &#x2F;&#x2F;jdbcTokenRepository.setCreateTableOnStartup(true);    return jdbcTokenRepository;&#125;</code></pre></div><p>在configure中开启记住我功能</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 开启记住我.and().rememberMe().tokenRepository(persistentTokenRepository()).tokenValiditySeconds(60).userDetailsService(userDetailsService).and().csrf().disable();        &#x2F;&#x2F; 关闭csrf防护</code></pre></div><p>在页面添加复选框</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">记住我&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;remember-me&quot;&gt;</code></pre></div><h1 id="web权限方案-CSRF功能"><a href="#web权限方案-CSRF功能" class="headerlink" title="web权限方案-CSRF功能"></a>web权限方案-CSRF功能</h1><ol><li><p>生成 csrfToken 保存到 HttpSession 或者 Cookie 中</p></li><li><p>请求到来时，从请求中提取 csrfToken，和保存的 csrfToken 做比较，进而判断当 前请求是否合法。主要通过 CsrfFilter 过滤器来完成。</p></li></ol><h1 id="微服务权限方案-认证授权过程分析"><a href="#微服务权限方案-认证授权过程分析" class="headerlink" title="微服务权限方案-认证授权过程分析"></a>微服务权限方案-认证授权过程分析</h1><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/13-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="13-微服务权限方案-实现过程分析"></p><h1 id="微服务权限方案-数据模型介绍"><a href="#微服务权限方案-数据模型介绍" class="headerlink" title="微服务权限方案-数据模型介绍"></a>微服务权限方案-数据模型介绍</h1><p><img src="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/14-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B.png" alt="14-微服务权限方案-数据模型"></p><h1 id="微服务权限方案-搭建项目工程"><a href="#微服务权限方案-搭建项目工程" class="headerlink" title="微服务权限方案-搭建项目工程"></a>微服务权限方案-搭建项目工程</h1><p>参照谷粒学院的</p><h1 id="微服务权限方案-编写security工具类"><a href="#微服务权限方案-编写security工具类" class="headerlink" title="微服务权限方案-编写security工具类"></a>微服务权限方案-编写security工具类</h1><h2 id="密码处理"><a href="#密码处理" class="headerlink" title="密码处理"></a>密码处理</h2><p>DefaultPasswordEncoder</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.atguigu.utils.MD5;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;&#x2F;** * 密码处理 *&#x2F;@Componentpublic class DefaultPasswordEncoder implements PasswordEncoder &#123;    public DefaultPasswordEncoder() &#123;        this(-1);    &#125;    &#x2F;&#x2F; 有参构造    public DefaultPasswordEncoder(int strength) &#123;    &#125;    &#x2F;&#x2F; MD5工具处理密码    @Override    public String encode(CharSequence rawPassword) &#123;        return MD5.encrypt(rawPassword.toString());    &#125;    &#x2F;**     * 判断密码是否匹配     * @param rawPassword 输入的密码     * @param encodedPassword 已经处理过的密码     * @return 两个比较，如果相同，返回true，否则false     *&#x2F;    @Override    public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;        return encodedPassword.equals(MD5.encrypt(rawPassword.toString()));    &#125;&#125;</code></pre></div><h2 id="token事务"><a href="#token事务" class="headerlink" title="token事务"></a>token事务</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class TokenManager &#123;    &#x2F;&#x2F; token 过期时间    private long tokenExpiration &#x3D; 1000*60*60*24;   &#x2F;&#x2F; 一天    &#x2F;&#x2F; 密钥    private String tokenSignKey &#x3D; &quot;123456&quot;;    &#x2F;&#x2F; 生成token    public String createToken(String username)&#123;        String token &#x3D; Jwts.builder().setSubject(username)     &#x2F;&#x2F; 设置用户名                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))        &#x2F;&#x2F; 设置过期时间                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();&#x2F;&#x2F; 设置密码        &#x2F;&#x2F; 返回token        return token;    &#125;    &#x2F;&#x2F; 根据token获取用户信息    public String getUserInfoFromToken(String token)&#123;        String user &#x3D; Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();        return user;    &#125;    &#x2F;&#x2F; 删除token    public void removeToken(String token)&#123;        &#x2F;&#x2F; jwttoken无需删除，客户端扔掉即可。    &#125;&#125;</code></pre></div><h2 id="退出登录处理器"><a href="#退出登录处理器" class="headerlink" title="退出登录处理器"></a>退出登录处理器</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 退出登录处理器 *&#x2F;@Componentpublic class TokenLogoutHandler implements LogoutHandler &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    &#x2F;&#x2F; 有参构成    public TokenLogoutHandler(TokenManager tokenManager,RedisTemplate redisTemplate)&#123;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    @Override    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;        &#x2F;&#x2F; 删除token，根据token获取用户名，根据用户名从redis中删除相关信息        &#x2F;&#x2F; 获取token        String token &#x3D; request.getHeader(&quot;token&quot;);        if (token !&#x3D; null)&#123;            &#x2F;&#x2F; 删除token            tokenManager.removeToken(token);            &#x2F;&#x2F; 清空当前用户缓存中的权限数据            String username &#x3D; tokenManager.getUserInfoFromToken(token);            redisTemplate.delete(username);        &#125;        &#x2F;&#x2F; 退出        ResponseUtil.out(response, R.ok());    &#125;&#125;</code></pre></div><h1 id="微服务权限方案-编写security认证过滤器"><a href="#微服务权限方案-编写security认证过滤器" class="headerlink" title="微服务权限方案-编写security认证过滤器"></a>微服务权限方案-编写security认证过滤器</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 认证的过滤器 *&#x2F;public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    private AuthenticationManager authenticationManager;    &#x2F;&#x2F; 有参构造    public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate) &#123;        this.authenticationManager &#x3D; authenticationManager;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;        this.setPostOnly(false);        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;&#x2F;admin&#x2F;acl&#x2F;login&quot;,&quot;POST&quot;));    &#125;    &#x2F;&#x2F; 认证用户名和密码,获取表单提交用户名和密码    @Override    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;        &#x2F;&#x2F; 获取表单提交数据        try &#123;            User user &#x3D; new ObjectMapper().readValue(request.getInputStream(), User.class);            return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(),user.getPassword(),                    new ArrayList&lt;&gt;()));        &#125; catch (IOException e) &#123;            e.printStackTrace();            throw new RuntimeException();        &#125;    &#125;    &#x2F;&#x2F; 认证成功执行    @Override    protected void successfulAuthentication(HttpServletRequest request,                                            HttpServletResponse response, FilterChain chain, Authentication authResult)            throws IOException, ServletException &#123;        &#x2F;&#x2F; 得到用户认证成功后的信息        SecurityUser user &#x3D; (SecurityUser) authResult.getPrincipal();        &#x2F;&#x2F; 生成token信息        String token &#x3D; tokenManager.createToken(user.getCurrentUserInfo().getUsername());        &#x2F;&#x2F; 存到redis，k为用户名，value为权限值        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(),user.getPermissionValueList());        ResponseUtil.out(response, R.ok().data(&quot;token&quot;,token));    &#125;    &#x2F;&#x2F; 认证失败执行    @Override    protected void unsuccessfulAuthentication(HttpServletRequest request,                                              HttpServletResponse response, AuthenticationException failed)            throws IOException, ServletException &#123;        ResponseUtil.out(response,R.error());    &#125;&#125;</code></pre></div><h1 id="微服务权限方案-security授权过滤器"><a href="#微服务权限方案-security授权过滤器" class="headerlink" title="微服务权限方案-security授权过滤器"></a>微服务权限方案-security授权过滤器</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 授权过滤器 *&#x2F;public class TokenAuthenticationFilter extends BasicAuthenticationFilter &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    public TokenAuthenticationFilter(AuthenticationManager authenticationManager) &#123;        super(authenticationManager);        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    @Override    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        &#x2F;&#x2F; 获取当前认证成功的用户信息        UsernamePasswordAuthenticationToken authRequest &#x3D; getAuthentication(request);        &#x2F;&#x2F; 判断如果有权限值，就放到权限上下文中        if (authRequest !&#x3D; null)&#123;            SecurityContextHolder.getContext().setAuthentication(authRequest);        &#125;                chain.doFilter(request,response);    &#125;    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request)&#123;        &#x2F;&#x2F; 从header中获取token信息        String token &#x3D; request.getHeader(&quot;token&quot;);        if (token !&#x3D; null)&#123;            &#x2F;&#x2F; 根据token信息获取用户信息            String username &#x3D; tokenManager.getUserInfoFromToken(token);            &#x2F;&#x2F; 从redis中查询对应的权限列表            List&lt;String&gt; permissionValueList &#x3D; (List&lt;String&gt;) redisTemplate.opsForValue().get(username);            &#x2F;&#x2F; 将权限列表的类型转换为GrantedAuthority            Collection&lt;GrantedAuthority&gt; authorities &#x3D; new ArrayList&lt;&gt;();            for (String permission : permissionValueList) &#123;                SimpleGrantedAuthority auth &#x3D; new SimpleGrantedAuthority(permission);                authorities.add(auth);            &#125;            return new UsernamePasswordAuthenticationToken(username,token,authorities);        &#125;        return null;    &#125;&#125;</code></pre></div><h1 id="微服务权限方案-核心配置类"><a href="#微服务权限方案-核心配置类" class="headerlink" title="微服务权限方案-核心配置类"></a>微服务权限方案-核心配置类</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 核心配置类 *&#x2F;@Configurationpublic class TokenWebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    private UserDetailsService userDetailsService;    private DefaultPasswordEncoder defaultPasswordEncoder;    @Autowired    public TokenWebSecurityConfig(UserDetailsService userDetailsService, DefaultPasswordEncoder defaultPasswordEncoder,                                  TokenManager tokenManager, RedisTemplate redisTemplate) &#123;        this.userDetailsService &#x3D; userDetailsService;        this.defaultPasswordEncoder &#x3D; defaultPasswordEncoder;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    &#x2F;**     * 配置设置     * @param http     * @throws Exception     *&#x2F;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.exceptionHandling()                .authenticationEntryPoint(new UnauthEntryPoint())       &#x2F;&#x2F; 没有权限访问                .and().csrf().disable()                .authorizeRequests()                .anyRequest().authenticated()                .and().logout().logoutUrl(&quot;&#x2F;admin&#x2F;acl&#x2F;index&#x2F;logout&quot;)    &#x2F;&#x2F; 设置退出路径                .addLogoutHandler(new TokenLogoutHandler(tokenManager,redisTemplate)).and()                .addFilter(new TokenLoginFilter(authenticationManager(), tokenManager, redisTemplate))                .addFilter(new TokenAuthenticationFilter(authenticationManager(), tokenManager, redisTemplate)).httpBasic();    &#125;    &#x2F;&#x2F; 调用userDetailsService和密码处理    @Override    protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userDetailsService).passwordEncoder(defaultPasswordEncoder);    &#125;    &#x2F;&#x2F; 不进行认证的路径，可以直接访问    @Override    public void configure(WebSecurity web) throws Exception &#123;        web.ignoring().antMatchers(&quot;&#x2F;api&#x2F;**&quot;);    &#125;&#125;</code></pre></div><h1 id="微服务权限方案-UserDetailsService实现类"><a href="#微服务权限方案-UserDetailsService实现类" class="headerlink" title="微服务权限方案-UserDetailsService实现类"></a>微服务权限方案-UserDetailsService实现类</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * security的UserDetailsService实现类 *&#x2F;@Service(&quot;userDetailsService&quot;)public class UserDetailsServiceImpl implements UserDetailsService &#123;    @Autowired    private UserService userService;    @Autowired    private PermissionService permissionService;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;        &#x2F;&#x2F; 根据用户名查询数据        User user &#x3D; userService.selectByUsername(username);        &#x2F;&#x2F; 判断        if (user &#x3D;&#x3D; null)&#123;            throw new UsernameNotFoundException(&quot;用户不存在&quot;);        &#125;        com.atguigu.entity.User curUser &#x3D; new com.atguigu.entity.User();        BeanUtils.copyProperties(user,curUser);        &#x2F;&#x2F; 根据用户id查询权限列表        List&lt;String&gt; permissionValueList &#x3D; permissionService.selectPermissionValueByUserId(user.getId());        SecurityUser securityUser &#x3D; new SecurityUser();        securityUser.setPermissionValueList(permissionValueList);        return securityUser;    &#125;&#125;</code></pre></div><h1 id="微服务权限-整合网关和权限"><a href="#微服务权限-整合网关和权限" class="headerlink" title="微服务权限-整合网关和权限"></a>微服务权限-整合网关和权限</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 解决跨域 *&#x2F;@Configurationpublic class CorsConfig &#123;    &#x2F;&#x2F; 方法，请求头，跨域都可以访问    @Bean    public CorsWebFilter corsWebFilter() &#123;        CorsConfiguration config &#x3D; new CorsConfiguration();        config.addAllowedMethod(&quot;*&quot;);        config.addAllowedOrigin(&quot;*&quot;);        config.addAllowedHeader(&quot;*&quot;);        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(new PathPatternParser());        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;</code></pre></div><p>配置文件</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8222# 服务名spring.application.name&#x3D;service-gateway# nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848#使用路由发现spring.cloud.gateway.discovery.locator.enabled&#x3D;true#设置路由idspring.cloud.gateway.routes[0].id&#x3D;service-acl#设置路由的uri   lb:&#x2F;&#x2F;nacos注册服务名称spring.cloud.gateway.routes[0].uri&#x3D;lb:&#x2F;&#x2F;service-acl#设置路由断言,代理servicerId为auth-service的&#x2F;auth&#x2F;路径spring.cloud.gateway.routes[0].predicates&#x3D; Path&#x3D;&#x2F;*&#x2F;acl&#x2F;**</code></pre></div><h1 id="SpringSecurity原理总结"><a href="#SpringSecurity原理总结" class="headerlink" title="SpringSecurity原理总结"></a>SpringSecurity原理总结</h1><p>源码：</p>]]></content>
    
    
    <categories>
      
      <category>framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day14-讲师分页_课程列表_课程详情</title>
    <link href="/myBlog/day14-%E8%AE%B2%E5%B8%88%E5%88%86%E9%A1%B5_%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8_%E8%AF%BE%E7%A8%8B%E8%AF%A6%E6%83%85/"/>
    <url>/myBlog/day14-%E8%AE%B2%E5%B8%88%E5%88%86%E9%A1%B5_%E8%AF%BE%E7%A8%8B%E5%88%97%E8%A1%A8_%E8%AF%BE%E7%A8%8B%E8%AF%A6%E6%83%85/</url>
    
    <content type="html"><![CDATA[<h1 id="day14-讲师分页-课程列表-课程详情"><a href="#day14-讲师分页-课程列表-课程详情" class="headerlink" title="day14-讲师分页 课程列表 课程详情"></a>day14-讲师分页 课程列表 课程详情</h1><h1 id="讲师分页查询接口"><a href="#讲师分页查询接口" class="headerlink" title="讲师分页查询接口"></a>讲师分页查询接口</h1><p>com.atguigu.eduservice.controller.front </p><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;teacherfront&quot;)@CrossOriginpublic class TeacherFrontController &#123;    @Autowired    private EduTeacherService teacherService;    &#x2F;&#x2F; 分页查询讲师的方法    @PostMapping(&quot;getTeacherFrontList&#x2F;&#123;page&#125;&#x2F;&#123;limit&#125;&quot;)    public R getTeacherFrontList(@PathVariable long page,@PathVariable long limit)&#123;        Page&lt;EduTeacher&gt; teacherPage &#x3D; new Page&lt;&gt;(page, limit);        Map&lt;String,Object&gt; map &#x3D; teacherService.getTeacherFrontList(teacherPage);        return R.ok().data(map);    &#125;&#125;</code></pre></div><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduTeacherService extends IService&lt;EduTeacher&gt; &#123;    &#x2F;&#x2F; 分页查询讲师的方法    Map&lt;String, Object&gt; getTeacherFrontList(Page&lt;EduTeacher&gt; teacherPage);&#125;</code></pre></div><h2 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduTeacherServiceImpl extends ServiceImpl&lt;EduTeacherMapper, EduTeacher&gt; implements EduTeacherService &#123;    &#x2F;&#x2F; 分页查询讲师的方法    @Override    public Map&lt;String, Object&gt; getTeacherFrontList(Page&lt;EduTeacher&gt; teacherPage) &#123;        QueryWrapper&lt;EduTeacher&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        &#x2F;&#x2F; 按照id降序排序        wrapper.orderByDesc(&quot;id&quot;);        baseMapper.selectPage(teacherPage,wrapper);        List&lt;EduTeacher&gt; records &#x3D; teacherPage.getRecords();        long current &#x3D; teacherPage.getCurrent();        long pages &#x3D; teacherPage.getPages();        long size &#x3D; teacherPage.getSize();        long total &#x3D; teacherPage.getTotal();        boolean hasNext &#x3D; teacherPage.hasNext();        boolean hasPrevious &#x3D; teacherPage.hasPrevious();        &#x2F;&#x2F; 将查询出来的封装到map        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(&quot;records&quot;,records);        map.put(&quot;current&quot;,current);        map.put(&quot;pages&quot;,pages);        map.put(&quot;size&quot;,size);        map.put(&quot;total&quot;,total);        map.put(&quot;hasNext&quot;,hasNext);        map.put(&quot;hasPrevious&quot;,hasPrevious);        &#x2F;&#x2F; 最后返回map        return map;    &#125;&#125;</code></pre></div><h1 id="讲师分页查询前端"><a href="#讲师分页查询前端" class="headerlink" title="讲师分页查询前端"></a>讲师分页查询前端</h1><h2 id="1、创建api"><a href="#1、创建api" class="headerlink" title="1、创建api"></a>1、创建api</h2><p>创建文件夹api，api下创建teacher.js，用于封装讲师模块的请求</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;  &#x2F;&#x2F; 分页查询名师  getTeacherList(page,limit) &#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;teacherfront&#x2F;getTeacherFrontList&#x2F;$&#123;page&#125;&#x2F;$&#123;limit&#125;&#96;,      method: &#39;post&#39;    &#125;)  &#125;&#125;</code></pre></div><h2 id="2、讲师列表组件中调用api"><a href="#2、讲师列表组件中调用api" class="headerlink" title="2、讲师列表组件中调用api"></a>2、讲师列表组件中调用api</h2><p>pages/teacher/index.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;   import teacher from &#39;@&#x2F;api&#x2F;teacher&#39; export default &#123;   &#x2F;&#x2F; 异步调用，调用一次   &#x2F;&#x2F; params : 相当于之前的this.$route.params.id 等价 params.id   asyncData(&#123;params,error&#125;)&#123;     return teacher.getTeacherList(1,8)      .then(response &#x3D;&gt;&#123;        &#x2F;&#x2F; console.log(response.data.data)        return &#123; data:response.data.data &#125;      &#125;)   &#125; &#125;; &lt;&#x2F;script&gt;</code></pre></div><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><h3 id="1、无数据提示"><a href="#1、无数据提示" class="headerlink" title="1、无数据提示"></a>1、无数据提示</h3><p>添加：v-if=”data.total==0”</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F;无数据提示 开始--&gt;&lt;section class&#x3D;&quot;no-data-wrap&quot; v-if&#x3D;&quot;data.total &#x3D;&#x3D; 0&quot;&gt;  &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;  &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;&lt;&#x2F;section&gt;&lt;!-- &#x2F;无数据提示 结束--&gt;</code></pre></div><h3 id="2、列表"><a href="#2、列表" class="headerlink" title="2、列表"></a>2、列表</h3><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;article class&#x3D;&quot;i-teacher-list&quot; v-if&#x3D;&quot;data.total &gt; 0&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot;&gt;               &lt;li v-for&#x3D;&quot;item in data.items&quot; :key&#x3D;&quot;item.id&quot;&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a :href&#x3D;&quot;&#39;&#x2F;teacher&#x2F;&#39;+item.id&quot; :title&#x3D;&quot;item.name&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img :src&#x3D;&quot;item.avatar&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a :href&#x3D;&quot;&#39;&#x2F;teacher&#x2F;&#39;+item.id&quot; title&#x3D;&quot;item.name&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;&#123;&#123;item.career&#125;&#125;&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;&#123;&#123;item.intro&#125;&#125;&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;                            &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;</code></pre></div><h1 id="讲师分页查询"><a href="#讲师分页查询" class="headerlink" title="讲师分页查询"></a>讲师分页查询</h1><h2 id="1、分页方法"><a href="#1、分页方法" class="headerlink" title="1、分页方法"></a>1、分页方法</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;  &#x2F;&#x2F; 分页切换  &#x2F;&#x2F; 参数是页码数  gotoPage(page)&#123;    teacher.getTeacherList(page,8)     .then(response &#x3D;&gt;&#123;       this.data &#x3D; response.data.data     &#125;)  &#125;&#125;</code></pre></div><h2 id="2、分页页面渲染"><a href="#2、分页页面渲染" class="headerlink" title="2、分页页面渲染"></a>2、分页页面渲染</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 公共分页 开始 --&gt;          &lt;div&gt;            &lt;div class&#x3D;&quot;paging&quot;&gt;              &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;首页&quot;                @click.prevent&#x3D;&quot;gotoPage(1)&quot;&gt;首&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;前一页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.current-1)&quot;&gt;&lt;&lt;&#x2F;a&gt;              &lt;a                v-for&#x3D;&quot;page in data.pages&quot;                :key&#x3D;&quot;page&quot;                :class&#x3D;&quot;&#123;current: data.current &#x3D;&#x3D; page, undisable: data.current &#x3D;&#x3D; page&#125;&quot;                :title&#x3D;&quot;&#39;第&#39;+page+&#39;页&#39;&quot;                href&#x3D;&quot;#&quot;                @click.prevent&#x3D;&quot;gotoPage(page)&quot;&gt;&#123;&#123; page &#125;&#125;&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;后一页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.current+1)&quot;&gt;&gt;&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;末页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.pages)&quot;&gt;末&lt;&#x2F;a&gt;              &lt;div class&#x3D;&quot;clear&quot;&#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;         &lt;!-- 公共分页 结束 --&gt;</code></pre></div><h1 id="讲师详情接口"><a href="#讲师详情接口" class="headerlink" title="讲师详情接口"></a>讲师详情接口</h1><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 讲师详情的功能@GetMapping(&quot;getTeacherFrontInfo&#x2F;&#123;teacherId&#125;&quot;)public R getTeacherFrontInfo(@PathVariable String teacherId)&#123;    &#x2F;&#x2F; 1.根据讲师id查询讲师基本信息    EduTeacher eduTeacher &#x3D; teacherService.getById(teacherId);    &#x2F;&#x2F; 2.根据讲师id查询讲师所有的课程    QueryWrapper&lt;EduCourse&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;teacher_id&quot;,teacherId);    List&lt;EduCourse&gt; courseList &#x3D; courseService.list(wrapper);    return R.ok().data(&quot;teacher&quot;,eduTeacher).data(&quot;courseList&quot;,courseList);&#125;</code></pre></div><h1 id="讲师详情前端"><a href="#讲师详情前端" class="headerlink" title="讲师详情前端"></a>讲师详情前端</h1><h2 id="1、teacher-api"><a href="#1、teacher-api" class="headerlink" title="1、teacher api"></a>1、teacher api</h2><p>api/teacher.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 讲师详情getTeacherInfo(id)&#123;  return request(&#123;    url: &#96;&#x2F;eduservice&#x2F;teacherfront&#x2F;getTeacherFrontInfo&#x2F;$&#123;id&#125;&#96;,    method: &#39;get&#39;  &#125;)&#125;</code></pre></div><h2 id="2、讲师详情页中调用api"><a href="#2、讲师详情页中调用api" class="headerlink" title="2、讲师详情页中调用api"></a>2、讲师详情页中调用api</h2><p>pages/teacher/_id.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;  import teacherApi from &#39;@&#x2F;api&#x2F;teacher&#39;export default &#123;  &#x2F;&#x2F; 异步调用  asyncData(&#123;params,error&#125;)&#123;    &#x2F;&#x2F; params.id获取路由中的id    return teacherApi.getTeacherInfo(params.id)     .then(response &#x3D;&gt;&#123;       return&#123;         teacher: response.data.data.teacher,         courseList : response.data.data.courseList       &#125;     &#125;)  &#125;&#125;;&lt;&#x2F;script&gt;</code></pre></div><h2 id="讲师详情显示"><a href="#讲师详情显示" class="headerlink" title="讲师详情显示"></a>讲师详情显示</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 讲师基本信息 --&gt;        &lt;section class&#x3D;&quot;fl t-infor-box c-desc-content&quot;&gt;          &lt;div class&#x3D;&quot;mt20 ml20&quot;&gt;            &lt;section class&#x3D;&quot;t-infor-pic&quot;&gt;              &lt;img :src&#x3D;&quot;teacher.avatar&quot;&gt;            &lt;&#x2F;section&gt;            &lt;h3 class&#x3D;&quot;hLh30&quot;&gt;              &lt;span class&#x3D;&quot;fsize24 c-333&quot;&gt;&#123;&#123;teacher.name&#125;&#125;&amp;nbsp;                &#123;&#123;teacher.level &#x3D;&#x3D;&#x3D; 1? &#39;高级讲师&#39;:&#39;首席讲师&#39;&#125;&#125;              &lt;&#x2F;span&gt;            &lt;&#x2F;h3&gt;            &lt;section class&#x3D;&quot;mt10&quot;&gt;              &lt;span class&#x3D;&quot;t-tag-bg&quot;&gt;&#123;&#123;teacher.intro&#125;&#125;&lt;&#x2F;span&gt;            &lt;&#x2F;section&gt;            &lt;section class&#x3D;&quot;t-infor-txt&quot;&gt;              &lt;p                class&#x3D;&quot;mt20&quot;&gt;&#123;&#123;teacher.career&#125;&#125;&lt;&#x2F;p&gt;            &lt;&#x2F;section&gt;            &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;section&gt;</code></pre></div><h2 id="无数据提示"><a href="#无数据提示" class="headerlink" title="无数据提示"></a>无数据提示</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F;无数据提示 开始--&gt;&lt;section class&#x3D;&quot;no-data-wrap&quot; v-if&#x3D;&quot;courseList.length &#x3D;&#x3D; 0&quot;&gt;  &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;  &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;&lt;&#x2F;section&gt;&lt;!-- &#x2F;无数据提示 结束--&gt;</code></pre></div><h2 id="当前讲师课程列表"><a href="#当前讲师课程列表" class="headerlink" title="当前讲师课程列表"></a>当前讲师课程列表</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;article class&#x3D;&quot;comm-course-list&quot;&gt;  &lt;ul class&#x3D;&quot;of&quot;&gt;    &lt;li v-for&#x3D;&quot;course in courseList&quot; :key&#x3D;&quot;course.id&quot;&gt;      &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;        &lt;section class&#x3D;&quot;course-img&quot;&gt;          &lt;img :src&#x3D;&quot;course.cover&quot; class&#x3D;&quot;img-responsive&quot; &gt;          &lt;div class&#x3D;&quot;cc-mask&quot;&gt;            &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;section&gt;        &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;          &lt;a href&#x3D;&quot;#&quot; :title&#x3D;&quot;course.title&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123;course.title&#125;&#125;&lt;&#x2F;a&gt;        &lt;&#x2F;h3&gt;      &lt;&#x2F;div&gt;    &lt;&#x2F;li&gt;     &lt;&#x2F;ul&gt;  &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;article&gt;</code></pre></div><h2 id="完整页面"><a href="#完整页面" class="headerlink" title="完整页面"></a>完整页面</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- 讲师介绍 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;header class&#x3D;&quot;comm-title&quot;&gt;         &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;           &lt;span class&#x3D;&quot;c-333&quot;&gt;讲师介绍&lt;&#x2F;span&gt;         &lt;&#x2F;h2&gt;       &lt;&#x2F;header&gt;       &lt;div class&#x3D;&quot;t-infor-wrap&quot;&gt;         &lt;!-- 讲师基本信息 --&gt;         &lt;section class&#x3D;&quot;fl t-infor-box c-desc-content&quot;&gt;           &lt;div class&#x3D;&quot;mt20 ml20&quot;&gt;             &lt;section class&#x3D;&quot;t-infor-pic&quot;&gt;               &lt;img :src&#x3D;&quot;teacher.avatar&quot;&gt;             &lt;&#x2F;section&gt;             &lt;h3 class&#x3D;&quot;hLh30&quot;&gt;               &lt;span class&#x3D;&quot;fsize24 c-333&quot;&gt;&#123;&#123;teacher.name&#125;&#125;&amp;nbsp;                 &#123;&#123;teacher.level &#x3D;&#x3D;&#x3D; 1? &#39;高级讲师&#39;:&#39;首席讲师&#39;&#125;&#125;               &lt;&#x2F;span&gt;             &lt;&#x2F;h3&gt;             &lt;section class&#x3D;&quot;mt10&quot;&gt;               &lt;span class&#x3D;&quot;t-tag-bg&quot;&gt;&#123;&#123;teacher.intro&#125;&#125;&lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;t-infor-txt&quot;&gt;               &lt;p                 class&#x3D;&quot;mt20&quot;&gt;&#123;&#123;teacher.career&#125;&#125;&lt;&#x2F;p&gt;             &lt;&#x2F;section&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;       &lt;section class&#x3D;&quot;mt30&quot;&gt;         &lt;div&gt;           &lt;header class&#x3D;&quot;comm-title all-teacher-title c-course-content&quot;&gt;             &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;               &lt;span class&#x3D;&quot;c-333&quot;&gt;主讲课程&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;             &lt;section class&#x3D;&quot;c-tab-title&quot;&gt;               &lt;a href&#x3D;&quot;javascript: void(0)&quot;&gt;&amp;nbsp;&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;header&gt;           &lt;!-- &#x2F;无数据提示 开始--&gt;           &lt;section class&#x3D;&quot;no-data-wrap&quot; v-if&#x3D;&quot;courseList.length &#x3D;&#x3D; 0&quot;&gt;             &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;             &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;           &lt;&#x2F;section&gt;           &lt;!-- &#x2F;无数据提示 结束--&gt;           &lt;article class&#x3D;&quot;comm-course-list&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot;&gt;               &lt;li v-for&#x3D;&quot;course in courseList&quot; :key&#x3D;&quot;course.id&quot;&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img :src&#x3D;&quot;course.cover&quot; class&#x3D;&quot;img-responsive&quot; &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;#&quot; :title&#x3D;&quot;course.title&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123;course.title&#125;&#125;&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;                           &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;         &lt;&#x2F;div&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;讲师介绍 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt;   import teacherApi from &#39;@&#x2F;api&#x2F;teacher&#39; export default &#123;   &#x2F;&#x2F; 异步调用   asyncData(&#123;params,error&#125;)&#123;     &#x2F;&#x2F; params.id获取路由中的id     return teacherApi.getTeacherInfo(params.id)      .then(response &#x3D;&gt;&#123;        return&#123;          teacher: response.data.data.teacher,          courseList : response.data.data.courseList        &#125;      &#125;)   &#125; &#125;; &lt;&#x2F;script&gt;</code></pre></div><h1 id="课程列表接口"><a href="#课程列表接口" class="headerlink" title="课程列表接口"></a>课程列表接口</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>com.atguigu.eduservice.controller.front</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;coursefront&quot;)@CrossOriginpublic class CourseFrontController &#123;    @Autowired    private EduCourseService courseService;    &#x2F;&#x2F; 条件分页查询课程，前台    @PostMapping(&quot;getCourseFrontList&#x2F;&#123;page&#125;&#x2F;&#123;limit&#125;&quot;)    public R getCourseFrontList(@PathVariable long page, @PathVariable long limit,                                @RequestBody(required &#x3D; false) CourseFrontVo courseFrontVo)&#123;        Page&lt;EduCourse&gt; coursePage &#x3D; new Page&lt;&gt;(page,limit);        Map&lt;String,Object&gt; map &#x3D; courseService.getCourseFrontList(coursePage,courseFrontVo);        return R.ok().data(map);    &#125;&#125;</code></pre></div><h2 id="Service-1"><a href="#Service-1" class="headerlink" title="Service"></a>Service</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 条件分页查询课程，前台Map&lt;String, Object&gt; getCourseFrontList(Page&lt;EduCourse&gt; coursePage, CourseFrontVo courseFrontVo);</code></pre></div><h2 id="serviceImpl-1"><a href="#serviceImpl-1" class="headerlink" title="serviceImpl"></a>serviceImpl</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 条件分页查询课程，前台@Overridepublic Map&lt;String, Object&gt; getCourseFrontList(Page&lt;EduCourse&gt; coursePage, CourseFrontVo courseFrontVo) &#123;    QueryWrapper&lt;EduCourse&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; 先判断传过来的值是否为空    if (!StringUtils.isEmpty(courseFrontVo.getSubjectParentId()))&#123;        &#x2F;&#x2F; 一级标题        wrapper.eq(&quot;subject_parent_id&quot;,courseFrontVo.getSubjectParentId());    &#125;    if (!StringUtils.isEmpty(courseFrontVo.getSubjectId()))&#123;        &#x2F;&#x2F; 二级标题        wrapper.eq(&quot;subject_id&quot;,courseFrontVo.getSubjectId());    &#125;    if (!StringUtils.isEmpty(courseFrontVo.getBuyCountSort()))&#123;        &#x2F;&#x2F; 销售量        wrapper.orderByDesc(&quot;buy_count&quot;);    &#125;    if (!StringUtils.isEmpty(courseFrontVo.getGmtCreateSort()))&#123;        &#x2F;&#x2F; 创建时间        wrapper.orderByDesc(&quot;gmt_create&quot;);    &#125;    if (!StringUtils.isEmpty(courseFrontVo.getPriceSort()))&#123;        &#x2F;&#x2F; 价格        wrapper.orderByDesc(&quot;price&quot;);    &#125;    baseMapper.selectPage(coursePage,wrapper);    List&lt;EduCourse&gt; records &#x3D; coursePage.getRecords();    long current &#x3D; coursePage.getCurrent();    long pages &#x3D; coursePage.getPages();    long size &#x3D; coursePage.getSize();    long total &#x3D; coursePage.getTotal();    boolean hasNext &#x3D; coursePage.hasNext();    boolean hasPrevious &#x3D; coursePage.hasPrevious();    &#x2F;&#x2F; 将查询出来的封装到map    Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();    map.put(&quot;items&quot;,records);    map.put(&quot;current&quot;,current);    map.put(&quot;pages&quot;,pages);    map.put(&quot;size&quot;,size);    map.put(&quot;total&quot;,total);    map.put(&quot;hasNext&quot;,hasNext);    map.put(&quot;hasPrevious&quot;,hasPrevious);    &#x2F;&#x2F; 最后返回map    return map;&#125;</code></pre></div><h1 id="课程列表前端"><a href="#课程列表前端" class="headerlink" title="课程列表前端"></a>课程列表前端</h1><h2 id="1、定义api"><a href="#1、定义api" class="headerlink" title="1、定义api"></a>1、定义api</h2><p>api/course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;  &#x2F;&#x2F; 条件分页查询课程  getCourseList(page,limit,searchObj) &#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;coursefront&#x2F;getCourseFrontList&#x2F;$&#123;page&#125;&#x2F;$&#123;limit&#125;&#96;,      method: &#39;post&#39;,      data:searchObj    &#125;)  &#125;,  &#x2F;&#x2F; 查询所有分类的方法  getAllSubject()&#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;subject&#x2F;findAllSubject&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div><h2 id="2、页面调用接口"><a href="#2、页面调用接口" class="headerlink" title="2、页面调用接口"></a>2、页面调用接口</h2><p>pages/course/index.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;   import courseApi from &#39;@&#x2F;api&#x2F;course&#39; export default &#123;   data()&#123;     return&#123;      page:1,      data:&#123;&#125;,  &#x2F;&#x2F; 当前页的课程列表      subjectNestedList: [], &#x2F;&#x2F; 一级分类列表      subSubjectList: [], &#x2F;&#x2F; 二级分类列表      searchObj: &#123;&#125;, &#x2F;&#x2F; 查询表单对象      oneIndex:-1,      twoIndex:-1,      buyCountSort:&quot;&quot;,      gmtCreateSort:&quot;&quot;,      priceSort:&quot;&quot;     &#125;   &#125;,   created()&#123;     &#x2F;&#x2F; 初始化课程列表     this.initCourse()     &#x2F;&#x2F; 初始化分类     this.initSubject()   &#125;,   methods:&#123;     &#x2F;&#x2F;1 查询第一页课程     initCourse()&#123;       courseApi.getCourseList(1,8,this.searchObj)        .then(response &#x3D;&gt;&#123;          this.data &#x3D; response.data.data        &#125;)     &#125;,     &#x2F;&#x2F; 2查询所有一级分类     initSubject()&#123;       courseApi.getAllSubject()        .then(response &#x3D;&gt;&#123;          this.subjectNestedList &#x3D; response.data.data.list        &#125;)     &#125;,     &#x2F;&#x2F; 3条件分页查询 下一页     gotoPage(page)&#123;       courseApi.getCourseList(page,8,this.searchObj)        .then(response &#x3D;&gt;&#123;          this.data &#x3D; response.data.data        &#125;)     &#125;,     &#x2F;&#x2F; 4二级分类联动，点击一级分类，显示二级分类     searchOne(subjectParentId,index)&#123;      &#x2F;&#x2F; 为了清空排序      this.buyCountSort &#x3D; &quot;&quot;      this.gmtCreateSort &#x3D; &quot;&quot;      this.priceSort &#x3D; &quot;&quot;       &#x2F;&#x2F; 选中一级分类变色，为了样式能显示       this.oneIndex &#x3D; index       this.twoIndex &#x3D; -1       this.searchObj.subjectId &#x3D;&#39;&#39;       this.subSubjectList &#x3D; []       &#x2F;&#x2F; 点击一级分类的时候，把点击的分类的id赋值给searchObj       this.searchObj.subjectParentId &#x3D; subjectParentId       &#x2F;&#x2F; 条件分页查询       this.gotoPage(1)       &#x2F;&#x2F; 拿着一级分类id和所有一级分类id进行比较       &#x2F;&#x2F;遍历所有的一级分类       for(let i &#x3D; 0; i &lt; this.subjectNestedList.length; i++)&#123;         &#x2F;&#x2F; 取到每一个一级分类         var oneSubject &#x3D; this.subjectNestedList[i]         &#x2F;&#x2F; 将传进来的一级分类id和遍历出来的所有一级分类对比         if(subjectParentId &#x3D;&#x3D; oneSubject.id)&#123;           &#x2F;&#x2F; 将查询出来的二级分类赋值给subSubjectList           this.subSubjectList &#x3D; oneSubject.children         &#125;       &#125;     &#125;,     &#x2F;&#x2F; 5.点击二级分类，显示课程    searchTwo(subjectId,index)&#123;      &#x2F;&#x2F; 为了清空排序      this.buyCountSort &#x3D; &quot;&quot;      this.gmtCreateSort &#x3D; &quot;&quot;      this.priceSort &#x3D; &quot;&quot;      &#x2F;&#x2F; 给index赋值，为了让样式生效      this.twoIndex &#x3D; index       &#x2F;&#x2F; 点击二级分类的时候，把点击的分类的id赋值给searchObj       this.searchObj.subjectId &#x3D; subjectId       &#x2F;&#x2F; 条件分页查询      this.gotoPage(1)    &#125;,    &#x2F;&#x2F; 6.按照销量排序    searchBuyCount() &#123;      this.buyCountSort &#x3D; &quot;1&quot;      this.gmtCreateSort &#x3D; &quot;&quot;      this.priceSort &#x3D; &quot;&quot;      this.searchObj.buyCountSort &#x3D; this.buyCountSort      this.searchObj.gmtCreateSort &#x3D; this.gmtCreateSort      this.searchObj.priceSort &#x3D; this.priceSort      this.gotoPage(1)    &#125;,    &#x2F;&#x2F; 7.按照时间排序    searchGmtCreate()&#123;      this.buyCountSort &#x3D; &quot;&quot;      this.gmtCreateSort &#x3D; &quot;1&quot;      this.priceSort &#x3D; &quot;&quot;      this.searchObj.buyCountSort &#x3D; this.buyCountSort      this.searchObj.gmtCreateSort &#x3D; this.gmtCreateSort      this.searchObj.priceSort &#x3D; this.priceSort      this.gotoPage(1)    &#125;,    &#x2F;&#x2F; 8.按照价格排序    searchPrice()&#123;      this.buyCountSort &#x3D; &quot;&quot;      this.gmtCreateSort &#x3D; &quot;&quot;      this.priceSort &#x3D; &quot;1&quot;      this.searchObj.buyCountSort &#x3D; this.buyCountSort      this.searchObj.gmtCreateSort &#x3D; this.gmtCreateSort      this.searchObj.priceSort &#x3D; this.priceSort      this.gotoPage(1)    &#125;   &#125; &#125;; &lt;&#x2F;script&gt;&#x2F;&#x2F; #bdbdbd;rgba(24, 223, 24, 0.514);rgba(172, 255, 47, 0.493); &lt;style scoped&gt;  .active &#123;     background: rgba(24, 223, 24, 0.514);  &#125;  .hide &#123;    display: none;  &#125;  .show &#123;    display: block;  &#125;&lt;&#x2F;style&gt;</code></pre></div><h2 id="3、课程类别显示"><a href="#3、课程类别显示" class="headerlink" title="3、课程类别显示"></a>3、课程类别显示</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;section class&#x3D;&quot;c-s-dl&quot;&gt;           &lt;dl&gt;             &lt;dt&gt;               &lt;span class&#x3D;&quot;c-999 fsize14&quot;&gt;课程类别&lt;&#x2F;span&gt;             &lt;&#x2F;dt&gt;             &lt;dd class&#x3D;&quot;c-s-dl-li&quot;&gt;               &lt;ul class&#x3D;&quot;clearfix&quot;&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;全部&quot; href&#x3D;&quot;#&quot;&gt;全部&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li v-for&#x3D;&quot;(item,index) in subjectNestedList&quot; :key&#x3D;&quot;index&quot;  :class&#x3D;&quot;&#123;active:oneIndex&#x3D;&#x3D;index&#125;&quot;&gt;                   &lt;a :title&#x3D;&quot;item.title&quot; href&#x3D;&quot;#&quot; @click&#x3D;&quot;searchOne(item.id,index)&quot; &gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;             &lt;&#x2F;dd&gt;           &lt;&#x2F;dl&gt;           &lt;dl&gt;             &lt;dt&gt;               &lt;span class&#x3D;&quot;c-999 fsize14&quot;&gt;&lt;&#x2F;span&gt;             &lt;&#x2F;dt&gt;             &lt;dd class&#x3D;&quot;c-s-dl-li&quot;&gt;               &lt;ul class&#x3D;&quot;clearfix&quot;&gt;                 &lt;li v-for&#x3D;&quot;(item,index) in subSubjectList&quot; :key&#x3D;&quot;index&quot; :class&#x3D;&quot;&#123;active:twoIndex&#x3D;&#x3D;index&#125;&quot;&gt;                   &lt;a :title&#x3D;&quot;item.title&quot; href&#x3D;&quot;#&quot; @click&#x3D;&quot;searchTwo(item.id,index)&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                               &lt;&#x2F;ul&gt;             &lt;&#x2F;dd&gt;           &lt;&#x2F;dl&gt;           &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;</code></pre></div><h2 id="4、排序方式显示"><a href="#4、排序方式显示" class="headerlink" title="4、排序方式显示"></a>4、排序方式显示</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;section class&#x3D;&quot;fl&quot;&gt;  &lt;ol class&#x3D;&quot;js-tap clearfix&quot;&gt;     &lt;li :class&#x3D;&quot;&#123;&#39;current bg-orange&#39;:buyCountSort!&#x3D;&#39;&#39;&#125;&quot;&gt;       &lt;a title&#x3D;&quot;销量&quot; href&#x3D;&quot;javascript:void(0);&quot; @click&#x3D;&quot;searchBuyCount()&quot;&gt;销量       &lt;span :class&#x3D;&quot;&#123;hide:buyCountSort&#x3D;&#x3D;&#39;&#39;&#125;&quot;&gt;↓&lt;&#x2F;span&gt;       &lt;&#x2F;a&gt;     &lt;&#x2F;li&gt;     &lt;li :class&#x3D;&quot;&#123;&#39;current bg-orange&#39;:gmtCreateSort!&#x3D;&#39;&#39;&#125;&quot;&gt;       &lt;a title&#x3D;&quot;最新&quot; href&#x3D;&quot;javascript:void(0);&quot; @click&#x3D;&quot;searchGmtCreate()&quot;&gt;最新       &lt;span :class&#x3D;&quot;&#123;hide:gmtCreateSort&#x3D;&#x3D;&#39;&#39;&#125;&quot;&gt;↓&lt;&#x2F;span&gt;       &lt;&#x2F;a&gt;     &lt;&#x2F;li&gt;     &lt;li :class&#x3D;&quot;&#123;&#39;current bg-orange&#39;:priceSort!&#x3D;&#39;&#39;&#125;&quot;&gt;       &lt;a title&#x3D;&quot;价格&quot; href&#x3D;&quot;javascript:void(0);&quot; @click&#x3D;&quot;searchPrice()&quot;&gt;价格&amp;nbsp;         &lt;span :class&#x3D;&quot;&#123;hide:priceSort&#x3D;&#x3D;&#39;&#39;&#125;&quot;&gt;↓&lt;&#x2F;span&gt;       &lt;&#x2F;a&gt;     &lt;&#x2F;li&gt;  &lt;&#x2F;ol&gt;&lt;&#x2F;section&gt;</code></pre></div><h2 id="5、无数据提示"><a href="#5、无数据提示" class="headerlink" title="5、无数据提示"></a>5、无数据提示</h2><p>添加：v-if=”data.total==0”</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F;无数据提示 开始--&gt;&lt;section class&#x3D;&quot;no-data-wrap&quot; v-if&#x3D;&quot;data.total &#x3D;&#x3D; 0&quot;&gt;  &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;  &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;&lt;&#x2F;section&gt;&lt;!-- &#x2F;无数据提示 结束--&gt;</code></pre></div><h2 id="6、列表"><a href="#6、列表" class="headerlink" title="6、列表"></a>6、列表</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;article class&#x3D;&quot;comm-course-list&quot;  v-if&#x3D;&quot;data.total &gt; 0&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot; id&#x3D;&quot;bna&quot;&gt;               &lt;li v-for&#x3D;&quot;(item,index) in data.items&quot; :key&#x3D;&quot;index&quot;&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img :src&#x3D;&quot;item.cover&quot; class&#x3D;&quot;img-responsive&quot; :alt&#x3D;&quot;item.title&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a :href&#x3D;&quot;&#39;&#x2F;course&#x2F;&#39;+item.id&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a :href&#x3D;&quot;&#39;&#x2F;course&#x2F;&#39;+item.id&quot; :title&#x3D;&quot;item.title&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span v-if&#x3D;&quot;Number(item.price) &#x3D;&#x3D; 0&quot; class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;</code></pre></div><h2 id="7、分页页面渲染"><a href="#7、分页页面渲染" class="headerlink" title="7、分页页面渲染"></a>7、分页页面渲染</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 公共分页 开始 --&gt;          &lt;div&gt;            &lt;div class&#x3D;&quot;paging&quot;&gt;              &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;首页&quot;                @click.prevent&#x3D;&quot;gotoPage(1)&quot;&gt;首&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;前一页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.current-1)&quot;&gt;&lt;&lt;&#x2F;a&gt;              &lt;a                v-for&#x3D;&quot;page in data.pages&quot;                :key&#x3D;&quot;page&quot;                :class&#x3D;&quot;&#123;current: data.current &#x3D;&#x3D; page, undisable: data.current &#x3D;&#x3D; page&#125;&quot;                :title&#x3D;&quot;&#39;第&#39;+page+&#39;页&#39;&quot;                href&#x3D;&quot;#&quot;                @click.prevent&#x3D;&quot;gotoPage(page)&quot;&gt;&#123;&#123; page &#125;&#125;&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;后一页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.current+1)&quot;&gt;&gt;&lt;&#x2F;a&gt;              &lt;a                :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;                href&#x3D;&quot;#&quot;                title&#x3D;&quot;末页&quot;                @click.prevent&#x3D;&quot;gotoPage(data.pages)&quot;&gt;末&lt;&#x2F;a&gt;              &lt;div class&#x3D;&quot;clear&quot;&#x2F;&gt;            &lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;         &lt;!-- 公共分页 结束 --&gt;</code></pre></div><h1 id="课程详情功能接口"><a href="#课程详情功能接口" class="headerlink" title="课程详情功能接口"></a>课程详情功能接口</h1><h2 id="Vo"><a href="#Vo" class="headerlink" title="Vo"></a>Vo</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class CourseFrontVo implements Serializable &#123;    private static final long serialVersionUID &#x3D; 1L;    @ApiModelProperty(value &#x3D; &quot;课程名称&quot;)    private String title;    @ApiModelProperty(value &#x3D; &quot;讲师id&quot;)    private String teacherId;    @ApiModelProperty(value &#x3D; &quot;一级类别id&quot;)    private String subjectParentId;    @ApiModelProperty(value &#x3D; &quot;二级类别id&quot;)    private String subjectId;    @ApiModelProperty(value &#x3D; &quot;销量排序&quot;)    private String buyCountSort;    @ApiModelProperty(value &#x3D; &quot;最新时间排序&quot;)    private String gmtCreateSort;    @ApiModelProperty(value &#x3D; &quot;价格排序&quot;)    private String priceSort;&#125;</code></pre></div><h2 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 2.课程详情的方法@GetMapping(&quot;getFrontCourseInfo&#x2F;&#123;courseId&#125;&quot;)public R getFrontCourseInfo(@PathVariable String courseId)&#123;    &#x2F;&#x2F; 根据课程id，编写SQL语句查询课程信息    CourseWebVo courseWebVo &#x3D; courseService.getBaseCourseInfo(courseId);    &#x2F;&#x2F; 根据课程id，查询章节和小节    List&lt;ChapterVo&gt; chapterVideoList &#x3D; chapterService.getAllChapterVideo(courseId);    return R.ok().data(&quot;courseWebVo&quot;,courseWebVo).data(&quot;chapterVideoList&quot;,chapterVideoList);&#125;</code></pre></div><h2 id="Service-2"><a href="#Service-2" class="headerlink" title="Service"></a>Service</h2><p>package com.atguigu.eduservice.service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id，编写SQL语句查询课程信息CourseWebVo getBaseCourseInfo(String courseId);</code></pre></div><h2 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h2><p>com.atguigu.eduservice.service.impl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id，编写SQL语句查询课程信息@Overridepublic CourseWebVo getBaseCourseInfo(String courseId) &#123;    return baseMapper.getBaseCourseInfo(courseId);&#125;</code></pre></div><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><p>package com.atguigu.eduservice.mapper</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id，编写SQL语句查询课程信息CourseWebVo getBaseCourseInfo(String courseId);</code></pre></div><h2 id="Xml"><a href="#Xml" class="headerlink" title="Xml"></a>Xml</h2><p>com/atguigu/eduservice/mapper/xml/EduCourseMapper.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--根据课程id查询课程前端详情信息--&gt;&lt;select id&#x3D;&quot;getBaseCourseInfo&quot; resultType&#x3D;&quot;com.atguigu.eduservice.entity.frontvo.CourseWebVo&quot;&gt;    SELECT      ec.&#96;id&#96;,      ec.&#96;title&#96;,      ec.&#96;price&#96;,      ec.&#96;lesson_num&#96; AS lessonNum,      ec.&#96;cover&#96;,      ec.&#96;buy_count&#96; AS buyCount,      ec.&#96;view_count&#96; AS viewCount,      ecd.&#96;description&#96; AS description,      et.&#96;id&#96; AS teacherId,      et.&#96;name&#96; AS teacherName,      et.&#96;intro&#96; AS intro,      et.&#96;avatar&#96;AS avatar,      es1.&#96;id&#96; AS subjectLevelOneId,      es1.&#96;title&#96; AS subjectLevelOne,      es2.&#96;id&#96; AS subjectLevelTwoId,      es2.&#96;title&#96; AS subjectLevelTwo    FROM      edu_course ec      LEFT OUTER JOIN edu_course_description ecd        ON ec.&#96;id&#96; &#x3D; ecd.&#96;id&#96;      LEFT OUTER JOIN edu_teacher et        ON ec.&#96;teacher_id&#96; &#x3D; et.&#96;id&#96;      LEFT OUTER JOIN edu_subject es1        ON ec.&#96;subject_parent_id&#96; &#x3D; es1.&#96;id&#96;      LEFT OUTER JOIN edu_subject es2        ON ec.&#96;subject_id&#96; &#x3D; es2.&#96;id&#96;    WHERE ec.&#96;id&#96; &#x3D; #&#123;courseId&#125;&lt;&#x2F;select&gt;</code></pre></div><h1 id="课程详情功能前端"><a href="#课程详情功能前端" class="headerlink" title="课程详情功能前端"></a>课程详情功能前端</h1><h2 id="1、api-course-js"><a href="#1、api-course-js" class="headerlink" title="1、api/course.js"></a>1、api/course.js</h2><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据id查询课程详情信息getCourseInfo(id)&#123;  return request(&#123;    url: &#96;&#x2F;eduservice&#x2F;coursefront&#x2F;getFrontCourseInfo&#x2F;$&#123;id&#125;&#96;,    method: &#39;get&#39;  &#125;)&#125;</code></pre></div><h2 id="2、pages-course-id-vue"><a href="#2、pages-course-id-vue" class="headerlink" title="2、pages/course/_id.vue"></a>2、pages/course/_id.vue</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"> &lt;script&gt;import course from &quot;@&#x2F;api&#x2F;course&quot; export default &#123;   asyncData(&#123; params, error  &#125;)&#123;     console.log(params.id)     return course.getCourseInfo(params.id)      .then(response &#x3D;&gt;&#123;        console.log(response)        return&#123;          courseWebVo: response.data.data.courseWebVo,          chapterVideoList: response.data.data.chapterVideoList        &#125;      &#125;)   &#125;    &#125;; &lt;&#x2F;scrip&gt;</code></pre></div><h2 id="课程所属分类"><a href="#课程所属分类" class="headerlink" title="课程所属分类"></a>课程所属分类</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F;课程详情 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;section class&#x3D;&quot;path-wrap txtOf hLh30&quot;&gt;         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;首页&lt;&#x2F;a&gt;         \         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;&#123;&#123;courseWebVo.subjectLevelOne&#125;&#125;&lt;&#x2F;a&gt;         \         &lt;span class&#x3D;&quot;c-333 fsize14&quot;&gt;&#123;&#123;courseWebVo.subjectLevelTwo&#125;&#125;&lt;&#x2F;span&gt;       &lt;&#x2F;section&gt;</code></pre></div><h2 id="课程基本信息"><a href="#课程基本信息" class="headerlink" title="课程基本信息"></a>课程基本信息</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div&gt;        &lt;article class&#x3D;&quot;c-v-pic-wrap&quot; style&#x3D;&quot;height: 357px;&quot;&gt;          &lt;section class&#x3D;&quot;p-h-video-box&quot; id&#x3D;&quot;videoPlay&quot;&gt;            &lt;img :src&#x3D;&quot;courseWebVo.cover&quot; :alt&#x3D;&quot;courseWebVo.title&quot; class&#x3D;&quot;dis c-v-pic&quot;&gt;          &lt;&#x2F;section&gt;        &lt;&#x2F;article&gt;        &lt;aside class&#x3D;&quot;c-attr-wrap&quot;&gt;          &lt;section class&#x3D;&quot;ml20 mr15&quot;&gt;            &lt;h2 class&#x3D;&quot;hLh30 txtOf mt15&quot;&gt;              &lt;span class&#x3D;&quot;c-fff fsize24&quot;&gt;&#123;&#123;courseWebVo.title&#125;&#125;&lt;&#x2F;span&gt;            &lt;&#x2F;h2&gt;            &lt;section class&#x3D;&quot;c-attr-jg&quot;&gt;              &lt;span class&#x3D;&quot;c-fff&quot;&gt;价格：&lt;&#x2F;span&gt;              &lt;b class&#x3D;&quot;c-yellow&quot; style&#x3D;&quot;font-size:24px;&quot;&gt;￥&#123;&#123;courseWebVo.price&#125;&#125;&lt;&#x2F;b&gt;            &lt;&#x2F;section&gt;            &lt;section class&#x3D;&quot;c-attr-mt c-attr-undis&quot;&gt;              &lt;span class&#x3D;&quot;c-fff fsize14&quot;&gt;主讲： &#123;&#123;courseWebVo.teacherName&#125;&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;&#x2F;span&gt;            &lt;&#x2F;section&gt;            &lt;section class&#x3D;&quot;c-attr-mt of&quot;&gt;              &lt;span class&#x3D;&quot;ml10 vam&quot;&gt;                &lt;em class&#x3D;&quot;icon18 scIcon&quot;&gt;&lt;&#x2F;em&gt;                &lt;a class&#x3D;&quot;c-fff vam&quot; title&#x3D;&quot;收藏&quot; href&#x3D;&quot;#&quot; &gt;收藏&lt;&#x2F;a&gt;              &lt;&#x2F;span&gt;            &lt;&#x2F;section&gt;            &lt;section class&#x3D;&quot;c-attr-mt&quot;&gt;              &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;立即观看&quot; class&#x3D;&quot;comm-btn c-btn-3&quot;&gt;立即观看&lt;&#x2F;a&gt;            &lt;&#x2F;section&gt;          &lt;&#x2F;section&gt;        &lt;&#x2F;aside&gt;        &lt;aside class&#x3D;&quot;thr-attr-box&quot;&gt;          &lt;ol class&#x3D;&quot;thr-attr-ol clearfix&quot;&gt;            &lt;li&gt;              &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;              &lt;aside&gt;                &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;购买数&lt;&#x2F;span&gt;                &lt;br&gt;                &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.buyCount&#125;&#125;&#125;&lt;&#x2F;h6&gt;              &lt;&#x2F;aside&gt;            &lt;&#x2F;li&gt;            &lt;li&gt;              &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;              &lt;aside&gt;                &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;课时数&lt;&#x2F;span&gt;                &lt;br&gt;                &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.lessonNum&#125;&#125;&lt;&#x2F;h6&gt;              &lt;&#x2F;aside&gt;            &lt;&#x2F;li&gt;            &lt;li&gt;              &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;              &lt;aside&gt;                &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;浏览数&lt;&#x2F;span&gt;                &lt;br&gt;                &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.viewCount&#125;&#125;&lt;&#x2F;h6&gt;              &lt;&#x2F;aside&gt;            &lt;&#x2F;li&gt;          &lt;&#x2F;ol&gt;        &lt;&#x2F;aside&gt;        &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;</code></pre></div><h2 id="课程详情介绍"><a href="#课程详情介绍" class="headerlink" title="课程详情介绍"></a>课程详情介绍</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div&gt;                  &lt;h6 class&#x3D;&quot;c-i-content c-infor-title&quot;&gt;                    &lt;span&gt;课程介绍&lt;&#x2F;span&gt;                  &lt;&#x2F;h6&gt;                  &lt;div class&#x3D;&quot;course-txt-body-wrap&quot;&gt;                    &lt;section class&#x3D;&quot;course-txt-body&quot;&gt;                      &lt;p v-html&#x3D;&quot;courseWebVo.description&quot; &gt;&#123;&#123;courseWebVo.description&#125;&#125;&lt;&#x2F;p&gt;                    &lt;&#x2F;section&gt;                  &lt;&#x2F;div&gt;                &lt;&#x2F;div&gt;</code></pre></div><h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F;课程介绍 --&gt;                 &lt;div class&#x3D;&quot;mt50&quot;&gt;                   &lt;h6 class&#x3D;&quot;c-g-content c-infor-title&quot;&gt;                     &lt;span&gt;课程大纲&lt;&#x2F;span&gt;                   &lt;&#x2F;h6&gt;                   &lt;section class&#x3D;&quot;mt20&quot;&gt;                     &lt;div class&#x3D;&quot;lh-menu-wrap&quot;&gt;                       &lt;menu id&#x3D;&quot;lh-menu&quot; class&#x3D;&quot;lh-menu mt10 mr10&quot;&gt;                         &lt;ul&gt;                           &lt;!-- 文件目录 --&gt;                           &lt;li class&#x3D;&quot;lh-menu-stair&quot; v-for&#x3D;&quot;chapter in chapterVideoList&quot; :key&#x3D;&quot;chapter.id&quot;&gt;                             &lt;a href&#x3D;&quot;javascript: void(0)&quot; :title&#x3D;&quot;chapter.title&quot; class&#x3D;&quot;current-1&quot;&gt;                               &lt;em class&#x3D;&quot;lh-menu-i-1 icon18 mr10&quot;&gt;&lt;&#x2F;em&gt;&#123;&#123;chapter.title&#125;&#125;                             &lt;&#x2F;a&gt;                             &lt;ol class&#x3D;&quot;lh-menu-ol&quot; style&#x3D;&quot;display: block;&quot;&gt;                               &lt;li class&#x3D;&quot;lh-menu-second ml30&quot; v-for&#x3D;&quot;video in chapter.children&quot; :key&#x3D;&quot;video.id&quot;&gt;                                 &lt;a href&#x3D;&quot;#&quot; title&gt;                                   &lt;span class&#x3D;&quot;fr&quot; v-if&#x3D;&quot;Number(courseWebVo.price) &#x3D;&#x3D; 0&quot;&gt;                                     &lt;i class&#x3D;&quot;free-icon vam mr10&quot; &gt;免费试听&lt;&#x2F;i&gt;                                   &lt;&#x2F;span&gt;                                   &lt;em class&#x3D;&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;&#123;&#123;video.title&#125;&#125;                                 &lt;&#x2F;a&gt;                               &lt;&#x2F;li&gt;                                                            &lt;&#x2F;ol&gt;                           &lt;&#x2F;li&gt;                         &lt;&#x2F;ul&gt;                       &lt;&#x2F;menu&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;                 &lt;!-- &#x2F;课程大纲 --&gt;</code></pre></div><h2 id="主讲讲师"><a href="#主讲讲师" class="headerlink" title="主讲讲师"></a>主讲讲师</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;div class&#x3D;&quot;i-box&quot;&gt;             &lt;div&gt;               &lt;section class&#x3D;&quot;c-infor-tabTitle c-tab-title&quot;&gt;                 &lt;a title href&#x3D;&quot;javascript:void(0)&quot;&gt;主讲讲师&lt;&#x2F;a&gt;               &lt;&#x2F;section&gt;               &lt;section class&#x3D;&quot;stud-act-list&quot;&gt;                 &lt;ul style&#x3D;&quot;height: auto;&quot;&gt;                   &lt;li&gt;                     &lt;div class&#x3D;&quot;u-face&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot;&gt;                         &lt;img :src&#x3D;&quot;courseWebVo.avatar&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; alt&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;section class&#x3D;&quot;hLh30 txtOf&quot;&gt;                       &lt;a class&#x3D;&quot;c-333 fsize16 fl&quot; href&#x3D;&quot;#&quot;&gt;&#123;&#123;courseWebVo.teacherName&#125;&#125;&lt;&#x2F;a&gt;                     &lt;&#x2F;section&gt;                     &lt;section class&#x3D;&quot;hLh20 txtOf&quot;&gt;                       &lt;span class&#x3D;&quot;c-999&quot;&gt;&#123;&#123;courseWebVo.intro&#125;&#125;&lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;li&gt;                 &lt;&#x2F;ul&gt;               &lt;&#x2F;section&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;</code></pre></div><h2 id="完整页面-1"><a href="#完整页面-1" class="headerlink" title="完整页面"></a>完整页面</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- &#x2F;课程详情 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;section class&#x3D;&quot;path-wrap txtOf hLh30&quot;&gt;         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;首页&lt;&#x2F;a&gt;         \         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;&#123;&#123;courseWebVo.subjectLevelOne&#125;&#125;&lt;&#x2F;a&gt;         \         &lt;span class&#x3D;&quot;c-333 fsize14&quot;&gt;&#123;&#123;courseWebVo.subjectLevelTwo&#125;&#125;&lt;&#x2F;span&gt;       &lt;&#x2F;section&gt;       &lt;div&gt;         &lt;article class&#x3D;&quot;c-v-pic-wrap&quot; style&#x3D;&quot;height: 357px;&quot;&gt;           &lt;section class&#x3D;&quot;p-h-video-box&quot; id&#x3D;&quot;videoPlay&quot;&gt;             &lt;img :src&#x3D;&quot;courseWebVo.cover&quot; :alt&#x3D;&quot;courseWebVo.title&quot; class&#x3D;&quot;dis c-v-pic&quot;&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;article&gt;         &lt;aside class&#x3D;&quot;c-attr-wrap&quot;&gt;           &lt;section class&#x3D;&quot;ml20 mr15&quot;&gt;             &lt;h2 class&#x3D;&quot;hLh30 txtOf mt15&quot;&gt;               &lt;span class&#x3D;&quot;c-fff fsize24&quot;&gt;&#123;&#123;courseWebVo.title&#125;&#125;&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;             &lt;section class&#x3D;&quot;c-attr-jg&quot;&gt;               &lt;span class&#x3D;&quot;c-fff&quot;&gt;价格：&lt;&#x2F;span&gt;               &lt;b class&#x3D;&quot;c-yellow&quot; style&#x3D;&quot;font-size:24px;&quot;&gt;￥&#123;&#123;courseWebVo.price&#125;&#125;&lt;&#x2F;b&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt c-attr-undis&quot;&gt;               &lt;span class&#x3D;&quot;c-fff fsize14&quot;&gt;主讲： &#123;&#123;courseWebVo.teacherName&#125;&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt of&quot;&gt;               &lt;span class&#x3D;&quot;ml10 vam&quot;&gt;                 &lt;em class&#x3D;&quot;icon18 scIcon&quot;&gt;&lt;&#x2F;em&gt;                 &lt;a class&#x3D;&quot;c-fff vam&quot; title&#x3D;&quot;收藏&quot; href&#x3D;&quot;#&quot; &gt;收藏&lt;&#x2F;a&gt;               &lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;立即观看&quot; class&#x3D;&quot;comm-btn c-btn-3&quot;&gt;立即观看&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;aside&gt;         &lt;aside class&#x3D;&quot;thr-attr-box&quot;&gt;           &lt;ol class&#x3D;&quot;thr-attr-ol clearfix&quot;&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;购买数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.buyCount&#125;&#125;&#125;&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;课时数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.lessonNum&#125;&#125;&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;浏览数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;&#123;&#123;courseWebVo.viewCount&#125;&#125;&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;           &lt;&#x2F;ol&gt;         &lt;&#x2F;aside&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;       &lt;!-- &#x2F;课程封面介绍 --&gt;       &lt;div class&#x3D;&quot;mt20 c-infor-box&quot;&gt;         &lt;article class&#x3D;&quot;fl col-7&quot;&gt;           &lt;section class&#x3D;&quot;mr30&quot;&gt;             &lt;div class&#x3D;&quot;i-box&quot;&gt;               &lt;div&gt;                 &lt;section id&#x3D;&quot;c-i-tabTitle&quot; class&#x3D;&quot;c-infor-tabTitle c-tab-title&quot;&gt;                   &lt;a name&#x3D;&quot;c-i&quot; class&#x3D;&quot;current&quot; title&#x3D;&quot;课程详情&quot;&gt;课程详情&lt;&#x2F;a&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;div&gt;               &lt;article class&#x3D;&quot;ml10 mr10 pt20&quot;&gt;                 &lt;div&gt;                   &lt;h6 class&#x3D;&quot;c-i-content c-infor-title&quot;&gt;                     &lt;span&gt;课程介绍&lt;&#x2F;span&gt;                   &lt;&#x2F;h6&gt;                   &lt;div class&#x3D;&quot;course-txt-body-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-txt-body&quot;&gt;                       &lt;p v-html&#x3D;&quot;courseWebVo.description&quot; &gt;&#123;&#123;courseWebVo.description&#125;&#125;&lt;&#x2F;p&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;div&gt;                 &lt;!-- &#x2F;课程介绍 --&gt;                 &lt;div class&#x3D;&quot;mt50&quot;&gt;                   &lt;h6 class&#x3D;&quot;c-g-content c-infor-title&quot;&gt;                     &lt;span&gt;课程大纲&lt;&#x2F;span&gt;                   &lt;&#x2F;h6&gt;                   &lt;section class&#x3D;&quot;mt20&quot;&gt;                     &lt;div class&#x3D;&quot;lh-menu-wrap&quot;&gt;                       &lt;menu id&#x3D;&quot;lh-menu&quot; class&#x3D;&quot;lh-menu mt10 mr10&quot;&gt;                         &lt;ul&gt;                           &lt;!-- 文件目录 --&gt;                           &lt;li class&#x3D;&quot;lh-menu-stair&quot; v-for&#x3D;&quot;chapter in chapterVideoList&quot; :key&#x3D;&quot;chapter.id&quot;&gt;                             &lt;a href&#x3D;&quot;javascript: void(0)&quot; :title&#x3D;&quot;chapter.title&quot; class&#x3D;&quot;current-1&quot;&gt;                               &lt;em class&#x3D;&quot;lh-menu-i-1 icon18 mr10&quot;&gt;&lt;&#x2F;em&gt;&#123;&#123;chapter.title&#125;&#125;                             &lt;&#x2F;a&gt;                             &lt;ol class&#x3D;&quot;lh-menu-ol&quot; style&#x3D;&quot;display: block;&quot;&gt;                               &lt;li class&#x3D;&quot;lh-menu-second ml30&quot; v-for&#x3D;&quot;video in chapter.children&quot; :key&#x3D;&quot;video.id&quot;&gt;                                 &lt;a href&#x3D;&quot;#&quot; title&gt;                                   &lt;span class&#x3D;&quot;fr&quot; v-if&#x3D;&quot;Number(courseWebVo.price) &#x3D;&#x3D; 0&quot;&gt;                                     &lt;i class&#x3D;&quot;free-icon vam mr10&quot; &gt;免费试听&lt;&#x2F;i&gt;                                   &lt;&#x2F;span&gt;                                   &lt;em class&#x3D;&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;&#123;&#123;video.title&#125;&#125;                                 &lt;&#x2F;a&gt;                               &lt;&#x2F;li&gt;                                                            &lt;&#x2F;ol&gt;                           &lt;&#x2F;li&gt;                         &lt;&#x2F;ul&gt;                       &lt;&#x2F;menu&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;                 &lt;!-- &#x2F;课程大纲 --&gt;               &lt;&#x2F;article&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;article&gt;         &lt;aside class&#x3D;&quot;fl col-3&quot;&gt;           &lt;div class&#x3D;&quot;i-box&quot;&gt;             &lt;div&gt;               &lt;section class&#x3D;&quot;c-infor-tabTitle c-tab-title&quot;&gt;                 &lt;a title href&#x3D;&quot;javascript:void(0)&quot;&gt;主讲讲师&lt;&#x2F;a&gt;               &lt;&#x2F;section&gt;               &lt;section class&#x3D;&quot;stud-act-list&quot;&gt;                 &lt;ul style&#x3D;&quot;height: auto;&quot;&gt;                   &lt;li&gt;                     &lt;div class&#x3D;&quot;u-face&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot;&gt;                         &lt;img :src&#x3D;&quot;courseWebVo.avatar&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; alt&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;section class&#x3D;&quot;hLh30 txtOf&quot;&gt;                       &lt;a class&#x3D;&quot;c-333 fsize16 fl&quot; href&#x3D;&quot;#&quot;&gt;&#123;&#123;courseWebVo.teacherName&#125;&#125;&lt;&#x2F;a&gt;                     &lt;&#x2F;section&gt;                     &lt;section class&#x3D;&quot;hLh20 txtOf&quot;&gt;                       &lt;span class&#x3D;&quot;c-999&quot;&gt;&#123;&#123;courseWebVo.intro&#125;&#125;&lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;li&gt;                 &lt;&#x2F;ul&gt;               &lt;&#x2F;section&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;aside&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;课程详情 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt;import course from &quot;@&#x2F;api&#x2F;course&quot; export default &#123;   asyncData(&#123; params, error  &#125;)&#123;     console.log(params.id)     return course.getCourseInfo(params.id)      .then(response &#x3D;&gt;&#123;        console.log(response)        return&#123;          courseWebVo: response.data.data.courseWebVo,          chapterVideoList: response.data.data.chapterVideoList        &#125;      &#125;)   &#125;    &#125;; &lt;&#x2F;script&gt;</code></pre></div><h1 id="整合阿里云视频播放器测试"><a href="#整合阿里云视频播放器测试" class="headerlink" title="整合阿里云视频播放器测试"></a>整合阿里云视频播放器测试</h1><h2 id="视频地址播放"><a href="#视频地址播放" class="headerlink" title="视频地址播放"></a>视频地址播放</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;skins&#x2F;default&#x2F;aliplayer-min.css&quot; &#x2F;&gt;&lt;script charset&#x3D;&quot;utf-8&quot; type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;aliplayer-min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;body&gt;    &lt;div  class&#x3D;&quot;prism-player&quot; id&#x3D;&quot;J_prismPlayer&quot;&gt;&lt;&#x2F;div&gt;        &lt;script&gt;            var player &#x3D; new Aliplayer(&#123;                id: &#39;J_prismPlayer&#39;,                width: &#39;100%&#39;,                autoplay: false,                cover: &#39;http:&#x2F;&#x2F;liveroom-img.oss-cn-qingdao.aliyuncs.com&#x2F;logo.png&#39;,                  &#x2F;&#x2F;播放配置                &#x2F;&#x2F;播放方式一：支持播放地址播放,此播放优先级最高，此种方式不能播放加密视频                source : &#39;https:&#x2F;&#x2F;outin-e7915c6967b411eca96500163e1c60dc.oss-cn-shanghai.aliyuncs.com&#x2F;sv&#x2F;12b862d3-17e007b353b&#x2F;12b862d3-17e007b353b.mp4?Expires&#x3D;1641138735&amp;OSSAccessKeyId&#x3D;LTAIxSaOfEzCnBOj&amp;Signature&#x3D;LZvaSss9BmRFXSrXL6DMmhmi%2BiQ%3D&#39;,            &#125;,function(player)&#123;                           &#125;);        &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h2 id="凭证播放"><a href="#凭证播放" class="headerlink" title="凭证播放"></a>凭证播放</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;skins&#x2F;default&#x2F;aliplayer-min.css&quot; &#x2F;&gt;&lt;script charset&#x3D;&quot;utf-8&quot; type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;aliplayer-min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;body&gt;    &lt;div  class&#x3D;&quot;prism-player&quot; id&#x3D;&quot;J_prismPlayer&quot;&gt;&lt;&#x2F;div&gt;        &lt;script&gt;            var player &#x3D; new Aliplayer(&#123;                id: &#39;J_prismPlayer&#39;,                width: &#39;100%&#39;,                autoplay: false,                cover: &#39;http:&#x2F;&#x2F;liveroom-img.oss-cn-qingdao.aliyuncs.com&#x2F;logo.png&#39;,                  &#x2F;&#x2F;播放配置                encryptType:&#39;1&#39;,&#x2F;&#x2F;如果播放加密视频，则需设置encryptType&#x3D;1，非加密视频无需设置此项                vid: &#39;&#39;,&#x2F;&#x2F; 视频id                playauth : &#39;&#39;,&#x2F;&#x2F; 授权信息            &#125;,function(player)&#123;                           &#125;);        &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h1 id="整合阿里云视频播放器"><a href="#整合阿里云视频播放器" class="headerlink" title="整合阿里云视频播放器"></a>整合阿里云视频播放器</h1><h2 id="一、后端获取播放凭证"><a href="#一、后端获取播放凭证" class="headerlink" title="一、后端获取播放凭证"></a>一、后端获取播放凭证</h2><h3 id="1、VideoController"><a href="#1、VideoController" class="headerlink" title="1、VideoController"></a>1、VideoController</h3><p>service-vod微服务中创建 VideoController.java</p><p>controller中创建 getVideoAuth接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据视频id获取凭证@GetMapping(&quot;getVideoAuth&#x2F;&#123;id&#125;&quot;)public R getVideoAuth(@PathVariable String id)&#123;    try &#123;        &#x2F;&#x2F; 创建初始化对象        DefaultAcsClient client &#x3D; InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET);        &#x2F;&#x2F; 创建获取凭证的request和response对象        GetVideoPlayAuthRequest request &#x3D; new GetVideoPlayAuthRequest();        &#x2F;&#x2F; 设置视频id        request.setVideoId(id);        &#x2F;&#x2F; 调用初始化对象获取凭证        GetVideoPlayAuthResponse response &#x3D; client.getAcsResponse(request);        String playAuth &#x3D; response.getPlayAuth();        return R.ok().data(&quot;playAuth&quot;,playAuth);    &#125; catch (ClientException e) &#123;        e.printStackTrace();        throw new GuliException(20001,&quot;获取凭证失败&quot;);    &#125;&#125;</code></pre></div><h2 id="二、前端播放器整合"><a href="#二、前端播放器整合" class="headerlink" title="二、前端播放器整合"></a>二、前端播放器整合</h2><h3 id="1、点击播放超链接"><a href="#1、点击播放超链接" class="headerlink" title="1、点击播放超链接"></a>1、点击播放超链接</h3><p>course/_id.vue</p><p>修改课时目录超链接</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;a :href&#x3D;&quot;&#39;&#x2F;player&#x2F;&#39;+video.videoSourceId&quot; :title&#x3D;&quot;video.title&quot; target&#x3D;&quot;_blank&quot;&gt;    &lt;span class&#x3D;&quot;fr&quot; v-if&#x3D;&quot;Number(courseWebVo.price) &#x3D;&#x3D; 0&quot;&gt;        &lt;i class&#x3D;&quot;free-icon vam mr10&quot; &gt;免费试听&lt;&#x2F;i&gt;    &lt;&#x2F;span&gt;    &lt;em class&#x3D;&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;&#123;&#123;video.title&#125;&#125;&lt;&#x2F;a&gt;</code></pre></div><h3 id="2、layout"><a href="#2、layout" class="headerlink" title="2、layout"></a>2、layout</h3><p>因为播放器的布局和其他页面的基本布局不一致，因此创建新的布局容器 layouts/video.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;guli-player&quot;&gt;    &lt;div class&#x3D;&quot;head&quot;&gt;      &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;谷粒学院&quot;&gt;        &lt;img class&#x3D;&quot;logo&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;logo.png&quot; lt&#x3D;&quot;谷粒学院&quot;&gt;    &lt;&#x2F;a&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;body&quot;&gt;      &lt;div class&#x3D;&quot;content&quot;&gt;&lt;nuxt&#x2F;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;&#125;&lt;&#x2F;script&gt;&lt;style&gt;html,body&#123;  height:100%;&#125;&lt;&#x2F;style&gt;&lt;style scoped&gt;.head &#123;  height: 50px;  position: absolute;  top: 0;  left: 0;  width: 100%;&#125;.head .logo&#123;  height: 50px;  margin-left: 10px;&#125;.body &#123;  position: absolute;  top: 50px;  left: 0;  right: 0;  bottom: 0;  overflow: hidden;&#125;&lt;&#x2F;style&gt;</code></pre></div><h3 id="3、api"><a href="#3、api" class="headerlink" title="3、api"></a>3、api</h3><p>创建api模块 api/vod.js，从后端获取播放凭证</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;  getPlayAuth(vid) &#123;    return request(&#123;      url: &#96;&#x2F;eduvod&#x2F;video&#x2F;getVideoAuth&#x2F;$&#123;vid&#125;&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div><h3 id="4、播放组件相关文档"><a href="#4、播放组件相关文档" class="headerlink" title="4、播放组件相关文档"></a>4、播放组件相关文档</h3><p><strong>集成文档：</strong><a href="https://help.aliyun.com/document_detail/51991.html?spm=a2c4g.11186623.2.39.478e192b8VSdEn">https://help.aliyun.com/document_detail/51991.html?spm=a2c4g.11186623.2.39.478e192b8VSdEn</a></p><p><strong>在线配置：</strong><a href="https://player.alicdn.com/aliplayer/setting/setting.html">https://player.alicdn.com/aliplayer/setting/setting.html</a></p><p><strong>功能展示：</strong><a href="https://player.alicdn.com/aliplayer/presentation/index.html">https://player.alicdn.com/aliplayer/presentation/index.html</a></p><h3 id="5、创建播放页面"><a href="#5、创建播放页面" class="headerlink" title="5、创建播放页面"></a>5、创建播放页面</h3><p>创建 pages/player/_vid.vue</p><p>（1）引入播放器js库和css样式</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div&gt;    &lt;!-- 阿里云视频播放器样式 --&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;skins&#x2F;default&#x2F;aliplayer-min.css&quot; &gt;    &lt;!-- 阿里云视频播放器脚本 --&gt;    &lt;script charset&#x3D;&quot;utf-8&quot; type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;g.alicdn.com&#x2F;de&#x2F;prismplayer&#x2F;2.8.1&#x2F;aliplayer-min.js&quot; &#x2F;&gt;    &lt;!-- 定义播放器dom --&gt;    &lt;div id&#x3D;&quot;J_prismPlayer&quot; class&#x3D;&quot;prism-player&quot; &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p>（2）获取播放凭证</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;import vod from &#39;@&#x2F;api&#x2F;vod&#39;export default &#123;    layout: &#39;video&#39;,&#x2F;&#x2F;应用video布局    asyncData(&#123; params, error &#125;) &#123;        return vod.getPlayAuth(params.vid)            .then(response &#x3D;&gt;&#123;                console.log(response.data.data.playAuth)                return&#123;                    playAuth: response.data.data.playAuth,                    vid:params.vid                &#125;            &#125;)    &#125;,    &#125;&lt;&#x2F;script&gt;</code></pre></div><p>（3）创建播放器</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;** * 页面渲染完成时：此时js脚本已加载，Aliplayer已定义，可以使用 * 如果在created生命周期函数中使用，Aliplayer is not defined错误 *&#x2F;&#x2F;&#x2F; 在页面渲染之后执行mounted() &#123;    new Aliplayer(&#123;        id: &#39;J_prismPlayer&#39;,        vid: this.vid, &#x2F;&#x2F; 视频id        playauth: this.playAuth, &#x2F;&#x2F; 播放凭证        encryptType: &#39;1&#39;, &#x2F;&#x2F; 如果播放加密视频，则需设置encryptType&#x3D;1，非加密视频无需设置此项        width: &#39;100%&#39;,        height: &#39;500px&#39;    &#125;, function(player) &#123;        &#x2F;&#x2F;console.log(&#39;播放器创建成功&#39;)    &#125;)&#125;</code></pre></div><p>（4）其他常见的可选配置</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">    &#x2F;&#x2F; 以下可选设置    cover: &#39;http:&#x2F;&#x2F;guli.shop&#x2F;photo&#x2F;banner&#x2F;1525939573202.jpg&#39;, &#x2F;&#x2F; 封面    qualitySort: &#39;asc&#39;, &#x2F;&#x2F; 清晰度排序    mediaType: &#39;video&#39;, &#x2F;&#x2F; 返回音频还是视频    autoplay: false, &#x2F;&#x2F; 自动播放    isLive: false, &#x2F;&#x2F; 直播    rePlay: false, &#x2F;&#x2F; 循环播放    preload: true,    controlBarVisibility: &#39;hover&#39;, &#x2F;&#x2F; 控制条的显示方式：鼠标悬停    useH5Prism: true, &#x2F;&#x2F; 播放器类型：html5&#125;, function(player) &#123;    &#x2F;&#x2F;console.log(&#39;播放器创建成功&#39;)</code></pre></div><h3 id="6、加入播放组件"><a href="#6、加入播放组件" class="headerlink" title="6、加入播放组件"></a>6、加入播放组件</h3><p><strong>功能展示：</strong><a href="https://player.alicdn.com/aliplayer/presentation/index.html">https://player.alicdn.com/aliplayer/presentation/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day13-微信登录</title>
    <link href="/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
    <url>/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Day13-微信登录"><a href="#Day13-微信登录" class="headerlink" title="Day13-微信登录"></a>Day13-微信登录</h1><h1 id="OAuth2介绍"><a href="#OAuth2介绍" class="headerlink" title="OAuth2介绍"></a>OAuth2介绍</h1><p>OAuth2解决方案:令牌机制，按照一定规则生成字符串，字符串包含用户信息</p><p><img src="/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/image-20220107001223830.png" alt="image-20220107001223830"></p><h1 id="微信扫描登录-生成授权url（生成二维码）"><a href="#微信扫描登录-生成授权url（生成二维码）" class="headerlink" title="微信扫描登录-生成授权url（生成二维码）"></a>微信扫描登录-生成授权url（生成二维码）</h1><h2 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h2><h3 id="1、添加配置"><a href="#1、添加配置" class="headerlink" title="1、添加配置"></a>1、添加配置</h3><p>application.properties添加相关配置信息</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 微信开放平台 appidwx.open.app_id&#x3D;wxed9954c01bb89b47# 微信开放平台 appsecretwx.open.app_secret&#x3D;a7482517235173ddb4083788de60b90e# 微信开放平台 重定向urlwx.open.redirect_url&#x3D;http:&#x2F;&#x2F;localhost:8160&#x2F;api&#x2F;ucenter&#x2F;wx&#x2F;callback</code></pre></div><p><img src="/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/image-20220107001247192.png" alt="image-20220107001247192"></p><h3 id="2、创建常量类"><a href="#2、创建常量类" class="headerlink" title="2、创建常量类"></a>2、创建常量类</h3><p>创建util包，创建ConstantPropertiesUtil.java常量类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class ConstantWxUtil implements InitializingBean &#123;    @Value(&quot;$&#123;wx.open.app_id&#125;&quot;)    private String appId;    @Value(&quot;$&#123;wx.open.app_secret&#125;&quot;)    private String appSecret;    @Value(&quot;$&#123;wx.open.redirect_url&#125;&quot;)    private String redirectUrl;    public static String WX_OPEN_APP_ID;    public static String WX_OPEN_APP_SECRET;    public static String WX_OPEN_REDIRECT_URL;    @Override    public void afterPropertiesSet() throws Exception &#123;        WX_OPEN_APP_ID &#x3D; appId;        WX_OPEN_APP_SECRET &#x3D; appSecret;        WX_OPEN_REDIRECT_URL &#x3D; redirectUrl;    &#125;&#125;</code></pre></div><h3 id="3、创建controller"><a href="#3、创建controller" class="headerlink" title="3、创建controller"></a>3、创建controller</h3><p>guli-microservice-ucenter微服务中创建api包</p><p>api包中创建WxApiController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@CrossOrigin@Controller &#x2F;&#x2F; 这里不需要返回数据，所以用controller@RequestMapping(&quot;&#x2F;api&#x2F;ucenter&#x2F;wx&quot;)public class WxApiController &#123;    @GetMapping(&quot;login&quot;)    public String getWxCode()&#123;        &#x2F;&#x2F; 微信开放平台授权baseUrl        String baseUrl &#x3D; &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;qrconnect&quot; +        &quot;?appid&#x3D;%s&quot; +        &quot;&amp;redirect_uri&#x3D;%s&quot; +        &quot;&amp;response_type&#x3D;code&quot; +        &quot;&amp;scope&#x3D;snsapi_login&quot; +        &quot;&amp;state&#x3D;%s&quot; +        &quot;#wechat_redirect&quot;;        &#x2F;&#x2F; redirect_url需要转码        String redirectUrl &#x3D; ConstantWxUtil.WX_OPEN_REDIRECT_URL;        try &#123;            redirectUrl &#x3D; URLEncoder.encode(redirectUrl, &quot;utf-8&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        &#x2F;&#x2F; 生成url        String url &#x3D; String.format(                baseUrl,                ConstantWxUtil.WX_OPEN_APP_ID,                redirectUrl,                &quot;atguigu&quot;        );        return &quot;redirect:&quot;+url;    &#125;&#125;</code></pre></div><h3 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h3><p>访问：<a href="http://localhost:8006/api/ucenter/wx/login">http://localhost:8006/api/ucenter/wx/login</a> </p><p>发现错误</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">redirect_uri 参数错误</code></pre></div><p>解决方案</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">微信扫码失效的，使用新的，首先将模块启动端口改成8160（一定得是这个，其他的没用），其次将redirect_url 改为：http:&#x2F;&#x2F;localhost:8160&#x2F;api&#x2F;ucenter&#x2F;wx&#x2F;callback，还需要将Nginx的配置改成对应的url</code></pre></div><h1 id="微信扫描登录-开发回调url（获取扫描人的信息）"><a href="#微信扫描登录-开发回调url（获取扫描人的信息）" class="headerlink" title="微信扫描登录-开发回调url（获取扫描人的信息）"></a>微信扫描登录-开发回调url（获取扫描人的信息）</h1><p>扫描之后获取扫描人信息流程分析</p><p><img src="/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/image-20220107001357983.png" alt="image-20220107001357983"></p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1、全局配置的跳转路径"><a href="#1、全局配置的跳转路径" class="headerlink" title="1、全局配置的跳转路径"></a>1、全局配置的跳转路径</h3><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 微信开放平台 重定向urlwx.open.redirect_url&#x3D;http:&#x2F;&#x2F;localhost:8160&#x2F;api&#x2F;ucenter&#x2F;wx&#x2F;callback</code></pre></div><h3 id="2、修改当前项目启动端口号为8160"><a href="#2、修改当前项目启动端口号为8160" class="headerlink" title="2、修改当前项目启动端口号为8160"></a>2、修改当前项目启动端口号为8160</h3><h3 id="3、测试回调是否可用"><a href="#3、测试回调是否可用" class="headerlink" title="3、测试回调是否可用"></a>3、测试回调是否可用</h3><p>在WxApiController中添加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping(&quot;callback&quot;)public String callback(String code, String state, HttpSession session) &#123;   &#x2F;&#x2F;得到授权临时票据code   System.out.println(&quot;code &#x3D; &quot; + code);   System.out.println(&quot;state &#x3D; &quot; + state);&#125;</code></pre></div><h2 id="二、后台开发"><a href="#二、后台开发" class="headerlink" title="二、后台开发"></a>二、后台开发</h2><h3 id="1、添加依赖"><a href="#1、添加依赖" class="headerlink" title="1、添加依赖"></a>1、添加依赖</h3><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!--httpclient--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--commons-io--&gt;    &lt;dependency&gt;        &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--gson--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><h3 id="2、创建httpclient工具类"><a href="#2、创建httpclient工具类" class="headerlink" title="2、创建httpclient工具类"></a>2、创建httpclient工具类</h3><p>放入util包</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.educenter.utils;import org.apache.commons.io.IOUtils;import org.apache.commons.lang.StringUtils;import org.apache.http.Consts;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.config.RequestConfig.Builder;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.conn.ConnectTimeoutException;import org.apache.http.conn.ssl.SSLConnectionSocketFactory;import org.apache.http.conn.ssl.SSLContextBuilder;import org.apache.http.conn.ssl.TrustStrategy;import org.apache.http.conn.ssl.X509HostnameVerifier;import org.apache.http.entity.ContentType;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicNameValuePair;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLException;import javax.net.ssl.SSLSession;import javax.net.ssl.SSLSocket;import java.io.IOException;import java.net.SocketTimeoutException;import java.security.GeneralSecurityException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;&#x2F;** *  依赖的jar包有：commons-lang-2.6.jar、httpclient-4.3.2.jar、httpcore-4.3.1.jar、commons-io-2.4.jar * @author zhaoyb * *&#x2F;public class HttpClientUtils &#123;    public static final int connTimeout&#x3D;10000;    public static final int readTimeout&#x3D;10000;    public static final String charset&#x3D;&quot;UTF-8&quot;;    private static HttpClient client &#x3D; null;    static &#123;        PoolingHttpClientConnectionManager cm &#x3D; new PoolingHttpClientConnectionManager();        cm.setMaxTotal(128);        cm.setDefaultMaxPerRoute(128);        client &#x3D; HttpClients.custom().setConnectionManager(cm).build();    &#125;    public static String postParameters(String url, String parameterStr) throws ConnectTimeoutException, SocketTimeoutException, Exception&#123;        return post(url,parameterStr,&quot;application&#x2F;x-www-form-urlencoded&quot;,charset,connTimeout,readTimeout);    &#125;    public static String postParameters(String url, String parameterStr,String charset, Integer connTimeout, Integer readTimeout) throws ConnectTimeoutException, SocketTimeoutException, Exception&#123;        return post(url,parameterStr,&quot;application&#x2F;x-www-form-urlencoded&quot;,charset,connTimeout,readTimeout);    &#125;    public static String postParameters(String url, Map&lt;String, String&gt; params) throws ConnectTimeoutException,            SocketTimeoutException, Exception &#123;        return postForm(url, params, null, connTimeout, readTimeout);    &#125;    public static String postParameters(String url, Map&lt;String, String&gt; params, Integer connTimeout,Integer readTimeout) throws ConnectTimeoutException,            SocketTimeoutException, Exception &#123;        return postForm(url, params, null, connTimeout, readTimeout);    &#125;    public static String get(String url) throws Exception &#123;        return get(url, charset, null, null);    &#125;    public static String get(String url, String charset) throws Exception &#123;        return get(url, charset, connTimeout, readTimeout);    &#125;    &#x2F;**     * 发送一个 Post 请求, 使用指定的字符集编码.     *     * @param url     * @param body RequestBody     * @param mimeType 例如 application&#x2F;xml &quot;application&#x2F;x-www-form-urlencoded&quot; a&#x3D;1&amp;b&#x3D;2&amp;c&#x3D;3     * @param charset 编码     * @param connTimeout 建立链接超时时间,毫秒.     * @param readTimeout 响应超时时间,毫秒.     * @return ResponseBody, 使用指定的字符集编码.     * @throws ConnectTimeoutException 建立链接超时异常     * @throws SocketTimeoutException  响应超时     * @throws Exception     *&#x2F;    public static String post(String url, String body, String mimeType,String charset, Integer connTimeout, Integer readTimeout)            throws ConnectTimeoutException, SocketTimeoutException, Exception &#123;        HttpClient client &#x3D; null;        HttpPost post &#x3D; new HttpPost(url);        String result &#x3D; &quot;&quot;;        try &#123;            if (StringUtils.isNotBlank(body)) &#123;                HttpEntity entity &#x3D; new StringEntity(body, ContentType.create(mimeType, charset));                post.setEntity(entity);            &#125;            &#x2F;&#x2F; 设置参数            Builder customReqConf &#x3D; RequestConfig.custom();            if (connTimeout !&#x3D; null) &#123;                customReqConf.setConnectTimeout(connTimeout);            &#125;            if (readTimeout !&#x3D; null) &#123;                customReqConf.setSocketTimeout(readTimeout);            &#125;            post.setConfig(customReqConf.build());            HttpResponse res;            if (url.startsWith(&quot;https&quot;)) &#123;                &#x2F;&#x2F; 执行 Https 请求.                client &#x3D; createSSLInsecureClient();                res &#x3D; client.execute(post);            &#125; else &#123;                &#x2F;&#x2F; 执行 Http 请求.                client &#x3D; HttpClientUtils.client;                res &#x3D; client.execute(post);            &#125;            result &#x3D; IOUtils.toString(res.getEntity().getContent(), charset);        &#125; finally &#123;            post.releaseConnection();            if (url.startsWith(&quot;https&quot;) &amp;&amp; client !&#x3D; null&amp;&amp; client instanceof CloseableHttpClient) &#123;                ((CloseableHttpClient) client).close();            &#125;        &#125;        return result;    &#125;    &#x2F;**     * 提交form表单     *     * @param url     * @param params     * @param connTimeout     * @param readTimeout     * @return     * @throws ConnectTimeoutException     * @throws SocketTimeoutException     * @throws Exception     *&#x2F;    public static String postForm(String url, Map&lt;String, String&gt; params, Map&lt;String, String&gt; headers, Integer connTimeout,Integer readTimeout) throws ConnectTimeoutException,            SocketTimeoutException, Exception &#123;        HttpClient client &#x3D; null;        HttpPost post &#x3D; new HttpPost(url);        try &#123;            if (params !&#x3D; null &amp;&amp; !params.isEmpty()) &#123;                List&lt;NameValuePair&gt; formParams &#x3D; new ArrayList&lt;NameValuePair&gt;();                Set&lt;Entry&lt;String, String&gt;&gt; entrySet &#x3D; params.entrySet();                for (Entry&lt;String, String&gt; entry : entrySet) &#123;                    formParams.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));                &#125;                UrlEncodedFormEntity entity &#x3D; new UrlEncodedFormEntity(formParams, Consts.UTF_8);                post.setEntity(entity);            &#125;            if (headers !&#x3D; null &amp;&amp; !headers.isEmpty()) &#123;                for (Entry&lt;String, String&gt; entry : headers.entrySet()) &#123;                    post.addHeader(entry.getKey(), entry.getValue());                &#125;            &#125;            &#x2F;&#x2F; 设置参数            Builder customReqConf &#x3D; RequestConfig.custom();            if (connTimeout !&#x3D; null) &#123;                customReqConf.setConnectTimeout(connTimeout);            &#125;            if (readTimeout !&#x3D; null) &#123;                customReqConf.setSocketTimeout(readTimeout);            &#125;            post.setConfig(customReqConf.build());            HttpResponse res &#x3D; null;            if (url.startsWith(&quot;https&quot;)) &#123;                &#x2F;&#x2F; 执行 Https 请求.                client &#x3D; createSSLInsecureClient();                res &#x3D; client.execute(post);            &#125; else &#123;                &#x2F;&#x2F; 执行 Http 请求.                client &#x3D; HttpClientUtils.client;                res &#x3D; client.execute(post);            &#125;            return IOUtils.toString(res.getEntity().getContent(), &quot;UTF-8&quot;);        &#125; finally &#123;            post.releaseConnection();            if (url.startsWith(&quot;https&quot;) &amp;&amp; client !&#x3D; null                    &amp;&amp; client instanceof CloseableHttpClient) &#123;                ((CloseableHttpClient) client).close();            &#125;        &#125;    &#125;    &#x2F;**     * 发送一个 GET 请求     *     * @param url     * @param charset     * @param connTimeout  建立链接超时时间,毫秒.     * @param readTimeout  响应超时时间,毫秒.     * @return     * @throws ConnectTimeoutException   建立链接超时     * @throws SocketTimeoutException   响应超时     * @throws Exception     *&#x2F;    public static String get(String url, String charset, Integer connTimeout,Integer readTimeout)            throws ConnectTimeoutException,SocketTimeoutException, Exception &#123;        HttpClient client &#x3D; null;        HttpGet get &#x3D; new HttpGet(url);        String result &#x3D; &quot;&quot;;        try &#123;            &#x2F;&#x2F; 设置参数            Builder customReqConf &#x3D; RequestConfig.custom();            if (connTimeout !&#x3D; null) &#123;                customReqConf.setConnectTimeout(connTimeout);            &#125;            if (readTimeout !&#x3D; null) &#123;                customReqConf.setSocketTimeout(readTimeout);            &#125;            get.setConfig(customReqConf.build());            HttpResponse res &#x3D; null;            if (url.startsWith(&quot;https&quot;)) &#123;                &#x2F;&#x2F; 执行 Https 请求.                client &#x3D; createSSLInsecureClient();                res &#x3D; client.execute(get);            &#125; else &#123;                &#x2F;&#x2F; 执行 Http 请求.                client &#x3D; HttpClientUtils.client;                res &#x3D; client.execute(get);            &#125;            result &#x3D; IOUtils.toString(res.getEntity().getContent(), charset);        &#125; finally &#123;            get.releaseConnection();            if (url.startsWith(&quot;https&quot;) &amp;&amp; client !&#x3D; null &amp;&amp; client instanceof CloseableHttpClient) &#123;                ((CloseableHttpClient) client).close();            &#125;        &#125;        return result;    &#125;    &#x2F;**     * 从 response 里获取 charset     *     * @param ressponse     * @return     *&#x2F;    @SuppressWarnings(&quot;unused&quot;)    private static String getCharsetFromResponse(HttpResponse ressponse) &#123;        &#x2F;&#x2F; Content-Type:text&#x2F;html; charset&#x3D;GBK        if (ressponse.getEntity() !&#x3D; null  &amp;&amp; ressponse.getEntity().getContentType() !&#x3D; null &amp;&amp; ressponse.getEntity().getContentType().getValue() !&#x3D; null) &#123;            String contentType &#x3D; ressponse.getEntity().getContentType().getValue();            if (contentType.contains(&quot;charset&#x3D;&quot;)) &#123;                return contentType.substring(contentType.indexOf(&quot;charset&#x3D;&quot;) + 8);            &#125;        &#125;        return null;    &#125;    &#x2F;**     * 创建 SSL连接     * @return     * @throws GeneralSecurityException     *&#x2F;    private static CloseableHttpClient createSSLInsecureClient() throws GeneralSecurityException &#123;        try &#123;            SSLContext sslContext &#x3D; new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() &#123;                public boolean isTrusted(X509Certificate[] chain,String authType) throws CertificateException &#123;                    return true;                &#125;            &#125;).build();            SSLConnectionSocketFactory sslsf &#x3D; new SSLConnectionSocketFactory(sslContext, new X509HostnameVerifier() &#123;                @Override                public boolean verify(String arg0, SSLSession arg1) &#123;                    return true;                &#125;                @Override                public void verify(String host, SSLSocket ssl)                        throws IOException &#123;                &#125;                @Override                public void verify(String host, X509Certificate cert)                        throws SSLException &#123;                &#125;                @Override                public void verify(String host, String[] cns,                                   String[] subjectAlts) throws SSLException &#123;                &#125;            &#125;);            return HttpClients.custom().setSSLSocketFactory(sslsf).build();        &#125; catch (GeneralSecurityException e) &#123;            throw e;        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            String str&#x3D; post(&quot;https:&#x2F;&#x2F;localhost:443&#x2F;ssl&#x2F;test.shtml&quot;,&quot;name&#x3D;12&amp;page&#x3D;34&quot;,&quot;application&#x2F;x-www-form-urlencoded&quot;, &quot;UTF-8&quot;, 10000, 10000);            &#x2F;&#x2F;String str&#x3D; get(&quot;https:&#x2F;&#x2F;localhost:443&#x2F;ssl&#x2F;test.shtml?name&#x3D;12&amp;page&#x3D;34&quot;,&quot;GBK&quot;);            &#x2F;*Map&lt;String,String&gt; map &#x3D; new HashMap&lt;String,String&gt;();            map.put(&quot;name&quot;, &quot;111&quot;);            map.put(&quot;page&quot;, &quot;222&quot;);            String str&#x3D; postForm(&quot;https:&#x2F;&#x2F;localhost:443&#x2F;ssl&#x2F;test.shtml&quot;,map,null, 10000, 10000);*&#x2F;            System.out.println(str);        &#125; catch (ConnectTimeoutException e) &#123;            &#x2F;&#x2F; TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (SocketTimeoutException e) &#123;            &#x2F;&#x2F; TODO Auto-generated catch block            e.printStackTrace();        &#125; catch (Exception e) &#123;            &#x2F;&#x2F; TODO Auto-generated catch block            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><h3 id="3、创建回调controller方法"><a href="#3、创建回调controller方法" class="headerlink" title="3、创建回调controller方法"></a>3、创建回调controller方法</h3><p>在WxApiController.java中添加如下方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 2.获取扫描人信息，添加数据@GetMapping(&quot;callback&quot;)public String callback(String code,String state)&#123;    try &#123;        &#x2F;&#x2F; 1.获取code和state        &#x2F;&#x2F; 2.根据获取到的code和state，去请求微信固定的地址，获取access_token        String baseAccessTokenUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token&quot; +                &quot;?appid&#x3D;%s&quot; +                &quot;&amp;secret&#x3D;%s&quot; +                &quot;&amp;code&#x3D;%s&quot; +                &quot;&amp;grant_type&#x3D;authorization_code&quot;;        String accessTokenUrl &#x3D; String.format(                baseAccessTokenUrl,                ConstantWxUtil.WX_OPEN_APP_ID,                ConstantWxUtil.WX_OPEN_APP_SECRET,                code);        &#x2F;&#x2F; 请求拼接好的url，得到返回的access_token和openid        &#x2F;&#x2F; 使用HTTPClient发送请求        String accessTokenInfo &#x3D; HttpClientUtils.get(accessTokenUrl);        &#x2F;&#x2F;System.out.println(&quot;accessTokenInfo:&quot;+accessTokenInfo);        &#x2F;&#x2F; 从获取到的accessTokenInfo中将accessToken和openid取出来        &#x2F;&#x2F; 将获取到的accessTokenInfo字符串转换为map，利用gson        Gson gson &#x3D; new Gson();        HashMap mapAccessToken &#x3D; gson.fromJson(accessTokenInfo, HashMap.class);        String accessToken &#x3D; (String) mapAccessToken.get(&quot;access_token&quot;);        String openid &#x3D; (String) mapAccessToken.get(&quot;openid&quot;);        &#x2F;&#x2F; 根据accessToken和openid去请求微信固定的地址，获取用户信息        &#x2F;&#x2F; 拼接地址        &#x2F;&#x2F;访问微信的资源服务器，获取用户信息        String baseUserInfoUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo&quot; +        &quot;?access_token&#x3D;%s&quot; +        &quot;&amp;openid&#x3D;%s&quot;;        String userInfoUrl &#x3D; String.format(baseUserInfoUrl, accessToken, openid);                &#x2F;&#x2F; 根据userInfoUrl调用HTTPClient,发送请求        String userInfo &#x3D; HttpClientUtils.get(userInfoUrl);        &#x2F;&#x2F;System.out.println(&quot;userInfo&#x3D;&quot;+userInfo);        &#x2F;&#x2F; 将获取到的用户信息字符串转换给map        HashMap userInfoMap &#x3D; gson.fromJson(userInfo, HashMap.class);        String nickname &#x3D; (String) userInfoMap.get(&quot;nickname&quot;); &#x2F;&#x2F; 昵称        String headimgurl &#x3D; (String) userInfoMap.get(&quot;headimgurl&quot;);  &#x2F;&#x2F; 头像        &#x2F;&#x2F; 把扫描人的信息加到数据库中        &#x2F;&#x2F; 先判断数据库是否已经存在        UcenterMember member &#x3D; memberService.getOpenIdMember(openid);        if (member &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 说明没有，直接添加            member &#x3D; new UcenterMember();            member.setId(openid);            member.setNickname(nickname);            member.setAvatar(headimgurl);            memberService.save(member);        &#125;        &#x2F;&#x2F; 登录成功之后，跳转到首页        return &quot;redirect:http:&#x2F;&#x2F;localhost:3000&quot;;    &#125; catch (Exception e) &#123;        e.printStackTrace();        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#125;</code></pre></div><h3 id="4、业务层"><a href="#4、业务层" class="headerlink" title="4、业务层"></a>4、业务层</h3><p>业务接口：MemberService.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 把扫描人的信息加到数据库中UcenterMember getOpenIdMember(String openid);</code></pre></div><p>业务实现：MemberServiceImpl.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据openID查询用户@Overridepublic UcenterMember getOpenIdMember(String openid) &#123;    QueryWrapper&lt;UcenterMember&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;openid&quot;,openid);    UcenterMember member &#x3D; baseMapper.selectOne(wrapper);    return member;&#125;</code></pre></div><h1 id="微信扫描登录-功能完善和整合jwt令牌"><a href="#微信扫描登录-功能完善和整合jwt令牌" class="headerlink" title="微信扫描登录-功能完善和整合jwt令牌"></a>微信扫描登录-功能完善和整合jwt令牌</h1><p>把第3步换了位置，由于cookie不能跨域，所以整合jwt将用户信息转换成token字符串，通过路径传递。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 2.获取扫描人信息，添加数据@GetMapping(&quot;callback&quot;)public String callback(String code,String state)&#123;    try &#123;        &#x2F;&#x2F; 1.获取code和state        &#x2F;&#x2F; 2.根据获取到的code和state，去请求微信固定的地址，获取access_token        String baseAccessTokenUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token&quot; +                &quot;?appid&#x3D;%s&quot; +                &quot;&amp;secret&#x3D;%s&quot; +                &quot;&amp;code&#x3D;%s&quot; +                &quot;&amp;grant_type&#x3D;authorization_code&quot;;        String accessTokenUrl &#x3D; String.format(                baseAccessTokenUrl,                ConstantWxUtil.WX_OPEN_APP_ID,                ConstantWxUtil.WX_OPEN_APP_SECRET,                code);        &#x2F;&#x2F; 请求拼接好的url，得到返回的access_token和openid        &#x2F;&#x2F; 使用HTTPClient发送请求        String accessTokenInfo &#x3D; HttpClientUtils.get(accessTokenUrl);        &#x2F;&#x2F;System.out.println(&quot;accessTokenInfo:&quot;+accessTokenInfo);        &#x2F;&#x2F; 从获取到的accessTokenInfo中将accessToken和openid取出来        &#x2F;&#x2F; 将获取到的accessTokenInfo字符串转换为map，利用gson        Gson gson &#x3D; new Gson();        HashMap mapAccessToken &#x3D; gson.fromJson(accessTokenInfo, HashMap.class);        String accessToken &#x3D; (String) mapAccessToken.get(&quot;access_token&quot;);        String openid &#x3D; (String) mapAccessToken.get(&quot;openid&quot;);        &#x2F;&#x2F; 把扫描人的信息加到数据库中        &#x2F;&#x2F; 先判断数据库是否已经存在        UcenterMember member &#x3D; memberService.getOpenIdMember(openid);        if (member &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 说明没有，直接添加            &#x2F;&#x2F; 3.根据accessToken和openid去请求微信固定的地址，获取用户信息            &#x2F;&#x2F; 拼接地址            &#x2F;&#x2F;访问微信的资源服务器，获取用户信息            String baseUserInfoUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo&quot; +                    &quot;?access_token&#x3D;%s&quot; +                    &quot;&amp;openid&#x3D;%s&quot;;            String userInfoUrl &#x3D; String.format(baseUserInfoUrl, accessToken, openid);            &#x2F;&#x2F; 根据userInfoUrl调用HTTPClient,发送请求            String userInfo &#x3D; HttpClientUtils.get(userInfoUrl);            &#x2F;&#x2F;System.out.println(&quot;userInfo&#x3D;&quot;+userInfo);            &#x2F;&#x2F; 将获取到的用户信息字符串转换给map            HashMap userInfoMap &#x3D; gson.fromJson(userInfo, HashMap.class);            String nickname &#x3D; (String) userInfoMap.get(&quot;nickname&quot;); &#x2F;&#x2F; 昵称            String headimgurl &#x3D; (String) userInfoMap.get(&quot;headimgurl&quot;);  &#x2F;&#x2F; 头像            member &#x3D; new UcenterMember();            member.setOpenid(openid);            member.setNickname(nickname);            member.setAvatar(headimgurl);            memberService.save(member);        &#125;        &#x2F;&#x2F; 由于cookie不能跨域，所以需要用jwt生成token信息，通过路径传递        String jwtToken &#x3D; JwtUtils.getJwtToken(member.getId(), member.getNickname());        &#x2F;&#x2F; 登录成功之后，跳转到首页        return &quot;redirect:http:&#x2F;&#x2F;localhost:3000?token&#x3D;&quot;+jwtToken;    &#125; catch (Exception e) &#123;        e.printStackTrace();        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;&#125;</code></pre></div><h1 id="微信扫描登录-首页面显示信息"><a href="#微信扫描登录-首页面显示信息" class="headerlink" title="微信扫描登录-首页面显示信息"></a>微信扫描登录-首页面显示信息</h1><p><img src="/myBlog/day13-%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/image-20220107001556836.png" alt="image-20220107001556836"></p><h2 id="1、修改default-vue页面脚本"><a href="#1、修改default-vue页面脚本" class="headerlink" title="1、修改default.vue页面脚本"></a>1、修改default.vue页面脚本</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">export default &#123;     layout: &#39;sign&#39;,     data () &#123;       return &#123;         user:&#123;           mobile:&#39;&#39;,           password:&#39;&#39;         &#125;,         loginInfo:&#123;&#125;       &#125;     &#125;,     methods: &#123;       &#x2F;&#x2F; 登录       submitLogin()&#123;         &#x2F;&#x2F; 第一步调用接口获取登录token值         loginApi.submitLoginUser(this.user)          .then(response &#x3D;&gt;&#123;            &#x2F;&#x2F; 第二步，将获取到的token值放到cookie中            cookie.set(&#39;guli_token&#39;,response.data.data.token,&#123; domain: &#39;localhost&#39; &#125;)            &#x2F;&#x2F; 第四步，根据token的值，调用接口，获取用户数据，并存入cookie中            loginApi.getUserInfo()              .then(response &#x3D;&gt;&#123;                this.loginInfo &#x3D; response.data.data.userInfo                &#x2F;&#x2F; 将得到的用户信息存入cookie中                cookie.set(&quot;guli_ucenter&quot;,JSON.stringify(this.loginInfo),&#123; domain: &#39;localhost&#39; &#125;)                &#x2F;&#x2F; 跳转页面                window.location.href &#x3D; &quot;&#x2F;&quot;              &#125;)          &#125;)                 &#125;,       checkPhone (rule, value, callback) &#123;         &#x2F;&#x2F;debugger         if (!(&#x2F;^1[34578]\d&#123;9&#125;$&#x2F;.test(value))) &#123;           return callback(new Error(&#39;手机号码格式不正确&#39;))         &#125;         return callback()       &#125;     &#125;   &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day12-登录业务</title>
    <link href="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/"/>
    <url>/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Day12-登录业务"><a href="#Day12-登录业务" class="headerlink" title="Day12-登录业务"></a>Day12-登录业务</h1><h1 id="登录业务介绍（单点登录）"><a href="#登录业务介绍（单点登录）" class="headerlink" title="登录业务介绍（单点登录）"></a>登录业务介绍（单点登录）</h1><p><img src="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/image-20220107000233656.png" alt="image-20220107000233656"></p><h1 id="Jwt介绍"><a href="#Jwt介绍" class="headerlink" title="Jwt介绍"></a>Jwt介绍</h1><p><img src="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/image-20220107000249450.png" alt="image-20220107000249450"></p><h1 id="整合JWT令牌"><a href="#整合JWT令牌" class="headerlink" title="整合JWT令牌"></a>整合JWT令牌</h1><h2 id="1、在common-utils模块中添加jwt工具依赖"><a href="#1、在common-utils模块中添加jwt工具依赖" class="headerlink" title="1、在common_utils模块中添加jwt工具依赖"></a>1、在common_utils模块中添加jwt工具依赖</h2><p>在pom中添加</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!-- JWT --&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><h2 id="创建JWT工具类"><a href="#创建JWT工具类" class="headerlink" title="创建JWT工具类"></a>创建JWT工具类</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JwtUtils &#123;    &#x2F;&#x2F; 常量    public static final long EXPIRE &#x3D; 1000 * 60 * 60 * 24;     &#x2F;&#x2F; token过期时间    public static final String APP_SECRET &#x3D; &quot;ukc8BDbRigUDaY6pZFfWus2jZWLPHO&quot;;   &#x2F;&#x2F; 秘钥    &#x2F;&#x2F; 生成token字符串的方法    public static String getJwtToken(String id, String nickname)&#123;        String JwtToken &#x3D; Jwts.builder()                &#x2F;&#x2F; 头信息                .setHeaderParam(&quot;typ&quot;, &quot;JWT&quot;)                .setHeaderParam(&quot;alg&quot;, &quot;HS256&quot;)                .setSubject(&quot;guli-user&quot;)                .setIssuedAt(new Date())                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))                .claim(&quot;id&quot;, id)    &#x2F;&#x2F; 设置token主体部分，存储用户信息                .claim(&quot;nickname&quot;, nickname)                .signWith(SignatureAlgorithm.HS256, APP_SECRET)                .compact();        return JwtToken;    &#125;    &#x2F;**     * 判断token是否存在与有效     * @param jwtToken     * @return     *&#x2F;    public static boolean checkToken(String jwtToken) &#123;        if(StringUtils.isEmpty(jwtToken)) return false;        try &#123;            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;        return true;    &#125;    &#x2F;**     * 判断token是否存在与有效     * @param request     * @return     *&#x2F;    public static boolean checkToken(HttpServletRequest request) &#123;        try &#123;            String jwtToken &#x3D; request.getHeader(&quot;token&quot;);            if(StringUtils.isEmpty(jwtToken)) return false;            Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;        return true;    &#125;    &#x2F;**     * 根据token获取会员id     * @param request     * @return     *&#x2F;    public static String getMemberIdByJwtToken(HttpServletRequest request) &#123;        String jwtToken &#x3D; request.getHeader(&quot;token&quot;);        if(StringUtils.isEmpty(jwtToken)) return &quot;&quot;;        Jws&lt;Claims&gt; claimsJws &#x3D; Jwts.parser().setSigningKey(APP_SECRET).parseClaimsJws(jwtToken);        Claims claims &#x3D; claimsJws.getBody();        return (String)claims.get(&quot;id&quot;);    &#125;&#125;</code></pre></div><h1 id="整合阿里云短信"><a href="#整合阿里云短信" class="headerlink" title="整合阿里云短信"></a>整合阿里云短信</h1><h2 id="新建短信微服务"><a href="#新建短信微服务" class="headerlink" title="新建短信微服务"></a>新建短信微服务</h2><p>1、在service模块下创建子模块service-msm</p><p>2、创建controller和service代码</p><p>3、配置application.properties</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8005# 服务名spring.application.name&#x3D;service-msm# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root# redisspring.redis.host&#x3D;192.168.242.3spring.redis.password&#x3D;123456spring.redis.port&#x3D;6379spring.redis.database&#x3D; 0spring.redis.timeout&#x3D;1800000spring.redis.lettuce.pool.max-active&#x3D;20spring.redis.lettuce.pool.max-wait&#x3D;-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle&#x3D;5spring.redis.lettuce.pool.min-idle&#x3D;0#最小空闲#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;edumsm&#x2F;mapper&#x2F;xml&#x2F;*.xml#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div><p>4、创建启动类</p><p>创建MsmApplication.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ComponentScan(&#123;&quot;com.atguigu&quot;&#125;)@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class)     &#x2F;&#x2F; 去掉数据库自动装配public class MsmApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MsmApplication.class,args);    &#125;&#125;</code></pre></div><h2 id="编写发送短信接口"><a href="#编写发送短信接口" class="headerlink" title="编写发送短信接口"></a>编写发送短信接口</h2><p>1、在service-msm的pom中引入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;aliyun-java-sdk-core&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>2、编写controller，根据手机号发送短信</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;edumsm&#x2F;msm&quot;)@CrossOriginpublic class MsmController &#123;    @Autowired    private MsmService msmService;    @Autowired    private RedisTemplate&lt;String,String&gt; redisTemplate;    &#x2F;&#x2F; 发送验证码    @GetMapping(value &#x3D; &quot;send&#x2F;&#123;phone&#125;&quot;)    public R code(@PathVariable String phone) &#123;        &#x2F;&#x2F; 1.先从redis中查询，如果查询出来就发送        String code &#x3D; redisTemplate.opsForValue().get(phone);        if (!StringUtils.isEmpty(code))&#123;            return R.ok();        &#125;        &#x2F;&#x2F; 2.查询不出来，在发送阿里云短信        &#x2F;&#x2F; 随机生成验证码        code &#x3D; RandomUtil.getFourBitRandom();        Map&lt;String,Object&gt; param &#x3D; new HashMap&lt;&gt;();        param.put(&quot;code&quot;, code);        boolean isSend &#x3D; msmService.send(phone, param);        if(isSend) &#123;            redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);            return R.ok();        &#125; else &#123;            return R.error().message(&quot;发送短信失败&quot;);        &#125;    &#125;&#125;</code></pre></div><p>3、编写service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class MsmServiceImpl implements MsmService &#123;    &#x2F;&#x2F; 发送验证码    @Override    public boolean send(String phone, Map&lt;String, Object&gt; param) &#123;        if(StringUtils.isEmpty(phone)) return false;        DefaultProfile profile &#x3D;                DefaultProfile.getProfile(&quot;default&quot;, &quot;LTAIq6nIPY09VROj&quot;, &quot;FQ7UcixT9wEqMv9F35nORPqKr8XkTF&quot;);        IAcsClient client &#x3D; new DefaultAcsClient(profile);        CommonRequest request &#x3D; new CommonRequest();        &#x2F;&#x2F;request.setProtocol(ProtocolType.HTTPS);        request.setMethod(MethodType.POST);        request.setDomain(&quot;dysmsapi.aliyuncs.com&quot;);        request.setVersion(&quot;2017-05-25&quot;);        request.setAction(&quot;SendSms&quot;);        request.putQueryParameter(&quot;PhoneNumbers&quot;, phone);        request.putQueryParameter(&quot;SignName&quot;, &quot;我的谷粒在线教育网站&quot;);        request.putQueryParameter(&quot;TemplateCode&quot;, &quot;SMS_180051135&quot;);        request.putQueryParameter(&quot;TemplateParam&quot;, JSONObject.toJSONString(param));        try &#123;            CommonResponse response &#x3D; client.getCommonResponse(request);            System.out.println(response.getData());            return response.getHttpResponse().isSuccess();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        return false;    &#125;&#125;</code></pre></div><h2 id="云市场的短信验证码接收"><a href="#云市场的短信验证码接收" class="headerlink" title="云市场的短信验证码接收"></a>云市场的短信验证码接收</h2><p>这里我使用的是阿里云的云市场的，不用阿里云的短信服务</p><p>Controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 用阿里云的云市场短信服务@GetMapping(&quot;sendByPhone&#x2F;&#123;phone&#125;&quot;)public R sendByPhone(@PathVariable String phone)&#123;    &#x2F;&#x2F; 1.先从redis中取验证码    String code &#x3D; redisTemplate.opsForValue().get(phone);    if (!StringUtils.isEmpty(code))&#123;        return R.ok();    &#125;    code &#x3D; RandomUtil.getFourBitRandom();    &#x2F;&#x2F; 2.如果redis没有，再发送短信    boolean isSend &#x3D; msmService.sendCodeByPhone(phone,code);    if (isSend)&#123;        redisTemplate.opsForValue().set(phone,code,5,TimeUnit.MINUTES);        return R.ok();    &#125; else &#123;        return R.error().message(&quot;发送验证码失败&quot;);    &#125;&#125;</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 用阿里云的云市场短信服务@Overridepublic boolean sendCodeByPhone(String phone, String code) &#123;    if(StringUtils.isEmpty(phone)) return false;    String host &#x3D; &quot;https:&#x2F;&#x2F;gyytz.market.alicloudapi.com&quot;;    String path &#x3D; &quot;&#x2F;sms&#x2F;smsSend&quot;;    String method &#x3D; &quot;POST&quot;;    String appcode &#x3D; &quot;9……………2&quot;;    Map&lt;String, String&gt; headers &#x3D; new HashMap&lt;String, String&gt;();    &#x2F;&#x2F;最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105    headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; + appcode);    Map&lt;String, String&gt; querys &#x3D; new HashMap&lt;String, String&gt;();    querys.put(&quot;mobile&quot;, phone);    querys.put(&quot;param&quot;, &quot;**code**:&quot;+code+&quot;,**minute**:5&quot;);    querys.put(&quot;smsSignId&quot;, &quot;2e65b1bb3d054466b82f0c9d125465e2&quot;);    querys.put(&quot;templateId&quot;, &quot;908e94ccf08b4476ba6c876d13f084ad&quot;);    Map&lt;String, String&gt; bodys &#x3D; new HashMap&lt;String, String&gt;();    try &#123;        &#x2F;**         * 重要提示如下:         * HttpUtils请从         * https:&#x2F;&#x2F;github.com&#x2F;aliyun&#x2F;api-gateway-demo-sign-java&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;aliyun&#x2F;api&#x2F;gateway&#x2F;demo&#x2F;util&#x2F;HttpUtils.java         * 下载         *         * 相应的依赖请参照         * https:&#x2F;&#x2F;github.com&#x2F;aliyun&#x2F;api-gateway-demo-sign-java&#x2F;blob&#x2F;master&#x2F;pom.xml         *&#x2F;        HttpResponse response &#x3D; HttpUtils.doPost(host, path, method, headers, querys, bodys);        System.out.println(response.toString());        &#x2F;&#x2F;获取response的body        &#x2F;&#x2F;System.out.println(EntityUtils.toString(response.getEntity()));        return true;    &#125; catch (Exception e) &#123;        e.printStackTrace();        return false;    &#125;&#125;</code></pre></div><h1 id="登录功能接口"><a href="#登录功能接口" class="headerlink" title="登录功能接口"></a>登录功能接口</h1><h2 id="新建用户微服务"><a href="#新建用户微服务" class="headerlink" title="新建用户微服务"></a>新建用户微服务</h2><h3 id="1、在service模块下创建子模块service-ucenter"><a href="#1、在service模块下创建子模块service-ucenter" class="headerlink" title="1、在service模块下创建子模块service-ucenter"></a>1、在service模块下创建子模块service-ucenter</h3><h3 id="2、使用代码生成器生成代码"><a href="#2、使用代码生成器生成代码" class="headerlink" title="2、使用代码生成器生成代码"></a>2、使用代码生成器生成代码</h3><p>（1）创建ucenter_member表</p><p><img src="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/image-20220107000552998.png" alt="image-20220107000552998"></p><p>生成代码</p><h3 id="3、配置application-properties"><a href="#3、配置application-properties" class="headerlink" title="3、配置application.properties"></a>3、配置application.properties</h3><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8006# 服务名spring.application.name&#x3D;service-ucenter# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;rootspring.redis.host&#x3D;192.168.242.3spring.redis.password&#x3D;123456spring.redis.port&#x3D;6379spring.redis.database&#x3D; 0spring.redis.timeout&#x3D;1800000spring.redis.lettuce.pool.max-active&#x3D;20spring.redis.lettuce.pool.max-wait&#x3D;-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle&#x3D;5spring.redis.lettuce.pool.min-idle&#x3D;0#最小空闲#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;educenter&#x2F;mapper&#x2F;xml&#x2F;*.xml#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div><h3 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h3><p>创建ServiceUcApplication.java</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ComponentScan(&#123;&quot;com.atguigu&quot;&#125;)     &#x2F;&#x2F; 整合swagger@MapperScan(&quot;com.atguigu.educenter.mapper&quot;) &#x2F;&#x2F; 扫描mapperpublic class UcenterApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(UcenterApplication.class,args);    &#125;&#125;</code></pre></div><h2 id="创建登录接口"><a href="#创建登录接口" class="headerlink" title="创建登录接口"></a>创建登录接口</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;educenter&#x2F;member&quot;)@CrossOriginpublic class UcenterMemberController &#123;    @Autowired    private UcenterMemberService memberService;    &#x2F;&#x2F; 登录    @GetMapping(&quot;login&quot;)    public R login(@RequestBody UcenterMember member)&#123;        String token &#x3D; memberService.login(member);&#x2F;&#x2F; 返回token，用jwt生成        return R.ok().data(&quot;token&quot;,token);    &#125;    &#x2F;&#x2F; 注册&#125;</code></pre></div><h3 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class UcenterMemberServiceImpl extends ServiceImpl&lt;UcenterMemberMapper, UcenterMember&gt; implements UcenterMemberService &#123;    &#x2F;&#x2F; 登录@Overridepublic String login(UcenterMember member) &#123;    &#x2F;&#x2F; 获取传过来的手机号码和密码    String mobile &#x3D; member.getMobile();    String password &#x3D; member.getPassword();    &#x2F;&#x2F; 判断手机号码是否为空    if (StringUtils.isEmpty(mobile))&#123;        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#x2F;&#x2F; 判断密码是否为空    if (StringUtils.isEmpty(password))&#123;        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#x2F;&#x2F; 根据手机号码从数据库中查询对象    QueryWrapper&lt;UcenterMember&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;mobile&quot;,mobile);    UcenterMember mobileMember &#x3D; baseMapper.selectOne(wrapper);    &#x2F;&#x2F; 如果查出来的对象为空    if (mobileMember &#x3D;&#x3D; null)&#123;        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#x2F;&#x2F; 判断传进来的密码和数据库查出来的是否一致    &#x2F;&#x2F; 先将传进来的密码加密，再和数据库的比较    if (!MD5.encrypt(password).equals(mobileMember.getPassword()))&#123;        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#x2F;&#x2F; 判断是否被禁用    if (mobileMember.getIsDisabled())&#123;        throw new GuliException(20001,&quot;登录失败&quot;);    &#125;    &#x2F;&#x2F; 如果上面的校验都过了，说明可以登录,利用jwt工具生成token，并放回    String jwtToken &#x3D; JwtUtils.getJwtToken(mobileMember.getId(), mobileMember.getNickname());    return jwtToken;&#125;&#125;</code></pre></div><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public final class MD5 &#123;    public static String encrypt(String strSrc) &#123;        try &#123;            char hexChars[] &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;,                    &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;            byte[] bytes &#x3D; strSrc.getBytes();            MessageDigest md &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);            md.update(bytes);            bytes &#x3D; md.digest();            int j &#x3D; bytes.length;            char[] chars &#x3D; new char[j * 2];            int k &#x3D; 0;            for (int i &#x3D; 0; i &lt; bytes.length; i++) &#123;                byte b &#x3D; bytes[i];                chars[k++] &#x3D; hexChars[b &gt;&gt;&gt; 4 &amp; 0xf];                chars[k++] &#x3D; hexChars[b &amp; 0xf];            &#125;            return new String(chars);        &#125; catch (NoSuchAlgorithmException e) &#123;            e.printStackTrace();            throw new RuntimeException(&quot;MD5加密出错！！+&quot; + e);        &#125;    &#125;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>出现异常</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public com.atguigu.commonutils.R com.atguigu.educenter.controller.UcenterMemberController.login(com.atguigu.educenter.entity.UcenterMember)</code></pre></div><p>经过排查，发现是controller的注解写错，把@GetMapping改成@PostMapping即可</p><h2 id="创建注册接口"><a href="#创建注册接口" class="headerlink" title="创建注册接口"></a>创建注册接口</h2><h3 id="RegisterVo"><a href="#RegisterVo" class="headerlink" title="RegisterVo"></a>RegisterVo</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class RegisterVo &#123;   @ApiModelProperty(value &#x3D; &quot;昵称&quot;)   private String nickname;   @ApiModelProperty(value &#x3D; &quot;手机号&quot;)   private String mobile;   @ApiModelProperty(value &#x3D; &quot;密码&quot;)   private String password;   @ApiModelProperty(value &#x3D; &quot;验证码&quot;)    private String code;   &#125;</code></pre></div><h3 id="Controller-1"><a href="#Controller-1" class="headerlink" title="Controller"></a>Controller</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 注册@PostMapping(&quot;register&quot;)public R registerUser(@RequestBody RegisterVo registerVo)&#123;    memberService.register(registerVo);    return R.ok();&#125;</code></pre></div><h3 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 注册@Overridepublic void register(RegisterVo registerVo) &#123;    &#x2F;&#x2F; 获取注册信息    String nickname &#x3D; registerVo.getNickname();    String mobile &#x3D; registerVo.getMobile();    String password &#x3D; registerVo.getPassword();    String code &#x3D; registerVo.getCode();    &#x2F;&#x2F; 判断非空    if (StringUtils.isEmpty(nickname) || StringUtils.isEmpty(mobile)            || StringUtils.isEmpty(password) || StringUtils.isEmpty(code))&#123;        throw new GuliException(20001,&quot;注册失败，注册信息不能为空&quot;);    &#125;    &#x2F;&#x2F; 判断验证码，从redis中取出来    String mobileCode &#x3D; redisTemplate.opsForValue().get(mobile);    if (!code.equals(mobileCode))&#123;        throw new GuliException(20001,&quot;注册失败，验证码错误&quot;);    &#125;    &#x2F;&#x2F; 判断手机号码时候已经在数据库中    QueryWrapper&lt;UcenterMember&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;mobile&quot;,mobile);    Integer count &#x3D; baseMapper.selectCount(wrapper);    if (count &gt; 0)&#123;        &#x2F;&#x2F; 如果大于0，说明数据库中已经存在        throw new GuliException(20001,&quot;注册失败，手机号已经存在&quot;);    &#125;    &#x2F;&#x2F; 将注册对象添加到数据库中    UcenterMember ucenterMember &#x3D; new UcenterMember();    ucenterMember.setNickname(registerVo.getNickname());    ucenterMember.setMobile(registerVo.getMobile());    ucenterMember.setPassword(MD5.encrypt(registerVo.getPassword()));    ucenterMember.setIsDisabled(false);     &#x2F;&#x2F; 是否被禁用    ucenterMember.setAvatar(&quot;http:&#x2F;&#x2F;thirdwx.qlogo.cn&#x2F;mmopen&#x2F;vi_32&#x2F;Q0j4TwGTfTKxCqRzuYWQmpwiaqQEjNxbC7WicebicXQusU306jgmfoOzUcFg1qaDq5BStiblwBjw5dUOblQ2gUicQOQ&#x2F;132&quot;);    baseMapper.insert(ucenterMember);&#125;</code></pre></div><p>测试，先往redis中存验证码，再用swagger测试。</p><h2 id="根据token获取用户信息接口"><a href="#根据token获取用户信息接口" class="headerlink" title="根据token获取用户信息接口"></a>根据token获取用户信息接口</h2><p>Controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据token获取用户信息@GetMapping(&quot;getMemberInfo&quot;)public R getMemberInfo(HttpServletRequest request)&#123;    &#x2F;&#x2F; 根据token获取用户信息    String memberId &#x3D; JwtUtils.getMemberIdByJwtToken(request);    &#x2F;&#x2F; 根据id查询用户对象    UcenterMember member &#x3D; memberService.getById(memberId);    return R.ok().data(&quot;userInfo&quot;,member);&#125;</code></pre></div><h1 id="整合登录和注册页面"><a href="#整合登录和注册页面" class="headerlink" title="整合登录和注册页面"></a>整合登录和注册页面</h1><h2 id="一、在nuxt环境中安装插件"><a href="#一、在nuxt环境中安装插件" class="headerlink" title="一、在nuxt环境中安装插件"></a>一、在nuxt环境中安装插件</h2><h3 id="1、安装element-ui-和-vue-qriously"><a href="#1、安装element-ui-和-vue-qriously" class="headerlink" title="1、安装element-ui 和 vue-qriously"></a>1、安装element-ui 和 vue-qriously</h3><p>（1）执行命令安装</p><p>npm install element-ui</p><p>npm install vue-qriously</p><h3 id="2、修改配置文件-nuxt-swiper-plugin-js，使用插件"><a href="#2、修改配置文件-nuxt-swiper-plugin-js，使用插件" class="headerlink" title="2、修改配置文件 nuxt-swiper-plugin.js，使用插件"></a>2、修改配置文件 nuxt-swiper-plugin.js，使用插件</h3><p>nuxt-swiper-plugin.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import Vue from &#39;vue&#39;import VueAwesomeSwiper from &#39;vue-awesome-swiper&#x2F;dist&#x2F;ssr&#39;import VueQriously from &#39;vue-qriously&#39;import ElementUI from &#39;element-ui&#39; &#x2F;&#x2F;element-ui的全部组件import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;&#x2F;&#x2F;element-ui的cssVue.use(ElementUI) &#x2F;&#x2F;使用elementUIVue.use(VueQriously)Vue.use(VueAwesomeSwiper)</code></pre></div><h2 id="二、用户注册功能前端整合"><a href="#二、用户注册功能前端整合" class="headerlink" title="二、用户注册功能前端整合"></a>二、用户注册功能前端整合</h2><h3 id="1、在api文件夹中创建注册的js文件，定义接口"><a href="#1、在api文件夹中创建注册的js文件，定义接口" class="headerlink" title="1、在api文件夹中创建注册的js文件，定义接口"></a>1、在api文件夹中创建注册的js文件，定义接口</h3><p><strong>register.js</strong></p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;    &#x2F;&#x2F; 根据手机号码发送验证码  getCode(mobile) &#123;    return request(&#123;      url: &#96;&#x2F;edumsm&#x2F;msm&#x2F;sendByPhone&#x2F;$&#123;mobile&#125;&#96;,      method: &#39;get&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 注册  registerMember(formItem)&#123;    return request(&#123;      url: &#96;&#x2F;educenter&#x2F;member&#x2F;register&#96;,      method: &#39;post&#39;,      data:formItem    &#125;)  &#125;&#125;</code></pre></div><h3 id="2、在pages文件夹中创建注册页面，调用方法"><a href="#2、在pages文件夹中创建注册页面，调用方法" class="headerlink" title="2、在pages文件夹中创建注册页面，调用方法"></a>2、在pages文件夹中创建注册页面，调用方法</h3><p><strong>（1）在layouts创建布局页面</strong></p><p><strong>sign.vue</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;sign&quot;&gt;    &lt;!--标题--&gt;    &lt;div class&#x3D;&quot;logo&quot;&gt;      &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;logo.png&quot; alt&#x3D;&quot;logo&quot;&gt;    &lt;&#x2F;div&gt;    &lt;!--表单--&gt;    &lt;nuxt&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p><strong>（2）创建注册页面</strong></p><p><strong>修改layouts文件夹里面default.vue页面，修改登录和注册超链接地址</strong></p><p><img src="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/image-20220107000912160.png" alt="image-20220107000912160"></p><p><strong>在pages文件夹下，创建注册和登录页面</strong></p><p><strong>register.vue</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;main&quot;&gt;     &lt;div class&#x3D;&quot;title&quot;&gt;       &lt;a href&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;a&gt;       &lt;span&gt;·&lt;&#x2F;span&gt;       &lt;a class&#x3D;&quot;active&quot; href&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;a&gt;     &lt;&#x2F;div&gt;     &lt;div class&#x3D;&quot;sign-up-container&quot;&gt;       &lt;el-form ref&#x3D;&quot;userForm&quot; :model&#x3D;&quot;params&quot;&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend restyle&quot; prop&#x3D;&quot;nickname&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入你的昵称&#39;, trigger: &#39;blur&#39; &#125;]&quot;&gt;           &lt;div&gt;             &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;你的昵称&quot; v-model&#x3D;&quot;params.nickname&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-user&quot;&#x2F;&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend restyle no-radius&quot; prop&#x3D;&quot;mobile&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入手机号码&#39;, trigger: &#39;blur&#39; &#125;,&#123;validator: checkPhone, trigger: &#39;blur&#39;&#125;]&quot;&gt;           &lt;div&gt;             &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;手机号&quot; v-model&#x3D;&quot;params.mobile&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-phone&quot;&#x2F;&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend restyle no-radius&quot; prop&#x3D;&quot;code&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入验证码&#39;, trigger: &#39;blur&#39; &#125;]&quot;&gt;           &lt;div style&#x3D;&quot;width: 100%;display: block;float: left;position: relative&quot;&gt;             &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;验证码&quot; v-model&#x3D;&quot;params.code&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-phone&quot;&#x2F;&gt;           &lt;&#x2F;div&gt;           &lt;div class&#x3D;&quot;btn&quot; style&#x3D;&quot;position:absolute;right: 0;top: 6px;width: 40%;&quot;&gt;             &lt;a href&#x3D;&quot;javascript:&quot; type&#x3D;&quot;button&quot; @click&#x3D;&quot;getCodeFun()&quot; :value&#x3D;&quot;codeTest&quot; style&#x3D;&quot;border: none;background-color: none&quot;&gt;&#123;&#123;codeTest&#125;&#125;&lt;&#x2F;a&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend&quot; prop&#x3D;&quot;password&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;]&quot;&gt;           &lt;div&gt;             &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;设置密码&quot; v-model&#x3D;&quot;params.password&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-password&quot;&#x2F;&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;div class&#x3D;&quot;btn&quot;&gt;           &lt;input type&#x3D;&quot;button&quot; class&#x3D;&quot;sign-up-button&quot; value&#x3D;&quot;注册&quot; @click&#x3D;&quot;submitRegister()&quot;&gt;         &lt;&#x2F;div&gt;         &lt;p class&#x3D;&quot;sign-up-msg&quot;&gt;           点击 “注册” 即表示您同意并愿意遵守简书           &lt;br&gt;           &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;c44d171298ce&quot;&gt;用户协议&lt;&#x2F;a&gt;           和           &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;2ov8x3&quot;&gt;隐私政策&lt;&#x2F;a&gt; 。         &lt;&#x2F;p&gt;       &lt;&#x2F;el-form&gt;       &lt;!-- 更多注册方式 --&gt;       &lt;div class&#x3D;&quot;more-sign&quot;&gt;         &lt;h6&gt;社交帐号直接注册&lt;&#x2F;h6&gt;         &lt;ul&gt;           &lt;li&gt;&lt;a id&#x3D;&quot;weixin&quot; class&#x3D;&quot;weixin&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;huaan.free.idcfengye.com&#x2F;api&#x2F;ucenter&#x2F;wx&#x2F;login&quot;&gt;&lt;i             class&#x3D;&quot;iconfont icon-weixin&quot;&#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;           &lt;li&gt;&lt;a id&#x3D;&quot;qq&quot; class&#x3D;&quot;qq&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;#&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-qq&quot;&#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;         &lt;&#x2F;ul&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt;   import &#39;~&#x2F;assets&#x2F;css&#x2F;sign.css&#39;   import &#39;~&#x2F;assets&#x2F;css&#x2F;iconfont.css&#39;   import registerApi from &#39;@&#x2F;api&#x2F;register&#39;   export default &#123;     layout: &#39;sign&#39;,     data() &#123;       return &#123;         params: &#123;           mobile: &#39;&#39;,           code: &#39;&#39;,           nickname: &#39;&#39;,           password: &#39;&#39;         &#125;,         sending: true,      &#x2F;&#x2F;是否发送验证码         second: 60,        &#x2F;&#x2F;倒计时间         codeTest: &#39;获取验证码&#39;       &#125;     &#125;,     methods: &#123;       &#x2F;&#x2F; 获取验证码       getCodeFun()&#123;         registerApi.getCode(this.params.mobile)          .then(response &#x3D;&gt;&#123;            this.sending &#x3D; false            &#x2F;&#x2F; 倒计时            this.timeDown()          &#125;)       &#125;,      &#x2F;&#x2F; 倒计时      timeDown() &#123;        let result &#x3D; setInterval(() &#x3D;&gt; &#123;          --this.second;          this.codeTest &#x3D; this.second          if (this.second &lt; 1) &#123;            clearInterval(result);            this.sending &#x3D; true;            &#x2F;&#x2F;this.disabled &#x3D; false;            this.second &#x3D; 60;            this.codeTest &#x3D; &quot;获取验证码&quot;          &#125;        &#125;, 1000);      &#125;,       &#x2F;&#x2F; 注册       submitRegister()&#123;         registerApi.registerMember(this.params)          .then(response &#x3D;&gt;&#123;            &#x2F;&#x2F;提示注册成功              this.$message(&#123;                type: &#39;success&#39;,                message: &quot;注册成功&quot;              &#125;)                          &#x2F;&#x2F; 跳转至登录页面            this.$router.push(&#123;path:&#39;&#x2F;login&#39;&#125;)          &#125;)       &#125;,              checkPhone (rule, value, callback) &#123;         &#x2F;&#x2F;debugger         if (!(&#x2F;^1[34578]\d&#123;9&#125;$&#x2F;.test(value))) &#123;           return callback(new Error(&#39;手机号码格式不正确&#39;))         &#125;         return callback()       &#125;     &#125;   &#125;&lt;&#x2F;script&gt;</code></pre></div><h2 id="三、用户登录功能前端整合"><a href="#三、用户登录功能前端整合" class="headerlink" title="三、用户登录功能前端整合"></a>三、用户登录功能前端整合</h2><p>登录功能流程分析：</p><p>1、 点击登录，调用接口返回登录的token信息</p><p>2、 将返回的token存放到cookie中</p><p>3、 创建拦截器，判断cookie中是否有token，如果有就将token设置到请求头header中</p><p>4、 根据token调用接口，返回用户信息</p><p>5、 根据返回的用户信息，在页面显示对应的数据</p><p><img src="/myBlog/day12-%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1/image-20220107000936830.png" alt="image-20220107000936830"></p><h3 id="1、在api文件夹中创建登录的js文件，定义接口"><a href="#1、在api文件夹中创建登录的js文件，定义接口" class="headerlink" title="1、在api文件夹中创建登录的js文件，定义接口"></a>1、在api文件夹中创建登录的js文件，定义接口</h3><p><strong>login.js</strong></p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;    &#x2F;&#x2F; 登录  submitLoginUser(userInfo) &#123;    return request(&#123;      url: &#96;&#x2F;educenter&#x2F;member&#x2F;login&#96;,      method: &#39;post&#39;,      data:userInfo    &#125;)  &#125;,  &#x2F;&#x2F; 根据token获取用户信息  getUserInfo()&#123;    return request(&#123;      url: &#96;&#x2F;educenter&#x2F;member&#x2F;getMemberInfo&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div><h3 id="2、在pages文件夹中创建登录页面，调用方法"><a href="#2、在pages文件夹中创建登录页面，调用方法" class="headerlink" title="2、在pages文件夹中创建登录页面，调用方法"></a>2、在pages文件夹中创建登录页面，调用方法</h3><p>（1）安装js-cookie插件</p><p>npm install js-cookie</p><p>（2）login.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;main&quot;&gt;     &lt;div class&#x3D;&quot;title&quot;&gt;       &lt;a class&#x3D;&quot;active&quot; href&#x3D;&quot;&#x2F;login&quot;&gt;登录&lt;&#x2F;a&gt;       &lt;span&gt;·&lt;&#x2F;span&gt;       &lt;a href&#x3D;&quot;&#x2F;register&quot;&gt;注册&lt;&#x2F;a&gt;     &lt;&#x2F;div&gt;     &lt;div class&#x3D;&quot;sign-up-container&quot;&gt;       &lt;el-form ref&#x3D;&quot;userForm&quot; :model&#x3D;&quot;user&quot;&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend restyle&quot; prop&#x3D;&quot;mobile&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入手机号码&#39;, trigger: &#39;blur&#39; &#125;,&#123;validator: checkPhone, trigger: &#39;blur&#39;&#125;]&quot;&gt;           &lt;div &gt;             &lt;el-input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;手机号&quot; v-model&#x3D;&quot;user.mobile&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-phone&quot; &#x2F;&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item class&#x3D;&quot;input-prepend&quot; prop&#x3D;&quot;password&quot; :rules&#x3D;&quot;[&#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;]&quot;&gt;           &lt;div&gt;             &lt;el-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;密码&quot; v-model&#x3D;&quot;user.password&quot;&#x2F;&gt;             &lt;i class&#x3D;&quot;iconfont icon-password&quot;&#x2F;&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;el-form-item&gt;         &lt;div class&#x3D;&quot;btn&quot;&gt;           &lt;input type&#x3D;&quot;button&quot; class&#x3D;&quot;sign-in-button&quot; value&#x3D;&quot;登录&quot; @click&#x3D;&quot;submitLogin()&quot;&gt;         &lt;&#x2F;div&gt;       &lt;&#x2F;el-form&gt;       &lt;!-- 更多登录方式 --&gt;       &lt;div class&#x3D;&quot;more-sign&quot;&gt;         &lt;h6&gt;社交帐号登录&lt;&#x2F;h6&gt;         &lt;ul&gt;           &lt;li&gt;&lt;a id&#x3D;&quot;weixin&quot; class&#x3D;&quot;weixin&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;qy.free.idcfengye.com&#x2F;api&#x2F;ucenter&#x2F;weixinLogin&#x2F;login&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-weixin&quot;&#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;           &lt;li&gt;&lt;a id&#x3D;&quot;qq&quot; class&#x3D;&quot;qq&quot; target&#x3D;&quot;_blank&quot; href&#x3D;&quot;#&quot;&gt;&lt;i class&#x3D;&quot;iconfont icon-qq&quot;&#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;         &lt;&#x2F;ul&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt;   import &#39;~&#x2F;assets&#x2F;css&#x2F;sign.css&#39;   import &#39;~&#x2F;assets&#x2F;css&#x2F;iconfont.css&#39;   import cookie from &#39;js-cookie&#39;   import loginApi from &#39;@&#x2F;api&#x2F;login&#39;   export default &#123;     layout: &#39;sign&#39;,     data () &#123;       return &#123;         user:&#123;           mobile:&#39;&#39;,           password:&#39;&#39;         &#125;,         loginInfo:&#123;&#125;       &#125;     &#125;,     methods: &#123;       &#x2F;&#x2F; 登录       submitLogin()&#123;         &#x2F;&#x2F; 第一步调用接口获取登录token值         loginApi.submitLoginUser(this.user)          .then(response &#x3D;&gt;&#123;            &#x2F;&#x2F; 第二步，将获取到的token值放到cookie中            cookie.set(&#39;guli_token&#39;,response.data.data.token,&#123; domain: &#39;localhost&#39; &#125;)            &#x2F;&#x2F; 第四步，根据token的值，调用接口，获取用户数据，并存入cookie中            loginApi.getUserInfo()              .then(response &#x3D;&gt;&#123;                this.loginInfo &#x3D; response.data.data.userInfo                &#x2F;&#x2F; 将得到的用户信息存入cookie中                cookie.set(&quot;guli_ucenter&quot;,JSON.stringify(this.loginInfo),&#123; domain: &#39;localhost&#39; &#125;)                &#x2F;&#x2F; 跳转页面                window.location.href &#x3D; &quot;&#x2F;&quot;              &#125;)          &#125;)                 &#125;,       checkPhone (rule, value, callback) &#123;         &#x2F;&#x2F;debugger         if (!(&#x2F;^1[34578]\d&#123;9&#125;$&#x2F;.test(value))) &#123;           return callback(new Error(&#39;手机号码格式不正确&#39;))         &#125;         return callback()       &#125;     &#125;   &#125; &lt;&#x2F;script&gt;&lt;style&gt;   .el-form-item__error&#123;    z-index: 9999999;  &#125;&lt;&#x2F;style&gt;</code></pre></div><h3 id="3、在request-js添加拦截器，用于传递token信息"><a href="#3、在request-js添加拦截器，用于传递token信息" class="headerlink" title="3、在request.js添加拦截器，用于传递token信息"></a>3、在request.js添加拦截器，用于传递token信息</h3><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import axios from &#39;axios&#39;import cookie from &#39;js-cookie&#39;import &#123; MessageBox, Message &#125; from &#39;element-ui&#39;&#x2F;&#x2F; 创建axios实例const service &#x3D; axios.create(&#123;  baseURL: &#39;http:&#x2F;&#x2F;localhost:9001&#39;, &#x2F;&#x2F; api的base_url  timeout: 20000 &#x2F;&#x2F; 请求超时时间&#125;)&#x2F;&#x2F; 第三步，编写一个拦截器&#x2F;&#x2F; http request 拦截器service.interceptors.request.use(  config &#x3D;&gt; &#123;  &#x2F;&#x2F;debugger  if (cookie.get(&#39;guli_token&#39;)) &#123;    &#x2F;&#x2F; 将token的值存入到请求头中    config.headers[&#39;token&#39;] &#x3D; cookie.get(&#39;guli_token&#39;);  &#125;    return config  &#125;,  err &#x3D;&gt; &#123;  return Promise.reject(err);&#125;)&#x2F;&#x2F; http response 拦截器service.interceptors.response.use(  response &#x3D;&gt; &#123;    &#x2F;&#x2F;debugger    if (response.data.code &#x3D;&#x3D; 28004) &#123;        console.log(&quot;response.data.resultCode是28004&quot;)        &#x2F;&#x2F; 返回 错误代码-1 清除ticket信息并跳转到登录页面        &#x2F;&#x2F;debugger        window.location.href&#x3D;&quot;&#x2F;login&quot;        return    &#125;else&#123;      if (response.data.code !&#x3D;&#x3D; 20000) &#123;        &#x2F;&#x2F;25000：订单支付中，不做任何提示        if(response.data.code !&#x3D; 25000) &#123;          Message(&#123;            message: response.data.message || &#39;error&#39;,            type: &#39;error&#39;,            duration: 5 * 1000          &#125;)        &#125;      &#125; else &#123;        return response;      &#125;    &#125;  &#125;,  error &#x3D;&gt; &#123;    return Promise.reject(error.response)   &#x2F;&#x2F; 返回接口返回的错误信息&#125;);export default service</code></pre></div><h3 id="4、修改layouts中的default-vue页面"><a href="#4、修改layouts中的default-vue页面" class="headerlink" title="4、修改layouts中的default.vue页面"></a>4、修改layouts中的default.vue页面</h3><p>（1）显示登录之后的用户信息</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt; import &quot;~&#x2F;assets&#x2F;css&#x2F;reset.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;theme.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;global.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;web.css&quot;;   import cookie from &#39;js-cookie&#39;   import loginApi from &#39;@&#x2F;api&#x2F;login&#39; export default &#123;   data()&#123;     return&#123;      token: &#39;&#39;,      loginInfo: &#123;        id: &#39;&#39;,        age: &#39;&#39;,        avatar: &#39;&#39;,        mobile: &#39;&#39;,        nickname: &#39;&#39;,        sex: &#39;&#39;      &#125;     &#125;   &#125;,   created()&#123;    this.showUserInfo()   &#125;,   methods:&#123;     &#x2F;&#x2F; 显示用户信息，从cookie中取出用户信息     showUserInfo()&#123;       loginApi.getUserInfo()       .then(response &#x3D;&gt;&#123;         &#x2F;&#x2F; 第五步，从cookie中取出用户信息，取出来的是字符串          var userStr &#x3D; cookie.get(&quot;guli_ucenter&quot;)          &#x2F;&#x2F; 判断取出来的字符串是有为空          if(userStr)&#123;          &#x2F;&#x2F; 将取出来的字符串转为json，并赋值给loginInfo          this.loginInfo &#x3D; JSON.parse(userStr)          &#125;       &#125;)     &#125;   &#125; &#125;; &lt;&#x2F;script&gt;</code></pre></div><p>（2）default.vue页面显示登录之后的用户信息</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- &#x2F; nav --&gt;          &lt;ul class&#x3D;&quot;h-r-login&quot;&gt;              &lt;li v-if&#x3D;&quot;!loginInfo.id&quot; id&#x3D;&quot;no-login&quot;&gt;                  &lt;a href&#x3D;&quot;&#x2F;login&quot; title&#x3D;&quot;登录&quot;&gt;                      &lt;em class&#x3D;&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;                      &lt;span class&#x3D;&quot;vam ml5&quot;&gt;登录&lt;&#x2F;span&gt;                  &lt;&#x2F;a&gt;                  |                  &lt;a href&#x3D;&quot;&#x2F;register&quot; title&#x3D;&quot;注册&quot;&gt;                      &lt;span class&#x3D;&quot;vam ml5&quot;&gt;注册&lt;&#x2F;span&gt;                  &lt;&#x2F;a&gt;              &lt;&#x2F;li&gt;              &lt;li v-if&#x3D;&quot;loginInfo.id&quot; id&#x3D;&quot;is-login-one&quot; class&#x3D;&quot;mr10&quot;&gt;                  &lt;a id&#x3D;&quot;headerMsgCountId&quot; href&#x3D;&quot;#&quot; title&#x3D;&quot;消息&quot;&gt;                      &lt;em class&#x3D;&quot;icon18 news-icon&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;                  &lt;&#x2F;a&gt;                  &lt;q class&#x3D;&quot;red-point&quot; style&#x3D;&quot;display: none&quot;&gt;&amp;nbsp;&lt;&#x2F;q&gt;              &lt;&#x2F;li&gt;              &lt;li v-if&#x3D;&quot;loginInfo.id&quot; id&#x3D;&quot;is-login-two&quot; class&#x3D;&quot;h-r-user&quot;&gt;                  &lt;a href&#x3D;&quot;&#x2F;ucenter&quot; title&gt;                      &lt;img                            :src&#x3D;&quot;loginInfo.avatar&quot;                            width&#x3D;&quot;30&quot;                            height&#x3D;&quot;30&quot;                            class&#x3D;&quot;vam picImg&quot;                            alt                            &gt;                      &lt;span id&#x3D;&quot;userName&quot; class&#x3D;&quot;vam disIb&quot;&gt;&#123;&#123; loginInfo.nickname &#125;&#125;&lt;&#x2F;span&gt;                  &lt;&#x2F;a&gt;                  &lt;a href&#x3D;&quot;javascript:void(0);&quot; title&#x3D;&quot;退出&quot; @click&#x3D;&quot;logout()&quot; class&#x3D;&quot;ml5&quot;&gt;退出&lt;&#x2F;a&gt;              &lt;&#x2F;li&gt;              &lt;!-- &#x2F;未登录显示第1 li；登录后显示第2，3 li --&gt;          &lt;&#x2F;ul&gt;</code></pre></div><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 退出登录logout()&#123;  cookie.set(&#39;guli_token&#39;,&#39;&#39;,&#123; domain: &#39;localhost&#39; &#125;)  cookie.set(&quot;guli_ucenter&quot;,&#39;&#39;,&#123; domain: &#39;localhost&#39; &#125;)  &#x2F;&#x2F; 跳转页面  window.location.href &#x3D; &quot;&#x2F;&quot;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day11-首页数据显示</title>
    <link href="/myBlog/day11-%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA/"/>
    <url>/myBlog/day11-%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[#  day11-首页数据显示 <img src="/myBlog/day11-%E9%A6%96%E9%A1%B5%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA/image-20220106234709803.png" alt="image-20220106234709803"> {{% raw %}}# 搭建项目前台环境NUXT {{ sensitive }} {{%  endraw %}}## 下载压缩包https://github.com/nuxt-community/starter-template/archive/master.zip## 解压将template中的内容复制到 guli## 修改package.jsonname、description、author（必须修改这里，否则项目无法安装）<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&quot;name&quot;: &quot;guli&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;谷粒学院前台网站&quot;,  &quot;author&quot;: &quot;Helen &lt;111111111@qq.com&gt;&quot;,</code></pre></div>## 修改nuxt.config.js修改title: '{{ name }}'、content: '{{escape description }}'这里的设置最后会显示在页面标题栏和meta数据中<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">head: &#123;    title: &#39;谷粒学院 - Java视频|HTML5视频|前端视频|Python视频|大数据视频-自学拿1万+月薪的IT在线视频课程，谷粉力挺，老学员为你推荐&#39;,    meta: [      &#123; charset: &#39;utf-8&#39; &#125;,      &#123; name: &#39;viewport&#39;, content: &#39;width&#x3D;device-width, initial-scale&#x3D;1&#39; &#125;,      &#123; hid: &#39;keywords&#39;, name: &#39;keywords&#39;, content: &#39;谷粒学院,IT在线视频教程,Java视频,HTML5视频,前端视频,Python视频,大数据视频&#39; &#125;,      &#123; hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;谷粒学院是国内领先的IT在线视频学习平台、职业教育平台。截止目前,谷粒学院线上、线下学习人次数以万计！会同上百个知名开发团队联合制定的Java、HTML5前端、大数据、Python等视频课程，被广大学习者及IT工程师誉为：业界最适合自学、代码量最大、案例最多、实战性最强、技术最前沿的IT系列视频课程！&#39; &#125;    ],    link: [      &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;favicon.ico&#39; &#125;    ]  &#125;,</code></pre></div>## 安装依赖<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install</code></pre></div>## 测试运行<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm run dev</code></pre></div>## 幻灯片插件<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install vue-awesome-swiper</code></pre></div>在 plugins 文件夹下新建文件 nuxt-swiper-plugin.js，内容是<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import Vue from &#39;vue&#39;import VueAwesomeSwiper from &#39;vue-awesome-swiper&#x2F;dist&#x2F;ssr&#39;Vue.use(VueAwesomeSwiper)</code></pre></div> 在 nuxt.config.js 文件中配置插件将 plugins 和 css节点 复制到 module.exports节点下<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">module.exports &#x3D; &#123;  plugins: [    &#123; src: &#39;~&#x2F;plugins&#x2F;nuxt-swiper-plugin.js&#39;, ssr: false &#125;  ],  css: [    &#39;swiper&#x2F;dist&#x2F;css&#x2F;swiper.css&#39;  ],</code></pre></div># NUXT框架介绍## 目录介绍![image-20220106234951219](day11-首页数据显示/image-20220106234951219.png)## 页面加载方式![image-20220106235005937](day11-首页数据显示/image-20220106235005937.png)# 整合项目首页面## 页面布局## 复制静态资源将静态原型中的css、img、js、photo目录拷贝至assets目录下 将favicon.ico复制到static目录下## 定义布局我们可以把页头和页尾提取出来，形成布局页修改layouts目录下default.vue，从静态页面中复制首页，修改了原始文件中的资源路径为~/assets/，将主内容区域的内容替换成<nuxt>内容如下：完整的内容如下<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;in-wrap&quot;&gt;     &lt;!-- 公共头引入 --&gt;     &lt;header id&#x3D;&quot;header&quot;&gt;       &lt;section class&#x3D;&quot;container&quot;&gt;         &lt;h1 id&#x3D;&quot;logo&quot;&gt;           &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;谷粒学院&quot;&gt;             &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;logo.png&quot; width&#x3D;&quot;100%&quot; alt&#x3D;&quot;谷粒学院&quot;&gt;           &lt;&#x2F;a&gt;         &lt;&#x2F;h1&gt;         &lt;div class&#x3D;&quot;h-r-nsl&quot;&gt;           &lt;ul class&#x3D;&quot;nav&quot;&gt;             &lt;router-link to&#x3D;&quot;&#x2F;&quot; tag&#x3D;&quot;li&quot; active-class&#x3D;&quot;current&quot; exact&gt;               &lt;a&gt;首页&lt;&#x2F;a&gt;             &lt;&#x2F;router-link&gt;             &lt;router-link to&#x3D;&quot;&#x2F;course&quot; tag&#x3D;&quot;li&quot; active-class&#x3D;&quot;current&quot;&gt;               &lt;a&gt;课程&lt;&#x2F;a&gt;             &lt;&#x2F;router-link&gt;             &lt;router-link to&#x3D;&quot;&#x2F;teacher&quot; tag&#x3D;&quot;li&quot; active-class&#x3D;&quot;current&quot;&gt;               &lt;a&gt;名师&lt;&#x2F;a&gt;             &lt;&#x2F;router-link&gt;             &lt;router-link to&#x3D;&quot;&#x2F;article&quot; tag&#x3D;&quot;li&quot; active-class&#x3D;&quot;current&quot;&gt;               &lt;a&gt;文章&lt;&#x2F;a&gt;             &lt;&#x2F;router-link&gt;             &lt;router-link to&#x3D;&quot;&#x2F;qa&quot; tag&#x3D;&quot;li&quot; active-class&#x3D;&quot;current&quot;&gt;               &lt;a&gt;问答&lt;&#x2F;a&gt;             &lt;&#x2F;router-link&gt;           &lt;&#x2F;ul&gt;           &lt;!-- &#x2F; nav --&gt;           &lt;ul class&#x3D;&quot;h-r-login&quot;&gt;             &lt;li id&#x3D;&quot;no-login&quot;&gt;               &lt;a href&#x3D;&quot;&#x2F;sing_in&quot; title&#x3D;&quot;登录&quot;&gt;                 &lt;em class&#x3D;&quot;icon18 login-icon&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;                 &lt;span class&#x3D;&quot;vam ml5&quot;&gt;登录&lt;&#x2F;span&gt;               &lt;&#x2F;a&gt;               |               &lt;a href&#x3D;&quot;&#x2F;sign_up&quot; title&#x3D;&quot;注册&quot;&gt;                 &lt;span class&#x3D;&quot;vam ml5&quot;&gt;注册&lt;&#x2F;span&gt;               &lt;&#x2F;a&gt;             &lt;&#x2F;li&gt;             &lt;li class&#x3D;&quot;mr10 undis&quot; id&#x3D;&quot;is-login-one&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;消息&quot; id&#x3D;&quot;headerMsgCountId&quot;&gt;                 &lt;em class&#x3D;&quot;icon18 news-icon&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;               &lt;&#x2F;a&gt;               &lt;q class&#x3D;&quot;red-point&quot; style&#x3D;&quot;display: none&quot;&gt;&amp;nbsp;&lt;&#x2F;q&gt;             &lt;&#x2F;li&gt;             &lt;li class&#x3D;&quot;h-r-user undis&quot; id&#x3D;&quot;is-login-two&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&gt;                 &lt;img                   src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;avatar-boy.gif&quot;                   width&#x3D;&quot;30&quot;                   height&#x3D;&quot;30&quot;                   class&#x3D;&quot;vam picImg&quot;                   alt                 &gt;                 &lt;span class&#x3D;&quot;vam disIb&quot; id&#x3D;&quot;userName&quot;&gt;&lt;&#x2F;span&gt;               &lt;&#x2F;a&gt;               &lt;a href&#x3D;&quot;javascript:void(0)&quot; title&#x3D;&quot;退出&quot; onclick&#x3D;&quot;exit();&quot; class&#x3D;&quot;ml5&quot;&gt;退出&lt;&#x2F;a&gt;             &lt;&#x2F;li&gt;             &lt;!-- &#x2F;未登录显示第1 li；登录后显示第2，3 li --&gt;           &lt;&#x2F;ul&gt;           &lt;aside class&#x3D;&quot;h-r-search&quot;&gt;             &lt;form action&#x3D;&quot;#&quot; method&#x3D;&quot;post&quot;&gt;               &lt;label class&#x3D;&quot;h-r-s-box&quot;&gt;                 &lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;输入你想学的课程&quot; name&#x3D;&quot;queryCourse.courseName&quot; value&gt;                 &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;s-btn&quot;&gt;                   &lt;em class&#x3D;&quot;icon18&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;                 &lt;&#x2F;button&gt;               &lt;&#x2F;label&gt;             &lt;&#x2F;form&gt;           &lt;&#x2F;aside&gt;         &lt;&#x2F;div&gt;         &lt;aside class&#x3D;&quot;mw-nav-btn&quot;&gt;           &lt;div class&#x3D;&quot;mw-nav-icon&quot;&gt;&lt;&#x2F;div&gt;         &lt;&#x2F;aside&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;header&gt;     &lt;!-- &#x2F;公共头引入 --&gt;     &lt;nuxt&#x2F;&gt;     &lt;!-- 公共底引入 --&gt;     &lt;footer id&#x3D;&quot;footer&quot;&gt;       &lt;section class&#x3D;&quot;container&quot;&gt;         &lt;div class&gt;           &lt;h4 class&#x3D;&quot;hLh30&quot;&gt;             &lt;span class&#x3D;&quot;fsize18 f-fM c-999&quot;&gt;友情链接&lt;&#x2F;span&gt;           &lt;&#x2F;h4&gt;           &lt;ul class&#x3D;&quot;of flink-list&quot;&gt;             &lt;li&gt;               &lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.atguigu.com&#x2F;&quot; title&#x3D;&quot;尚硅谷&quot; target&#x3D;&quot;_blank&quot;&gt;尚硅谷&lt;&#x2F;a&gt;             &lt;&#x2F;li&gt;           &lt;&#x2F;ul&gt;           &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;b-foot&quot;&gt;           &lt;section class&#x3D;&quot;fl col-7&quot;&gt;             &lt;section class&#x3D;&quot;mr20&quot;&gt;               &lt;section class&#x3D;&quot;b-f-link&quot;&gt;                 &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;关于我们&quot; target&#x3D;&quot;_blank&quot;&gt;关于我们&lt;&#x2F;a&gt;|                 &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;联系我们&quot; target&#x3D;&quot;_blank&quot;&gt;联系我们&lt;&#x2F;a&gt;|                 &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;帮助中心&quot; target&#x3D;&quot;_blank&quot;&gt;帮助中心&lt;&#x2F;a&gt;|                 &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;资源下载&quot; target&#x3D;&quot;_blank&quot;&gt;资源下载&lt;&#x2F;a&gt;|                 &lt;span&gt;服务热线：010-56253825(北京) 0755-85293825(深圳)&lt;&#x2F;span&gt;                 &lt;span&gt;Email：info@atguigu.com&lt;&#x2F;span&gt;               &lt;&#x2F;section&gt;               &lt;section class&#x3D;&quot;b-f-link mt10&quot;&gt;                 &lt;span&gt;©2018课程版权均归谷粒学院所有 京ICP备17055252号&lt;&#x2F;span&gt;               &lt;&#x2F;section&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;section&gt;           &lt;aside class&#x3D;&quot;fl col-3 tac mt15&quot;&gt;             &lt;section class&#x3D;&quot;gf-tx&quot;&gt;               &lt;span&gt;                 &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;wx-icon.png&quot; alt&gt;               &lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;gf-tx&quot;&gt;               &lt;span&gt;                 &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;wb-icon.png&quot; alt&gt;               &lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;aside&gt;           &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;footer&gt;     &lt;!-- &#x2F;公共底引入 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; import &quot;~&#x2F;assets&#x2F;css&#x2F;reset.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;theme.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;global.css&quot;; import &quot;~&#x2F;assets&#x2F;css&#x2F;web.css&quot;; export default &#123;&#125;; &lt;&#x2F;script&gt;</code></pre></div>## 定义首页面（不包含幻灯片）修改pages/index.vue：修改了原始文件中的资源路径为~/assets/内容如下：<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div&gt;      &lt;!-- 幻灯片 开始 --&gt;            &lt;!-- 幻灯片 结束 --&gt;      &lt;div id&#x3D;&quot;aCoursesList&quot;&gt;       &lt;!-- 网校课程 开始 --&gt;       &lt;div&gt;         &lt;section class&#x3D;&quot;container&quot;&gt;           &lt;header class&#x3D;&quot;comm-title&quot;&gt;             &lt;h2 class&#x3D;&quot;tac&quot;&gt;               &lt;span class&#x3D;&quot;c-333&quot;&gt;热门课程&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;           &lt;&#x2F;header&gt;           &lt;div&gt;             &lt;article class&#x3D;&quot;comm-course-list&quot;&gt;               &lt;ul class&#x3D;&quot;of&quot; id&#x3D;&quot;bna&quot;&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295592705.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;听力口语&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;听力口语&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;听力口语&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295581911.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;Java精品课程&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;Java精品课程&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;Java精品课程&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;501人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;501评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295604295.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;C4D零基础&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;C4D零基础&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;C4D零基础&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;300人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;300评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442302831779.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;数学给宝宝带来的兴趣&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;数学给宝宝带来的兴趣&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;数学给宝宝带来的兴趣&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;256人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;256评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295455437.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;零基础入门学习Python课程学习&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a                         href&#x3D;&quot;#&quot;                         title&#x3D;&quot;零基础入门学习Python课程学习&quot;                         class&#x3D;&quot;course-title fsize18 c-333&quot;                       &gt;零基础入门学习Python课程学习&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;137人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;137评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295570359.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;MySql从入门到精通&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;MySql从入门到精通&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;MySql从入门到精通&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;125人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;125评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442302852837.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;搜索引擎优化技术&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;搜索引擎优化技术&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;搜索引擎优化技术&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;123人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;123评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-img&quot;&gt;                       &lt;img                         src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295379715.jpg&quot;                         class&#x3D;&quot;img-responsive&quot;                         alt&#x3D;&quot;20世纪西方音乐&quot;                       &gt;                       &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                         &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                       &lt;&#x2F;div&gt;                     &lt;&#x2F;section&gt;                     &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;20世纪西方音乐&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;20世纪西方音乐&lt;&#x2F;a&gt;                     &lt;&#x2F;h3&gt;                     &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                       &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                         &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                       &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;34人学习&lt;&#x2F;i&gt;                         |                         &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;34评论&lt;&#x2F;i&gt;                       &lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;               &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;             &lt;&#x2F;article&gt;             &lt;section class&#x3D;&quot;tac pt20&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;全部课程&quot; class&#x3D;&quot;comm-btn c-btn-2&quot;&gt;全部课程&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;       &lt;&#x2F;div&gt;       &lt;!-- &#x2F;网校课程 结束 --&gt;       &lt;!-- 网校名师 开始 --&gt;       &lt;div&gt;         &lt;section class&#x3D;&quot;container&quot;&gt;           &lt;header class&#x3D;&quot;comm-title&quot;&gt;             &lt;h2 class&#x3D;&quot;tac&quot;&gt;               &lt;span class&#x3D;&quot;c-333&quot;&gt;名师大咖&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;           &lt;&#x2F;header&gt;           &lt;div&gt;             &lt;article class&#x3D;&quot;i-teacher-list&quot;&gt;               &lt;ul class&#x3D;&quot;of&quot;&gt;                 &lt;li&gt;                   &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                     &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;姚晨&quot;&gt;                         &lt;img alt&#x3D;&quot;姚晨&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297885942.jpg&quot;&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;姚晨&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;姚晨&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                       &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;北京师范大学法学院副教授&lt;&#x2F;span&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                       &lt;p                         class&#x3D;&quot;c-999 f-fA&quot;                       &gt;北京师范大学法学院副教授、清华大学法学博士。自2004年至今已有9年的司法考试培训经验。长期从事司法考试辅导，深知命题规律，了解解题技巧。内容把握准确，授课重点明确，层次分明，调理清晰，将法条法理与案例有机融合，强调综合，深入浅出。&lt;&#x2F;p&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                     &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;谢娜&quot;&gt;                         &lt;img alt&#x3D;&quot;谢娜&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297919077.jpg&quot;&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;谢娜&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;谢娜&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                       &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;资深课程设计专家，专注10年AACTP美国培训协会认证导师&lt;&#x2F;span&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                       &lt;p                         class&#x3D;&quot;c-999 f-fA&quot;                       &gt;十年课程研发和培训咨询经验，曾任国企人力资源经理、大型外企培训经理，负责企业大学和培训体系搭建；曾任专业培训机构高级顾问、研发部总监，为包括广东移动、东莞移动、深圳移动、南方电网、工商银行、农业银行、民生银行、邮储银行、TCL集团、清华大学继续教育学院、中天路桥、广西扬翔股份等超过200家企业提供过培训与咨询服务，并担任近50个大型项目的总负责人。&lt;&#x2F;p&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                     &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;刘德华&quot;&gt;                         &lt;img alt&#x3D;&quot;刘德华&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297927029.jpg&quot;&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;刘德华&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;刘德华&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                       &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;上海师范大学法学院副教授&lt;&#x2F;span&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                       &lt;p                         class&#x3D;&quot;c-999 f-fA&quot;                       &gt;上海师范大学法学院副教授、清华大学法学博士。自2004年至今已有9年的司法考试培训经验。长期从事司法考试辅导，深知命题规律，了解解题技巧。内容把握准确，授课重点明确，层次分明，调理清晰，将法条法理与案例有机融合，强调综合，深入浅出。&lt;&#x2F;p&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                     &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周润发&quot;&gt;                         &lt;img alt&#x3D;&quot;周润发&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297935589.jpg&quot;&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周润发&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;周润发&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                       &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;考研政治辅导实战派专家，全国考研政治命题研究组核心成员。&lt;&#x2F;span&gt;                     &lt;&#x2F;div&gt;                     &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                       &lt;p                         class&#x3D;&quot;c-999 f-fA&quot;                       &gt;法学博士，北京师范大学马克思主义学院副教授，专攻毛泽东思想概论、邓小平理论，长期从事考研辅导。出版著作两部，发表学术论文30余篇，主持国家社会科学基金项目和教育部重大课题子课题各一项，参与中央实施马克思主义理论研究和建设工程项目。&lt;&#x2F;p&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;               &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;             &lt;&#x2F;article&gt;             &lt;section class&#x3D;&quot;tac pt20&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;全部讲师&quot; class&#x3D;&quot;comm-btn c-btn-2&quot;&gt;全部讲师&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;       &lt;&#x2F;div&gt;       &lt;!-- &#x2F;网校名师 结束 --&gt;     &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123; &#125; &lt;&#x2F;script&gt;  &lt;script&gt; export default &#123;   data () &#123;     return &#123;       swiperOption: &#123;         &#x2F;&#x2F;配置分页         pagination: &#123;           el: &#39;.swiper-pagination&#39;&#x2F;&#x2F;分页的dom节点         &#125;,         &#x2F;&#x2F;配置导航         navigation: &#123;           nextEl: &#39;.swiper-button-next&#39;,&#x2F;&#x2F;下一页dom节点           prevEl: &#39;.swiper-button-prev&#39;&#x2F;&#x2F;前一页dom节点         &#125;       &#125;     &#125;   &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div>## 幻灯片插件<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 幻灯片 开始 --&gt;      &lt;div v-swiper:mySwiper&#x3D;&quot;swiperOption&quot;&gt;          &lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt;              &lt;div class&#x3D;&quot;swiper-slide&quot; style&#x3D;&quot;background: #040B1B;&quot;&gt;                  &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&#x2F;&quot;&gt;                      &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;banner&#x2F;1525939573202.jpg&quot; alt&#x3D;&quot;首页banner&quot;&gt;                  &lt;&#x2F;a&gt;              &lt;&#x2F;div&gt;              &lt;div class&#x3D;&quot;swiper-slide&quot; style&#x3D;&quot;background: #040B1B;&quot;&gt;                  &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;&#x2F;&quot;&gt;                      &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;banner&#x2F;1525939573202.jpg&quot; alt&#x3D;&quot;首页banner&quot;&gt;                  &lt;&#x2F;a&gt;              &lt;&#x2F;div&gt;          &lt;&#x2F;div&gt;          &lt;div class&#x3D;&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;&#x2F;div&gt;          &lt;div class&#x3D;&quot;swiper-button-prev swiper-button-white&quot; slot&#x3D;&quot;button-prev&quot;&gt;&lt;&#x2F;div&gt;          &lt;div class&#x3D;&quot;swiper-button-next swiper-button-white&quot; slot&#x3D;&quot;button-next&quot;&gt;&lt;&#x2F;div&gt;      &lt;&#x2F;div&gt;      &lt;!-- 幻灯片 结束 --&gt;</code></pre></div>Script<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt; export default &#123;   data () &#123;     return &#123;       swiperOption: &#123;         &#x2F;&#x2F;配置分页         pagination: &#123;           el: &#39;.swiper-pagination&#39;&#x2F;&#x2F;分页的dom节点         &#125;,         &#x2F;&#x2F;配置导航         navigation: &#123;           nextEl: &#39;.swiper-button-next&#39;,&#x2F;&#x2F;下一页dom节点           prevEl: &#39;.swiper-button-prev&#39;&#x2F;&#x2F;前一页dom节点         &#125;       &#125;     &#125;   &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div>## 启动项目报错解决方案Could not compile template.......swiper\dist\css\swiper.css<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">P168报错:ERROR Could not compile template.......swiper\dist\css\swiper.css因为我们导入的&#96;import swiper&#x2F;css&#x2F;swiper.css&#96;在低版本中有，Swiper 6.0.0或者更高版本就不是这个导入地址了，所以解决方案有两种：方案一：导入&#96;import swiper&#x2F;swiper-bundle.css&#96;， 同时删除&#96;import swiper&#x2F;css&#x2F;swiper.css&#96;方案二：把安装的vue-awesome-swiper版本回退到低版本，这样就可以保留&#96;import swiper&#x2F;css&#x2F;swiper.css&#96;:指令为: &#96;npm i vue-awesome-swiper@3.1.3 --save&#96;或者 将package.js里面的dependencies下的vue-awesome-swiper: ^4.x.x改为3.1.3,然后npm install 在之后启动还会报一个错:potentially fixable with the &#96;--fix&#96; option解决办法:找到 nuxt.config.js在extend (config, &#123; isDev, isClient &#125;) &#123;&#125;括号内最后面添加options: &#123;fix: true&#125;也就是:extend (config, &#123; isDev, isClient &#125;) &#123;if (isDev &amp;&amp; isClient) &#123;config.module.rules.push(&#123;enforce: pre,test: &#x2F;\.(js|vue)$&#x2F;,loader: eslint-loader,exclude: &#x2F;(node_modules)&#x2F;,options: &#123;fix: true&#125;&#125;)&#125;&#125;</code></pre></div># 整合课程和名师页面## 课程列表页面创建 pages/course/index.vue<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- &#x2F;课程列表 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;header class&#x3D;&quot;comm-title&quot;&gt;         &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;           &lt;span class&#x3D;&quot;c-333&quot;&gt;全部课程&lt;&#x2F;span&gt;         &lt;&#x2F;h2&gt;       &lt;&#x2F;header&gt;       &lt;section class&#x3D;&quot;c-sort-box&quot;&gt;         &lt;section class&#x3D;&quot;c-s-dl&quot;&gt;           &lt;dl&gt;             &lt;dt&gt;               &lt;span class&#x3D;&quot;c-999 fsize14&quot;&gt;课程类别&lt;&#x2F;span&gt;             &lt;&#x2F;dt&gt;             &lt;dd class&#x3D;&quot;c-s-dl-li&quot;&gt;               &lt;ul class&#x3D;&quot;clearfix&quot;&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;全部&quot; href&#x3D;&quot;#&quot;&gt;全部&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;数据库&quot; href&#x3D;&quot;#&quot;&gt;数据库&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li class&#x3D;&quot;current&quot;&gt;                   &lt;a title&#x3D;&quot;外语考试&quot; href&#x3D;&quot;#&quot;&gt;外语考试&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;教师资格证&quot; href&#x3D;&quot;#&quot;&gt;教师资格证&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;公务员&quot; href&#x3D;&quot;#&quot;&gt;公务员&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;移动开发&quot; href&#x3D;&quot;#&quot;&gt;移动开发&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;操作系统&quot; href&#x3D;&quot;#&quot;&gt;操作系统&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;             &lt;&#x2F;dd&gt;           &lt;&#x2F;dl&gt;           &lt;dl&gt;             &lt;dt&gt;               &lt;span class&#x3D;&quot;c-999 fsize14&quot;&gt;&lt;&#x2F;span&gt;             &lt;&#x2F;dt&gt;             &lt;dd class&#x3D;&quot;c-s-dl-li&quot;&gt;               &lt;ul class&#x3D;&quot;clearfix&quot;&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;职称英语&quot; href&#x3D;&quot;#&quot;&gt;职称英语&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;英语四级&quot; href&#x3D;&quot;#&quot;&gt;英语四级&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;                 &lt;li&gt;                   &lt;a title&#x3D;&quot;英语六级&quot; href&#x3D;&quot;#&quot;&gt;英语六级&lt;&#x2F;a&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;             &lt;&#x2F;dd&gt;           &lt;&#x2F;dl&gt;           &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;         &lt;div class&#x3D;&quot;js-wrap&quot;&gt;           &lt;section class&#x3D;&quot;fr&quot;&gt;             &lt;span class&#x3D;&quot;c-ccc&quot;&gt;               &lt;i class&#x3D;&quot;c-master f-fM&quot;&gt;1&lt;&#x2F;i&gt;&#x2F;               &lt;i class&#x3D;&quot;c-666 f-fM&quot;&gt;1&lt;&#x2F;i&gt;             &lt;&#x2F;span&gt;           &lt;&#x2F;section&gt;           &lt;section class&#x3D;&quot;fl&quot;&gt;             &lt;ol class&#x3D;&quot;js-tap clearfix&quot;&gt;               &lt;li&gt;                 &lt;a title&#x3D;&quot;关注度&quot; href&#x3D;&quot;#&quot;&gt;关注度&lt;&#x2F;a&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;a title&#x3D;&quot;最新&quot; href&#x3D;&quot;#&quot;&gt;最新&lt;&#x2F;a&gt;               &lt;&#x2F;li&gt;               &lt;li class&#x3D;&quot;current bg-orange&quot;&gt;                 &lt;a title&#x3D;&quot;价格&quot; href&#x3D;&quot;#&quot;&gt;价格&amp;nbsp;                   &lt;span&gt;↓&lt;&#x2F;span&gt;                 &lt;&#x2F;a&gt;               &lt;&#x2F;li&gt;             &lt;&#x2F;ol&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;mt40&quot;&gt;           &lt;!-- &#x2F;无数据提示 开始--&gt;           &lt;section class&#x3D;&quot;no-data-wrap&quot;&gt;             &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;             &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;           &lt;&#x2F;section&gt;           &lt;!-- &#x2F;无数据提示 结束--&gt;           &lt;article class&#x3D;&quot;comm-course-list&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot; id&#x3D;&quot;bna&quot;&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295592705.jpg&quot; class&#x3D;&quot;img-responsive&quot; alt&#x3D;&quot;听力口语&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;听力口语&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;听力口语&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295581911.jpg&quot; class&#x3D;&quot;img-responsive&quot; alt&#x3D;&quot;Java精品课程&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;Java精品课程&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;Java精品课程&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;501人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;501评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295604295.jpg&quot; class&#x3D;&quot;img-responsive&quot; alt&#x3D;&quot;C4D零基础&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;C4D零基础&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;C4D零基础&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;300人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;300评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img                       src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442302831779.jpg&quot;                       class&#x3D;&quot;img-responsive&quot;                       alt&#x3D;&quot;数学给宝宝带来的兴趣&quot;                     &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;数学给宝宝带来的兴趣&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;数学给宝宝带来的兴趣&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;256人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;256评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img                       src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295455437.jpg&quot;                       class&#x3D;&quot;img-responsive&quot;                       alt&#x3D;&quot;零基础入门学习Python课程学习&quot;                     &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a                       href&#x3D;&quot;&#x2F;course&#x2F;1&quot;                       title&#x3D;&quot;零基础入门学习Python课程学习&quot;                       class&#x3D;&quot;course-title fsize18 c-333&quot;                     &gt;零基础入门学习Python课程学习&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;137人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;137评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img                       src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295570359.jpg&quot;                       class&#x3D;&quot;img-responsive&quot;                       alt&#x3D;&quot;MySql从入门到精通&quot;                     &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;MySql从入门到精通&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;MySql从入门到精通&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;125人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;125评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442302852837.jpg&quot; class&#x3D;&quot;img-responsive&quot; alt&#x3D;&quot;搜索引擎优化技术&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;搜索引擎优化技术&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;搜索引擎优化技术&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;123人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;123评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295379715.jpg&quot; class&#x3D;&quot;img-responsive&quot; alt&#x3D;&quot;20世纪西方音乐&quot;&gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;course&#x2F;1&quot; title&#x3D;&quot;20世纪西方音乐&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;20世纪西方音乐&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                   &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                     &lt;span class&#x3D;&quot;fr jgTag bg-green&quot;&gt;                       &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                     &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;34人学习&lt;&#x2F;i&gt;                       |                       &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;34评论&lt;&#x2F;i&gt;                     &lt;&#x2F;span&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;         &lt;&#x2F;div&gt;         &lt;!-- 公共分页 开始 --&gt;         &lt;div&gt;           &lt;div class&#x3D;&quot;paging&quot;&gt;             &lt;a class&#x3D;&quot;undisable&quot; title&gt;首&lt;&#x2F;a&gt;             &lt;a id&#x3D;&quot;backpage&quot; class&#x3D;&quot;undisable&quot; href&#x3D;&quot;#&quot; title&gt;&lt;&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;current undisable&quot;&gt;1&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&gt;2&lt;&#x2F;a&gt;             &lt;a id&#x3D;&quot;nextpage&quot; href&#x3D;&quot;#&quot; title&gt;&gt;&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&gt;末&lt;&#x2F;a&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;         &lt;!-- 公共分页 结束 --&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;课程列表 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;&#125;; &lt;&#x2F;script&gt;</code></pre></div>## 课程详情页面创建 pages/course/_id.vue<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- &#x2F;课程详情 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;section class&#x3D;&quot;path-wrap txtOf hLh30&quot;&gt;         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;首页&lt;&#x2F;a&gt;         \         &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;c-999 fsize14&quot;&gt;课程列表&lt;&#x2F;a&gt;         \         &lt;span class&#x3D;&quot;c-333 fsize14&quot;&gt;Java精品课程&lt;&#x2F;span&gt;       &lt;&#x2F;section&gt;       &lt;div&gt;         &lt;article class&#x3D;&quot;c-v-pic-wrap&quot; style&#x3D;&quot;height: 357px;&quot;&gt;           &lt;section class&#x3D;&quot;p-h-video-box&quot; id&#x3D;&quot;videoPlay&quot;&gt;             &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295581911.jpg&quot; alt&#x3D;&quot;Java精品课程&quot; class&#x3D;&quot;dis c-v-pic&quot;&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;article&gt;         &lt;aside class&#x3D;&quot;c-attr-wrap&quot;&gt;           &lt;section class&#x3D;&quot;ml20 mr15&quot;&gt;             &lt;h2 class&#x3D;&quot;hLh30 txtOf mt15&quot;&gt;               &lt;span class&#x3D;&quot;c-fff fsize24&quot;&gt;Java精品课程&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;             &lt;section class&#x3D;&quot;c-attr-jg&quot;&gt;               &lt;span class&#x3D;&quot;c-fff&quot;&gt;价格：&lt;&#x2F;span&gt;               &lt;b class&#x3D;&quot;c-yellow&quot; style&#x3D;&quot;font-size:24px;&quot;&gt;￥0.00&lt;&#x2F;b&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt c-attr-undis&quot;&gt;               &lt;span class&#x3D;&quot;c-fff fsize14&quot;&gt;主讲： 唐嫣&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt of&quot;&gt;               &lt;span class&#x3D;&quot;ml10 vam&quot;&gt;                 &lt;em class&#x3D;&quot;icon18 scIcon&quot;&gt;&lt;&#x2F;em&gt;                 &lt;a class&#x3D;&quot;c-fff vam&quot; title&#x3D;&quot;收藏&quot; href&#x3D;&quot;#&quot; &gt;收藏&lt;&#x2F;a&gt;               &lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;c-attr-mt&quot;&gt;               &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;立即观看&quot; class&#x3D;&quot;comm-btn c-btn-3&quot;&gt;立即观看&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;aside&gt;         &lt;aside class&#x3D;&quot;thr-attr-box&quot;&gt;           &lt;ol class&#x3D;&quot;thr-attr-ol clearfix&quot;&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;购买数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;150&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;课时数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;20&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;             &lt;li&gt;               &lt;p&gt;&amp;nbsp;&lt;&#x2F;p&gt;               &lt;aside&gt;                 &lt;span class&#x3D;&quot;c-fff f-fM&quot;&gt;浏览数&lt;&#x2F;span&gt;                 &lt;br&gt;                 &lt;h6 class&#x3D;&quot;c-fff f-fM mt10&quot;&gt;501&lt;&#x2F;h6&gt;               &lt;&#x2F;aside&gt;             &lt;&#x2F;li&gt;           &lt;&#x2F;ol&gt;         &lt;&#x2F;aside&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;       &lt;!-- &#x2F;课程封面介绍 --&gt;       &lt;div class&#x3D;&quot;mt20 c-infor-box&quot;&gt;         &lt;article class&#x3D;&quot;fl col-7&quot;&gt;           &lt;section class&#x3D;&quot;mr30&quot;&gt;             &lt;div class&#x3D;&quot;i-box&quot;&gt;               &lt;div&gt;                 &lt;section id&#x3D;&quot;c-i-tabTitle&quot; class&#x3D;&quot;c-infor-tabTitle c-tab-title&quot;&gt;                   &lt;a name&#x3D;&quot;c-i&quot; class&#x3D;&quot;current&quot; title&#x3D;&quot;课程详情&quot;&gt;课程详情&lt;&#x2F;a&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;div&gt;               &lt;article class&#x3D;&quot;ml10 mr10 pt20&quot;&gt;                 &lt;div&gt;                   &lt;h6 class&#x3D;&quot;c-i-content c-infor-title&quot;&gt;                     &lt;span&gt;课程介绍&lt;&#x2F;span&gt;                   &lt;&#x2F;h6&gt;                   &lt;div class&#x3D;&quot;course-txt-body-wrap&quot;&gt;                     &lt;section class&#x3D;&quot;course-txt-body&quot;&gt;                       &lt;p&gt;                         Java的发展历史，可追溯到1990年。当时Sun&amp;nbsp;Microsystem公司为了发展消费性电子产品而进行了一个名为Green的项目计划。该计划                         负责人是James&amp;nbsp;Gosling。起初他以C++来写一种内嵌式软件，可以放在烤面包机或PAD等小型电子消费设备里，使得机器更聪明，具有人工智                         能。但他发现C++并不适合完成这类任务！因为C++常会有使系统失效的程序错误，尤其是内存管理，需要程序设计师记录并管理内存资源。这给设计师们造成                         极大的负担，并可能产生许多bugs。&amp;nbsp;                         &lt;br&gt;为了解决所遇到的问题，Gosling决定要发展一种新的语言，来解决C++的潜在性危险问题，这个语言名叫Oak。Oak是一种可移植性语言，也就是一种平台独立语言，能够在各种芯片上运行。                         &lt;br&gt;1994年，Oak技术日趋成熟，这时网络正开始蓬勃发展。Oak研发小组发现Oak很适合作为一种网络程序语言。因此发展了一个能与Oak配合的浏                         览器--WebRunner，后更名为HotJava，它证明了Oak是一种能在网络上发展的程序语言。由于Oak商标已被注册，工程师们便想到以自己常                         享用的咖啡(Java)来重新命名，并于Sun&amp;nbsp;World&amp;nbsp;95中被发表出来。                       &lt;&#x2F;p&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;div&gt;                 &lt;!-- &#x2F;课程介绍 --&gt;                 &lt;div class&#x3D;&quot;mt50&quot;&gt;                   &lt;h6 class&#x3D;&quot;c-g-content c-infor-title&quot;&gt;                     &lt;span&gt;课程大纲&lt;&#x2F;span&gt;                   &lt;&#x2F;h6&gt;                   &lt;section class&#x3D;&quot;mt20&quot;&gt;                     &lt;div class&#x3D;&quot;lh-menu-wrap&quot;&gt;                       &lt;menu id&#x3D;&quot;lh-menu&quot; class&#x3D;&quot;lh-menu mt10 mr10&quot;&gt;                         &lt;ul&gt;                           &lt;!-- 文件目录 --&gt;                           &lt;li class&#x3D;&quot;lh-menu-stair&quot;&gt;                             &lt;a href&#x3D;&quot;javascript: void(0)&quot; title&#x3D;&quot;第一章&quot; class&#x3D;&quot;current-1&quot;&gt;                               &lt;em class&#x3D;&quot;lh-menu-i-1 icon18 mr10&quot;&gt;&lt;&#x2F;em&gt;第一章                             &lt;&#x2F;a&gt;                             &lt;ol class&#x3D;&quot;lh-menu-ol&quot; style&#x3D;&quot;display: block;&quot;&gt;                               &lt;li class&#x3D;&quot;lh-menu-second ml30&quot;&gt;                                 &lt;a href&#x3D;&quot;#&quot; title&gt;                                   &lt;span class&#x3D;&quot;fr&quot;&gt;                                     &lt;i class&#x3D;&quot;free-icon vam mr10&quot;&gt;免费试听&lt;&#x2F;i&gt;                                   &lt;&#x2F;span&gt;                                   &lt;em class&#x3D;&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;第一节                                 &lt;&#x2F;a&gt;                               &lt;&#x2F;li&gt;                               &lt;li class&#x3D;&quot;lh-menu-second ml30&quot;&gt;                                 &lt;a href&#x3D;&quot;#&quot; title class&#x3D;&quot;current-2&quot;&gt;                                   &lt;em class&#x3D;&quot;lh-menu-i-2 icon16 mr5&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;第二节                                 &lt;&#x2F;a&gt;                               &lt;&#x2F;li&gt;                             &lt;&#x2F;ol&gt;                           &lt;&#x2F;li&gt;                         &lt;&#x2F;ul&gt;                       &lt;&#x2F;menu&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                 &lt;&#x2F;div&gt;                 &lt;!-- &#x2F;课程大纲 --&gt;               &lt;&#x2F;article&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;article&gt;         &lt;aside class&#x3D;&quot;fl col-3&quot;&gt;           &lt;div class&#x3D;&quot;i-box&quot;&gt;             &lt;div&gt;               &lt;section class&#x3D;&quot;c-infor-tabTitle c-tab-title&quot;&gt;                 &lt;a title href&#x3D;&quot;javascript:void(0)&quot;&gt;主讲讲师&lt;&#x2F;a&gt;               &lt;&#x2F;section&gt;               &lt;section class&#x3D;&quot;stud-act-list&quot;&gt;                 &lt;ul style&#x3D;&quot;height: auto;&quot;&gt;                   &lt;li&gt;                     &lt;div class&#x3D;&quot;u-face&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot;&gt;                         &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297969808.jpg&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; alt&gt;                       &lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                     &lt;section class&#x3D;&quot;hLh30 txtOf&quot;&gt;                       &lt;a class&#x3D;&quot;c-333 fsize16 fl&quot; href&#x3D;&quot;#&quot;&gt;周杰伦&lt;&#x2F;a&gt;                     &lt;&#x2F;section&gt;                     &lt;section class&#x3D;&quot;hLh20 txtOf&quot;&gt;                       &lt;span class&#x3D;&quot;c-999&quot;&gt;毕业于北京大学数学系&lt;&#x2F;span&gt;                     &lt;&#x2F;section&gt;                   &lt;&#x2F;li&gt;                 &lt;&#x2F;ul&gt;               &lt;&#x2F;section&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;aside&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;课程详情 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;&#125;; &lt;&#x2F;script&gt; </code></pre></div>## 名师列表页面创建 pages/teacher/index.vue<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- 讲师列表 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;header class&#x3D;&quot;comm-title all-teacher-title&quot;&gt;         &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;           &lt;span class&#x3D;&quot;c-333&quot;&gt;全部讲师&lt;&#x2F;span&gt;         &lt;&#x2F;h2&gt;         &lt;section class&#x3D;&quot;c-tab-title&quot;&gt;           &lt;a id&#x3D;&quot;subjectAll&quot; title&#x3D;&quot;全部&quot; href&#x3D;&quot;#&quot;&gt;全部&lt;&#x2F;a&gt;           &lt;!-- &lt;c:forEach var&#x3D;&quot;subject&quot; items&#x3D;&quot;$&#123;subjectList &#125;&quot;&gt;                             &lt;a id&#x3D;&quot;$&#123;subject.subjectId&#125;&quot; title&#x3D;&quot;$&#123;subject.subjectName &#125;&quot; href&#x3D;&quot;javascript:void(0)&quot; onclick&#x3D;&quot;submitForm($&#123;subject.subjectId&#125;)&quot;&gt;$&#123;subject.subjectName &#125;&lt;&#x2F;a&gt;           &lt;&#x2F;c:forEach&gt;--&gt;         &lt;&#x2F;section&gt;       &lt;&#x2F;header&gt;       &lt;section class&#x3D;&quot;c-sort-box unBr&quot;&gt;         &lt;div&gt;           &lt;!-- &#x2F;无数据提示 开始--&gt;           &lt;section class&#x3D;&quot;no-data-wrap&quot;&gt;             &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;             &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;           &lt;&#x2F;section&gt;           &lt;!-- &#x2F;无数据提示 结束--&gt;           &lt;article class&#x3D;&quot;i-teacher-list&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot;&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;姚晨&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297885942.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;姚晨&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;姚晨&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;北京师范大学法学院副教授、清华大学法学博士。自2004年至今已有9年的司法考试培训经验。长期从事司法考试辅导，深知命题规律，了解解题技巧。内容把握准确，授课重点明确，层次分明，调理清晰，将法条法理与案例有机融合，强调综合，深入浅出。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;北京师范大学法学院副教授&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;谢娜&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297919077.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;谢娜&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;谢娜&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;十年课程研发和培训咨询经验，曾任国企人力资源经理、大型外企培训经理，负责企业大学和培训体系搭建；曾任专业培训机构高级顾问、研发部总监，为包括广东移动、东莞移动、深圳移动、南方电网、工商银行、农业银行、民生银行、邮储银行、TCL集团、清华大学继续教育学院、中天路桥、广西扬翔股份等超过200家企业提供过培训与咨询服务，并担任近50个大型项目的总负责人。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;资深课程设计专家，专注10年AACTP美国培训协会认证导师&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;刘德华&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297927029.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;刘德华&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;刘德华&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;上海师范大学法学院副教授、清华大学法学博士。自2004年至今已有9年的司法考试培训经验。长期从事司法考试辅导，深知命题规律，了解解题技巧。内容把握准确，授课重点明确，层次分明，调理清晰，将法条法理与案例有机融合，强调综合，深入浅出。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;上海师范大学法学院副教授&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周润发&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297935589.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周润发&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;周润发&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;法学博士，北京师范大学马克思主义学院副教授，专攻毛泽东思想概论、邓小平理论，长期从事考研辅导。出版著作两部，发表学术论文30余篇，主持国家社会科学基金项目和教育部重大课题子课题各一项，参与中央实施马克思主义理论研究和建设工程项目。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;考研政治辅导实战派专家，全国考研政治命题研究组核心成员。&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;钟汉良&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442298121626.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;钟汉良&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;钟汉良&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;具备深厚的数学思维功底、丰富的小学教育经验，授课风格生动活泼，擅长用形象生动的比喻帮助理解、简单易懂的语言讲解难题，深受学生喜欢&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;唐嫣&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297957332.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;唐嫣&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;唐嫣&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;中国科学院数学与系统科学研究院应用数学专业博士，研究方向为数字图像处理，中国工业与应用数学学会会员。参与全国教育科学“十五”规划重点课题“信息化进程中的教育技术发展研究”的子课题“基与课程改革的资源开发与应用”，以及全国“十五”科研规划全国重点项目“掌上型信息技术产品在教学中的运用和开发研究”的子课题“用技术学数学”。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;中国人民大学附属中学数学一级教师&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周杰伦&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297969808.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;周杰伦&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;周杰伦&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;中教一级职称。讲课极具亲和力。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;毕业于北京大学数学系&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                   &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;陈伟霆&quot; target&#x3D;&quot;_blank&quot;&gt;                       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297977255.jpg&quot; alt&gt;                     &lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                     &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;陈伟霆&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;陈伟霆&lt;&#x2F;a&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                     &lt;span                       class&#x3D;&quot;fsize14 c-999&quot;                     &gt;政治学博士、管理学博士后，北京师范大学马克思主义学院副教授。多年来总结出了一套行之有效的应试技巧与答题方法，针对性和实用性极强，能帮助考生在轻松中应考，在激励的竞争中取得高分，脱颖而出。&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                     &lt;p class&#x3D;&quot;c-999 f-fA&quot;&gt;长期从事考研政治课讲授和考研命题趋势与应试对策研究。考研辅导新锐派的代表。&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;section&gt;               &lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;         &lt;&#x2F;div&gt;         &lt;!-- 公共分页 开始 --&gt;         &lt;div&gt;           &lt;div class&#x3D;&quot;paging&quot;&gt;             &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;首页&quot;&gt;首&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;前一页&quot;&gt;&lt;&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;第1页&quot; class&#x3D;&quot;current undisable&quot;&gt;1&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;第2页&quot;&gt;2&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;后一页&quot;&gt;&gt;&lt;&#x2F;a&gt;             &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;末页&quot;&gt;末&lt;&#x2F;a&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;         &lt;!-- 公共分页 结束 --&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;讲师列表 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;&#125;; &lt;&#x2F;script&gt;</code></pre></div>## 名师详情页面创建 pages/teacher/_id.vue修改资源路径为~/assets/<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div id&#x3D;&quot;aCoursesList&quot; class&#x3D;&quot;bg-fa of&quot;&gt;     &lt;!-- 讲师介绍 开始 --&gt;     &lt;section class&#x3D;&quot;container&quot;&gt;       &lt;header class&#x3D;&quot;comm-title&quot;&gt;         &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;           &lt;span class&#x3D;&quot;c-333&quot;&gt;讲师介绍&lt;&#x2F;span&gt;         &lt;&#x2F;h2&gt;       &lt;&#x2F;header&gt;       &lt;div class&#x3D;&quot;t-infor-wrap&quot;&gt;         &lt;!-- 讲师基本信息 --&gt;         &lt;section class&#x3D;&quot;fl t-infor-box c-desc-content&quot;&gt;           &lt;div class&#x3D;&quot;mt20 ml20&quot;&gt;             &lt;section class&#x3D;&quot;t-infor-pic&quot;&gt;               &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;teacher&#x2F;1442297885942.jpg&quot;&gt;             &lt;&#x2F;section&gt;             &lt;h3 class&#x3D;&quot;hLh30&quot;&gt;               &lt;span class&#x3D;&quot;fsize24 c-333&quot;&gt;姚晨&amp;nbsp;高级讲师&lt;&#x2F;span&gt;             &lt;&#x2F;h3&gt;             &lt;section class&#x3D;&quot;mt10&quot;&gt;               &lt;span class&#x3D;&quot;t-tag-bg&quot;&gt;北京师范大学法学院副教授&lt;&#x2F;span&gt;             &lt;&#x2F;section&gt;             &lt;section class&#x3D;&quot;t-infor-txt&quot;&gt;               &lt;p                 class&#x3D;&quot;mt20&quot;               &gt;北京师范大学法学院副教授、清华大学法学博士。自2004年至今已有9年的司法考试培训经验。长期从事司法考试辅导，深知命题规律，了解解题技巧。内容把握准确，授课重点明确，层次分明，调理清晰，将法条法理与案例有机融合，强调综合，深入浅出。&lt;&#x2F;p&gt;             &lt;&#x2F;section&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;section&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;       &lt;section class&#x3D;&quot;mt30&quot;&gt;         &lt;div&gt;           &lt;header class&#x3D;&quot;comm-title all-teacher-title c-course-content&quot;&gt;             &lt;h2 class&#x3D;&quot;fl tac&quot;&gt;               &lt;span class&#x3D;&quot;c-333&quot;&gt;主讲课程&lt;&#x2F;span&gt;             &lt;&#x2F;h2&gt;             &lt;section class&#x3D;&quot;c-tab-title&quot;&gt;               &lt;a href&#x3D;&quot;javascript: void(0)&quot;&gt;&amp;nbsp;&lt;&#x2F;a&gt;             &lt;&#x2F;section&gt;           &lt;&#x2F;header&gt;           &lt;!-- &#x2F;无数据提示 开始--&gt;           &lt;section class&#x3D;&quot;no-data-wrap&quot;&gt;             &lt;em class&#x3D;&quot;icon30 no-data-ico&quot;&gt;&amp;nbsp;&lt;&#x2F;em&gt;             &lt;span class&#x3D;&quot;c-666 fsize14 ml10 vam&quot;&gt;没有相关数据，小编正在努力整理中...&lt;&#x2F;span&gt;           &lt;&#x2F;section&gt;           &lt;!-- &#x2F;无数据提示 结束--&gt;           &lt;article class&#x3D;&quot;comm-course-list&quot;&gt;             &lt;ul class&#x3D;&quot;of&quot;&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295455437.jpg&quot; class&#x3D;&quot;img-responsive&quot; &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;零基础入门学习Python课程学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;零基础入门学习Python课程学习&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295472860.jpg&quot; class&#x3D;&quot;img-responsive&quot; &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;影想力摄影小课堂&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;影想力摄影小课堂&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442302831779.jpg&quot; class&#x3D;&quot;img-responsive&quot; &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;数学给宝宝带来的兴趣&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;数学给宝宝带来的兴趣&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;               &lt;li&gt;                 &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                   &lt;section class&#x3D;&quot;course-img&quot;&gt;                     &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;photo&#x2F;course&#x2F;1442295506745.jpg&quot; class&#x3D;&quot;img-responsive&quot; &gt;                     &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                       &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                     &lt;&#x2F;div&gt;                   &lt;&#x2F;section&gt;                   &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                     &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;国家教师资格考试专用&quot; target&#x3D;&quot;_blank&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;国家教师资格考试专用&lt;&#x2F;a&gt;                   &lt;&#x2F;h3&gt;                 &lt;&#x2F;div&gt;               &lt;&#x2F;li&gt;             &lt;&#x2F;ul&gt;             &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;           &lt;&#x2F;article&gt;         &lt;&#x2F;div&gt;       &lt;&#x2F;section&gt;     &lt;&#x2F;section&gt;     &lt;!-- &#x2F;讲师介绍 结束 --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;&#125;; &lt;&#x2F;script&gt;</code></pre></div># 首页数据显示-banner接口## 在service模块下创建子模块service-cms### 使用代码生成器生成banner代码（1）创建crm_banner表（2）生成代码 ### 配置application.properties<div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8004# 服务名spring.application.name&#x3D;service-cms# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;educms&#x2F;mapper&#x2F;xml&#x2F;*.xml#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div>### 创建启动类<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ComponentScan(basePackages &#x3D; &#123;&quot;com.atguigu&quot;&#125;)  &#x2F;&#x2F; 指定扫描位置@MapperScan(&quot;com.atguigu.educms.mapper&quot;)public class CmsApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(CmsApplication.class,args);    &#125;&#125;</code></pre></div>## 创建banner服务接口### 1、创建banner后台管理接口**banner****后台分页查询、添加、修改、删除接口**<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;educms&#x2F;banneradmin&quot;)@CrossOriginpublic class BannerAdminController &#123;    @Autowired    private CrmBannerService crmBannerService;    &#x2F;&#x2F; 获取分页列表    @GetMapping(&quot;pageBanner&#x2F;&#123;page&#125;&#x2F;&#123;limit&#125;&quot;)    public R pageBanner(@PathVariable long page,@PathVariable long limit)&#123;        Page&lt;CrmBanner&gt; bannerPage &#x3D; new Page&lt;&gt;(page, limit);        crmBannerService.page(bannerPage, null);        return R.ok().data(&quot;list&quot;,bannerPage.getRecords()).data(&quot;total&quot;,bannerPage.getTotal());    &#125;    &#x2F;&#x2F; 根据id查询banner    @GetMapping(&quot;getBannerById&#x2F;&#123;id&#125;&quot;)    public R getBannerById(@PathVariable String id)&#123;        CrmBanner banner &#x3D; crmBannerService.getById(id);        return R.ok().data(&quot;banner&quot;,banner);    &#125;    &#x2F;&#x2F; 添加banner    @PostMapping(&quot;addBanner&quot;)    public R addBanner(@RequestBody CrmBanner banner)&#123;        crmBannerService.save(banner);        return R.ok();    &#125;    &#x2F;&#x2F; 修改    @PostMapping(&quot;updateBanner&quot;)    public R updateBanner(@RequestBody CrmBanner banner)&#123;        crmBannerService.updateById(banner);        return R.ok();    &#125;    &#x2F;&#x2F; 删除    @DeleteMapping(&quot;deleteBanner&#x2F;&#123;id&#125;&quot;)    public R deleteBanner(@PathVariable String id)&#123;        crmBannerService.removeById(id);        return R.ok();    &#125;&#125;</code></pre></div>### 创建banner前台查询接口**首页获取banner数据接口**<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;educms&#x2F; bannerfront&quot;)@CrossOriginpublic class BannerFrontController &#123;    @Autowired    private CrmBannerService crmBannerService;    &#x2F;&#x2F; 显示所有banner    @GetMapping(&quot;getAllBanner&quot;)    public R getAllBanner()&#123;        List&lt;CrmBanner&gt; list &#x3D; crmBannerService.list(null);        return R.ok().data(&quot;list&quot;,list);    &#125;&#125;</code></pre></div>修改前台banner查询所有的方法<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;educms&#x2F;bannerfront&quot;)@CrossOriginpublic class BannerFrontController &#123;    @Autowired    private CrmBannerService crmBannerService;    &#x2F;&#x2F; 显示所有banner    @GetMapping(&quot;getAllBanner&quot;)    public R getAllBanner()&#123;        List&lt;CrmBanner&gt; list &#x3D; crmBannerService.selectAllBanner();        return R.ok().data(&quot;list&quot;,list);    &#125;&#125;</code></pre></div>Impl<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123;    &#x2F;&#x2F; 显示所有banner    @Override    public List&lt;CrmBanner&gt; selectAllBanner() &#123;        &#x2F;&#x2F; 根据id降序，查询前2两条记录        QueryWrapper&lt;CrmBanner&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.orderByDesc(&quot;id&quot;);        wrapper.last(&quot;limit 2&quot;);        List&lt;CrmBanner&gt; list &#x3D; baseMapper.selectList(wrapper);        return list;    &#125;&#125;</code></pre></div># 首页数据显示-热门课程和名师接口为了调用方便，直接在eduservice中写com.atguigu.eduservice.controller.front;<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;eduservice&#x2F;index&quot;)@CrossOriginpublic class IndexController &#123;    @Autowired    private EduTeacherService teacherService;    @Autowired    private EduCourseService courseService;    &#x2F;&#x2F; 根据id降序查询出前8个热门课程，前4个名师    @GetMapping(&quot;index&quot;)    public R index()&#123;        &#x2F;&#x2F; 课程        QueryWrapper&lt;EduCourse&gt; CourseWrapper &#x3D; new QueryWrapper&lt;&gt;();        CourseWrapper.orderByDesc(&quot;id&quot;);        CourseWrapper.last(&quot;limit 8&quot;);        List&lt;EduCourse&gt; courseList &#x3D; courseService.list(CourseWrapper);        &#x2F;&#x2F; 名师        QueryWrapper&lt;EduTeacher&gt; teacherWrapper &#x3D; new QueryWrapper&lt;&gt;();        teacherWrapper.orderByDesc(&quot;id&quot;);        teacherWrapper.last(&quot;limit 4&quot;);        List&lt;EduTeacher&gt; teacherList &#x3D; teacherService.list(teacherWrapper);        return R.ok().data(&quot;courseList&quot;,courseList).data(&quot;teacherList&quot;,teacherList);    &#125;&#125;</code></pre></div># 首页数据显示-banner显示前端## 封装axios我们可以参考guli-admin将axios操作封装起来下载axios ，使用命令 **npm install axios**创建utils文件夹，utils下创建request.js<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import axios from &#39;axios&#39;&#x2F;&#x2F; 创建axios实例const service &#x3D; axios.create(&#123;  baseURL: &#39;http:&#x2F;&#x2F;localhost:9001&#39;, &#x2F;&#x2F; api的base_url  timeout: 20000 &#x2F;&#x2F; 请求超时时间&#125;)export default service</code></pre></div>## 首页banner数据显示### 创建api文件夹，创建banner.js文件**banner.js**<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;    &#x2F;&#x2F; 查询前两条banner，幻灯片  getListBanner() &#123;    return request(&#123;      url: &#96;&#x2F;educms&#x2F;bannerfront&#x2F;getAllBanner&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div>### 在首页面引入，调用实现<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;import banner from &quot;@&#x2F;api&#x2F;banner&quot; export default &#123;   data () &#123;     return &#123;       swiperOption: &#123;         &#x2F;&#x2F;配置分页         pagination: &#123;           el: &#39;.swiper-pagination&#39;&#x2F;&#x2F;分页的dom节点         &#125;,         &#x2F;&#x2F;配置导航         navigation: &#123;           nextEl: &#39;.swiper-button-next&#39;,&#x2F;&#x2F;下一页dom节点           prevEl: &#39;.swiper-button-prev&#39;&#x2F;&#x2F;前一页dom节点         &#125;       &#125;,       &#x2F;&#x2F; 定义banner数组        bannerList: &#123;&#125;     &#125;   &#125;,   created()&#123;     this.getAllBanner()   &#125;,   methods:&#123;     getAllBanner()&#123;       banner.getListBanner()        .then(response &#x3D;&gt;&#123;          this.bannerList &#x3D; response.data.data.list        &#125;)     &#125;   &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div>### 在页面遍历显示banner<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 幻灯片 开始 --&gt;&lt;div v-swiper:mySwiper&#x3D;&quot;swiperOption&quot;&gt;    &lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt;        &lt;div v-for&#x3D;&quot;banner in bannerList&quot; :key&#x3D;&quot;banner.id&quot; class&#x3D;&quot;swiper-slide&quot; style&#x3D;&quot;background: #040B1B;&quot;&gt;            &lt;a target&#x3D;&quot;_blank&quot; :href&#x3D;&quot;banner.linkUrl&quot;&gt;                &lt;img :src&#x3D;&quot;banner.imageUrl&quot; :alt&#x3D;&quot;banner.title&quot;&gt;            &lt;&#x2F;a&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;swiper-pagination swiper-pagination-white&quot;&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;swiper-button-prev swiper-button-white&quot; slot&#x3D;&quot;button-prev&quot;&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;swiper-button-next swiper-button-white&quot; slot&#x3D;&quot;button-next&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;!-- 幻灯片 结束 --&gt;</code></pre></div># 首页数据显示-热门课程和名师列表前端Api/index.js<div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;    &#x2F;&#x2F; 首页数据  getIndexdata() &#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;indexfront&#x2F;index&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div>Pages/index.vue导入依赖<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import index from &#39;@&#x2F;api&#x2F;index&#39;</code></pre></div>初始化数组<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">teacherList:[], courseList:[]</code></pre></div>调用方法<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;  &#x2F;&#x2F; 得到首页数据  getIndexDate()&#123;    index.getIndexdata()     .then(response &#x3D;&gt;&#123;       this.courseList &#x3D; response.data.data.courseList       this.teacherList &#x3D; response.data.data.teacherList     &#125;)  &#125;,</code></pre></div>Templates，遍历和名师<div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 网校课程 开始 --&gt;      &lt;div&gt;        &lt;section class&#x3D;&quot;container&quot;&gt;          &lt;header class&#x3D;&quot;comm-title&quot;&gt;            &lt;h2 class&#x3D;&quot;tac&quot;&gt;              &lt;span class&#x3D;&quot;c-333&quot;&gt;热门课程&lt;&#x2F;span&gt;            &lt;&#x2F;h2&gt;          &lt;&#x2F;header&gt;          &lt;div&gt;            &lt;article class&#x3D;&quot;comm-course-list&quot;&gt;              &lt;ul class&#x3D;&quot;of&quot; id&#x3D;&quot;bna&quot;&gt;                &lt;li v-for&#x3D;&quot;course in courseList&quot; :key&#x3D;&quot;course.id&quot;&gt;                  &lt;div class&#x3D;&quot;cc-l-wrap&quot;&gt;                    &lt;section class&#x3D;&quot;course-img&quot;&gt;                      &lt;img                        :src&#x3D;&quot;course.cover&quot;                        class&#x3D;&quot;img-responsive&quot;                        :alt&#x3D;&quot;course.title&quot;                      &gt;                      &lt;div class&#x3D;&quot;cc-mask&quot;&gt;                        &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;开始学习&quot; class&#x3D;&quot;comm-btn c-btn-1&quot;&gt;开始学习&lt;&#x2F;a&gt;                      &lt;&#x2F;div&gt;                    &lt;&#x2F;section&gt;                    &lt;h3 class&#x3D;&quot;hLh30 txtOf mt10&quot;&gt;                      &lt;a href&#x3D;&quot;#&quot; :title&#x3D;&quot;course.title&quot; class&#x3D;&quot;course-title fsize18 c-333&quot;&gt;&#123;&#123;course.title&#125;&#125;&lt;&#x2F;a&gt;                    &lt;&#x2F;h3&gt;                    &lt;section class&#x3D;&quot;mt10 hLh20 of&quot;&gt;                      &lt;span class&#x3D;&quot;fr jgTag bg-green&quot; :v-if&#x3D;&quot;Number(course.price &#x3D;&#x3D;&#x3D; 0)&quot;&gt;                        &lt;i class&#x3D;&quot;c-fff fsize12 f-fA&quot;&gt;免费&lt;&#x2F;i&gt;                      &lt;&#x2F;span&gt;                      &lt;span class&#x3D;&quot;fl jgAttr c-ccc f-fA&quot;&gt;                        &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634人学习&lt;&#x2F;i&gt;                        |                        &lt;i class&#x3D;&quot;c-999 f-fA&quot;&gt;9634评论&lt;&#x2F;i&gt;                      &lt;&#x2F;span&gt;                    &lt;&#x2F;section&gt;                  &lt;&#x2F;div&gt;                &lt;&#x2F;li&gt;                              &lt;&#x2F;ul&gt;              &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;            &lt;&#x2F;article&gt;            &lt;section class&#x3D;&quot;tac pt20&quot;&gt;              &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;全部课程&quot; class&#x3D;&quot;comm-btn c-btn-2&quot;&gt;全部课程&lt;&#x2F;a&gt;            &lt;&#x2F;section&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;section&gt;      &lt;&#x2F;div&gt;      &lt;!-- &#x2F;网校课程 结束 --&gt;      &lt;!-- 网校名师 开始 --&gt;      &lt;div&gt;        &lt;section class&#x3D;&quot;container&quot;&gt;          &lt;header class&#x3D;&quot;comm-title&quot;&gt;            &lt;h2 class&#x3D;&quot;tac&quot;&gt;              &lt;span class&#x3D;&quot;c-333&quot;&gt;名师大咖&lt;&#x2F;span&gt;            &lt;&#x2F;h2&gt;          &lt;&#x2F;header&gt;          &lt;div&gt;            &lt;article class&#x3D;&quot;i-teacher-list&quot;&gt;              &lt;ul class&#x3D;&quot;of&quot;&gt;                &lt;li v-for&#x3D;&quot;teacher in teacherList&quot; :key&#x3D;&quot;teacher.id&quot;&gt;                  &lt;section class&#x3D;&quot;i-teach-wrap&quot;&gt;                    &lt;div class&#x3D;&quot;i-teach-pic&quot;&gt;                      &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; :title&#x3D;&quot;teacher.name&quot;&gt;                        &lt;img :alt&#x3D;&quot;teacher.name&quot; :src&#x3D;&quot;teacher.avatar&quot;&gt;                      &lt;&#x2F;a&gt;                    &lt;&#x2F;div&gt;                    &lt;div class&#x3D;&quot;mt10 hLh30 txtOf tac&quot;&gt;                      &lt;a href&#x3D;&quot;&#x2F;teacher&#x2F;1&quot; title&#x3D;&quot;teacher.name&quot; class&#x3D;&quot;fsize18 c-666&quot;&gt;&#123;&#123;teacher.name&#125;&#125;&lt;&#x2F;a&gt;                    &lt;&#x2F;div&gt;                    &lt;div class&#x3D;&quot;hLh30 txtOf tac&quot;&gt;                      &lt;span class&#x3D;&quot;fsize14 c-999&quot;&gt;&#123;&#123;teacher.level&#125;&#125;&lt;&#x2F;span&gt;                    &lt;&#x2F;div&gt;                    &lt;div class&#x3D;&quot;mt15 i-q-txt&quot;&gt;                      &lt;p                        class&#x3D;&quot;c-999 f-fA&quot;                      &gt;&#123;&#123;teacher.intro&#125;&#125;&lt;&#x2F;p&gt;                    &lt;&#x2F;div&gt;                  &lt;&#x2F;section&gt;                &lt;&#x2F;li&gt;                              &lt;&#x2F;ul&gt;              &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;            &lt;&#x2F;article&gt;            &lt;section class&#x3D;&quot;tac pt20&quot;&gt;              &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;全部讲师&quot; class&#x3D;&quot;comm-btn c-btn-2&quot;&gt;全部讲师&lt;&#x2F;a&gt;            &lt;&#x2F;section&gt;          &lt;&#x2F;div&gt;        &lt;&#x2F;section&gt;      &lt;&#x2F;div&gt;      &lt;!-- &#x2F;网校名师 结束 --&gt;</code></pre></div># 首页数据显示-redis回顾![image-20220106235934903](day11-首页数据显示/image-20220106235934903.png)# 首页数据显示-添加redis缓存## 在common模块添加依赖由于redis缓存是公共应用，所以我们把依赖与配置添加到了common模块下面，在common模块pom.xml下添加以下依赖<div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!-- spring2.X集成redis所需common-pool2--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.6.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency</code></pre></div>## 在service-base模块添加redis配置类<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableCaching  &#x2F;&#x2F; 开启缓存@Configuration  &#x2F;&#x2F; 配置类public class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om &#x3D; new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        template.setConnectionFactory(factory);        &#x2F;&#x2F;key序列化方式        template.setKeySerializer(redisSerializer);        &#x2F;&#x2F;value序列化        template.setValueSerializer(jackson2JsonRedisSerializer);        &#x2F;&#x2F;value hashmap序列化        template.setHashValueSerializer(jackson2JsonRedisSerializer);        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);        &#x2F;&#x2F;解决查询缓存转换异常的问题        ObjectMapper om &#x3D; new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        &#x2F;&#x2F; 配置序列化（解决乱码的问题）,过期时间600秒        RedisCacheConfiguration config &#x3D; RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofSeconds(600))                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))                .disableCachingNullValues();        RedisCacheManager cacheManager &#x3D; RedisCacheManager.builder(factory)                .cacheDefaults(config)                .build();        return cacheManager;    &#125;&#125;</code></pre></div>## 在接口中添加redis缓存由于首页数据变化不是很频繁，而且首页访问量相对较大，所以我们有必要把首页接口数据缓存到redis缓存中，减少数据库压力和提高访问速度。改造service-cms模块首页banner接口，首页课程与讲师接口类似**Spring Boot****缓存注解**### （1）缓存@Cacheable根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。查看源码，属性值如下：| **属性/****方法名** | **解释**                                         || ------------------- | ------------------------------------------------ || value               | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 || cacheNames          | 与 value 差不多，二选一即可                      || key                 | 可选属性，可以使用 SpEL 标签自定义缓存的key      |### （2）缓存@CachePut使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。查看源码，属性值如下：| **属性/****方法名** | **解释**                                         || ------------------- | ------------------------------------------------ || value               | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 || cacheNames          | 与 value 差不多，二选一即可                      || key                 | 可选属性，可以使用 SpEL 标签自定义缓存的key      |### （3）缓存@CacheEvict使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上查看源码，属性值如下：| **属性/****方法名** | **解释**                                                     || ------------------- | ------------------------------------------------------------ || value               | 缓存名，必填，它指定了你的缓存存放在哪块命名空间             || cacheNames          | 与 value 差不多，二选一即可                                  || key                 | 可选属性，可以使用 SpEL 标签自定义缓存的key                  || allEntries          | 是否清空所有缓存，默认为 false。如果指定为 true，则方法调用后将立即清空所有的缓存 || beforeInvocation    | 是否在方法执行前就清空，默认为 false。如果指定为 true，则在方法执行前就会清空缓存 | 添加@Cacheable注解在查询banner的方法上<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class CrmBannerServiceImpl extends ServiceImpl&lt;CrmBannerMapper, CrmBanner&gt; implements CrmBannerService &#123;    &#x2F;&#x2F; 显示所有banner    @Cacheable(value &#x3D; &quot;banner&quot;,key &#x3D; &quot;&#39;selectIndexList&#39;&quot;)    @Override    public List&lt;CrmBanner&gt; selectAllBanner() &#123;        &#x2F;&#x2F; 根据id降序，查询前2两条记录        QueryWrapper&lt;CrmBanner&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.orderByDesc(&quot;id&quot;);        wrapper.last(&quot;limit 2&quot;);        List&lt;CrmBanner&gt; list &#x3D; baseMapper.selectList(wrapper);        return list;    &#125;&#125;</code></pre></div>## 启动redis服务### 连接redis服务可能遇到的问题连接redis服务可能遇到的问题（1）关闭liunx防火墙service firewalld stop（2）找到redis配置文件， 注释一行配置![img](day11-首页数据显示/clip_image001.png)（3）如果出现下面错误提示![image-20220107000054865](day11-首页数据显示/image-20220107000054865.png)修改 protected-mode yes改为protected-mode no### banner接口改造**在service-cms模块配置文件添加redis配置**<div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.redis.host&#x3D;192.168.242.3spring.redis.port&#x3D;6379spring.redis.password&#x3D;123456spring.redis.database&#x3D; 0spring.redis.timeout&#x3D;1800000spring.redis.lettuce.pool.max-active&#x3D;20spring.redis.lettuce.pool.max-wait&#x3D;-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle&#x3D;5spring.redis.lettuce.pool.min-idle&#x3D;0</code></pre></div>启动测试，在redis中添加了key![image-20220107000133155](day11-首页数据显示/image-20220107000133155.png)**通过源码查看到key生成的规则**<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package org.springframework.data.redis.cache;@FunctionalInterfacepublic interface CacheKeyPrefix &#123;    String compute(String var1);    static CacheKeyPrefix simple() &#123;        return (name) -&gt; &#123;            return name + &quot;::&quot;;        &#125;;    &#125;&#125;</code></pre></div></nuxt>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day-10-课程管理</title>
    <link href="/myBlog/day10-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/myBlog/day10-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h1><h1 id="课程管理-删除视屏接口"><a href="#课程管理-删除视屏接口" class="headerlink" title="课程管理-删除视屏接口"></a>课程管理-删除视屏接口</h1><p>创建InitVodUtils工具类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class InitVodClient &#123;    public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123;        String regionId &#x3D; &quot;cn-shanghai&quot;;  &#x2F;&#x2F; 点播服务接入区域        DefaultProfile profile &#x3D; DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);        DefaultAcsClient client &#x3D; new DefaultAcsClient(profile);        return client;    &#125;&#125;</code></pre></div><p>在VodController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除阿里云的视频@DeleteMapping(&quot;deleteAlyVideo&#x2F;&#123;id&#125;&quot;)public R deleteAlyVideo(@PathVariable String id)&#123;    try &#123;        &#x2F;&#x2F; 初始化对象        DefaultAcsClient client &#x3D; InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET);        &#x2F;&#x2F; 创建删除的request请求        DeleteVideoRequest request &#x3D; new DeleteVideoRequest();        &#x2F;&#x2F; 设置视频id        request.setVideoIds(id);        &#x2F;&#x2F; 调用初始化方法进行删除        client.getAcsResponse(request);        return R.ok();    &#125; catch (ClientException e) &#123;        e.printStackTrace();        throw new GuliException(20001,&quot;删除视频失败&quot;);    &#125;&#125;</code></pre></div><h1 id="课程管理-删除视屏前端"><a href="#课程管理-删除视屏前端" class="headerlink" title="课程管理-删除视屏前端"></a>课程管理-删除视屏前端</h1><p>Api</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 删除小节视频 deleteAlyVideo(id)&#123;     return request(&#123;         url: &#96;&#x2F;eduvod&#x2F;video&#x2F;deleteAlyVideo&#x2F;$&#123;id&#125;&#96;,         method: &#39;delete&#39;       &#125;) &#125;</code></pre></div><p>Video.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;     &#x2F;&#x2F; 点击确认的时候删除     handleVodRemove()&#123;        video.deleteAlyVideo(this.video.videoSourceId)          .then(response &#x3D;&gt;&#123;             &#x2F;&#x2F; 提示信息              this.$message(&#123;                  type: &#39;success&#39;,                  message: &#39;删除视频成功!&#39;              &#125;);              fileList: []  &#x2F;&#x2F; 清空上传列表              this.video.videoSourceId &#x3D; &#39;&#39;              this.video.videoOriginalName &#x3D; &#39;&#39;          &#125;)     &#125;,     &#x2F;&#x2F; 点击x的时候弹框     beforeVodRemove(file, fileList)&#123;      return this.$confirm(&#96;确定移除 $&#123; file.name &#125;？&#96;);     &#125;,</code></pre></div><h1 id="技术点-微服务SpringCloud"><a href="#技术点-微服务SpringCloud" class="headerlink" title="技术点-微服务SpringCloud"></a>技术点-微服务SpringCloud</h1><h2 id="SpringCloud和SpringBoot的关系："><a href="#SpringCloud和SpringBoot的关系：" class="headerlink" title="SpringCloud和SpringBoot的关系："></a>SpringCloud和SpringBoot的关系：</h2><p>SpringBoot是Spring的一套快速配置脚手架，可以基于SpringBoot快速开发单个微服务。SpringCloud是一系列框架的总称。要使用SpringCloud的话必须要基于SpringBoot，而SpringBoot可以单独使用。</p><h1 id="Nacos下载安装"><a href="#Nacos下载安装" class="headerlink" title="Nacos下载安装"></a>Nacos下载安装</h1><p><strong>下载地址和版本</strong></p><p>下载地址：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>下载版本：nacos-server-1.1.4.tar.gz或nacos-server-1.1.4.zip，解压任意目录即可</p><p>- Windows</p><p>启动命令：cmd startup.cmd 或者双击startup.cmd运行文件。</p><p>访问：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a></p><p>用户名密码：nacos/nacos</p><h1 id="服务注册（service-edu为例）"><a href="#服务注册（service-edu为例）" class="headerlink" title="服务注册（service_edu为例）"></a>服务注册（service_edu为例）</h1><h2 id="在service模块配置pom"><a href="#在service模块配置pom" class="headerlink" title="在service模块配置pom"></a>在service模块配置pom</h2><p>配置Nacos客户端的pom依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--服务注册--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div><h2 id="添加服务配置信息"><a href="#添加服务配置信息" class="headerlink" title="添加服务配置信息"></a>添加服务配置信息</h2><p>配置application.properties，在客户端微服务中添加注册Nacos服务的配置信息</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848</code></pre></div><h2 id="添加Nacos客户端注解"><a href="#添加Nacos客户端注解" class="headerlink" title="添加Nacos客户端注解"></a>添加Nacos客户端注解</h2><p>在客户端微服务启动类中添加注解@EnableDiscoveryClient</p><h2 id="启动客户端微服务"><a href="#启动客户端微服务" class="headerlink" title="启动客户端微服务"></a>启动客户端微服务</h2><p>启动注册中心     </p><p>启动已注册的微服务，可以在Nacos服务列表中看到被注册的微服务</p><h1 id="课程管理-删除小节删除视频Feign"><a href="#课程管理-删除小节删除视频Feign" class="headerlink" title="课程管理-删除小节删除视频Feign"></a>课程管理-删除小节删除视频Feign</h1><h2 id="在service模块添加pom依赖"><a href="#在service模块添加pom依赖" class="headerlink" title="在service模块添加pom依赖"></a>在service模块添加pom依赖</h2><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 服务调用 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div><h2 id="在调用端的启动类添加注解"><a href="#在调用端的启动类添加注解" class="headerlink" title="在调用端的启动类添加注解"></a>在调用端的启动类添加注解</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EnableFeignClients &#x2F;&#x2F; 开启远程调用</code></pre></div><h2 id="创建包和接口"><a href="#创建包和接口" class="headerlink" title="创建包和接口"></a>创建包和接口</h2><p>创建client包</p><p>@FeignClient注解用于指定从哪个服务中调用功能 ，名称与被调用的服务名保持一致。</p><p>@GetMapping注解用于对被调用的微服务进行地址映射。</p><p>@PathVariable注解一定要指定参数名称，否则出错</p><p>@Component注解防止，在其他位置注入CodClient时idea报错</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(&quot;service-vod&quot;)     &#x2F;&#x2F; 远程调用服务名称public interface VodClient &#123;    &#x2F;&#x2F; 删除阿里云的视频    &#x2F;&#x2F; 路径为全路径    &#x2F;&#x2F; @PathVariable(&quot;id&quot;)需要指名参数名字，否则会报错    @DeleteMapping(&quot;&#x2F;eduvod&#x2F;video&#x2F;deleteAlyVideo&#x2F;&#123;id&#125;&quot;)    public R deleteAlyVideo(@PathVariable(&quot;id&quot;) String id);&#125;</code></pre></div><h2 id="调用微服务"><a href="#调用微服务" class="headerlink" title="调用微服务"></a>调用微服务</h2><p>在调用端的VideoServiceImpl中调用client中的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除小节 顺便删除视频@DeleteMapping(&quot;&#123;id&#125;&quot;)public R deleteVideo(@PathVariable String id)&#123;    &#x2F;&#x2F; 根据小节id查询出视频id    EduVideo eduVideo &#x3D; eduVideoService.getById(id);    String videoSourceId &#x3D; eduVideo.getVideoSourceId();    &#x2F;&#x2F; 先判断得到的视频id是否为空    if (!StringUtils.isEmpty(videoSourceId))&#123;        &#x2F;&#x2F; 根据视频id删除阿里云的视频        vodClient.deleteAlyVideo(videoSourceId);    &#125;    eduVideoService.removeById(id);    return R.ok();&#125;</code></pre></div><p>测试</p><h1 id="课程管理-删除课程删除视频后端"><a href="#课程管理-删除课程删除视频后端" class="headerlink" title="课程管理-删除课程删除视频后端"></a>课程管理-删除课程删除视频后端</h1><p>com.atguigu.vod.controller.VodController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除多个阿里云视频@RequestMapping(&quot;delete-batch&quot;)public R deleteBatch(@RequestParam(&quot;videoIddList&quot;) List&lt;String&gt; videoIddList)&#123;    vodService.removeMoreVideo(videoIddList);    return R.ok();&#125;</code></pre></div><p>VodService</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除多个阿里云视频void removeMoreVideo(List&lt;String&gt; videoIddList);</code></pre></div><p>VodServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除多个阿里云视频@Overridepublic void removeMoreVideo(List&lt;String&gt; videoIddList) &#123;    try &#123;        &#x2F;&#x2F; 初始化对象        DefaultAcsClient client &#x3D; InitVodClient.initVodClient(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET);        &#x2F;&#x2F; 创建删除的request请求        DeleteVideoRequest request &#x3D; new DeleteVideoRequest();        &#x2F;&#x2F; 将videoIds集合遍历出来，做成1,2,3这样的形式        String videoIds &#x3D; StringUtils.join(videoIddList.toArray(), &quot;,&quot;);        &#x2F;&#x2F; 设置视频id        request.setVideoIds(videoIds);        &#x2F;&#x2F; 调用初始化方法进行删除        client.getAcsResponse(request);    &#125; catch (ClientException e) &#123;        e.printStackTrace();        throw new GuliException(20001,&quot;删除视频失败&quot;);    &#125;&#125;</code></pre></div><h1 id="课程管理-删除课程删除视频远程调用"><a href="#课程管理-删除课程删除视频远程调用" class="headerlink" title="课程管理-删除课程删除视频远程调用"></a>课程管理-删除课程删除视频远程调用</h1><p>com.atguigu.eduservice.client.VodClient</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除多个阿里云视频@RequestMapping(&quot;&#x2F;eduvod&#x2F;video&#x2F;delete-batch&quot;)public R deleteBatch(@RequestParam(&quot;videoIddList&quot;) List&lt;String&gt; videoIddList);</code></pre></div><p>com.atguigu.eduservice.service.impl.EduVideoServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduVideoServiceImpl extends ServiceImpl&lt;EduVideoMapper, EduVideo&gt; implements EduVideoService &#123;    @Autowired    private VodClient vodClient;    &#x2F;&#x2F; 根据课程id删除小节    @Override    public void removeVideoByCourseId(String courseId) &#123;        &#x2F;&#x2F; 根据课程id查询课程所有的视频id        QueryWrapper&lt;EduVideo&gt; wrapperVideo &#x3D; new QueryWrapper&lt;&gt;();        wrapperVideo.eq(&quot;course_id&quot;,courseId);        &#x2F;&#x2F; 只需要这一个字段        wrapperVideo.select(&quot;video_source_id&quot;);        List&lt;EduVideo&gt; eduVideoList &#x3D; baseMapper.selectList(wrapperVideo);        &#x2F;&#x2F; 需要将List&lt;EduVideo&gt;变成List&lt;String&gt;这样        List&lt;String&gt; videoIds &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F; 遍历eduVideoList，拿到里面的每一个id值        for (int i &#x3D; 0; i &lt; eduVideoList.size(); i++) &#123;            EduVideo eduVideo &#x3D; eduVideoList.get(i);            String videoSourceId &#x3D; eduVideo.getVideoSourceId();            &#x2F;&#x2F; 判断videoSourceId是否为空            if (StringUtils.isEmpty(videoSourceId))&#123;                &#x2F;&#x2F; 不为空，将id加入集合                videoIds.add(videoSourceId);            &#125;        &#125;        &#x2F;&#x2F; 判断集合videoIds是否为空        if (videoIds.size() &gt; 0)&#123;            &#x2F;&#x2F; 调用远程方法，根据多少id进行删除视频            vodClient.deleteBatch(videoIds);        &#125;        QueryWrapper&lt;EduVideo&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;course_id&quot;,courseId);        baseMapper.delete(wrapper);    &#125;&#125;</code></pre></div><h1 id="技术点-SpringCloud调用接口流程"><a href="#技术点-SpringCloud调用接口流程" class="headerlink" title="技术点-SpringCloud调用接口流程"></a>技术点-SpringCloud调用接口流程</h1><p>Feign-&gt;Hystrix-&gt;Ribbon-&gt;Http Client</p><p><img src="/myBlog/day10-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/image-20220106234453087.png" alt="image-20220106234453087"></p><h1 id="课程管理-项目中整合熔断器"><a href="#课程管理-项目中整合熔断器" class="headerlink" title="课程管理-项目中整合熔断器"></a>课程管理-项目中整合熔断器</h1><p>导入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--hystrix依赖，主要是用  @HystrixCommand --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>配置文件开启熔断器</p><div class="code-wrapper"><pre class="line-numbers language-pro" data-language="pro"><code class="language-pro">#开启熔断机制feign.hystrix.enabled&#x3D;true# 设置hystrix超时时间，默认1000ms# hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds&#x3D;6000</code></pre></div><p>编写调用远程方法接口的实现类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class VodFileDegradeFeignClient implements VodClient &#123;    &#x2F;&#x2F; 熔断器，服务发送错误时调用次方法    @Override    public R deleteAlyVideo(String id) &#123;        return R.error().message(&quot;删除视频失败&quot;);    &#125;    @Override    public R deleteBatch(List&lt;String&gt; videoIddList) &#123;        return R.error().message(&quot;删除多个视频失败&quot;);    &#125;&#125;</code></pre></div><p>在接口的Feign加入fallback属性</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name &#x3D; &quot;service-vod&quot;,fallback &#x3D; VodFileDegradeFeignClient.class)     &#x2F;&#x2F; 远程调用服务名称public interface VodClient &#123;</code></pre></div><p>修改删除小节的方法，Debug测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@DeleteMapping(&quot;&#123;id&#125;&quot;)public R deleteVideo(@PathVariable String id)&#123;    &#x2F;&#x2F; 根据小节id查询出视频id    EduVideo eduVideo &#x3D; eduVideoService.getById(id);    String videoSourceId &#x3D; eduVideo.getVideoSourceId();    &#x2F;&#x2F; 先判断得到的视频id是否为空    if (!StringUtils.isEmpty(videoSourceId))&#123;        &#x2F;&#x2F; 根据视频id删除阿里云的视频        R result &#x3D; vodClient.deleteAlyVideo(videoSourceId);        if (result.getCode() &#x3D;&#x3D; 20001)&#123;            throw new GuliException(20001,&quot;删除视频失败，熔断器...&quot;);        &#125;    &#125;    eduVideoService.removeById(id);    return R.ok();&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day18-权限管理_Nacos配置中心_Git</title>
    <link href="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/"/>
    <url>/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/</url>
    
    <content type="html"><![CDATA[<h1 id="day18-权限管理-Nacos-配置中心-Git"><a href="#day18-权限管理-Nacos-配置中心-Git" class="headerlink" title="day18-权限管理 Nacos 配置中心 Git"></a>day18-权限管理 Nacos 配置中心 Git</h1><h1 id="权限管理-SpringSecurity介绍"><a href="#权限管理-SpringSecurity介绍" class="headerlink" title="权限管理-SpringSecurity介绍"></a>权限管理-SpringSecurity介绍</h1><h2 id="授权和认证实现思路"><a href="#授权和认证实现思路" class="headerlink" title="授权和认证实现思路"></a>授权和认证实现思路</h2><p>用户先进行输入账号密码登录，从数据库中查询数据，如果登录成功，将用户的用户名作为key，将从数据库中查询出来的权限作为value存到redis中。登录成功后，返回token，将token存到cookie中并且在请起头header也存放token信息。接着SpringSecurity再请求头header中获取token信息，从token信息中解析出用户名，根据用户名去redis中查询该用户所有的权限，最后，SpringSecurity根据查询出来的权限赋予用户相当于的权限，可以进行对应的操作。</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220107014803076.png" alt="image-20220107014803076"></p><h1 id="权限管理-整合SpringSecurity"><a href="#权限管理-整合SpringSecurity" class="headerlink" title="权限管理-整合SpringSecurity"></a>权限管理-整合SpringSecurity</h1><p><strong>1、在common下创建spring_security模块</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105234509111.png" alt="image-20220105234509111"></p><p><strong>2、在spring_security引入相关依赖</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;common_utils&lt;&#x2F;artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!-- Spring Security依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.jsonwebtoken&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jjwt&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>**3、在service_acl引入*<em>spring_security*<em>依赖</em></em></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring_security&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p><strong>代码结构说明：</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105234622263.png" alt="image-20220105234622263"></p><p><strong>4、创建spring security核心配置类</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105234639165.png" alt="image-20220105234639165"></p><p>Spring Security的核心配置就是继承WebSecurityConfigurerAdapter并注解@EnableWebSecurity的配置。</p><p>这个配置指明了用户名密码的处理方式、请求路径的开合、登录登出控制等和安全相关的配置</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.config;import com.atguigu.serurity.filter.TokenAuthenticationFilter;import com.atguigu.serurity.filter.TokenLoginFilter;import com.atguigu.serurity.security.DefaultPasswordEncoder;import com.atguigu.serurity.security.TokenLogoutHandler;import com.atguigu.serurity.security.TokenManager;import com.atguigu.serurity.security.UnauthorizedEntryPoint;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;&#x2F;** * &lt;p&gt; * Security配置类 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-18 *&#x2F;@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true)public class TokenWebSecurityConfig extends WebSecurityConfigurerAdapter &#123;    private UserDetailsService userDetailsService;    private TokenManager tokenManager;    private DefaultPasswordEncoder defaultPasswordEncoder;    private RedisTemplate redisTemplate;    @Autowired    public TokenWebSecurityConfig(UserDetailsService userDetailsService, DefaultPasswordEncoder defaultPasswordEncoder,                                  TokenManager tokenManager, RedisTemplate redisTemplate) &#123;        this.userDetailsService &#x3D; userDetailsService;        this.defaultPasswordEncoder &#x3D; defaultPasswordEncoder;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    &#x2F;**     * 配置设置     * @param http     * @throws Exception     *&#x2F;    @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.exceptionHandling()                .authenticationEntryPoint(new UnauthorizedEntryPoint())                .and().csrf().disable()                .authorizeRequests()                .anyRequest().authenticated()                .and().logout().logoutUrl(&quot;&#x2F;admin&#x2F;acl&#x2F;index&#x2F;logout&quot;)                .addLogoutHandler(new TokenLogoutHandler(tokenManager,redisTemplate)).and()                .addFilter(new TokenLoginFilter(authenticationManager(), tokenManager, redisTemplate))                .addFilter(new TokenAuthenticationFilter(authenticationManager(), tokenManager, redisTemplate)).httpBasic();    &#125;    &#x2F;**     * 密码处理     * @param auth     * @throws Exception     *&#x2F;    @Override    public void configure(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.userDetailsService(userDetailsService).passwordEncoder(defaultPasswordEncoder);    &#125;    &#x2F;**     * 配置哪些请求不拦截     * @param web     * @throws Exception     *&#x2F;    @Override    public void configure(WebSecurity web) throws Exception &#123;        web.ignoring().antMatchers(&quot;&#x2F;api&#x2F;**&quot;,                &quot;&#x2F;swagger-resources&#x2F;**&quot;, &quot;&#x2F;webjars&#x2F;**&quot;, &quot;&#x2F;v2&#x2F;**&quot;, &quot;&#x2F;swagger-ui.html&#x2F;**&quot;               );    &#125;&#125;</code></pre></div><p><strong>5、创建认证授权相关的工具类</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105234720427.png" alt="image-20220105234720427"></p><p>（1）DefaultPasswordEncoder：密码处理的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.security;import com.atguigu.commonutils.MD5;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;&#x2F;** * &lt;p&gt; * t密码的处理方法类型 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;@Componentpublic class DefaultPasswordEncoder implements PasswordEncoder &#123;    public DefaultPasswordEncoder() &#123;        this(-1);    &#125;    &#x2F;**     * @param strength     *            the log rounds to use, between 4 and 31     *&#x2F;    public DefaultPasswordEncoder(int strength) &#123;    &#125;    public String encode(CharSequence rawPassword) &#123;        return MD5.encrypt(rawPassword.toString());    &#125;    public boolean matches(CharSequence rawPassword, String encodedPassword) &#123;        return encodedPassword.equals(MD5.encrypt(rawPassword.toString()));    &#125;&#125;</code></pre></div><p>（2）TokenManager：token操作的工具类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.security;import io.jsonwebtoken.CompressionCodecs;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.stereotype.Component;import java.util.Date;&#x2F;** * &lt;p&gt; * token管理 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;@Componentpublic class TokenManager &#123;    private long tokenExpiration &#x3D; 24*60*60*1000;    private String tokenSignKey &#x3D; &quot;123456&quot;;    public String createToken(String username) &#123;        String token &#x3D; Jwts.builder().setSubject(username)                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();        return token;    &#125;    public String getUserFromToken(String token) &#123;        String user &#x3D; Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();        return user;    &#125;    public void removeToken(String token) &#123;        &#x2F;&#x2F;jwttoken无需删除，客户端扔掉即可。    &#125;&#125;</code></pre></div><p>（3）TokenLogoutHandler：退出实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.security;import com.atguigu.commonutils.R;import com.atguigu.commonutils.ResponseUtil;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.logout.LogoutHandler;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;&#x2F;** * &lt;p&gt; * 登出业务逻辑类 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;public class TokenLogoutHandler implements LogoutHandler &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    public TokenLogoutHandler(TokenManager tokenManager, RedisTemplate redisTemplate) &#123;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    @Override    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123;        String token &#x3D; request.getHeader(&quot;token&quot;);        if (token !&#x3D; null) &#123;            tokenManager.removeToken(token);            &#x2F;&#x2F;清空当前用户缓存中的权限数据            String userName &#x3D; tokenManager.getUserFromToken(token);            redisTemplate.delete(userName);        &#125;        ResponseUtil.out(response, R.ok());    &#125;&#125;</code></pre></div><p>（4）UnauthorizedEntryPoint：未授权统一处理</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.security;import com.atguigu.commonutils.R;import com.atguigu.commonutils.ResponseUtil;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;&#x2F;** * &lt;p&gt; * 未授权的统一处理方式 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;public class UnauthorizedEntryPoint implements AuthenticationEntryPoint &#123;    @Override    public void commence(HttpServletRequest request, HttpServletResponse response,                         AuthenticationException authException) throws IOException, ServletException &#123;        ResponseUtil.out(response, R.error());    &#125;&#125;</code></pre></div><p><strong>6、创建认证授权实体类</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105234907668.png" alt="image-20220105234907668"></p><p><strong>（1）SecutityUser</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.entity;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.util.StringUtils;import java.util.ArrayList;import java.util.Collection;import java.util.List;&#x2F;** * &lt;p&gt; * 安全认证用户详情信息 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;@Data@Slf4jpublic class SecurityUser implements UserDetails &#123;    &#x2F;&#x2F;当前登录用户    private transient User currentUserInfo;    &#x2F;&#x2F;当前权限    private List&lt;String&gt; permissionValueList;    public SecurityUser() &#123;    &#125;    public SecurityUser(User user) &#123;        if (user !&#x3D; null) &#123;            this.currentUserInfo &#x3D; user;        &#125;    &#125;    @Override    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;        Collection&lt;GrantedAuthority&gt; authorities &#x3D; new ArrayList&lt;&gt;();        for(String permissionValue : permissionValueList) &#123;            if(StringUtils.isEmpty(permissionValue)) continue;            SimpleGrantedAuthority authority &#x3D; new SimpleGrantedAuthority(permissionValue);            authorities.add(authority);        &#125;        return authorities;    &#125;    @Override    public String getPassword() &#123;        return currentUserInfo.getPassword();    &#125;    @Override    public String getUsername() &#123;        return currentUserInfo.getUsername();    &#125;    @Override    public boolean isAccountNonExpired() &#123;        return true;    &#125;    @Override    public boolean isAccountNonLocked() &#123;        return true;    &#125;    @Override    public boolean isCredentialsNonExpired() &#123;        return true;    &#125;    @Override    public boolean isEnabled() &#123;        return true;    &#125;&#125;</code></pre></div><p><strong>（2）User</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.entity;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.Data;import java.io.Serializable;&#x2F;** * &lt;p&gt; * 用户实体类 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;@Data@ApiModel(description &#x3D; &quot;用户实体类&quot;)public class User implements Serializable &#123;private static final long serialVersionUID &#x3D; 1L;@ApiModelProperty(value &#x3D; &quot;微信openid&quot;)private String username;@ApiModelProperty(value &#x3D; &quot;密码&quot;)private String password;@ApiModelProperty(value &#x3D; &quot;昵称&quot;)private String nickName;@ApiModelProperty(value &#x3D; &quot;用户头像&quot;)private String salt;@ApiModelProperty(value &#x3D; &quot;用户签名&quot;)private String token;&#125;</code></pre></div><p><strong>7、创建认证和授权的filter</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220105235005444.png" alt="image-20220105235005444"></p><p><strong>（1）TokenLoginFilter：认证的filter</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.filter;import com.atguigu.commonutils.R;import com.atguigu.commonutils.ResponseUtil;import com.atguigu.serurity.entity.SecurityUser;import com.atguigu.serurity.entity.User;import com.atguigu.serurity.security.TokenManager;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.security.web.util.matcher.AntPathRequestMatcher;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;&#x2F;** * &lt;p&gt; * 登录过滤器，继承UsernamePasswordAuthenticationFilter，对用户名密码进行登录校验 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;public class TokenLoginFilter extends UsernamePasswordAuthenticationFilter &#123;    private AuthenticationManager authenticationManager;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    public TokenLoginFilter(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate) &#123;        this.authenticationManager &#x3D; authenticationManager;        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;        this.setPostOnly(false);        this.setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher(&quot;&#x2F;admin&#x2F;acl&#x2F;login&quot;,&quot;POST&quot;));    &#125;    @Override    public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res)            throws AuthenticationException &#123;        try &#123;            User user &#x3D; new ObjectMapper().readValue(req.getInputStream(), User.class);            return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()));        &#125; catch (IOException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    &#x2F;**     * 登录成功     * @param req     * @param res     * @param chain     * @param auth     * @throws IOException     * @throws ServletException     *&#x2F;    @Override    protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain,                                            Authentication auth) throws IOException, ServletException &#123;        SecurityUser user &#x3D; (SecurityUser) auth.getPrincipal();        String token &#x3D; tokenManager.createToken(user.getCurrentUserInfo().getUsername());        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList());        ResponseUtil.out(res, R.ok().data(&quot;token&quot;, token));    &#125;    &#x2F;**     * 登录失败     * @param request     * @param response     * @param e     * @throws IOException     * @throws ServletException     *&#x2F;    @Override    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,                                              AuthenticationException e) throws IOException, ServletException &#123;        ResponseUtil.out(response, R.error());    &#125;&#125;</code></pre></div><p>（2）TokenAuthenticationFilter：<br>授权filter</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.serurity.filter;import com.atguigu.commonutils.R;import com.atguigu.commonutils.ResponseUtil;import com.atguigu.serurity.security.TokenManager;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;import org.springframework.util.StringUtils;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.Collection;import java.util.List;&#x2F;** * &lt;p&gt; * 访问过滤器 * &lt;&#x2F;p&gt; * * @author qy * @since 2019-11-08 *&#x2F;public class TokenAuthenticationFilter extends BasicAuthenticationFilter &#123;    private TokenManager tokenManager;    private RedisTemplate redisTemplate;    public TokenAuthenticationFilter(AuthenticationManager authManager, TokenManager tokenManager,RedisTemplate redisTemplate) &#123;        super(authManager);        this.tokenManager &#x3D; tokenManager;        this.redisTemplate &#x3D; redisTemplate;    &#125;    @Override    protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain)            throws IOException, ServletException &#123;        logger.info(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+req.getRequestURI());        if(req.getRequestURI().indexOf(&quot;admin&quot;) &#x3D;&#x3D; -1) &#123;            chain.doFilter(req, res);            return;        &#125;        UsernamePasswordAuthenticationToken authentication &#x3D; null;        try &#123;            authentication &#x3D; getAuthentication(req);        &#125; catch (Exception e) &#123;            ResponseUtil.out(res, R.error());        &#125;        if (authentication !&#x3D; null) &#123;            SecurityContextHolder.getContext().setAuthentication(authentication);        &#125; else &#123;            ResponseUtil.out(res, R.error());        &#125;        chain.doFilter(req, res);    &#125;    private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) &#123;        &#x2F;&#x2F; token置于header里        String token &#x3D; request.getHeader(&quot;token&quot;);        if (token !&#x3D; null &amp;&amp; !&quot;&quot;.equals(token.trim())) &#123;            String userName &#x3D; tokenManager.getUserFromToken(token);            List&lt;String&gt; permissionValueList &#x3D; (List&lt;String&gt;) redisTemplate.opsForValue().get(userName);            Collection&lt;GrantedAuthority&gt; authorities &#x3D; new ArrayList&lt;&gt;();            for(String permissionValue : permissionValueList) &#123;                if(StringUtils.isEmpty(permissionValue)) continue;                SimpleGrantedAuthority authority &#x3D; new SimpleGrantedAuthority(permissionValue);                authorities.add(authority);            &#125;            if (!StringUtils.isEmpty(userName)) &#123;                return new UsernamePasswordAuthenticationToken(userName, token, authorities);            &#125;            return null;        &#125;        return null;    &#125;&#125;</code></pre></div><h1 id="Ncaos配置中心-读取配置文件"><a href="#Ncaos配置中心-读取配置文件" class="headerlink" title="Ncaos配置中心-读取配置文件"></a>Ncaos配置中心-读取配置文件</h1><h2 id="1、在Nacos创建统一配置文件"><a href="#1、在Nacos创建统一配置文件" class="headerlink" title="1、在Nacos创建统一配置文件"></a>1、在Nacos创建统一配置文件</h2><p><strong>（1）点击创建按钮</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106114719415.png" alt="image-20220106114719415"></p><p><strong>（2）输入配置信息</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106114733131.png" alt="image-20220106114733131"></p><p><strong>a）Data ID 的完整规则格式如下</strong></p><p><strong>${prefix}-${spring.profile.active}.${file-extension}</strong></p><p><strong>- prefix</strong> 服务名 </p><p><strong>- spring.profiles.active=dev</strong> 即为当前环境对应的 profile。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</p><p><strong>- file-exetension</strong> 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型</p><h2 id="2、以service-statistics模块为例"><a href="#2、以service-statistics模块为例" class="headerlink" title="2、以service-statistics模块为例"></a>2、以service-statistics模块为例</h2><p><strong>（1）在service中引入依赖</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p><strong>（2）创建bootstrap.properties配置文件</strong></p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#配置中心地址spring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.profiles.active&#x3D;dev# 该配置影响统一配置中心中的dataIdspring.application.name&#x3D;service-statistics</code></pre></div><p><strong>（3）把项目之前的application.properties内容注释，启动项目查看效果</strong></p><h2 id="3、补充：springboot配置文件加载顺序"><a href="#3、补充：springboot配置文件加载顺序" class="headerlink" title="3、补充：springboot配置文件加载顺序"></a><strong>3、补充：springboot配置文件加载顺序</strong></h2><p>其实yml和properties文件是一样的原理，且一个项目上要么yml或者properties，二选一的存在。推荐使用yml，更简洁。</p><p>bootstrap与application<br><strong>（1）加载顺序</strong><br>这里主要是说明application和bootstrap的加载顺序。</p><p>bootstrap.yml（bootstrap.properties）先加载<br>application.yml（application.properties）后加载<br>bootstrap.yml 用于应用程序上下文的引导阶段。</p><p>bootstrap.yml 由父Spring ApplicationContext加载。</p><p>父ApplicationContext 被加载到使用 application.yml 的之前。</p><p><strong>（2）配置区别</strong><br>bootstrap.yml 和application.yml 都可以用来配置参数。</p><p>bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。<br>application.yml 可以用来定义应用级别的。</p><h1 id="Nacos配置中心-命名空间切换"><a href="#Nacos配置中心-命名空间切换" class="headerlink" title="Nacos配置中心-命名空间切换"></a>Nacos配置中心-命名空间切换</h1><p><strong>1、创建命名空间</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122544604.png" alt="image-20220106122544604"></p><p>默认只有public，新建了dev、test和prod命名空间</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122615420.png" alt="image-20220106122615420"></p><p><strong>2、克隆配置</strong></p><p><strong>（1）切换到配置列表：</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122627430.png" alt="image-20220106122627430"></p><p><strong>可以发现有四个名称空间：public（默认）以及我们自己添加的3个名称空间（prod、dev、test），可以点击查看每个名称空间下的配置文件，当然现在只有public下有一个配置。默认情况下，项目会到public下找 服务名.properties文件。接下来，在dev名称空间中也添加一个nacos-provider.properties配置。这时有两种方式：第一，切换到dev名称空间，添加一个新的配置文件。缺点：每个环境都要重复配置类似的项目第二，直接通过clone方式添加配置，并修改即可。推荐</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122646003.png" alt="image-20220106122646003"></p><p><strong>点击编辑：修改配置内容，端口号改为8013以作区分</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122658060.png" alt="image-20220106122658060"></p><p><strong>在项目模块中，修改bootstrap.properties添加如下配置</strong></p><p><strong>namespace的值为：</strong></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106122722359.png" alt="image-20220106122722359"></p><p><strong>重启服务提供方服务，测试修改之后是否生效</strong></p><h1 id="Nacos配置中心-多配置文件加载"><a href="#Nacos配置中心-多配置文件加载" class="headerlink" title="Nacos配置中心-多配置文件加载"></a>Nacos配置中心-多配置文件加载</h1><p>在一些情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：service-statistics.properties、redis.properties、jdbc.properties</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106124021259.png" alt="image-20220106124021259"></p><p><strong>添加配置，加载多个配置文件</strong></p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">spring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848spring.profiles.active&#x3D;dev# 该配置影响统一配置中心中的dataId，之前已经配置过spring.application.name&#x3D;service-statisticsspring.cloud.nacos.config.namespace&#x3D;13b5c197-de5b-47e7-9903-ec0538c9db01spring.cloud.nacos.config.ext-config[0].data-id&#x3D;redis.properties# 开启动态刷新配置，否则配置文件修改，工程无法感知spring.cloud.nacos.config.ext-config[0].refresh&#x3D;truespring.cloud.nacos.config.ext-config[1].data-id&#x3D;jdbc.properties</code></pre></div><h1 id="远程Git仓库-提交代码（idea提交）"><a href="#远程Git仓库-提交代码（idea提交）" class="headerlink" title="远程Git仓库-提交代码（idea提交）"></a>远程Git仓库-提交代码（idea提交）</h1><ol><li><p>在gitee新创建一个仓库</p></li><li><p>在idea设置git的路径</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106131621652.png" alt="image-20220106131621652"></p><ol start="3"><li><p>创建一个本地git仓库，一般以项目为仓库</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106131738561.png" alt="image-20220106131738561"></p></li><li><p>选中项目根目录右键，点击git，选中add，添加到本地仓库</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132035893.png" alt="image-20220106132035893"></p></li><li><p>设置要提交的远程仓库地址</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132207764.png" alt="image-20220106132207764"></p></li><li><p>输入url，第一次需要输入用户名和密码验证</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132326937.png" alt="image-20220106132326937"></p></li><li><p>添加好url后，点击git，选中commit Directory</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132415267.png" alt="image-20220106132415267"></p></li><li><p>填好信息，点击提交</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132610094.png" alt="image-20220106132610094"></p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132635518.png" alt="image-20220106132635518"></p></li><li><p>忽略警告，继续提交</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132745104.png" alt="image-20220106132745104"></p></li><li><p>点击push</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132821361.png" alt="image-20220106132821361"></p></li><li><p>输入用户名和密码验证</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132905658.png" alt="image-20220106132905658"></p></li><li><p>idea提示成功</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106132945997.png" alt="image-20220106132945997"></p></li><li><p>来到gitee的仓库中查看，已成功</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106133015778.png" alt="image-20220106133015778"></p></li></ol></li></ol><p><strong>如何让本地仓库与远程仓库断开连接？</strong></p><p>找version control,选中要断开的仓库，点击减号，最后OK</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106143054094.png" alt="image-20220106143054094"></p><p>来到项目的本地目录下，将.git文件夹删除，需要打开查看隐藏文件</p><p><img src="/myBlog/day18-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86_Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Git/image-20220106143227167.png" alt="image-20220106143227167"></p>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day17-canal_Gateway网关_权限管理</title>
    <link href="/myBlog/day17-canal_Gateway%E7%BD%91%E5%85%B3_%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/myBlog/day17-canal_Gateway%E7%BD%91%E5%85%B3_%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="day17-canal-Gateway网关-权限管理"><a href="#day17-canal-Gateway网关-权限管理" class="headerlink" title="day17-canal_Gateway网关_权限管理"></a>day17-canal_Gateway网关_权限管理</h1><h1 id="canal数据同步【TODO】"><a href="#canal数据同步【TODO】" class="headerlink" title="canal数据同步【TODO】"></a>canal数据同步【TODO】</h1><p>Linux中还没装数据库</p><h1 id="SpringCloud-Gateway网关"><a href="#SpringCloud-Gateway网关" class="headerlink" title="SpringCloud-Gateway网关"></a>SpringCloud-Gateway网关</h1><h2 id="创建api-gateway模块（网关服务）"><a href="#创建api-gateway模块（网关服务）" class="headerlink" title="创建api-gateway模块（网关服务）"></a>创建api-gateway模块（网关服务）</h2><p>1、在infrastructure模块下创建api_gateway模块</p><p>2、在pom.xml引入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;common_utils&lt;&#x2F;artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--gson--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--服务调用--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>3、编写application.properties配置文件</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8222# 服务名spring.application.name&#x3D;service-gateway# nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848#使用服务发现路由spring.cloud.gateway.discovery.locator.enabled&#x3D;true#服务路由名小写#spring.cloud.gateway.discovery.locator.lower-case-service-id&#x3D;true#设置路由idspring.cloud.gateway.routes[0].id&#x3D;service-acl#设置路由的urispring.cloud.gateway.routes[0].uri&#x3D;lb:&#x2F;&#x2F;service-acl#设置路由断言,代理servicerId为auth-service的&#x2F;auth&#x2F;路径spring.cloud.gateway.routes[0].predicates&#x3D; Path&#x3D;&#x2F;*&#x2F;acl&#x2F;**#配置service-edu服务spring.cloud.gateway.routes[1].id&#x3D;service-eduspring.cloud.gateway.routes[1].uri&#x3D;lb:&#x2F;&#x2F;service-eduspring.cloud.gateway.routes[1].predicates&#x3D; Path&#x3D;&#x2F;eduservice&#x2F;**#配置service-ucenter服务spring.cloud.gateway.routes[2].id&#x3D;service-ucenterspring.cloud.gateway.routes[2].uri&#x3D;lb:&#x2F;&#x2F;service-ucenterspring.cloud.gateway.routes[2].predicates&#x3D; Path&#x3D;&#x2F;ucenterservice&#x2F;**#配置service-ucenter服务spring.cloud.gateway.routes[3].id&#x3D;service-cmsspring.cloud.gateway.routes[3].uri&#x3D;lb:&#x2F;&#x2F;service-cmsspring.cloud.gateway.routes[3].predicates&#x3D; Path&#x3D;&#x2F;cmsservice&#x2F;**</code></pre></div><p>4、编写启动类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@EnableDiscoveryClientpublic class ApiGatewayApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ApiGatewayApplication.class,args);    &#125;&#125;</code></pre></div><h2 id="网关相关配置"><a href="#网关相关配置" class="headerlink" title="网关相关配置"></a>网关相关配置</h2><p><strong>1、网关解决跨域问题</strong></p><p><img src="/myBlog/day17-canal_Gateway%E7%BD%91%E5%85%B3_%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20220105165534139.png" alt="image-20220105165534139"></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class CorsConfig &#123;    @Bean    public CorsWebFilter corsFilter() &#123;        CorsConfiguration config &#x3D; new CorsConfiguration();        config.addAllowedMethod(&quot;*&quot;);        config.addAllowedOrigin(&quot;*&quot;);        config.addAllowedHeader(&quot;*&quot;);        UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource(new PathPatternParser());        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;</code></pre></div><p><strong>2、全局Filter，统一处理会员登录与外部不允许访问的服务</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * &lt;p&gt; * 全局Filter，统一处理会员登录与外部不允许访问的服务 * &lt;&#x2F;p&gt; *&#x2F;@Componentpublic class AuthGlobalFilter implements GlobalFilter, Ordered &#123;    private AntPathMatcher antPathMatcher &#x3D; new AntPathMatcher();    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        ServerHttpRequest request &#x3D; exchange.getRequest();        String path &#x3D; request.getURI().getPath();        &#x2F;&#x2F;谷粒学院api接口，校验用户必须登录        if(antPathMatcher.match(&quot;&#x2F;api&#x2F;**&#x2F;auth&#x2F;**&quot;, path)) &#123;            List&lt;String&gt; tokenList &#x3D; request.getHeaders().get(&quot;token&quot;);            if(null &#x3D;&#x3D; tokenList) &#123;                ServerHttpResponse response &#x3D; exchange.getResponse();                return out(response);            &#125; else &#123;&#x2F;&#x2F;                Boolean isCheck &#x3D; JwtUtils.checkToken(tokenList.get(0));&#x2F;&#x2F;                if(!isCheck) &#123;                ServerHttpResponse response &#x3D; exchange.getResponse();                return out(response);&#x2F;&#x2F;                &#125;            &#125;        &#125;        &#x2F;&#x2F;内部服务接口，不允许外部访问        if(antPathMatcher.match(&quot;&#x2F;**&#x2F;inner&#x2F;**&quot;, path)) &#123;            ServerHttpResponse response &#x3D; exchange.getResponse();            return out(response);        &#125;        return chain.filter(exchange);    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;    private Mono&lt;Void&gt; out(ServerHttpResponse response) &#123;        JsonObject message &#x3D; new JsonObject();        message.addProperty(&quot;success&quot;, false);        message.addProperty(&quot;code&quot;, 28004);        message.addProperty(&quot;data&quot;, &quot;鉴权失败&quot;);        byte[] bits &#x3D; message.toString().getBytes(StandardCharsets.UTF_8);        DataBuffer buffer &#x3D; response.bufferFactory().wrap(bits);        &#x2F;&#x2F;response.setStatusCode(HttpStatus.UNAUTHORIZED);        &#x2F;&#x2F;指定编码，否则在浏览器中会中文乱码        response.getHeaders().add(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;);        return response.writeWith(Mono.just(buffer));    &#125;&#125;</code></pre></div><p><strong>3、自定义异常处理</strong></p><p>服务网关调用服务时可能会有一些异常或服务不可用，它返回错误信息不友好，需要我们覆盖处理</p><p>ErrorHandlerConfig</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * &lt;p&gt; * 全局Filter，统一处理会员登录与外部不允许访问的服务 * &lt;&#x2F;p&gt; *&#x2F;@Configuration@EnableConfigurationProperties(&#123;ServerProperties.class, ResourceProperties.class&#125;)public class ErrorHandlerConfig &#123;    private final ServerProperties serverProperties;    private final ApplicationContext applicationContext;    private final ResourceProperties resourceProperties;    private final List&lt;ViewResolver&gt; viewResolvers;    private final ServerCodecConfigurer serverCodecConfigurer;    public ErrorHandlerConfig(ServerProperties serverProperties,                              ResourceProperties resourceProperties,                              ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,                              ServerCodecConfigurer serverCodecConfigurer,                              ApplicationContext applicationContext) &#123;        this.serverProperties &#x3D; serverProperties;        this.applicationContext &#x3D; applicationContext;        this.resourceProperties &#x3D; resourceProperties;        this.viewResolvers &#x3D; viewResolversProvider.getIfAvailable(Collections::emptyList);        this.serverCodecConfigurer &#x3D; serverCodecConfigurer;    &#125;    @Bean    @Order(Ordered.HIGHEST_PRECEDENCE)    public ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes) &#123;        JsonExceptionHandler exceptionHandler &#x3D; new JsonExceptionHandler(                errorAttributes,                this.resourceProperties,                this.serverProperties.getError(),                this.applicationContext);        exceptionHandler.setViewResolvers(this.viewResolvers);        exceptionHandler.setMessageWriters(this.serverCodecConfigurer.getWriters());        exceptionHandler.setMessageReaders(this.serverCodecConfigurer.getReaders());        return exceptionHandler;    &#125;&#125;</code></pre></div><p>JsonExceptionHandler</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 自定义异常处理 * &lt;p&gt;异常时用JSON代替HTML异常信息&lt;p&gt; *&#x2F;public class JsonExceptionHandler extends DefaultErrorWebExceptionHandler &#123;    public JsonExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,                                ErrorProperties errorProperties, ApplicationContext applicationContext) &#123;        super(errorAttributes, resourceProperties, errorProperties, applicationContext);    &#125;    &#x2F;**     * 获取异常属性     *&#x2F;    @Override    protected Map&lt;String, Object&gt; getErrorAttributes(ServerRequest request, boolean includeStackTrace) &#123;        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(&quot;success&quot;, false);        map.put(&quot;code&quot;, 20005);        map.put(&quot;message&quot;, &quot;网关失败&quot;);        map.put(&quot;data&quot;, null);        return map;    &#125;    &#x2F;**     * 指定响应处理方法为JSON处理的方法     *     * @param errorAttributes     *&#x2F;    @Override    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) &#123;        return RouterFunctions.route(RequestPredicates.all(), this::renderErrorResponse);    &#125;    &#x2F;**     * 根据code获取对应的HttpStatus     *     * @param errorAttributes     *&#x2F;&#x2F;&#x2F;    @Override&#x2F;&#x2F;    protected HttpStatus getHttpStatus(Map&lt;String, Object&gt; errorAttributes) &#123;&#x2F;&#x2F;        return HttpStatus.OK;&#x2F;&#x2F;    &#125;&#125;</code></pre></div><h1 id="权限管理-表结构和关系"><a href="#权限管理-表结构和关系" class="headerlink" title="权限管理-表结构和关系"></a>权限管理-表结构和关系</h1><p>![07 权限管理需求](day17-canal_Gateway网关_权限管理/07 权限管理需求.png)</p><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><p><strong>1、在service模块下创建子模块service-acl</strong></p><p><strong>2、在service_acl模块中引入依赖</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring_security&lt;&#x2F;artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p><strong>3、创建权限管理相关的表</strong></p><p><img src="/myBlog/day17-canal_Gateway%E7%BD%91%E5%85%B3_%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/image-20220105205447389.png" alt="image-20220105205447389"></p><p><strong>4、复制权限管理接口代码</strong></p><p><strong>5、复制整合Spring Security代码</strong></p><p><strong>（1）在common模块下创建子模块spring_security</strong></p><p><strong>6、编写application.properties配置文件</strong></p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8009# 服务名spring.application.name&#x3D;service-acl# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8spring.redis.host&#x3D;192.168.44.132spring.redis.port&#x3D;6379spring.redis.database&#x3D; 0spring.redis.timeout&#x3D;1800000spring.redis.lettuce.pool.max-active&#x3D;20spring.redis.lettuce.pool.max-wait&#x3D;-1#最大阻塞等待时间(负数表示没限制)spring.redis.lettuce.pool.max-idle&#x3D;5spring.redis.lettuce.pool.min-idle&#x3D;0#最小空闲#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;aclservice&#x2F;mapper&#x2F;xml&#x2F;*.xml# nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div><h1 id="权限管理-查询所有菜单-递归"><a href="#权限管理-查询所有菜单-递归" class="headerlink" title="权限管理-查询所有菜单-递归"></a>权限管理-查询所有菜单-递归</h1><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取全部菜单1@ApiOperation(value &#x3D; &quot;查询所有菜单1&quot;)@GetMappingpublic R indexAllPermission1() &#123;    List&lt;Permission&gt; list &#x3D;  permissionService.queryAllMenuGuli1();    return R.ok().data(&quot;children&quot;,list);&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取全部菜单1List&lt;Permission&gt; queryAllMenuGuli1();</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取全部菜单1@Overridepublic List&lt;Permission&gt; queryAllMenuGuli1() &#123;    &#x2F;&#x2F; 1.查询所有的菜单    QueryWrapper&lt;Permission&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.orderByDesc(&quot;id&quot;);    List&lt;Permission&gt; permissionList &#x3D; baseMapper.selectList(wrapper);    &#x2F;&#x2F; 按照要求把所有的菜单进行封装返回    List&lt;Permission&gt; resultList &#x3D; bulidPermission1(permissionList);    return resultList;&#125;&#x2F;&#x2F; 遍历所有的菜单，将得到的数据进行封装public static List&lt;Permission&gt; bulidPermission1(List&lt;Permission&gt; permissionList) &#123;    &#x2F;&#x2F; 构建一个集合，用于最终的数据封装    List&lt;Permission&gt; finalList &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F; 2.遍历所有的菜单，找到一级菜单    for (Permission permissionNode : permissionList) &#123;        &#x2F;&#x2F; 判断是否是一级菜单，一级菜单的id为0，即找到递归查询的入口        if (&quot;0&quot;.equals(permissionNode.getPid()))&#123;            &#x2F;&#x2F; 将它的level层级设置为1            permissionNode.setLevel(1);            &#x2F;&#x2F; 根据顶层菜单，递归查询下面的子菜单，并加入到最终的集合            finalList.add(selectChildren1(permissionNode,permissionList));        &#125;    &#125;    return finalList;&#125;&#x2F;&#x2F; 查询子菜单public static Permission selectChildren1(Permission permissionNode, List&lt;Permission&gt; permissionList) &#123;    &#x2F;&#x2F; 先初始化父菜单的子菜单    permissionNode.setChildren(new ArrayList&lt;&gt;());    &#x2F;&#x2F; 遍历所有的菜单，查到子菜单    for (Permission it : permissionList) &#123;        &#x2F;&#x2F; 判断子菜单是否属于父菜单，条件为子菜单的pid等于父菜单的id        if (it.getPid().equals(permissionNode.getId()))&#123;            &#x2F;&#x2F; 将子菜单的level+1            Integer level &#x3D; permissionNode.getLevel() + 1;            it.setLevel(level );            &#x2F;&#x2F; 添加之前应该判断子菜单是否为空，如果为空，初始化            if (permissionNode.getChildren() &#x3D;&#x3D; null)&#123;                permissionNode.setChildren(new ArrayList&lt;&gt;());            &#125;            &#x2F;&#x2F; 将查询出来的菜单放到该父菜单下的子菜单中            &#x2F;&#x2F; 再以这个菜单为父菜单，继续查询该菜单下的子菜单，即递归查询子菜单            permissionNode.getChildren().add(selectChildren1(it,permissionList));        &#125;    &#125;    &#x2F;&#x2F; 最后返回父菜单    return permissionNode;&#125;</code></pre></div><h1 id="权限管理-递归删除菜单"><a href="#权限管理-递归删除菜单" class="headerlink" title="权限管理-递归删除菜单"></a>权限管理-递归删除菜单</h1><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation(value &#x3D; &quot;递归删除菜单1&quot;)@DeleteMapping(&quot;remove&#x2F;&#123;id&#125;&quot;)public R remove(@PathVariable String id) &#123;    permissionService.removeChildByIdGuli1(id);    return R.ok();&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 递归删除菜单1void removeChildByIdGuli1(String id);</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; &#x3D;--------------递归删除菜单---------------------&#x2F;&#x2F; 递归删除菜单1@Overridepublic void removeChildByIdGuli1(String id) &#123;    &#x2F;&#x2F; 先创建一个集合，用于封装所有需要删除的id    List&lt;String&gt; idList &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F; 查询要删除的id下面的所有的子菜单的id    this.selectPermissionChildById1111(id,idList);    &#x2F;&#x2F; 将需要删除的结点也加入到集合    idList.add(id);    baseMapper.deleteBatchIds(idList);&#125;&#x2F;&#x2F; 递归查询要删除的id下面所有的子菜单的idprivate void selectPermissionChildById1111(String id, List&lt;String&gt; idList) &#123;    &#x2F;&#x2F; 根据id查询出该菜单才所有的子菜单id    QueryWrapper&lt;Permission&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;pid&quot;,id);    wrapper.select(&quot;id&quot;);    &#x2F;&#x2F; 查询出来的子菜单id    List&lt;Permission&gt; selectIdList &#x3D; baseMapper.selectList(wrapper);    &#x2F;&#x2F; 遍历查询出来的子菜单id，加入到idList集合中    selectIdList.stream().forEach(item -&gt;&#123;        idList.add(item.getId());        &#x2F;&#x2F; 再以这个结点递归查询他下面的子菜单        this.selectPermissionChildById1111(item.getId(),idList);    &#125;);&#125;</code></pre></div><h1 id="权限管理-角色分配菜单"><a href="#权限管理-角色分配菜单" class="headerlink" title="权限管理-角色分配菜单"></a>权限管理-角色分配菜单</h1><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation(value &#x3D; &quot;给角色分配权限1&quot;)@PostMapping(&quot;&#x2F;doAssign&quot;)public R doAssign(String roleId,String[] permissionId) &#123;    permissionService.saveRolePermissionRealtionShipGuli11(roleId,permissionId);    return R.ok();&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 给角色分配菜单void saveRolePermissionRealtionShipGuli11(String roleId, String[] permissionId);</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; &#x3D;--------------给角色分配菜单----------------@Overridepublic void saveRolePermissionRealtionShipGuli11(String roleId, String[] permissionIds) &#123;    &#x2F;&#x2F; 先创建一个集合，用于封装需要添加的数据    List&lt;RolePermission&gt; rolePermissionList &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F; 遍历permissionIds，得到要添加的每一个菜单id    for (String permissionId : permissionIds) &#123;        &#x2F;&#x2F; 构造一个RolePermission对象        RolePermission rolePermission &#x3D; new RolePermission();        &#x2F;&#x2F; 设置rolePermission的角色id        rolePermission.setRoleId(roleId);        &#x2F;&#x2F; 设置rolePermission的菜单id        rolePermission.setPermissionId(permissionId);        &#x2F;&#x2F; 将封装好的rolePermission对象加入到rolePermissionList中        rolePermissionList.add(rolePermission);    &#125;    &#x2F;&#x2F; 调用方法，加入到数据库中，由于操作的是角色菜单表，因此需要注入rolePermissionService    rolePermissionService.saveBatch(rolePermissionList);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day16-数据分析_统计分析</title>
    <link href="/myBlog/day16-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/"/>
    <url>/myBlog/day16-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="day16-数据分析-统计分析"><a href="#day16-数据分析-统计分析" class="headerlink" title="day16-数据分析_统计分析"></a>day16-数据分析_统计分析</h1><h1 id="课程详情页显示效果完善"><a href="#课程详情页显示效果完善" class="headerlink" title="课程详情页显示效果完善"></a>课程详情页显示效果完善</h1><h2 id="修改课程详情接口"><a href="#修改课程详情接口" class="headerlink" title="修改课程详情接口"></a>修改课程详情接口</h2><h3 id="1、在service-order模块添加接口"><a href="#1、在service-order模块添加接口" class="headerlink" title="1、在service_order模块添加接口"></a>1、在service_order模块添加接口</h3><p>根据用户id和课程id查询订单信息</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id和用户id查询订单支付状态@GetMapping(&quot;isBuyCourse&#x2F;&#123;courseId&#125;&#x2F;&#123;memberId&#125;&quot;)public boolean isBuyCourse(@PathVariable String courseId,@PathVariable String memberId)&#123;    QueryWrapper&lt;Order&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;course_id&quot;,courseId);    wrapper.eq(&quot;member_id&quot;,memberId);    wrapper.eq(&quot;status&quot;,1);     &#x2F;&#x2F; 1.已支付    int count &#x3D; orderService.count(wrapper);    if (count &gt; 0)&#123;        &#x2F;&#x2F; 说明已经支付        return true;    &#125; else &#123;        &#x2F;&#x2F; 否则未支付，返回false        return false;    &#125;&#125;</code></pre></div><h3 id="2、在service-edu模块课程详情接口远程调用"><a href="#2、在service-edu模块课程详情接口远程调用" class="headerlink" title="2、在service_edu模块课程详情接口远程调用"></a><strong>2、在service_edu模块课程详情接口远程调用</strong></h3><p>（1）创建OrderClient接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name &#x3D; &quot;service-order&quot;)public interface OrderClient &#123;    &#x2F;&#x2F; 根据课程id和用户id查询订单支付状态    @GetMapping(&quot;&#x2F;eduorder&#x2F;order&#x2F;isBuyCourse&#x2F;&#123;courseId&#125;&#x2F;&#123;memberId&#125;&quot;)    public boolean isBuyCourse(@PathVariable(&quot;courseId&quot;) String courseId, @PathVariable(&quot;memberId&quot;) String memberId);&#125;</code></pre></div><p>（2）在课程详情接口调用com.atguigu.eduservice.controller.front</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 2.课程详情的方法@GetMapping(&quot;getFrontCourseInfo&#x2F;&#123;courseId&#125;&quot;)public R getFrontCourseInfo(@PathVariable String courseId, HttpServletRequest request)&#123;    &#x2F;&#x2F; 根据课程id，编写SQL语句查询课程信息    CourseWebVo courseWebVo &#x3D; courseService.getBaseCourseInfo(courseId);    &#x2F;&#x2F; 根据课程id，查询章节和小节    List&lt;ChapterVo&gt; chapterVideoList &#x3D; chapterService.getAllChapterVideo(courseId);    &#x2F;&#x2F; 根据课程id和用户id查询当前课程是否已经支付过了    String memberId &#x3D; JwtUtils.getMemberIdByJwtToken(request);    &#x2F;&#x2F; 判断是否已经登录    if (!StringUtils.isEmpty(memberId))&#123;        boolean buyCourse &#x3D; orderClient.isBuyCourse(courseId, memberId);        return R.ok().data(&quot;courseWebVo&quot;,courseWebVo).data(&quot;chapterVideoList&quot;,chapterVideoList).data(&quot;isBuy&quot;,buyCourse);    &#125;    return R.ok().code(28004).message(&quot;请先登录&quot;);&#125;</code></pre></div><h2 id="修改课程详情页面"><a href="#修改课程详情页面" class="headerlink" title="修改课程详情页面"></a>修改课程详情页面</h2><p>1、页面内容修改</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;section class&#x3D;&quot;c-attr-mt&quot; v-if&#x3D;&quot;isBuy || Number(courseWebVo.price) &#x3D;&#x3D;&#x3D; 0&quot;&gt;  &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;立即观看&quot; class&#x3D;&quot;comm-btn c-btn-3&quot; &gt;立即观看&lt;&#x2F;a&gt;&lt;&#x2F;section&gt;&lt;section class&#x3D;&quot;c-attr-mt&quot; v-else&gt;  &lt;a href&#x3D;&quot;#&quot; title&#x3D;&quot;立即购买&quot; class&#x3D;&quot;comm-btn c-btn-3&quot; @click&#x3D;&quot;createOrder()&quot;&gt;立即购买&lt;&#x2F;a&gt;&lt;&#x2F;section&gt;</code></pre></div><p>2、调用方法修改</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"> &lt;script&gt;import course from &quot;@&#x2F;api&#x2F;course&quot;import order from &quot;@&#x2F;api&#x2F;order&quot; export default &#123;   asyncData(&#123; params, error  &#125;)&#123;     return &#123;courseId : params.id&#125;   &#125;,   data()&#123;     return&#123;          courseWebVo: &#123;&#125;,          chapterVideoList: [],          isBuy: false,     &#125;   &#125;,   created()&#123;    this.initCourseInfo()   &#125;,   methods:&#123;     initCourseInfo()&#123;      course.getCourseInfo(this.courseId)        .then(response &#x3D;&gt;&#123;            this.courseWebVo &#x3D; response.data.data.courseWebVo,            this.chapterVideoList &#x3D; response.data.data.chapterVideoList,            this.isBuy&#x3D;response.data.data.isBuy        &#125;)     &#125;,      &#x2F;&#x2F; 创建订单      createOrder()&#123;        order.createOrder(this.courseId)          .then(response &#x3D;&gt;&#123;            &#x2F;&#x2F; 获取返回的订单号            &#x2F;&#x2F; 将订单号放在路径上跳转订单显示页面            this.$router.push(&#123;path:&#39;&#x2F;order&#x2F;&#39;+response.data.data.orderId &#125;)          &#125;)      &#125;   &#125;    &#125;; &lt;&#x2F;script&gt;</code></pre></div><h1 id="数据分析-生成统计数据接口"><a href="#数据分析-生成统计数据接口" class="headerlink" title="数据分析-生成统计数据接口"></a>数据分析-生成统计数据接口</h1><h2 id="一、数据库设计"><a href="#一、数据库设计" class="headerlink" title="一、数据库设计"></a>一、数据库设计</h2><p>1、数据库</p><p>guli_statistics</p><p>2、数据表</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">guli_statistics.sql</code></pre></div><h2 id="二、创建微服务"><a href="#二、创建微服务" class="headerlink" title="二、创建微服务"></a><strong>二、创建微服务</strong></h2><h3 id="1、在service模块下创建子模块service-statistics"><a href="#1、在service模块下创建子模块service-statistics" class="headerlink" title="1、在service模块下创建子模块service_statistics"></a>1、在service模块下创建子模块service_statistics</h3><h3 id="2、application-properties"><a href="#2、application-properties" class="headerlink" title="2、application.properties"></a><strong>2</strong>、application.properties</h3><p>resources目录下创建文件</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8008# 服务名spring.application.name&#x3D;service-statistics# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;staservice&#x2F;mapper&#x2F;xml&#x2F;*.xml#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848</code></pre></div><h3 id="3、MP代码生成器生成代码"><a href="#3、MP代码生成器生成代码" class="headerlink" title="3、MP代码生成器生成代码"></a>3、MP代码生成器生成代码</h3><h3 id="4、创建SpringBoot启动类"><a href="#4、创建SpringBoot启动类" class="headerlink" title="4、创建SpringBoot启动类"></a>4、创建SpringBoot启动类</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplication@ComponentScan(&#123;&quot;com.atguigu&quot;&#125;)@MapperScan(&quot;com.atguigu.staservice.mapper&quot;)@EnableDiscoveryClient  &#x2F;&#x2F; 开启nacos@EnableFeignClients &#x2F;&#x2F; 开启远程调用public class StaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(StaApplication.class,args);    &#125;&#125;</code></pre></div><h2 id="三、实现服务调用"><a href="#三、实现服务调用" class="headerlink" title="三、实现服务调用"></a>三、实现服务调用</h2><h3 id="1、在service-ucenter模块创建接口，统计某一天的注册人数"><a href="#1、在service-ucenter模块创建接口，统计某一天的注册人数" class="headerlink" title="1、在service_ucenter模块创建接口，统计某一天的注册人数"></a>1、在service_ucenter模块创建接口，统计某一天的注册人数</h3><p><strong>controller</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据日期查询某一天的注册人数@PostMapping(&quot;countRegister&#x2F;&#123;day&#125;&quot;)public R countRegister(@PathVariable String day)&#123;    Integer count &#x3D; memberService.countRegister(day);    return R.ok().data(&quot;countRegister&quot;,count);&#125;</code></pre></div><p><strong>service</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据日期查询某一天的注册人数Integer countRegister(String day);</code></pre></div><p><strong>serviceImpl</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据日期查询某一天的注册人数@Overridepublic Integer countRegister(String day) &#123;    return baseMapper.countRegister(day);&#125;</code></pre></div><p><strong>mapper</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UcenterMemberMapper extends BaseMapper&lt;UcenterMember&gt; &#123;    &#x2F;&#x2F; 查询某一天的注册人数，如果是多个参数，需要用@Param(&quot;day&quot;)    Integer countRegister(@Param(&quot;day&quot;) String day);&#125;</code></pre></div><p><strong>xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;countRegister&quot; resultType&#x3D;&quot;java.lang.Integer&quot;&gt;    SELECT      COUNT(*)    FROM      ucenter_member uc    WHERE DATE(uc.&#96;gmt_create&#96;) &#x3D; #&#123;day&#125;&lt;&#x2F;select&gt;</code></pre></div><h3 id="2、在service-statistics模块创建远程调用接口"><a href="#2、在service-statistics模块创建远程调用接口" class="headerlink" title="2、在service_statistics模块创建远程调用接口"></a>2、在service_statistics模块创建远程调用接口</h3><p>创建client包和UcenterClient接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name &#x3D; &quot;service-ucenter&quot;)public interface UcenterClient &#123;    &#x2F;&#x2F; 根据日期查询某一天的注册人数    @PostMapping(&quot;&#x2F;educenter&#x2F;member&#x2F;countRegister&#x2F;&#123;day&#125;&quot;)    public R countRegister(@PathVariable(&quot;day&quot;) String day);&#125;</code></pre></div><h3 id="3、在service-statistics模块调用微服务"><a href="#3、在service-statistics模块调用微服务" class="headerlink" title="3、在service_statistics模块调用微服务"></a>3、在service_statistics模块调用微服务</h3><p><strong>controller</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;staservice&#x2F;sta&quot;)@CrossOriginpublic class StatisticsDailyController &#123;    @Autowired    private StatisticsDailyService dailyService;    &#x2F;&#x2F; 查询某一天的注册人数，并加入到数据库    @PostMapping(&quot;registerCount&#x2F;&#123;day&#125;&quot;)    public R registerCount(@PathVariable String day)&#123;        dailyService.registerCountDay(day);        return R.ok();    &#125;&#125;</code></pre></div><p><strong>service</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class StatisticsDailyServiceImpl extends ServiceImpl&lt;StatisticsDailyMapper, StatisticsDaily&gt; implements StatisticsDailyService &#123;    @Autowired    private UcenterClient ucenterClient;    &#x2F;&#x2F; 查询某一天的注册人数，并加入到数据库    @Override    public void registerCountDay(String day) &#123;        &#x2F;&#x2F; 添加记录之前先删除相同日期的        QueryWrapper&lt;StatisticsDaily&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;date_calculated&quot;,day);        baseMapper.delete(wrapper);        &#x2F;&#x2F; 调用远程方法，查询数据库        R registerR &#x3D; ucenterClient.countRegister(day);        &#x2F;&#x2F; data中取出人数        Integer countRegister &#x3D; (Integer) registerR.getData().get(&quot;countRegister&quot;);        &#x2F;&#x2F; 将数据加入到数据库        StatisticsDaily daily &#x3D; new StatisticsDaily();        daily.setRegisterNum(countRegister);        daily.setDateCalculated(day);        daily.setLoginNum(RandomUtils.nextInt(100, 200));        daily.setVideoViewNum(RandomUtils.nextInt(100, 200));        daily.setCourseNum(RandomUtils.nextInt(100, 200));        baseMapper.insert(daily);    &#125;&#125;</code></pre></div><h1 id="统计分析-生成统计数据前端整合"><a href="#统计分析-生成统计数据前端整合" class="headerlink" title="统计分析-生成统计数据前端整合"></a>统计分析-生成统计数据前端整合</h1><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;    path: &#39;&#x2F;sta&#39;,    component: Layout,    redirect: &#39;&#x2F;sta&#x2F;create&#39;,    name: &#39;统计分析&#39;,    meta: &#123; title: &#39;统计分析&#39;, icon: &#39;example&#39; &#125;,    children: [      &#123;        path: &#39;create&#39;,        name: &#39;生成数据&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;sta&#x2F;create&#39;),        meta: &#123; title: &#39;生成数据&#39;, icon: &#39;table&#39; &#125;      &#125;,      &#123;        path: &#39;show&#39;,        name: &#39;显示数据&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;sta&#x2F;show&#39;),        meta: &#123; title: &#39;显示数据&#39;, icon: &#39;tree&#39; &#125;      &#125;    ]  &#125;,</code></pre></div><h2 id="创建api"><a href="#创建api" class="headerlink" title="创建api"></a>创建api</h2><p>src/api/sta.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default&#123;    &#x2F;&#x2F; 生成数据    createStaDate(day)&#123;        return request(&#123;            url: &#96;&#x2F;staservice&#x2F;sta&#x2F;registerCount&#x2F;$&#123;day&#125;&#96;,            method: &#39;post&#39;          &#125;)    &#125;&#125;</code></pre></div><h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a><strong>创建组件</strong></h2><p>src/views/sta/create.vue</p><p>模板部分</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    &lt;!--表单--&gt;    &lt;el-form :inline&#x3D;&quot;true&quot; class&#x3D;&quot;demo-form-inline&quot;&gt;      &lt;el-form-item label&#x3D;&quot;日期&quot;&gt;        &lt;el-date-picker          v-model&#x3D;&quot;day&quot;          type&#x3D;&quot;date&quot;          placeholder&#x3D;&quot;选择要统计的日期&quot;          value-format&#x3D;&quot;yyyy-MM-dd&quot; &#x2F;&gt;      &lt;&#x2F;el-form-item&gt;      &lt;el-button        :disabled&#x3D;&quot;btnDisabled&quot;        type&#x3D;&quot;primary&quot;        @click&#x3D;&quot;create()&quot;&gt;生成&lt;&#x2F;el-button&gt;    &lt;&#x2F;el-form&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p>script</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;import sta from &quot;@&#x2F;api&#x2F;sta&quot;export default &#123;    data()&#123;        return&#123;            day:&#39;&#39;,            btnDisabled: false        &#125;    &#125;,    created()&#123;    &#125;,    methods:&#123;        create()&#123;            sta.createStaDate(this.day)                .then(response &#x3D;&gt;&#123;                    &#x2F;&#x2F; 提示信息                    this.$message(&#123;                            type: &#39;success&#39;,                            message: &#39;生成数据成功!&#39;                        &#125;);                    &#x2F;&#x2F; 跳转到生成页面                    this.$router.push(&#123;path:&#39;&#x2F;sta&#x2F;show&#39;&#125;)                &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><h1 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h1><h2 id="1、创建定时任务类，使用cron表达式"><a href="#1、创建定时任务类，使用cron表达式" class="headerlink" title="1、创建定时任务类，使用cron表达式"></a>1、创建定时任务类，使用cron表达式</h2><p><strong>复制日期工具类</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.staservice.utils;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;&#x2F;** * 日期操作工具类 * * @author qy * @since 1.0 *&#x2F;public class DateUtil &#123;    private static final String dateFormat &#x3D; &quot;yyyy-MM-dd&quot;;    &#x2F;**     * 格式化日期     *     * @param date     * @return     *&#x2F;    public static String formatDate(Date date) &#123;        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(dateFormat);        return sdf.format(date);    &#125;    &#x2F;**     * 在日期date上增加amount天 。     *     * @param date   处理的日期，非null     * @param amount 要加的天数，可能为负数     *&#x2F;    public static Date addDays(Date date, int amount) &#123;        Calendar now &#x3D;Calendar.getInstance();        now.setTime(date);        now.set(Calendar.DATE,now.get(Calendar.DATE)+amount);        return now.getTime();    &#125;    public static void main(String[] args) &#123;        System.out.println(DateUtil.formatDate(new Date()));        System.out.println(DateUtil.formatDate(DateUtil.addDays(new Date(), -1)));    &#125;&#125;</code></pre></div><h2 id="2、在启动类上添加注解"><a href="#2、在启动类上添加注解" class="headerlink" title="2、在启动类上添加注解"></a>2、在启动类上添加注解</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">@EnableScheduling   &#x2F;&#x2F; 开启定时任务</code></pre></div><h2 id="3-编写方法"><a href="#3-编写方法" class="headerlink" title="3.编写方法"></a>3.编写方法</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class ScheduledTask &#123;    @Autowired    private StatisticsDailyService dailyService;    &#x2F;&#x2F; 只能是6位，默认年为当前的年    &#x2F;&#x2F; 秒 分 时 日 月 周 年    @Scheduled(cron &#x3D; &quot;0 0 1 * * ?&quot;)    public void task2()&#123;        dailyService.registerCountDay(DateUtil.formatDate(DateUtil.addDays(new Date(), -1)));    &#125;&#x2F;*    &#x2F;&#x2F; 每隔5秒执行一次    @Scheduled(cron &#x3D; &quot;0&#x2F;5 * * * * ?&quot;)    public void task1() &#123;        System.out.println(&quot;*********++++++++++++*****执行了&quot;);    &#125;*&#x2F;&#125;</code></pre></div><p>在线生成工具</p><p><a href="https://www.pppet.net/">https://www.pppet.net/</a></p><h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p><h2 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h2><p>入门参考：官网-&gt;文档-&gt;教程-&gt;5分钟上手ECharts</p><p>（1）创建html页面：柱图.html</p><p>（2）引入ECharts</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!-- 引入 ECharts 文件 --&gt;&lt;script src&#x3D;&quot;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></div><p>（3）定义图表区域</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;&lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt; </code></pre></div><p>（4）渲染图表</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;        &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例        var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;));        &#x2F;&#x2F; 指定图表的配置项和数据        var option &#x3D; &#123;            title: &#123;                text: &#39;ECharts 入门示例&#39;            &#125;,            tooltip: &#123;&#125;,            legend: &#123;                data:[&#39;销量&#39;]            &#125;,            xAxis: &#123;                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]            &#125;,            yAxis: &#123;&#125;,            series: [&#123;                name: &#39;销量&#39;,                type: &#39;bar&#39;,                data: [5, 20, 36, 10, 10, 20]            &#125;]        &#125;;        &#x2F;&#x2F; 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);    &lt;&#x2F;script&gt;</code></pre></div><h2 id="3、折线图"><a href="#3、折线图" class="headerlink" title="3、折线图"></a>3、折线图</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;!-- 引入 ECharts 文件 --&gt;&lt;script src&#x3D;&quot;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;     &lt;script&gt;        var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;));        var option &#x3D; &#123;            &#x2F;&#x2F;x轴是类目轴（离散数据）,必须通过data设置类目数据            xAxis: &#123;                type: &#39;category&#39;,                data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]            &#125;,            &#x2F;&#x2F;y轴是数据轴（连续数据）            yAxis: &#123;                type: &#39;value&#39;            &#125;,            &#x2F;&#x2F;系列列表。每个系列通过 type 决定自己的图表类型            series: [&#123;                &#x2F;&#x2F;系列中的数据内容数组                data: [820, 932, 901, 934, 1290, 1330, 1320],                &#x2F;&#x2F;折线图                type: &#39;line&#39;            &#125;]        &#125;;        myChart.setOption(option);    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h1 id="统计分析-图表显示-页面整合"><a href="#统计分析-图表显示-页面整合" class="headerlink" title="统计分析-图表显示-页面整合"></a>统计分析-图表显示-页面整合</h1><h2 id="1、安装ECharts"><a href="#1、安装ECharts" class="headerlink" title="1、安装ECharts"></a>1、安装ECharts</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --save echarts@4.1.0# 如果不行就用cnpm </code></pre></div><h2 id="3、创建组件"><a href="#3、创建组件" class="headerlink" title="3、创建组件"></a>3、创建组件</h2><p>src/views/sta/show.vue</p><p><strong>模板</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;!--表单--&gt;     &lt;el-form :inline&#x3D;&quot;true&quot; class&#x3D;&quot;demo-form-inline&quot;&gt;       &lt;el-form-item&gt;         &lt;el-select v-model&#x3D;&quot;searchObj.type&quot; clearable placeholder&#x3D;&quot;请选择&quot;&gt;           &lt;el-option label&#x3D;&quot;学员登录数统计&quot; value&#x3D;&quot;login_num&quot;&#x2F;&gt;           &lt;el-option label&#x3D;&quot;学员注册数统计&quot; value&#x3D;&quot;register_num&quot;&#x2F;&gt;           &lt;el-option label&#x3D;&quot;课程播放数统计&quot; value&#x3D;&quot;video_view_num&quot;&#x2F;&gt;           &lt;el-option label&#x3D;&quot;每日课程数统计&quot; value&#x3D;&quot;course_num&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item&gt;         &lt;el-date-picker           v-model&#x3D;&quot;searchObj.begin&quot;           type&#x3D;&quot;date&quot;           placeholder&#x3D;&quot;选择开始日期&quot;           value-format&#x3D;&quot;yyyy-MM-dd&quot; &#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item&gt;         &lt;el-date-picker           v-model&#x3D;&quot;searchObj.end&quot;           type&#x3D;&quot;date&quot;           placeholder&#x3D;&quot;选择截止日期&quot;           value-format&#x3D;&quot;yyyy-MM-dd&quot; &#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-button         :disabled&#x3D;&quot;btnDisabled&quot;         type&#x3D;&quot;primary&quot;         icon&#x3D;&quot;el-icon-search&quot;         @click&#x3D;&quot;showChart()&quot;&gt;查询&lt;&#x2F;el-button&gt;     &lt;&#x2F;el-form&gt;     &lt;div class&#x3D;&quot;chart-container&quot;&gt;       &lt;div id&#x3D;&quot;chart&quot; class&#x3D;&quot;chart&quot; style&#x3D;&quot;height:500px;width:100%&quot; &#x2F;&gt;     &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;</code></pre></div><p><strong>js：暂时显示临时数据</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;import echarts from &#39;echarts&#39; export default &#123;     data()&#123;         return&#123;             searchObj: &#123;                type: &#39;&#39;,                begin: &#39;&#39;,                end: &#39;&#39;            &#125;,            btnDisabled: false,            chart: null,            title: &#39;&#39;,            xData: [],            yData: []         &#125;     &#125;,     created()&#123;     &#125;,     methods:&#123;        showChart()&#123;            &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例            this.chart &#x3D; echarts.init(document.getElementById(&#39;chart&#39;))            &#x2F;&#x2F; console.log(this.chart)            &#x2F;&#x2F; 指定图表的配置项和数据            var option &#x3D; &#123;                &#x2F;&#x2F; x轴是类目轴（离散数据）,必须通过data设置类目数据                xAxis: &#123;                type: &#39;category&#39;,                data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]                &#125;,                &#x2F;&#x2F; y轴是数据轴（连续数据）                yAxis: &#123;                type: &#39;value&#39;                &#125;,                &#x2F;&#x2F; 系列列表。每个系列通过 type 决定自己的图表类型                series: [&#123;                &#x2F;&#x2F; 系列中的数据内容数组                data: [820, 932, 901, 934, 1290, 1330, 1320],                &#x2F;&#x2F; 折线图                type: &#39;line&#39;                        &#125;]            &#125;            this.chart.setOption(option)        &#125;,     &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div><h1 id="统计分析-图标显示接口"><a href="#统计分析-图标显示接口" class="headerlink" title="统计分析-图标显示接口"></a>统计分析-图标显示接口</h1><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 图表显示，返回两部分数据，日期json数组 数量json数组@PostMapping(&quot;showData&#x2F;&#123;type&#125;&#x2F;&#123;begin&#125;&#x2F;&#123;end&#125;&quot;)public R showData(@PathVariable String type,@PathVariable String begin,@PathVariable String end)&#123;    Map&lt;String,Object&gt; map &#x3D; dailyService.getShowData(type,begin,end);    return R.ok().data(map);&#125;</code></pre></div><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 图表显示，返回两部分数据，日期json数组 数量json数组Map&lt;String, Object&gt; getShowData(String type, String begin, String end);</code></pre></div><h2 id="serviceImpl"><a href="#serviceImpl" class="headerlink" title="serviceImpl"></a>serviceImpl</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 图表显示，返回两部分数据，日期json数组 数量json数组@Overridepublic Map&lt;String, Object&gt; getShowData(String type, String begin, String end) &#123;    &#x2F;&#x2F; 先根据条件查询数据    QueryWrapper&lt;StatisticsDaily&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.between(&quot;date_calculated&quot;,begin,end);    &#x2F;&#x2F; 由于只需要某个字段的数据，为了更加精确，所以有select    wrapper.select(&quot;date_calculated&quot;,type);    &#x2F;&#x2F; 查询    List&lt;StatisticsDaily&gt; staList &#x3D; baseMapper.selectList(wrapper);    &#x2F;&#x2F; 按照条件构造日期json数组和数量json数组    List&lt;String&gt; date_calculatedList &#x3D; new ArrayList&lt;&gt;();    List&lt;Integer&gt; numDataList &#x3D; new ArrayList&lt;&gt;();    for (int i &#x3D; 0; i &lt; staList.size(); i++) &#123;        StatisticsDaily daily &#x3D; staList.get(i);        &#x2F;&#x2F; 将时间添加到时间集合        date_calculatedList.add(daily.getDateCalculated());        &#x2F;&#x2F; 用switch判断选择的是哪个类型的数据        switch (type)&#123;            case &quot;login_num&quot;:                numDataList.add(daily.getLoginNum());                break;            case &quot;register_num&quot;:                numDataList.add(daily.getRegisterNum());                break;            case &quot;video_view_num&quot;:                numDataList.add(daily.getVideoViewNum());                break;            case &quot;course_num&quot;:                numDataList.add(daily.getCourseNum());                break;            default:                break;        &#125;    &#125;    &#x2F;&#x2F; 封装数据返回    Map&lt;String, Object&gt; map  &#x3D; new HashMap&lt;&gt;();    map.put(&quot;date_calculatedList&quot;,date_calculatedList);    map.put(&quot;numDataList&quot;,numDataList);    return map;&#125;</code></pre></div><h1 id="统计分析-图表显示前端"><a href="#统计分析-图表显示前端" class="headerlink" title="统计分析-图表显示前端"></a>统计分析-图表显示前端</h1><p>api/sta.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 图表显示getDataShow(searchObj)&#123;    return request(&#123;        url: &#96;&#x2F;staservice&#x2F;sta&#x2F;showData&#x2F;$&#123;searchObj.type&#125;&#x2F;$&#123;searchObj.begin&#125;&#x2F;$&#123;searchObj.end&#125;&#96;,        method: &#39;get&#39;      &#125;)&#125;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;       showChart()&#123;           staApi.getDataShow(this.searchObj)               .then(response &#x3D;&gt;&#123;                   this.xData &#x3D; response.data.date_calculatedList                   this.yData &#x3D; response.data.numDataList                   &#x2F;&#x2F; 调用方法                   this.setChart()               &#125;)        &#125;,       setChart()&#123;           &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例           this.chart &#x3D; echarts.init(document.getElementById(&#39;chart&#39;))           &#x2F;&#x2F; console.log(this.chart)           &#x2F;&#x2F; 指定图表的配置项和数据           var option &#x3D; &#123;               &#x2F;&#x2F; x轴是类目轴（离散数据）,必须通过data设置类目数据               xAxis: &#123;               type: &#39;category&#39;,               data: this.xData               &#125;,               &#x2F;&#x2F; y轴是数据轴（连续数据）               yAxis: &#123;               type: &#39;value&#39;               &#125;,               &#x2F;&#x2F; 系列列表。每个系列通过 type 决定自己的图表类型               series: [&#123;               &#x2F;&#x2F; 系列中的数据内容数组               data: this.yData,               &#x2F;&#x2F; 折线图               type: &#39;line&#39;                      &#125;]           &#125;           this.chart.setOption(option)       &#125;,</code></pre></div><h1 id="样式调整"><a href="#样式调整" class="headerlink" title="样式调整"></a>样式调整</h1><h2 id="1、显示标题"><a href="#1、显示标题" class="headerlink" title="1、显示标题"></a>1、显示标题</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 显示标题title: &#123;text: &quot;数据统计&quot;&#125;,</code></pre></div><h2 id="2、x坐标轴触发提示"><a href="#2、x坐标轴触发提示" class="headerlink" title="2、x坐标轴触发提示"></a>2、x坐标轴触发提示</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; x坐标轴触发提示tooltip: &#123;trigger: &#39;axis&#39;&#125;,</code></pre></div><h2 id="3、区域缩放"><a href="#3、区域缩放" class="headerlink" title="3、区域缩放"></a>3、区域缩放</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 区域缩放dataZoom: [&#123;    show: true,    height: 30,    xAxisIndex: [    0    ],    bottom: 30,    start: 10,    end: 80,    handleIcon: &#39;path:&#x2F;&#x2F;M306.1,413c0,2.2-1.8,4-4,4h-59.8c-2.2,0-4-1.8-4-4V200.8c0-2.2,1.8-4,4-4h59.8c2.2,0,4,1.8,4,4V413z&#39;,    handleSize: &#39;110%&#39;,    handleStyle: &#123;    color: &#39;#d3dee5&#39;    &#125;,    textStyle: &#123;    color: &#39;#fff&#39;    &#125;,    borderColor: &#39;#90979c&#39;    &#125;,    &#123;        type: &#39;inside&#39;,        show: true,        height: 15,        start: 1,        end: 35&#125;]</code></pre></div><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day15-课程评论分析_支付功能</title>
    <link href="/myBlog/day15-%E8%AF%BE%E7%A8%8B%E8%AF%84%E8%AE%BA%E5%88%86%E6%9E%90_%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/"/>
    <url>/myBlog/day15-%E8%AF%BE%E7%A8%8B%E8%AF%84%E8%AE%BA%E5%88%86%E6%9E%90_%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="day15-课程评论分析-支付功能"><a href="#day15-课程评论分析-支付功能" class="headerlink" title="day15-课程评论分析_支付功能"></a>day15-课程评论分析_支付功能</h1><h1 id="课程评论实现过程分析-TODO"><a href="#课程评论实现过程分析-TODO" class="headerlink" title="课程评论实现过程分析(TODO)"></a>课程评论实现过程分析(TODO)</h1><p>![02 课程评论实现过程分析](day15-课程评论分析_支付功能/02 课程评论实现过程分析.png)</p><h2 id="一、数据库设计"><a href="#一、数据库设计" class="headerlink" title="一、数据库设计"></a>一、数据库设计</h2><h3 id="1、数据库"><a href="#1、数据库" class="headerlink" title="1、数据库"></a>1、数据库</h3><p>edu_comment</p><h3 id="2、数据表"><a href="#2、数据表" class="headerlink" title="2、数据表"></a><strong>2、数据表</strong></h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">guli_edu.sql</code></pre></div><h2 id="二、创建课程评论接口"><a href="#二、创建课程评论接口" class="headerlink" title="二、创建课程评论接口"></a><strong>二、创建课程评论接口</strong></h2><h3 id="1、在service-edu模块，生成课程评论代码"><a href="#1、在service-edu模块，生成课程评论代码" class="headerlink" title="1、在service-edu模块，生成课程评论代码"></a>1、在service-edu模块，生成课程评论代码</h3><p>（1）使用mp代码生成器生成</p><h3 id="2、在service-ucenter模块，创建接口"><a href="#2、在service-ucenter模块，创建接口" class="headerlink" title="2、在service-ucenter模块，创建接口"></a>2、在service-ucenter模块，创建接口</h3><p>（1）实现用户id获取用户信息，返回用户信息对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据token字符串获取用户信息@PostMapping(&quot;getInfoUc&#x2F;&#123;id&#125;&quot;)public com.atguigu.commonutils.vo.UcenterMember getInfo(@PathVariable String id) &#123;        &#x2F;&#x2F;根据用户id获取用户信息        UcenterMember ucenterMember &#x3D; memberService.getById(id);        com.atguigu.commonutils.vo.UcenterMember memeber &#x3D; new com.atguigu.commonutils.vo.UcenterMember();        BeanUtils.copyProperties(ucenterMember,memeber);        return memeber;&#125;</code></pre></div><h3 id="3、创建课程评论controller"><a href="#3、创建课程评论controller" class="headerlink" title="3、创建课程评论controller"></a><strong>3、创建课程评论controller</strong></h3><p>（1）在service-edu模块创建client，实现微服务调用</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name&#x3D;&quot;service-ucenter&quot;,fallback &#x3D; UcenterClientImpl.class)public interface UcenterClient &#123;    &#x2F;&#x2F;根据用户id获取用户信息    @GetMapping(&quot;&#x2F;ucenterservice&#x2F;member&#x2F;getUcenterPay&#x2F;&#123;memberId&#125;&quot;)    public UcenterMemberPay getUcenterPay(@PathVariable(&quot;memberId&quot;) String memberId);&#125;@Componentpublic class UcenterClientImpl implements UcenterClient &#123;    @Override    public UcenterMemberPay getUcenterPay(String memberId) &#123;        return null;    &#125;&#125;</code></pre></div><p>（2）创建评论列表和添加评论接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;comment&quot;)@CrossOriginpublic class CommentFrontController &#123;    @Autowired    private CommentService commentService;    @Autowired    private UcenterClient ucenterClient;    &#x2F;&#x2F;根据课程id查询评论列表    @ApiOperation(value &#x3D; &quot;评论分页列表&quot;)    @GetMapping(&quot;&#123;page&#125;&#x2F;&#123;limit&#125;&quot;)    public R index(            @ApiParam(name &#x3D; &quot;page&quot;, value &#x3D; &quot;当前页码&quot;, required &#x3D; true)            @PathVariable Long page,            @ApiParam(name &#x3D; &quot;limit&quot;, value &#x3D; &quot;每页记录数&quot;, required &#x3D; true)            @PathVariable Long limit,            @ApiParam(name &#x3D; &quot;courseQuery&quot;, value &#x3D; &quot;查询对象&quot;, required &#x3D; false)                    String courseId) &#123;        Page&lt;Comment&gt; pageParam &#x3D; new Page&lt;&gt;(page, limit);        QueryWrapper&lt;Comment&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;course_id&quot;,courseId);        commentService.page(pageParam,wrapper);        List&lt;Comment&gt; commentList &#x3D; pageParam.getRecords();        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(&quot;items&quot;, commentList);        map.put(&quot;current&quot;, pageParam.getCurrent());        map.put(&quot;pages&quot;, pageParam.getPages());        map.put(&quot;size&quot;, pageParam.getSize());        map.put(&quot;total&quot;, pageParam.getTotal());        map.put(&quot;hasNext&quot;, pageParam.hasNext());        map.put(&quot;hasPrevious&quot;, pageParam.hasPrevious());        return R.ok().data(map);    &#125;    @ApiOperation(value &#x3D; &quot;添加评论&quot;)    @PostMapping(&quot;auth&#x2F;save&quot;)    public R save(@RequestBody Comment comment, HttpServletRequest request) &#123;        String memberId &#x3D; JwtUtils.getMemberIdByJwtToken(request);        if(StringUtils.isEmpty(memberId)) &#123;            return R.error().code(28004).message(&quot;请登录&quot;);        &#125;        comment.setMemberId(memberId);        UcenterMemberPay ucenterInfo &#x3D; ucenterClient.getUcenterPay(memberId);        comment.setNickname(ucenterInfo.getNickname());        comment.setAvatar(ucenterInfo.getAvatar());        commentService.save(comment);        return R.ok();    &#125;&#125;</code></pre></div><h2 id="三、课程评论前端整合"><a href="#三、课程评论前端整合" class="headerlink" title="三、课程评论前端整合"></a>三、课程评论前端整合</h2><h3 id="1、在api创建commonedu-js"><a href="#1、在api创建commonedu-js" class="headerlink" title="1、在api创建commonedu.js"></a>1、在api创建commonedu.js</h3><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;  getPageList(page, limit, courseId) &#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;comment&#x2F;$&#123;page&#125;&#x2F;$&#123;limit&#125;&#96;,      method: &#39;get&#39;,      params: &#123;courseId&#125;    &#125;)  &#125;,  addComment(comment) &#123;    return request(&#123;      url: &#96;&#x2F;eduservice&#x2F;comment&#x2F;auth&#x2F;save&#96;,      method: &#39;post&#39;,      data: comment    &#125;)  &#125;&#125;</code></pre></div><h3 id="2、在课程详情页面，调用方法-id-vue"><a href="#2、在课程详情页面，调用方法-id-vue" class="headerlink" title="2、在课程详情页面，调用方法 _id.vue"></a>2、在课程详情页面，调用方法 _id.vue</h3><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import comment from &#39;@&#x2F;api&#x2F;commonedu&#39;2 3&lt;script&gt;4import course from &#39;@&#x2F;api&#x2F;course&#39;5import comment from &#39;@&#x2F;api&#x2F;commonedu&#39;6export default &#123;      &#x2F;&#x2F;和页面异步开始的   asyncData(&#123; params, error &#125;) &#123;     return &#123;courseId: params.id&#125;   &#125;,   data() &#123;     return &#123;       data:&#123;&#125;,       page:1,       limit:4,       total:10,       comment:&#123;         content:&#39;&#39;,         courseId:&#39;&#39;       &#125;,       courseInfo:&#123;&#125;,       chapterVideoList:[],       isbuyCourse:false     &#125;   &#125;,   created() &#123;     this.initCourseInfo()     this.initComment()   &#125;,   methods:&#123;     &#x2F;&#x2F;获取课程详情     initCourseInfo() &#123;       course.getCourseInfo(this.courseId)             .then(response &#x3D;&gt; &#123;               this.courseInfo&#x3D;response.data.data.courseFrontInfo               this.chapterVideoList&#x3D;response.data.data.chapterVideoList               this.isbuyCourse&#x3D;response.data.data.isbuyCourse             &#125;)     &#125;,     initComment()&#123;        comment.getPageList(this.page, this.limit, this.courseId).then(response &#x3D;&gt; &#123;            this.data &#x3D; response.data.data        &#125;)     &#125;,     addComment()&#123;         this.comment.courseId &#x3D; this.courseId         this.comment.teacherId &#x3D; this.courseInfo.teacherId         comment.addComment(this.comment).then(response &#x3D;&gt; &#123;             if(response.data.success)&#123;                 this.comment.content &#x3D; &#39;&#39;                 this.initComment()             &#125;         &#125;)     &#125;,     gotoPage(page)&#123;           comment.getPageList(page, this.limit,this.courseId).then(response &#x3D;&gt; &#123;               this.data &#x3D; response.data.data           &#125;)       &#125;   &#125; &#125;; &lt;&#x2F;script&gt;</code></pre></div><h3 id="3、在课程详情页面-id-vue显示评论"><a href="#3、在课程详情页面-id-vue显示评论" class="headerlink" title="3、在课程详情页面 _id.vue显示评论"></a>3、在课程详情页面 _id.vue显示评论</h3><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;div class&#x3D;&quot;mt50 commentHtml&quot;&gt;&lt;div&gt;       &lt;h6 class&#x3D;&quot;c-c-content c-infor-title&quot; id&#x3D;&quot;i-art-comment&quot;&gt;         &lt;span class&#x3D;&quot;commentTitle&quot;&gt;课程评论&lt;&#x2F;span&gt;       &lt;&#x2F;h6&gt;       &lt;section class&#x3D;&quot;lh-bj-list pr mt20 replyhtml&quot;&gt;         &lt;ul&gt;           &lt;li class&#x3D;&quot;unBr&quot;&gt;             &lt;aside class&#x3D;&quot;noter-pic&quot;&gt;               &lt;img width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; class&#x3D;&quot;picImg&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;avatar-boy.gif&quot;&gt;               &lt;&#x2F;aside&gt;             &lt;div class&#x3D;&quot;of&quot;&gt;               &lt;section class&#x3D;&quot;n-reply-wrap&quot;&gt;                 &lt;fieldset&gt;                   &lt;textarea name&#x3D;&quot;&quot; v-model&#x3D;&quot;comment.content&quot; placeholder&#x3D;&quot;输入您要评论的文字&quot; id&#x3D;&quot;commentContent&quot;&gt;&lt;&#x2F;textarea&gt;                 &lt;&#x2F;fieldset&gt;                 &lt;p class&#x3D;&quot;of mt5 tar pl10 pr10&quot;&gt;                   &lt;span class&#x3D;&quot;fl &quot;&gt;&lt;tt class&#x3D;&quot;c-red commentContentmeg&quot; style&#x3D;&quot;display: none;&quot;&gt;&lt;&#x2F;tt&gt;&lt;&#x2F;span&gt;                   &lt;input type&#x3D;&quot;button&quot; @click&#x3D;&quot;addComment()&quot; value&#x3D;&quot;回复&quot; class&#x3D;&quot;lh-reply-btn&quot;&gt;                 &lt;&#x2F;p&gt;               &lt;&#x2F;section&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;li&gt;         &lt;&#x2F;ul&gt;       &lt;&#x2F;section&gt;       &lt;section class&#x3D;&quot;&quot;&gt;           &lt;section class&#x3D;&quot;question-list lh-bj-list pr&quot;&gt;             &lt;ul class&#x3D;&quot;pr10&quot;&gt;               &lt;li v-for&#x3D;&quot;(comment,index) in data.items&quot; v-bind:key&#x3D;&quot;index&quot;&gt;                   &lt;aside class&#x3D;&quot;noter-pic&quot;&gt;                     &lt;img width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot; class&#x3D;&quot;picImg&quot; :src&#x3D;&quot;comment.avatar&quot;&gt;                     &lt;&#x2F;aside&gt;                   &lt;div class&#x3D;&quot;of&quot;&gt;                     &lt;span class&#x3D;&quot;fl&quot;&gt;                      &lt;font class&#x3D;&quot;fsize12 c-blue&quot;&gt;                        &#123;&#123;comment.nickname&#125;&#125;&lt;&#x2F;font&gt;                     &lt;font class&#x3D;&quot;fsize12 c-999 ml5&quot;&gt;评论：&lt;&#x2F;font&gt;&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;noter-txt mt5&quot;&gt;                     &lt;p&gt;&#123;&#123;comment.content&#125;&#125;&lt;&#x2F;p&gt;                   &lt;&#x2F;div&gt;                   &lt;div class&#x3D;&quot;of mt5&quot;&gt;                     &lt;span class&#x3D;&quot;fr&quot;&gt;&lt;font class&#x3D;&quot;fsize12 c-999 ml5&quot;&gt;&#123;&#123;comment.gmtCreate&#125;&#125;&lt;&#x2F;font&gt;&lt;&#x2F;span&gt;                   &lt;&#x2F;div&gt;                 &lt;&#x2F;li&gt;               &lt;&#x2F;ul&gt;           &lt;&#x2F;section&gt;         &lt;&#x2F;section&gt;         &lt;!-- 公共分页 开始 --&gt;         &lt;div class&#x3D;&quot;paging&quot;&gt;             &lt;!-- undisable这个class是否存在，取决于数据属性hasPrevious --&gt;             &lt;a             :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;             href&#x3D;&quot;#&quot;             title&#x3D;&quot;首页&quot;             @click.prevent&#x3D;&quot;gotoPage(1)&quot;&gt;首&lt;&#x2F;a&gt;             &lt;a             :class&#x3D;&quot;&#123;undisable: !data.hasPrevious&#125;&quot;             href&#x3D;&quot;#&quot;             title&#x3D;&quot;前一页&quot;             @click.prevent&#x3D;&quot;gotoPage(data.current-1)&quot;&gt;&lt;&lt;&#x2F;a&gt;             &lt;a             v-for&#x3D;&quot;page in data.pages&quot;             :key&#x3D;&quot;page&quot;             :class&#x3D;&quot;&#123;current: data.current &#x3D;&#x3D; page, undisable: data.current &#x3D;&#x3D; page&#125;&quot;             :title&#x3D;&quot;&#39;第&#39;+page+&#39;页&#39;&quot;             href&#x3D;&quot;#&quot;             @click.prevent&#x3D;&quot;gotoPage(page)&quot;&gt;&#123;&#123; page &#125;&#125;&lt;&#x2F;a&gt;             &lt;a             :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;             href&#x3D;&quot;#&quot;             title&#x3D;&quot;后一页&quot;             @click.prevent&#x3D;&quot;gotoPage(data.current+1)&quot;&gt;&gt;&lt;&#x2F;a&gt;             &lt;a             :class&#x3D;&quot;&#123;undisable: !data.hasNext&#125;&quot;             href&#x3D;&quot;#&quot;             title&#x3D;&quot;末页&quot;             @click.prevent&#x3D;&quot;gotoPage(data.pages)&quot;&gt;末&lt;&#x2F;a&gt;             &lt;div class&#x3D;&quot;clear&quot;&#x2F;&gt;         &lt;&#x2F;div&gt;         &lt;!-- 公共分页 结束 --&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;div&gt;</code></pre></div><h1 id="课程支付功能0"><a href="#课程支付功能0" class="headerlink" title="课程支付功能0"></a>课程支付功能0</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>![03 课程支付需求分析](day15-课程评论分析_支付功能/03 课程支付需求分析.png)</p><h2 id="所需接口"><a href="#所需接口" class="headerlink" title="所需接口"></a>所需接口</h2><p>![04 课程支付接口](day15-课程评论分析_支付功能/04 课程支付接口.png)</p><h2 id="创建支付模块和准备"><a href="#创建支付模块和准备" class="headerlink" title="创建支付模块和准备"></a>创建支付模块和准备</h2><p>1、在service模块下创建子模块service_order</p><p>2、在service_order模块中引入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.wxpay&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;wxpay-sdk&lt;&#x2F;artifactId&gt;        &lt;version&gt;0.0.3&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>3、创建支付相关的表</p><p>4、使用代码生成器生成相关代码</p><p>5、编写application.properties配置文件</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8007# 服务名spring.application.name&#x3D;service-order# mysql数据库连接spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driverspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;guli?serverTimezone&#x3D;GMT%2B8spring.datasource.username&#x3D;rootspring.datasource.password&#x3D;root#返回json的全局时间格式spring.jackson.date-format&#x3D;yyyy-MM-dd HH:mm:ssspring.jackson.time-zone&#x3D;GMT+8#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;eduorder&#x2F;mapper&#x2F;xml&#x2F;*.xml#mybatis日志mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl# nacos服务地址spring.cloud.nacos.discovery.server-addr&#x3D;127.0.0.1:8848#开启熔断机制#feign.hystrix.enabled&#x3D;true# 设置hystrix超时时间，默认1000ms#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds&#x3D;3000</code></pre></div><h2 id="开发创建订单接口"><a href="#开发创建订单接口" class="headerlink" title="开发创建订单接口"></a>开发创建订单接口</h2><p>1、编写订单controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduorder&#x2F;order&quot;)@CrossOriginpublic class OrderController &#123;    @Autowired    private OrderService orderService;    &#x2F;&#x2F; 根据课程id，生成订单的方法，返回订单号    @PostMapping(&quot;createOrder&#x2F;&#123;id&#125;&quot;)    public R saveOrder(@PathVariable String id, HttpServletRequest request)&#123;        String orderId &#x3D; orderService.createOrder(id,JwtUtils.getMemberIdByJwtToken(request));        return R.ok().data(&quot;orderId&quot;,orderId);    &#125;&#125;</code></pre></div><p>2、在service_edu创建接口</p><p>（1）实现根据课程id获取课程信息，返回课程信息对象(所需要的返回对象，直接复制原来的实体类到公共模块即可)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id，查询课程信息@PostMapping(&quot;getCourseInfoOrder&#x2F;&#123;id&#125;&quot;)public CourseWebVoOrder getCourseInfoOrder(@PathVariable String id)&#123;    CourseWebVo courseInfo &#x3D; courseService.getBaseCourseInfo(id);    CourseWebVoOrder courseWebVoOrder &#x3D; new CourseWebVoOrder();    BeanUtils.copyProperties(courseInfo,courseWebVoOrder);    return courseWebVoOrder;&#125;</code></pre></div><p>3、在service_ucenter创建接口</p><p>（1）实现用户id获取用户信息，返回用户信息对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据用户id查询用户信息，前台@PostMapping(&quot;getUserInfoOrder&#x2F;&#123;id&#125;&quot;)public UcenterMemberOrder getUserInfoOrder(@PathVariable String id)&#123;    UcenterMember member &#x3D; memberService.getById(id);    UcenterMemberOrder ucenterMemberOrder &#x3D; new UcenterMemberOrder();    BeanUtils.copyProperties(member,ucenterMemberOrder);    return ucenterMemberOrder;&#125;</code></pre></div><p>4、编写订单service</p><p>（1）在service_order模块创建接口，实现远程调用</p><p><strong>EduClient</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name &#x3D; &quot;service-edu&quot;)public interface EduClient &#123;    &#x2F;&#x2F; 根据课程id，查询课程信息    @PostMapping(&quot;&#x2F;eduservice&#x2F;coursefront&#x2F;getCourseInfoOrder&#x2F;&#123;id&#125;&quot;)    public CourseWebVoOrder getCourseInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125;</code></pre></div><p><strong>UcenterClient</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@FeignClient(name &#x3D; &quot;service-ucenter&quot;)public interface UcenterClient &#123;    &#x2F;&#x2F; 根据用户id查询用户信息，前台    @PostMapping(&quot;&#x2F;educenter&#x2F;member&#x2F;getUserInfoOrder&#x2F;&#123;id&#125;&quot;)    public UcenterMemberOrder getUserInfoOrder(@PathVariable(&quot;id&quot;) String id);&#125;</code></pre></div><p>(2）在service_order模块编写创建订单service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class OrderServiceImpl extends ServiceImpl&lt;OrderMapper, Order&gt; implements OrderService &#123;    @Autowired    private EduClient eduClient;    @Autowired    private UcenterClient ucenterClient;    &#x2F;&#x2F; 根据课程id，生成订单的方法，返回订单号    @Override    public String createOrder(String courseId, String memberId) &#123;        &#x2F;&#x2F; 1.根据课程id查询课程信息        CourseWebVoOrder courseInfoOrder &#x3D; eduClient.getCourseInfoOrder(courseId);        &#x2F;&#x2F; 2.根据用户id，查询用户信息        UcenterMemberOrder userInfoOrder &#x3D; ucenterClient.getUserInfoOrder(memberId);        &#x2F;&#x2F; 加到数据库        Order order &#x3D; new Order();        order.setOrderNo(OrderNoUtil.getOrderNo());                 &#x2F;&#x2F; 订单号        order.setCourseId(courseId);        order.setCourseTitle(courseInfoOrder.getTitle());        order.setCourseCover(courseInfoOrder.getCover());        order.setTeacherName(courseInfoOrder.getTeacherName());        order.setTotalFee(courseInfoOrder.getPrice());        order.setMemberId(memberId);        order.setMobile(userInfoOrder.getMobile());        order.setNickname(userInfoOrder.getNickname());        order.setStatus(0);     &#x2F;&#x2F; 订单状态（0：未支付 1：已支付）        order.setPayType(1);    &#x2F;&#x2F; 支付类型（1：微信 2：支付宝）        baseMapper.insert(order);        &#x2F;&#x2F; 返回订单号        return order.getOrderNo();    &#125;&#125;</code></pre></div><p><strong>OrderNoUtil</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 订单号工具类 * * @author qy * @since 1.0 *&#x2F;public class OrderNoUtil &#123;    &#x2F;**     * 获取订单号     * @return     *&#x2F;    public static String getOrderNo() &#123;        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);        String newDate &#x3D; sdf.format(new Date());        String result &#x3D; &quot;&quot;;        Random random &#x3D; new Random();        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            result +&#x3D; random.nextInt(10);        &#125;        return newDate + result;    &#125;&#125;</code></pre></div><h2 id="开发获取订单接口"><a href="#开发获取订单接口" class="headerlink" title="开发获取订单接口"></a>开发获取订单接口</h2><p>1、在订单controller创建根据id获取订单信息接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据订单号查询订单信息@GetMapping(&quot;getOrder&#x2F;&#123;orderId&#125;&quot;)public R getOrder(@PathVariable String orderId)&#123;    QueryWrapper&lt;Order&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;order_no&quot;,orderId);    Order order &#x3D; orderService.getOne(wrapper);    return R.ok().data(&quot;item&quot;,order);&#125;</code></pre></div><h2 id="生成订单前端整合"><a href="#生成订单前端整合" class="headerlink" title="生成订单前端整合"></a>生成订单前端整合</h2><h3 id="页面样式修改"><a href="#页面样式修改" class="headerlink" title="页面样式修改"></a>页面样式修改</h3><p><strong>1、复制样式文件到assets</strong></p><p><img src="/myBlog/day15-%E8%AF%BE%E7%A8%8B%E8%AF%84%E8%AE%BA%E5%88%86%E6%9E%90_%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/image-20220103163408936.png" alt="image-20220103163408936"></p><p><strong>2、修改default.vue页面</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import &#39;~&#x2F;assets&#x2F;css&#x2F;reset.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;theme.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;global.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;web.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;base.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;activity_tab.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;bottom_rec.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;nice_select.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;order.css&#39;import &#39;~&#x2F;assets&#x2F;css&#x2F;swiper-3.3.1.min.css&#39;import &quot;~&#x2F;assets&#x2F;css&#x2F;pages-weixinpay.css&quot;</code></pre></div><h3 id="课程支付前端"><a href="#课程支付前端" class="headerlink" title="课程支付前端"></a><strong>课程支付前端</strong></h3><p>1、在api文件夹下创建order.js文件</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default &#123;  &#x2F;&#x2F; 创建订单  createOrder(courseId) &#123;    return request(&#123;      url: &#96;&#x2F;eduorder&#x2F;order&#x2F;createOrder&#x2F;$&#123;courseId&#125;&#96;,      method: &#39;post&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 根据订单号查询订单信息  getOrderInfo(id) &#123;    return request(&#123;      url: &#96;&#x2F;eduorder&#x2F;order&#x2F;getOrder&#x2F;$&#123;id&#125;&#96;,      method: &#39;get&#39;    &#125;)  &#125;&#125;</code></pre></div><p>2、在课程详情页面中添加创建订单方法</p><p>在“立即购买”位置添加事件</p><p><img src="/myBlog/day15-%E8%AF%BE%E7%A8%8B%E8%AF%84%E8%AE%BA%E5%88%86%E6%9E%90_%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/image-20220103163638975.png" alt="image-20220103163638975"></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;   &#x2F;&#x2F; 创建订单   createOrder()&#123;     order.createOrder(this.courseId)       .then(response &#x3D;&gt;&#123;         &#x2F;&#x2F; 获取返回的订单号         &#x2F;&#x2F; 将订单号放在路径上跳转订单显示页面         this.$router.push(&#123;path:&#39;&#x2F;order&#x2F;&#39;+response.data.data.orderId &#125;)       &#125;)   &#125;&#125;</code></pre></div><h3 id="创建订单页面，显示订单信息"><a href="#创建订单页面，显示订单信息" class="headerlink" title="创建订单页面，显示订单信息"></a><strong>创建订单页面，显示订单信息</strong></h3><p>在pages下面创建order文件夹，创建_oid.vue页面</p><p>在_oid.vue页面调用方法，获取订单信息</p><p>（1）页面部分</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;Page Confirm&quot;&gt;     &lt;div class&#x3D;&quot;Title&quot;&gt;       &lt;h1 class&#x3D;&quot;fl f18&quot;&gt;订单确认&lt;&#x2F;h1&gt;       &lt;img src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;cart_setp2.png&quot; class&#x3D;&quot;fr&quot;&gt;       &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;     &lt;&#x2F;div&gt;     &lt;form name&#x3D;&quot;flowForm&quot; id&#x3D;&quot;flowForm&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;&quot;&gt;       &lt;table class&#x3D;&quot;GoodList&quot;&gt;         &lt;tbody&gt;         &lt;tr&gt;           &lt;th class&#x3D;&quot;name&quot;&gt;商品&lt;&#x2F;th&gt;           &lt;th class&#x3D;&quot;price&quot;&gt;原价&lt;&#x2F;th&gt;           &lt;th class&#x3D;&quot;priceNew&quot;&gt;价格&lt;&#x2F;th&gt;         &lt;&#x2F;tr&gt;         &lt;&#x2F;tbody&gt;         &lt;tbody&gt;         &lt;!-- &lt;tr&gt;           &lt;td colspan&#x3D;&quot;3&quot; class&#x3D;&quot;Title red f18 fb&quot;&gt;&lt;p&gt;限时折扣&lt;&#x2F;p&gt;&lt;&#x2F;td&gt;         &lt;&#x2F;tr&gt; --&gt;         &lt;tr&gt;           &lt;td colspan&#x3D;&quot;3&quot; class&#x3D;&quot;teacher&quot;&gt;讲师：&#123;&#123;order.teacherName&#125;&#125;&lt;&#x2F;td&gt;         &lt;&#x2F;tr&gt;         &lt;tr class&#x3D;&quot;good&quot;&gt;           &lt;td class&#x3D;&quot;name First&quot;&gt;             &lt;a target&#x3D;&quot;_blank&quot; :href&#x3D;&quot;&#39;https:&#x2F;&#x2F;localhost:3000&#x2F;course&#x2F;&#39;+order.courseId&quot;&gt;               &lt;img :src&#x3D;&quot;order.courseCover&quot;&gt;&lt;&#x2F;a&gt;             &lt;div class&#x3D;&quot;goodInfo&quot;&gt;               &lt;input type&#x3D;&quot;hidden&quot; class&#x3D;&quot;ids ids_14502&quot; value&#x3D;&quot;14502&quot;&gt;               &lt;a target&#x3D;&quot;_blank&quot; :href&#x3D;&quot;&#39;https:&#x2F;&#x2F;localhost:3000&#x2F;course&#x2F;&#39;+ order.courseId&quot;&gt;&#123;&#123;order.courseTitle&#125;&#125;&lt;&#x2F;a&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;td&gt;           &lt;td class&#x3D;&quot;price&quot;&gt;             &lt;p&gt;￥&lt;strong&gt;&#123;&#123;order.totalFee&#125;&#125;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;             &lt;!-- &lt;span class&#x3D;&quot;discName red&quot;&gt;限时8折&lt;&#x2F;span&gt; --&gt;           &lt;&#x2F;td&gt;           &lt;td class&#x3D;&quot;red priceNew Last&quot;&gt;￥&lt;strong&gt;&#123;&#123;order.totalFee&#125;&#125;&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;         &lt;&#x2F;tr&gt;         &lt;tr&gt;           &lt;td class&#x3D;&quot;Billing tr&quot; colspan&#x3D;&quot;3&quot;&gt;             &lt;div class&#x3D;&quot;tr&quot;&gt;               &lt;p&gt;共 &lt;strong class&#x3D;&quot;red&quot;&gt;1&lt;&#x2F;strong&gt; 件商品，合计&lt;span                 class&#x3D;&quot;red f20&quot;&gt;￥&lt;strong&gt;&#123;&#123;order.totalFee&#125;&#125;&lt;&#x2F;strong&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;td&gt;         &lt;&#x2F;tr&gt;         &lt;&#x2F;tbody&gt;       &lt;&#x2F;table&gt;       &lt;div class&#x3D;&quot;Finish&quot;&gt;         &lt;div class&#x3D;&quot;fr&quot; id&#x3D;&quot;AgreeDiv&quot;&gt;           &lt;label for&#x3D;&quot;Agree&quot;&gt;&lt;p class&#x3D;&quot;on&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; checked&#x3D;&quot;checked&quot;&gt;我已阅读并同意&lt;a href&#x3D;&quot;javascript:&quot; target&#x3D;&quot;_blank&quot;&gt;《谷粒学院购买协议》&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;&lt;&#x2F;label&gt;         &lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;Main fl&quot;&gt;           &lt;div class&#x3D;&quot;fl&quot;&gt;             &lt;a :href&#x3D;&quot;&#39;&#x2F;course&#x2F;&#39;+order.courseId&quot;&gt;返回课程详情页&lt;&#x2F;a&gt;           &lt;&#x2F;div&gt;           &lt;div class&#x3D;&quot;fr&quot;&gt;             &lt;p&gt;共 &lt;strong class&#x3D;&quot;red&quot;&gt;1&lt;&#x2F;strong&gt; 件商品，合计&lt;span class&#x3D;&quot;red f20&quot;&gt;￥&lt;strong               id&#x3D;&quot;AllPrice&quot;&gt;&#123;&#123;order.totalFee&#125;&#125;&lt;&#x2F;strong&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;         &lt;input name&#x3D;&quot;score&quot; value&#x3D;&quot;0&quot; type&#x3D;&quot;hidden&quot; id&#x3D;&quot;usedScore&quot;&gt;         &lt;button class&#x3D;&quot;fr redb&quot; type&#x3D;&quot;button&quot; id&#x3D;&quot;submitPay&quot; @click&#x3D;&quot;toPay()&quot;&gt;去支付&lt;&#x2F;button&gt;         &lt;div class&#x3D;&quot;clear&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;</code></pre></div><p>（2）调用部分</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    import orderApi from &quot;@&#x2F;api&#x2F;order&quot;export default &#123;    &#x2F;&#x2F; 订单详情    asyncData(&#123;params,error&#125;)&#123;        return orderApi.getOrderInfo(params.oid)           .then(response &#x3D;&gt;&#123;               return&#123;                   order:response.data.data.item               &#125;           &#125;)    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><h2 id="生成微信支付二维码接口"><a href="#生成微信支付二维码接口" class="headerlink" title="生成微信支付二维码接口"></a>生成微信支付二维码接口</h2><p>需要用的信息</p><img src="/myBlog/day15-%E8%AF%BE%E7%A8%8B%E8%AF%84%E8%AE%BA%E5%88%86%E6%9E%90_%E6%94%AF%E4%BB%98%E5%8A%9F%E8%83%BD/image-20220103173830092.png" alt="image-20220103173830092"><h3 id="1、编写controller"><a href="#1、编写controller" class="headerlink" title="1、编写controller"></a>1、编写controller</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduorder&#x2F;paylog&quot;)@CrossOriginpublic class PayLogController &#123;    @Autowired    private PayLogService payLogService;    &#x2F;&#x2F; 生成微信支付二维码    @GetMapping(&quot;createNative&#x2F;&#123;orderNo&#125;&quot;)    public R createNative(@PathVariable String orderNo)&#123;        &#x2F;&#x2F; 需要返回二维码和订单信息        Map map &#x3D; payLogService.createNative(orderNo);        return R.ok().data(map);    &#125;&#125;</code></pre></div><h3 id="2、编写service"><a href="#2、编写service" class="headerlink" title="2、编写service"></a><strong>2、编写service</strong></h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">1@Servicepublic class PayLogServiceImpl extends ServiceImpl&lt;PayLogMapper, PayLog&gt; implements PayLogService &#123;    @Autowired    private OrderService orderService;    &#x2F;&#x2F; 生成微信支付二维码    @Override    public Map createNative(String orderNo) &#123;        try &#123;            &#x2F;&#x2F; 1.根据订单号，查询订单信息            QueryWrapper&lt;Order&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();            wrapper.eq(&quot;order_no&quot;,orderNo);            Order order &#x3D; orderService.getOne(wrapper);            &#x2F;&#x2F; 2.用map封装生成二维码需要的参数            Map m &#x3D; new HashMap();            m.put(&quot;appid&quot;, &quot;wx74862e0dfcf69954&quot;);            m.put(&quot;mch_id&quot;, &quot;1558950191&quot;);            m.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr());   &#x2F;&#x2F; 生成随机的字符串，让每一个二维码都不一样            m.put(&quot;body&quot;, order.getCourseTitle());  &#x2F;&#x2F; 课程标题            m.put(&quot;out_trade_no&quot;, orderNo);         &#x2F;&#x2F; 订单号            &#x2F;&#x2F; 将BigDecimal类型先转换为long，再转换为字符串            m.put(&quot;total_fee&quot;, order.getTotalFee().multiply(new BigDecimal(&quot;100&quot;)).longValue()+&quot;&quot;);            m.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;);            m.put(&quot;notify_url&quot;, &quot;http:&#x2F;&#x2F;guli.shop&#x2F;api&#x2F;order&#x2F;weixinPay&#x2F;weixinNotify\n&quot;);            m.put(&quot;trade_type&quot;, &quot;NATIVE&quot;);            &#x2F;&#x2F; 3.用client发送请求            HttpClient client &#x3D; new HttpClient(&quot;https:&#x2F;&#x2F;api.mch.weixin.qq.com&#x2F;pay&#x2F;unifiedorder&quot;);            &#x2F;&#x2F; client 设置参数            client.setXmlParam(WXPayUtil.generateSignedXml(m, &quot;T6m9iK73b0kn9g5v426MKfHQH7X8rKwb&quot;));            client.setHttps(true);            client.post();            &#x2F;&#x2F; 返回数据，xml格式            String xml &#x3D; client.getContent();            &#x2F;&#x2F; 利用微信提供的工具类将xml格式转换为map格式            Map&lt;String, String&gt; resultMap &#x3D; WXPayUtil.xmlToMap(xml);            &#x2F;&#x2F; 4.封装最后的数据            Map map &#x3D; new HashMap&lt;&gt;();            map.put(&quot;out_trade_no&quot;, orderNo);            map.put(&quot;course_id&quot;, order.getCourseId());            map.put(&quot;total_fee&quot;, order.getTotalFee());            map.put(&quot;result_code&quot;, resultMap.get(&quot;result_code&quot;));            map.put(&quot;code_url&quot;, resultMap.get(&quot;code_url&quot;));            &#x2F;&#x2F;微信支付二维码2小时过期，可采取2小时未支付取消订单            &#x2F;&#x2F;redisTemplate.opsForValue().set(orderNo, map, 120, TimeUnit.MINUTES);            &#x2F;&#x2F; 将封装好的map返回            return map;        &#125; catch (Exception e) &#123;            e.printStackTrace();            throw new GuliException(20001,&quot;生成二维码失败&quot;);        &#125;    &#125;&#125;</code></pre></div><h2 id="查询订单支付状态接口"><a href="#查询订单支付状态接口" class="headerlink" title="查询订单支付状态接口"></a>查询订单支付状态接口</h2><h3 id="1、编写controller-1"><a href="#1、编写controller-1" class="headerlink" title="1、编写controller"></a><strong>1、编写controller</strong></h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据订单号查询支付状态@GetMapping(&quot;queryPayStatus&#x2F;&#123;orderNo&#125;&quot;)public R queryPayStatus(@PathVariable String orderNo)&#123;    &#x2F;&#x2F; 根据订单号查询支付状态    Map&lt;String,String&gt; map &#x3D; payLogService.queryPayStatus(orderNo);    &#x2F;&#x2F; 判断返回的map是否为空    if (map &#x3D;&#x3D; null)&#123;        return R.error().message(&quot;支付失败&quot;);    &#125;    &#x2F;&#x2F;支付成功    if (map.get(&quot;trade_state&quot;).equals(&quot;SUCCESS&quot;))&#123;        &#x2F;&#x2F; 向表里面添加记录，更支付状态        payLogService.updataOrderStatus(map);        return R.ok().message(&quot;支付成功&quot;);    &#125;    return R.ok().message(&quot;支付中&quot;);&#125;</code></pre></div><h3 id="2、编写service，更新订单状态"><a href="#2、编写service，更新订单状态" class="headerlink" title="2、编写service，更新订单状态"></a>2、编写service，更新订单状态</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 向表里面添加记录，更支付状态@Overridepublic void updataOrderStatus(Map&lt;String,String&gt; map) &#123;    &#x2F;&#x2F; 获取订单号id    String orderNo &#x3D; map.get(&quot;out_trade_no&quot;);    &#x2F;&#x2F; 根据订单号，查询订单信息    QueryWrapper&lt;Order&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;order_no&quot;,orderNo);    Order order &#x3D; orderService.getOne(wrapper);    &#x2F;&#x2F; 判断是否已支付    if (order.getStatus().intValue() &#x3D;&#x3D; 1)&#123;        return;    &#125;    &#x2F;&#x2F; 如果没有支付,则设置支付状态    order.setStatus(1);    orderService.updateById(order);    &#x2F;&#x2F;记录支付日志    PayLog payLog&#x3D;new PayLog();    payLog.setOrderNo(order.getOrderNo());          &#x2F;&#x2F; 支付订单号    payLog.setPayTime(new Date());                  &#x2F;&#x2F; 支付时间    payLog.setPayType(1);                           &#x2F;&#x2F; 支付类型 1微信    payLog.setTotalFee(order.getTotalFee());        &#x2F;&#x2F; 总金额(分)    payLog.setTradeState(map.get(&quot;trade_state&quot;));   &#x2F;&#x2F; 支付状态    payLog.setTransactionId(map.get(&quot;transaction_id&quot;)); &#x2F;&#x2F; 流水号    payLog.setAttr(JSONObject.toJSONString(map));   &#x2F;&#x2F; 将其他信息加入以json的格式加入到数据库    baseMapper.insert(payLog);&#x2F;&#x2F;插入到支付日志表&#125;</code></pre></div><h2 id="生成微信支付二维码"><a href="#生成微信支付二维码" class="headerlink" title="生成微信支付二维码"></a>生成微信支付二维码</h2><p>（1）页面部分</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;cart py-container&quot;&gt;     &lt;!--主内容--&gt;     &lt;div class&#x3D;&quot;checkout py-container  pay&quot;&gt;       &lt;div class&#x3D;&quot;checkout-tit&quot;&gt;         &lt;h4 class&#x3D;&quot;fl tit-txt&quot;&gt;&lt;span class&#x3D;&quot;success-icon&quot;&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;success-info&quot;&gt;订单提交成功，请您及时付款！订单号：&#123;&#123;payObj.out_trade_no&#125;&#125;&lt;&#x2F;span&gt;         &lt;&#x2F;h4&gt;         &lt;span class&#x3D;&quot;fr&quot;&gt;&lt;em class&#x3D;&quot;sui-lead&quot;&gt;应付金额：&lt;&#x2F;em&gt;&lt;em class&#x3D;&quot;orange money&quot;&gt;￥&#123;&#123;payObj.total_fee&#125;&#125;&lt;&#x2F;em&gt;&lt;&#x2F;span&gt;         &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;       &lt;div class&#x3D;&quot;checkout-steps&quot;&gt;         &lt;div class&#x3D;&quot;fl weixin&quot;&gt;微信支付&lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;fl sao&quot;&gt;           &lt;p class&#x3D;&quot;red&quot;&gt;请使用微信扫一扫。&lt;&#x2F;p&gt;           &lt;div class&#x3D;&quot;fl code&quot;&gt;             &lt;!-- &lt;img id&#x3D;&quot;qrious&quot; src&#x3D;&quot;~&#x2F;assets&#x2F;img&#x2F;erweima.png&quot; alt&#x3D;&quot;&quot;&gt; --&gt;             &lt;!-- &lt;qriously value&#x3D;&quot;weixin:&#x2F;&#x2F;wxpay&#x2F;bizpayurl?pr&#x3D;R7tnDpZ&quot; :size&#x3D;&quot;338&quot;&#x2F;&gt; --&gt;             &lt;qriously :value&#x3D;&quot;payObj.code_url&quot; :size&#x3D;&quot;338&quot;&#x2F;&gt;             &lt;div class&#x3D;&quot;saosao&quot;&gt;               &lt;p&gt;请使用微信扫一扫&lt;&#x2F;p&gt;               &lt;p&gt;扫描二维码支付&lt;&#x2F;p&gt;             &lt;&#x2F;div&gt;           &lt;&#x2F;div&gt;         &lt;&#x2F;div&gt;         &lt;div class&#x3D;&quot;clearfix&quot;&gt;&lt;&#x2F;div&gt;         &lt;!-- &lt;p&gt;&lt;a href&#x3D;&quot;pay.html&quot; target&#x3D;&quot;_blank&quot;&gt;&gt; 其他支付方式&lt;&#x2F;a&gt;&lt;&#x2F;p&gt; --&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;</code></pre></div><p>（2）调用部分</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    import orderApi from &quot;@&#x2F;api&#x2F;order&quot;export default &#123;    &#x2F;&#x2F; 生成支付二维码    asyncData(&#123;params,error&#125;)&#123;        return orderApi.createNative(params.pid)           .then(response &#x3D;&gt;&#123;               return&#123;                   payObj: response.data.data               &#125;           &#125;)    &#125;,    data()&#123;        return&#123;            time1:&#39;&#39;        &#125;    &#125;,    &#x2F;&#x2F; 页面渲染之后执行    mounted()&#123;     &#x2F;&#x2F;在页面渲染之后执行     &#x2F;&#x2F;每隔三秒，去查询一次支付状态     this.timer1 &#x3D; setInterval(() &#x3D;&gt; &#123;       this.queryPayStatus(this.payObj.out_trade_no)     &#125;, 3000);    &#125;,    methods:&#123;        &#x2F;&#x2F; 查询订单状态        queryPayStatus(out_trade_no)&#123;            orderApi.getPayStatus(out_trade_no)               .then(response &#x3D;&gt;&#123;                       if (response.data.success) &#123;                           &#x2F;&#x2F;如果支付成功，清除定时器                           clearInterval(this.timer1)                           this.$message(&#123;                               type: &#39;success&#39;,                               message: &#39;支付成功!&#39;                            &#125;)                           &#x2F;&#x2F;跳转到课程详情页面观看视频                           this.$router.push(&#123;path: &#39;&#x2F;course&#x2F;&#39; + this.payObj.course_id&#125;)                   &#125;               &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day-09-课程管理</title>
    <link href="/myBlog/day09-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/myBlog/day09-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h1><h1 id="课程管理-课程信息确认前端"><a href="#课程管理-课程信息确认前端" class="headerlink" title="课程管理-课程信息确认前端"></a>课程管理-课程信息确认前端</h1><h2 id="定义api"><a href="#定义api" class="headerlink" title="定义api"></a>定义api</h2><p>course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据课程id查询最终发布的课程信息getPublishCourseInfo(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#x2F;getPublishCourseInfo&#x2F;&#96;+id,        method: &#39;get&#39;      &#125;)&#125;</code></pre></div><h2 id="定义数据模型"><a href="#定义数据模型" class="headerlink" title="定义数据模型"></a>定义数据模型</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">data() &#123;  return &#123;    saveBtnDisabled: false ,&#x2F;&#x2F; 保存按钮是否禁用    courseId:&#39;&#39;,    coursePublish:&#123;&#125;  &#125;&#125;,</code></pre></div><h2 id="完善步骤导航"><a href="#完善步骤导航" class="headerlink" title="完善步骤导航"></a>完善步骤导航</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">previous() &#123;      this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;chapter&#x2F;&#39;+this.courseId &#125;)    &#125;,    publish() &#123;      this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;list&#39; &#125;)    &#125;</code></pre></div><h2 id="组件方法定义"><a href="#组件方法定义" class="headerlink" title="组件方法定义"></a>组件方法定义</h2><p>import</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import course from &#39;@&#x2F;api&#x2F;edu&#x2F;course&#39;</code></pre></div><p>created</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created() &#123;  &#x2F;&#x2F; 获取路由id  if(this.$route.params &amp;&amp; this.$route.params.id)&#123;     this.courseId &#x3D; this.$route.params.id    &#x2F;&#x2F; 根据课程id回显数据    this.getPublishCourseId()  &#125;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;    &#x2F;&#x2F; 根据课程id回显数据    getPublishCourseId()&#123;      course.getPublishCourseInfo(this.courseId)       .then(response &#x3D;&gt;&#123;         this.coursePublish &#x3D; response.data.courseInfo       &#125;)    &#125;,</code></pre></div><h2 id="组件模板"><a href="#组件模板" class="headerlink" title="组件模板"></a>组件模板</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    &lt;h2 style&#x3D;&quot;text-align: center;&quot;&gt;发布新课程&lt;&#x2F;h2&gt;    &lt;el-steps :active&#x3D;&quot;3&quot; process-status&#x3D;&quot;wait&quot; align-center style&#x3D;&quot;margin-bottom: 40px;&quot;&gt;      &lt;el-step title&#x3D;&quot;填写课程基本信息&quot;&#x2F;&gt;      &lt;el-step title&#x3D;&quot;创建课程大纲&quot;&#x2F;&gt;      &lt;el-step title&#x3D;&quot;发布课程&quot;&#x2F;&gt;    &lt;&#x2F;el-steps&gt;    &lt;div class&#x3D;&quot;ccInfo&quot;&gt;      &lt;img :src&#x3D;&quot;coursePublish.cover&quot;&gt;      &lt;div class&#x3D;&quot;main&quot;&gt;        &lt;h2&gt;&#123;&#123; coursePublish.title &#125;&#125;&lt;&#x2F;h2&gt;        &lt;p class&#x3D;&quot;gray&quot;&gt;&lt;span&gt;共&#123;&#123; coursePublish.lessonNum &#125;&#125;课时&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;        &lt;p&gt;&lt;span&gt;所属分类：&#123;&#123; coursePublish.subjectLevelOne &#125;&#125; — &#123;&#123; coursePublish.subjectLevelTwo &#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;        &lt;p&gt;课程讲师：&#123;&#123; coursePublish.teacherName &#125;&#125;&lt;&#x2F;p&gt;        &lt;h3 class&#x3D;&quot;red&quot;&gt;￥&#123;&#123; coursePublish.price &#125;&#125;&lt;&#x2F;h3&gt;      &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div&gt;      &lt;el-button @click&#x3D;&quot;previous&quot;&gt;返回修改&lt;&#x2F;el-button&gt;      &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;publish&quot;&gt;发布课程&lt;&#x2F;el-button&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><h2 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style scoped&gt; .ccInfo &#123;      background: #f5f5f5;      padding: 20px;      overflow: hidden;      border: 1px dashed #DDD;      margin-bottom: 40px;      position: relative; &#125; .ccInfo img &#123;     background: #d6d6d6;     width: 500px;     height: 278px;     display: block;     float: left;     border: none; &#125; .ccInfo .main &#123;     margin-left: 520px; &#125; .ccInfo .main h2 &#123;     font-size: 28px;     margin-bottom: 30px;     line-height: 1;     font-weight: normal; &#125; .ccInfo .main p &#123;     margin-bottom: 10px;     word-wrap: break-word;     line-height: 24px;     max-height: 48px;     overflow: hidden; &#125; .ccInfo .main p &#123;     margin-bottom: 10px;     word-wrap: break-word;     line-height: 24px;     max-height: 48px;     overflow: hidden; &#125;.ccInfo .main h3 &#123;     left: 540px;     bottom: 20px;     line-height: 1;     font-size: 28px;     color: #d32f24;     font-weight: normal;     position: absolute; &#125; &lt;&#x2F;style&gt;</code></pre></div><h1 id="课程管理-课程最终发布"><a href="#课程管理-课程最终发布" class="headerlink" title="课程管理-课程最终发布"></a>课程管理-课程最终发布</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id实现最终课程发布，修改表中的status字段，课程状态 Draft未发布 Normal已发布@PostMapping(&quot;publishCourse&#x2F;&#123;id&#125;&quot;)public R publishCourse(@PathVariable String id)&#123;    EduCourse eduCourse &#x3D; new EduCourse();    eduCourse.setId(id);    eduCourse.setStatus(&quot;Normal&quot;);    eduCourseService.updateById(eduCourse);    return R.ok();&#125;</code></pre></div><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据课程id实现最终课程发布publishCourseInfo(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#x2F;publishCourse&#x2F;&#96;+id,        method: &#39;post&#39;      &#125;)&#125;</code></pre></div><p>publish.vue中的methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">publish() &#123;        &#x2F;&#x2F; 提示信息         this.$confirm(&#39;此操作将发布课程信息, 是否继续?&#39;, &#39;提示&#39;, &#123;           confirmButtonText: &#39;确定&#39;,           cancelButtonText: &#39;取消&#39;,           type: &#39;warning&#39;           &#125;).then(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 确认发布，执行then               &#x2F;&#x2F; 调用发布方法               course.publishCourseInfo(this.courseId)                   .then(response &#x3D;&gt;&#123;     &#x2F;&#x2F; 发布成功                       &#x2F;&#x2F; 提示信息                       this.$message(&#123;                           type: &#39;success&#39;,                           message: &#39;发布课程成功!&#39;                       &#125;);                      &#x2F;&#x2F; 回到列表页面                      this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;list&#39; &#125;)                   &#125;)                      &#125;)</code></pre></div><h1 id="课程管理-课程列表"><a href="#课程管理-课程列表" class="headerlink" title="课程管理-课程列表"></a>课程管理-课程列表</h1><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 课程列表@GetMappingpublic R getCourseList()&#123;    List&lt;EduCourse&gt; list &#x3D; eduCourseService.list(null);    return R.ok().data(&quot;list&quot;,list);&#125;</code></pre></div><h2 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h2><p>api/course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 课程列表getCourseList()&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#96;,        method: &#39;get&#39;      &#125;)&#125; </code></pre></div><p>list.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        课程列表     &lt;!--查询表单--&gt;     &lt;el-form :inline&#x3D;&quot;true&quot; class&#x3D;&quot;demo-form-inline&quot;&gt;       &lt;el-form-item&gt;         &lt;el-input v-model&#x3D;&quot;courseQuery.title&quot; placeholder&#x3D;&quot;课程名&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-form-item&gt;         &lt;el-select v-model&#x3D;&quot;courseQuery.status&quot; clearable placeholder&#x3D;&quot;课程状态&quot;&gt;           &lt;el-option :value&#x3D;&quot;Normal&quot; label&#x3D;&quot;已发布&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;Draft&quot; label&#x3D;&quot;未发布&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot; @click&#x3D;&quot;getList()&quot;&gt;查询&lt;&#x2F;el-button&gt;       &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;resetData()&quot;&gt;清空&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form&gt;        &lt;!-- 表格 --&gt;        &lt;el-table        :data&#x3D;&quot;list&quot;        border        fit        highlight-current-row&gt;        &lt;el-table-column            label&#x3D;&quot;序号&quot;            width&#x3D;&quot;70&quot;            align&#x3D;&quot;center&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;title&quot; label&#x3D;&quot;课程名称&quot; width&#x3D;&quot;80&quot; &#x2F;&gt;        &lt;el-table-column label&#x3D;&quot;状态&quot; width&#x3D;&quot;80&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &#123;&#123; scope.row.status&#x3D;&#x3D;&#x3D;&#39;Normal&#39; ? &#39;已发布&#39;:&#39;未发布&#39; &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;lessonNum&quot; label&#x3D;&quot;课时数&quot; &#x2F;&gt;        &lt;el-table-column prop&#x3D;&quot;gmtCreate&quot; label&#x3D;&quot;添加时间&quot; width&#x3D;&quot;160&quot;&#x2F;&gt;        &lt;el-table-column prop&#x3D;&quot;viewCount&quot; label&#x3D;&quot;浏览数量&quot; width&#x3D;&quot;60&quot; &#x2F;&gt;        &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;200&quot; align&#x3D;&quot;center&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;router-link :to&#x3D;&quot;&#39;&#x2F;teacher&#x2F;edit&#x2F;&#39;+scope.row.id&quot;&gt;                &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑课程基本信息&lt;&#x2F;el-button&gt;            &lt;&#x2F;router-link&gt;             &lt;router-link :to&#x3D;&quot;&#39;&#x2F;teacher&#x2F;edit&#x2F;&#39;+scope.row.id&quot;&gt;                &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;编辑课程大纲信息&lt;&#x2F;el-button&gt;            &lt;&#x2F;router-link&gt;            &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeDataById(scope.row.id)&quot;&gt;删除课程信息&lt;&#x2F;el-button&gt;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;&#x2F;el-table&gt;    &lt;!-- 分页 --&gt;    &lt;el-pagination      :current-page&#x3D;&quot;page&quot;      :page-size&#x3D;&quot;limit&quot;      :total&#x3D;&quot;total&quot;      style&#x3D;&quot;padding: 30px 0; text-align: center;&quot;      layout&#x3D;&quot;total, prev, pager, next, jumper&quot;      @current-change&#x3D;&quot;getList&quot;    &#x2F;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import course from &#39;@&#x2F;api&#x2F;edu&#x2F;course&#39;export default &#123;    data()&#123;     &#x2F;&#x2F; 定义变量和初始值        return&#123;            list:null,  &#x2F;&#x2F; 查询之后接口返回集合            page:1,   &#x2F;&#x2F; 当前页            limit:10, &#x2F;&#x2F; 每页的记录数            total:0,  &#x2F;&#x2F; 总记录数            courseQuery:&#123;&#125;    &#x2F;&#x2F; 条封装对象        &#125;    &#125;,    created()&#123;      &#x2F;&#x2F; 页面渲染之前执行，调用创建的方法        this.getList()    &#125;,    methods:&#123;        &#x2F;&#x2F; 讲师列表        getList()&#123;            course.getCourseList()                .then(response &#x3D;&gt;&#123;&#x2F;&#x2F; 执行成功                    &#x2F;&#x2F; response接口接口返回的数据                    this.list &#x3D; response.data.list                &#125;)                     .catch(error &#x3D;&gt;&#123; &#x2F;&#x2F; 执行失败                    console.log(error)                &#125;)           &#125;,        &#x2F;&#x2F; 清空        resetData()&#123;    &#x2F;&#x2F;清空            &#x2F;&#x2F; 清空所有数据            this.courseQuery &#x3D; &#123;&#125;            &#x2F;&#x2F; 查询所有用户            this.getList()        &#125;,            &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><h1 id="课程管理-删除课程后端"><a href="#课程管理-删除课程后端" class="headerlink" title="课程管理-删除课程后端"></a>课程管理-删除课程后端</h1><p>删除流程：</p><p>小节=&gt;章节=&gt;课程描述=&gt;课程</p><p>com.atguigu.eduservice.controller.EduCourseController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id删除课程@DeleteMapping(&quot;deleteCourse&#x2F;&#123;courseId&#125;&quot;)public R deleteCourse(@PathVariable String courseId)&#123;    eduCourseService.removeCourseById(courseId);    return R.ok();&#125;</code></pre></div><p>EduCourseService</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id删除课程void removeCourseById(String courseId);</code></pre></div><p>删除小节EduVideoService</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">public interface EduVideoService extends IService&lt;EduVideo&gt; &#123;    &#x2F;&#x2F; 根据课程id删除小节    void removeVideoByCourseId(String courseId);&#125;</code></pre></div><p>删除小节EduVideoServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduVideoServiceImpl extends ServiceImpl&lt;EduVideoMapper, EduVideo&gt; implements EduVideoService &#123;    &#x2F;&#x2F; 根据课程id删除小节    @Override    public void removeVideoByCourseId(String courseId) &#123;        QueryWrapper&lt;EduVideo&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;course_id&quot;,courseId);        baseMapper.delete(wrapper);    &#125;&#125;</code></pre></div><p>删除章节EduChapterService</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id删除章节void removeChapterByCourseId(String courseId);</code></pre></div><p>删除章节EduChapterServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">    &#x2F;&#x2F; 根据课程id删除章节    @Override    public void removeChapterByCourseId(String courseId) &#123;        QueryWrapper&lt;EduChapter&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;course_id&quot;,courseId);        baseMapper.delete(wrapper);    &#125;&#125;</code></pre></div><p>EduCourseServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id删除课程@Overridepublic void removeCourseById(String courseId) &#123;    &#x2F;&#x2F; 根据课程id删除小节    eduVideoService.removeVideoByCourseId(courseId);    &#x2F;&#x2F; 根据课程id删除章节    eduChapterService.removeChapterByCourseId(courseId);    &#x2F;&#x2F; 根据课程id删除描述,因为描述的id就是课程的id，可以直接删除    eduCourseDescriptionService.removeById(courseId);    &#x2F;&#x2F; 根据课程id删除课程    int result &#x3D; baseMapper.deleteById(courseId);    if (result &#x3D;&#x3D; 0)&#123;        throw new GuliException(20001,&quot;删除失败&quot;);    &#125;&#125;</code></pre></div><h1 id="课程管理-删除课程前端"><a href="#课程管理-删除课程前端" class="headerlink" title="课程管理-删除课程前端"></a>课程管理-删除课程前端</h1><p>course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据课程id删除课程deleteCourseById(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#x2F;deleteCourse&#x2F;&#96;+id,        method: &#39;delete&#39;      &#125;)&#125;</code></pre></div><p>list.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;        &#x2F;&#x2F; 根据课程id删除课程        removeDataById(id)&#123;            this.$confirm(&#39;此操作将永久删除讲师记录, 是否继续?&#39;, &#39;提示&#39;, &#123;            confirmButtonText: &#39;确定&#39;,            cancelButtonText: &#39;取消&#39;,            type: &#39;warning&#39;            &#125;).then(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 确认删除，执行then                &#x2F;&#x2F; 调用删除方法                course.deleteCourseById(id)                    .then(response &#x3D;&gt;&#123;     &#x2F;&#x2F; 删除成功                        &#x2F;&#x2F; 提示信息                        this.$message(&#123;                            type: &#39;success&#39;,                            message: &#39;删除课程成功!&#39;                        &#125;);                        &#x2F;&#x2F; 回到列表页面                        this.getList()                    &#125;)                        &#125;)        &#125;,</code></pre></div><p>TODO:</p><p>课程条件查询，分页</p><h1 id="课程管理-课程条件分页查询"><a href="#课程管理-课程条件分页查询" class="headerlink" title="课程管理-课程条件分页查询"></a>课程管理-课程条件分页查询</h1><h2 id="后端-2"><a href="#后端-2" class="headerlink" title="后端"></a>后端</h2><p>CourseQuery封装对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class CourseQuery &#123;    &#x2F;&#x2F; 课程名称    private String title;    &#x2F;&#x2F; 发布状态    private String status;&#125;</code></pre></div><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 分页带条件@PostMapping(&quot;getCoursePageCondition&#x2F;&#123;current&#125;&#x2F;&#123;limit&#125;&quot;)public R getCoursePageCondition(@PathVariable long current, @PathVariable long limit,                                @RequestBody CourseQuery courseQuery)&#123;    &#x2F;&#x2F; 构建分页对象    Page&lt;EduCourse&gt; coursePage &#x3D; new Page&lt;&gt;(current, limit);    &#x2F;&#x2F; 构建查询条件    QueryWrapper&lt;EduCourse&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; 取到传进来的对象的数据    String title &#x3D; courseQuery.getTitle();    String status &#x3D; courseQuery.getStatus();    &#x2F;&#x2F; 判断数据的有效性，并封装条件    if (!StringUtils.isEmpty(title))&#123;        &#x2F;&#x2F; 模块查询课程名称        wrapper.like(&quot;title&quot;,title);    &#125;    if (!StringUtils.isEmpty(status))&#123;        wrapper.like(&quot;status&quot;,status);    &#125;    &#x2F;&#x2F; 查询数据库    eduCourseService.page(coursePage,wrapper);    &#x2F;&#x2F; 得到所有数据    List&lt;EduCourse&gt; records &#x3D; coursePage.getRecords();    long total &#x3D; coursePage.getTotal();    return R.ok().data(&quot;records&quot;,records).data(&quot;total&quot;,total);&#125;</code></pre></div><h2 id="前端-2"><a href="#前端-2" class="headerlink" title="前端"></a>前端</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 条件查询分页       getList(page &#x3D; 1)&#123;           this.page &#x3D; page           course.getCourseListPage(this.page,this.limit,this.courseQuery)           .then(response &#x3D;&gt;&#123;                this.list &#x3D; response.data.records               this.total &#x3D; response.data.total                      &#125;)       &#125;,</code></pre></div><h1 id="阿里云视频点播"><a href="#阿里云视频点播" class="headerlink" title="阿里云视频点播"></a>阿里云视频点播</h1><p>选择存储区域的时候一定要选择上海，会报not found的错误 ，this video not exist</p><h2 id="课程管理-添加小节上传视频后端"><a href="#课程管理-添加小节上传视频后端" class="headerlink" title="课程管理-添加小节上传视频后端"></a>课程管理-添加小节上传视频后端</h2><p>在service模块下创建service_vod子模块</p><p>application.properties</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 服务端口server.port&#x3D;8003# 服务名spring.application.name&#x3D;service-vod# 环境设置：dev、test、prodspring.profiles.active&#x3D;dev#阿里云 vod#不同的服务器，地址不同aliyun.vod.file.keyid&#x3D;your accessKeyIdaliyun.vod.file.keysecret&#x3D;your accessKeySecret</code></pre></div><p>定义工具类ConstantVodUtils</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class ConstantVodUtils implements InitializingBean &#123;    @Value(&quot;aliyun.vod.file.keyid&quot;)    private String keyId;    @Value(&quot;aliyun.vod.file.keysecret&quot;)    private String keySecret;    public static String ACCESS_KEY_ID;    public static String ACCESS_KEY_SECRET;    @Override    public void afterPropertiesSet() throws Exception &#123;        ACCESS_KEY_ID &#x3D; keyId;        ACCESS_KEY_SECRET &#x3D; keySecret;    &#125;&#125;</code></pre></div><p>controller</p><p>com.atguigu.vod.controller.VodController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;eduvod&#x2F;video&quot;)@CrossOriginpublic class VodController &#123;    @Autowired    private VodService vodService;    &#x2F;&#x2F; 上传视频到阿里云    @PostMapping(&quot;uploadAlyVideo&quot;)    public R uploadAlyVideo(MultipartFile file)&#123;        String videoId &#x3D; vodService.uploadAly(file);        return R.ok().data(&quot;videoId&quot;,videoId);    &#125;&#125;</code></pre></div><p>Service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface VodService &#123;    &#x2F;&#x2F; 上传视频到阿里云    String uploadAly(MultipartFile file);&#125;</code></pre></div><p>ServiceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class VodServiceImpl implements VodService &#123;    &#x2F;&#x2F; 上传视频到阿里云    @Override    public String uploadAly(MultipartFile file) &#123;        try &#123;            &#x2F;&#x2F; 文件输入流            InputStream inputStream &#x3D; file.getInputStream();            &#x2F;&#x2F; 文件的源名字            String fileName &#x3D; file.getOriginalFilename();            &#x2F;&#x2F; 上传文件的名称            &#x2F;&#x2F; 源文件，01.mp4,改成01            String title &#x3D; fileName.substring(0, fileName.lastIndexOf(&quot;.&quot;));            UploadStreamRequest request &#x3D; new UploadStreamRequest(ConstantVodUtils.ACCESS_KEY_ID, ConstantVodUtils.ACCESS_KEY_SECRET, title, fileName, inputStream);            UploadVideoImpl uploader &#x3D; new UploadVideoImpl();            UploadStreamResponse response &#x3D; uploader.uploadStream(request);            System.out.print(&quot;RequestId&#x3D;&quot; + response.getRequestId() + &quot;\n&quot;);  &#x2F;&#x2F;请求视频点播服务的请求ID            &#x2F;&#x2F; 视频返回的id            String videoId &#x3D; &quot;&quot;;            if (response.isSuccess()) &#123;                videoId &#x3D; response.getVideoId();            &#125; else &#123; &#x2F;&#x2F;如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因                videoId &#x3D; response.getVideoId();            &#125;            return videoId;        &#125; catch (IOException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;</code></pre></div><p>启动测试，报了一下错误，超过文件上传最大的容量，1M</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Caused by: org.apache.tomcat.util.http.fileupload.FileUploadBase$FileSizeLimitExceededException: The field file exceeds its maximum permitted size of 1048576 bytes.</code></pre></div><p>解决方案</p><p>在application.properties配置文件中添加下面配置</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 最大上传单个文件大小：默认1Mspring.servlet.multipart.max-file-size&#x3D;1024MB# 最大置总上传的数据大小 ：默认10Mspring.servlet.multipart.max-request-size&#x3D;1024MB</code></pre></div><h2 id="课程管理-添加小节上传视频前端"><a href="#课程管理-添加小节上传视频前端" class="headerlink" title="课程管理-添加小节上传视频前端"></a>课程管理-添加小节上传视频前端</h2><p>配置nginx反向代理</p><p>将接口地址加入nginx配置</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">location ~ &#x2F;eduvod&#x2F; &#123;    proxy_pass http:&#x2F;&#x2F;localhost:8003;&#125;</code></pre></div><p>配置nginx上传文件大小，否则上传时会有 413 (Request Entity Too Large) 异常</p><p>打开nginx主配置文件nginx.conf，找到http{}，添加</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">client_max_body_size 1024m;</code></pre></div><p>重启nginx</p><p><strong>数据定义</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">fileList: [],&#x2F;&#x2F;上传文件列表BASE_API: process.env.BASE_API &#x2F;&#x2F; 接口API地址</code></pre></div><p><strong>整合上传组件</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;el-form-item label&#x3D;&quot;上传视频&quot;&gt;            &lt;el-upload                    :on-success&#x3D;&quot;handleVodUploadSuccess&quot;                    :on-remove&#x3D;&quot;handleVodRemove&quot;                    :before-remove&#x3D;&quot;beforeVodRemove&quot;                    :on-exceed&#x3D;&quot;handleUploadExceed&quot;                    :file-list&#x3D;&quot;fileList&quot;                    :action&#x3D;&quot;BASE_API+&#39;&#x2F;eduvod&#x2F;video&#x2F;uploadAlyVideo&#39;&quot;                    :limit&#x3D;&quot;1&quot;                    class&#x3D;&quot;upload-demo&quot;&gt;            &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;上传视频&lt;&#x2F;el-button&gt;            &lt;el-tooltip placement&#x3D;&quot;right-end&quot;&gt;                &lt;div slot&#x3D;&quot;content&quot;&gt;最大支持1G，&lt;br&gt;                    支持3GP、ASF、AVI、DAT、DV、FLV、F4V、&lt;br&gt;                    GIF、M2T、M4V、MJ2、MJPEG、MKV、MOV、MP4、&lt;br&gt;                    MPE、MPG、MPEG、MTS、OGG、QT、RM、RMVB、&lt;br&gt;                    SWF、TS、VOB、WMV、WEBM 等视频格式上传&lt;&#x2F;div&gt;                &lt;i class&#x3D;&quot;el-icon-question&quot;&#x2F;&gt;            &lt;&#x2F;el-tooltip&gt;            &lt;&#x2F;el-upload&gt;        &lt;&#x2F;el-form-item&gt;</code></pre></div><p><strong>方法定义</strong></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;     &#x2F;&#x2F; 成功     handleVodUploadSuccess(response,file,fileList)&#123;       this.video.videoSourceId &#x3D; response.data.videoId       this.video.videoOriginalName &#x3D; file.name     &#125;,    &#x2F;&#x2F;视图上传多于一个视频    handleUploadExceed(files, fileList) &#123;      this.$message.warning(&#39;想要重新上传视频，请先删除已上传的    &#125;,</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day08-课程管理</title>
    <link href="/myBlog/day08-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/myBlog/day08-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="day08-课程管理"><a href="#day08-课程管理" class="headerlink" title="day08-课程管理"></a>day08-课程管理</h1><h1 id="课程管理大纲列表后端"><a href="#课程管理大纲列表后端" class="headerlink" title="课程管理大纲列表后端"></a>课程管理大纲列表后端</h1><p>创建对应的vo实体类</p><p>ChapterVo</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 课程章节@Datapublic class ChapterVo &#123;    private String id;    private String title;    &#x2F;&#x2F; 每个章节里面包含小节    List&lt;VideoVo&gt; children &#x3D; new ArrayList&lt;&gt;();&#125;</code></pre></div><p>VideoVo</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 小节vo@Datapublic class VideoVo &#123;    private String id;    private String title;&#125;</code></pre></div><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;chapter&quot;)public class EduChapterController &#123;    @Autowired    private EduChapterService eduChapterService;    &#x2F;&#x2F; 查看所有课程大纲，章节小节    @GetMapping(&quot;getAllChapterVideo&#x2F;&#123;courseId&#125;&quot;)    public R getAllChapterVideo(@PathVariable String courseId)&#123;        List&lt;ChapterVo&gt; list &#x3D; eduChapterService.getAllChapterVideo(courseId);        return R.ok().data(&quot;list&quot;,list);    &#125;&#125;</code></pre></div><p>service接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduChapterService extends IService&lt;EduChapter&gt; &#123;    &#x2F;&#x2F; 查看所有课程大纲，章节小节    List&lt;ChapterVo&gt; getAllChapterVideo(String courseId);&#125;</code></pre></div><p>serviceImpl实现类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 查看所有课程大纲，章节小节@Overridepublic List&lt;ChapterVo&gt; getAllChapterVideo(String courseId) &#123;    &#x2F;&#x2F; 查询所有的章节    QueryWrapper&lt;EduChapter&gt; chapterWrapper &#x3D; new QueryWrapper&lt;&gt;();    chapterWrapper.eq(&quot;course_id&quot;,courseId);    List&lt;EduChapter&gt; chapterList &#x3D; baseMapper.selectList(chapterWrapper);    &#x2F;&#x2F; 查询所有的小节    QueryWrapper&lt;EduVideo&gt; videoWrapper &#x3D; new QueryWrapper&lt;&gt;();    chapterWrapper.eq(&quot;course_id&quot;,courseId);    List&lt;EduVideo&gt; eduVideoList &#x3D; eduVideoService.list(videoWrapper);    &#x2F;&#x2F; 创建集合保存最终的集合    List&lt;ChapterVo&gt; finalList &#x3D; new ArrayList&lt;&gt;();    &#x2F;&#x2F; 封装章节    for (int i &#x3D; 0; i &lt; chapterList.size(); i++) &#123;        &#x2F;&#x2F; 得到eduChapter对象        EduChapter eduChapter &#x3D; chapterList.get(i);        ChapterVo chapterVo &#x3D; new ChapterVo();        BeanUtils.copyProperties(eduChapter,chapterVo);        &#x2F;&#x2F; 将得到的章节加入最终集合        finalList.add(chapterVo);        &#x2F;&#x2F; 封装小节        &#x2F;&#x2F; 先创建一个集合存放小节        List&lt;VideoVo&gt; videoList &#x3D; new ArrayList&lt;&gt;();        for (int m &#x3D; 0; m &lt; eduVideoList.size(); m++) &#123;            EduVideo eduVideo &#x3D; eduVideoList.get(m);           &#x2F;&#x2F; 判断eduVideo中的chapter_id是否和章节的id相等            if (eduVideo.getChapterId().equals(eduChapter.getId()))&#123;                VideoVo videoVo &#x3D; new VideoVo();                BeanUtils.copyProperties(eduVideo,videoVo);                videoList.add(videoVo);            &#125;        &#125;        &#x2F;&#x2F; 将小节加到章节chapterVo中        chapterVo.setChildren(videoList);    &#125;    return finalList;&#125;</code></pre></div><h1 id="课程管理大纲列表前端"><a href="#课程管理大纲列表前端" class="headerlink" title="课程管理大纲列表前端"></a>课程管理大纲列表前端</h1><h2 id="定义api"><a href="#定义api" class="headerlink" title="定义api"></a>定义api</h2><p>chapter.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default&#123;    &#x2F;&#x2F; 根据课程id查询章节和小节    getAllChapterVideo(courseId)&#123;        return request(&#123;            url: &#96;&#x2F;eduservice&#x2F;chapter&#x2F;getAllChapterVideo&#x2F;$&#123;courseId&#125;&#96;,            method: &#39;get&#39;          &#125;)    &#125;&#125;</code></pre></div><h2 id="定义组件脚本"><a href="#定义组件脚本" class="headerlink" title="定义组件脚本"></a>定义组件脚本</h2><p>定义data</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">chapterVideoList:[],courseId:&#39;&#39;</code></pre></div><p>created中调用getChapterVideo方法</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created() &#123;     &#x2F;&#x2F; 获取路由的id     if(this.$route.params &amp;&amp; this.$route.params.id)&#123;       this.courseId &#x3D; this.$route.params.id;       &#x2F;&#x2F; 根据课程id获取章节和小节       this.getChapterVideo()     &#125;   &#125;,</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;     &#x2F;&#x2F; 根据课程id查询章节和小节     getChapterVideo()&#123;       chapter.getAllChapterVideo(this.courseId)        .then(response &#x3D;&gt;&#123;          this.chapterVideoList &#x3D; response.data.allChapterVideo        &#125;)     &#125;,</code></pre></div><h2 id="定义组件模板"><a href="#定义组件模板" class="headerlink" title="定义组件模板"></a>定义组件模板</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;el-button type&#x3D;&quot;text&quot;&gt;添加章节&lt;&#x2F;el-button&gt;      &lt;!-- 章节 --&gt;      &lt;ul class&#x3D;&quot;chanpterList&quot;&gt;          &lt;li              v-for&#x3D;&quot;chapter in chapterVideoList&quot;              :key&#x3D;&quot;chapter.id&quot;&gt;              &lt;p&gt;                  &#123;&#123; chapter.title &#125;&#125;                                &lt;&#x2F;p&gt;              &lt;!-- 视频 --&gt;              &lt;ul class&#x3D;&quot;chanpterList videoList&quot;&gt;                  &lt;li                      v-for&#x3D;&quot;video in chapter.children&quot;                      :key&#x3D;&quot;video.id&quot;&gt;                      &lt;p&gt;&#123;&#123; video.title &#125;&#125;                      &lt;&#x2F;p&gt;                  &lt;&#x2F;li&gt;              &lt;&#x2F;ul&gt;          &lt;&#x2F;li&gt;      &lt;&#x2F;ul&gt;      &lt;div&gt;          &lt;el-button @click&#x3D;&quot;previous&quot;&gt;上一步&lt;&#x2F;el-button&gt;          &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;next&quot;&gt;下一步&lt;&#x2F;el-button&gt;      &lt;&#x2F;div&gt;</code></pre></div><h2 id="定义样式"><a href="#定义样式" class="headerlink" title="定义样式"></a>定义样式</h2><p>将样式的定义放在页面的最后</p><p>scope表示这里定义的样式只在当前页面范围内生效，不会污染到其他的页</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"> &lt;style scoped&gt;.chanpterList&#123;    position: relative;    list-style: none;    margin: 0;    padding: 0;&#125;.chanpterList li&#123;  position: relative;&#125;.chanpterList p&#123;  float: left;  font-size: 20px;  margin: 10px 0;  padding: 10px;  height: 70px;  line-height: 50px;  width: 100%;  border: 1px solid #DDD;&#125;.chanpterList .acts &#123;    float: right;    font-size: 14px;&#125;.videoList&#123;  padding-left: 50px;&#125;.videoList p&#123;  float: left;  font-size: 14px;  margin: 10px 0;  padding: 10px;  height: 50px;  line-height: 30px;  width: 100%;  border: 1px dotted #DDD;&#125;&lt;&#x2F;style&gt;</code></pre></div><h2 id="完整chapter-vue代码"><a href="#完整chapter-vue代码" class="headerlink" title="完整chapter.vue代码"></a>完整chapter.vue代码</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;h2 style&#x3D;&quot;text-align: center;&quot;&gt;发布新课程&lt;&#x2F;h2&gt;     &lt;el-steps :active&#x3D;&quot;2&quot; process-status&#x3D;&quot;wait&quot; align-center style&#x3D;&quot;margin-bottom: 40px;&quot;&gt;       &lt;el-step title&#x3D;&quot;填写课程基本信息&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;创建课程大纲&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;最终发布&quot;&#x2F;&gt;     &lt;&#x2F;el-steps&gt;      &lt;el-button type&#x3D;&quot;text&quot;&gt;添加章节&lt;&#x2F;el-button&gt;      &lt;!-- 章节 --&gt;      &lt;ul class&#x3D;&quot;chanpterList&quot;&gt;          &lt;li              v-for&#x3D;&quot;chapter in chapterVideoList&quot;              :key&#x3D;&quot;chapter.id&quot;&gt;              &lt;p&gt;                  &#123;&#123; chapter.title &#125;&#125;                                &lt;&#x2F;p&gt;              &lt;!-- 视频 --&gt;              &lt;ul class&#x3D;&quot;chanpterList videoList&quot;&gt;                  &lt;li                      v-for&#x3D;&quot;video in chapter.children&quot;                      :key&#x3D;&quot;video.id&quot;&gt;                      &lt;p&gt;&#123;&#123; video.title &#125;&#125;                      &lt;&#x2F;p&gt;                  &lt;&#x2F;li&gt;              &lt;&#x2F;ul&gt;          &lt;&#x2F;li&gt;      &lt;&#x2F;ul&gt;      &lt;div&gt;          &lt;el-button @click&#x3D;&quot;previous&quot;&gt;上一步&lt;&#x2F;el-button&gt;          &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;next&quot;&gt;下一步&lt;&#x2F;el-button&gt;      &lt;&#x2F;div&gt;     &lt;!-- &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item&gt;         &lt;el-button @click&#x3D;&quot;previous&quot;&gt;上一步&lt;&#x2F;el-button&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;next&quot;&gt;下一步&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt; --&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt;   import chapter from &#39;@&#x2F;api&#x2F;edu&#x2F;chapter&#39; export default &#123;   data() &#123;     return &#123;       saveBtnDisabled: false, &#x2F;&#x2F; 保存按钮是否禁用       chapterVideoList:[],       courseId:&#39;&#39;     &#125;   &#125;,   created() &#123;     &#x2F;&#x2F; 获取路由的id     if(this.$route.params &amp;&amp; this.$route.params.id)&#123;       this.courseId &#x3D; this.$route.params.id;       &#x2F;&#x2F; 根据课程id获取章节和小节       this.getChapterVideo()     &#125;   &#125;,   methods: &#123;     &#x2F;&#x2F; 根据课程id查询章节和小节     getChapterVideo()&#123;       chapter.getAllChapterVideo(this.courseId)        .then(response &#x3D;&gt;&#123;          this.chapterVideoList &#x3D; response.data.allChapterVideo        &#125;)     &#125;,     previous() &#123;       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;info&#x2F;&#39;+this.courseId &#125;)     &#125;,     next() &#123;       console.log(&#39;next&#39;)       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;publish&#x2F;&#39;+this.courseId &#125;)     &#125;   &#125; &#125; &lt;&#x2F;script&gt;  &lt;style scoped&gt; .chanpterList&#123;     position: relative;     list-style: none;     margin: 0;     padding: 0; &#125; .chanpterList li&#123;   position: relative; &#125; .chanpterList p&#123;   float: left;   font-size: 20px;   margin: 10px 0;   padding: 10px;   height: 70px;   line-height: 50px;   width: 100%;   border: 1px solid #DDD; &#125; .chanpterList .acts &#123;     float: right;     font-size: 14px; &#125; .videoList&#123;   padding-left: 50px; &#125; .videoList p&#123;   float: left;   font-size: 14px;   margin: 10px 0;   padding: 10px;   height: 50px;   line-height: 30px;   width: 100%;   border: 1px dotted #DDD; &#125; &lt;&#x2F;style&gt;</code></pre></div><h1 id="课程管理-修改课程信息后端"><a href="#课程管理-修改课程信息后端" class="headerlink" title="课程管理-修改课程信息后端"></a>课程管理-修改课程信息后端</h1><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询基本信息@GetMapping(&quot;getCourseInfo&#x2F;&#123;courseId&#125;&quot;)public R getCourseInfo(@PathVariable String courseId)&#123;    CourseInfoVo courseInfoVo &#x3D; eduCourseService.getCourseInfo(courseId);    return R.ok().data(&quot;courseInfoVo&quot;,courseInfoVo);&#125;&#x2F;&#x2F; 修改课程信息@PostMapping(&quot;updateCourseInfo&quot;)public R updateCourseInfo(@RequestBody CourseInfoVo courseInfoVo)&#123;    eduCourseService.updateCourseInfo(courseInfoVo);    return R.ok();&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询基本信息CourseInfoVo getCourseInfo(String courseId);&#x2F;&#x2F; 修改课程信息void updateCourseInfo(CourseInfoVo courseInfoVo);</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询基本信息@Overridepublic CourseInfoVo getCourseInfo(String courseId) &#123;    &#x2F;&#x2F; 查询课程表    EduCourse eduCourse &#x3D; baseMapper.selectById(courseId);    CourseInfoVo courseInfoVo &#x3D; new CourseInfoVo();    BeanUtils.copyProperties(eduCourse,courseInfoVo);    &#x2F;&#x2F; 查询描述表    EduCourseDescription courseDescription &#x3D; eduCourseDescriptionService.getById(courseId);    courseInfoVo.setDescription(courseDescription.getDescription());    return courseInfoVo;&#125;&#x2F;&#x2F; 修改课程信息@Overridepublic void updateCourseInfo(CourseInfoVo courseInfoVo) &#123;    &#x2F;&#x2F; 修改课程表    EduCourse eduCourse &#x3D; new EduCourse();    BeanUtils.copyProperties(courseInfoVo,eduCourse);    int update &#x3D; baseMapper.updateById(eduCourse);    if (update &#x3D;&#x3D; 0)&#123;        throw new GuliException(20001,&quot;修改课程信息失败&quot;);    &#125;    &#x2F;&#x2F; 修改描述表    EduCourseDescription description &#x3D; new EduCourseDescription();    description.setId(courseInfoVo.getId());    description.setDescription(courseInfoVo.getDescription());    eduCourseDescriptionService.updateById(description);&#125;</code></pre></div><h1 id="课程管理-修改课程信息前端"><a href="#课程管理-修改课程信息前端" class="headerlink" title="课程管理-修改课程信息前端"></a>课程管理-修改课程信息前端</h1><p>course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据课程id查询课程信息getCourseInfo(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#x2F;getCourseInfo&#x2F;&#96;+id,        method: &#39;get&#39;      &#125;)&#125;,&#x2F;&#x2F; 修改课程信息updateCourseInfo(courseInfo)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;course&#x2F;updateCourseInfo&#96;,        method: &#39;post&#39;,        data:courseInfo      &#125;)&#125;</code></pre></div><p>info.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt;    import course from &#39;@&#x2F;api&#x2F;edu&#x2F;course&#39;    import subject from &#39;@&#x2F;api&#x2F;edu&#x2F;subject&#39;    import Tinymce from &#39;@&#x2F;components&#x2F;Tinymce&#39;export default &#123;.....    created()&#123;            &#x2F;&#x2F; 获取路由的id        if(this.$route.params &amp;&amp; this.$route.params.id)&#123;            this.courseId &#x3D; this.$route.params.id             &#x2F;&#x2F; 根据课程id查询课程信息            this.getCourseInfo()        &#125; else &#123;            &#x2F;&#x2F; 如果没有id，就清空表单            this.courseInfoVo &#x3D;&#123;&#125;            &#x2F;&#x2F; 初始化讲师下拉列表            this.findTeacherList()            &#x2F;&#x2F; 初始化一级分类            this.getOneSubjectList()        &#125;       &#125;,    methods:&#123;        &#x2F;&#x2F; 根据课程id查询课程信息        getCourseInfo()&#123;            course.getCourseInfo(this.courseId)            .then(response &#x3D;&gt;&#123;                &#x2F;&#x2F; 获取课程信息                this.courseInfo &#x3D; response.data.courseInfoVo                &#x2F;&#x2F; 查询所有的分类，包括一级分类和二级分类                 subject.getSubjectList()                    .then(response &#x3D;&gt;&#123;                        &#x2F;&#x2F; 获取所有的一级分类                        this.subjectOneList &#x3D; response.data.list                        &#x2F;&#x2F; 把所有的一级分类进行遍历                        for(var i &#x3D; 0; i &lt; this.subjectOneList.length; i++)&#123;                            &#x2F;&#x2F; 获取每一个一级分类                            var oneSubject &#x3D; this.subjectOneList[i];                            &#x2F;&#x2F; 比较当前courseInfo的一级分类id和所有一级分类的id                            if(this.courseInfo.subjectParentId &#x3D;&#x3D; oneSubject.id)&#123;                                &#x2F;&#x2F; 获取一级分类的所有二级分类                                this.subjectTwoList &#x3D; oneSubject.children                            &#125;                        &#125;                                        &#125;)                &#x2F;&#x2F; 初始化讲师下拉列表                this.findTeacherList()            &#125;)        &#125;,        ....                &#x2F;&#x2F; 添加        saveCourse()&#123;            course.addCourseInfo(this.courseInfo)            .then(response &#x3D;&gt;&#123;                &#x2F;&#x2F; 提示信息                this.$message(&#123;                        type: &#39;success&#39;,                        message: &#39;添加课程信息成功!&#39;                    &#125;);                  this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;chapter&#x2F;&#39;+response.data.courseId &#125;)            &#125;)                  &#125;,        &#x2F;&#x2F; 修改        updateCourse()&#123;            course.updateCourseInfo(this.courseInfo)            .then(response &#x3D;&gt;&#123;                this.$message(&#123;                        type: &#39;success&#39;,                        message: &#39;修改课程信息成功!&#39;                    &#125;);                  this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;chapter&#x2F;&#39;+this.courseId &#125;)            &#125;)        &#125;,        saveOrUpdate()&#123;          if(!this.courseId)&#123;              &#x2F;&#x2F; 添加              this.saveCourse()          &#125; else &#123;              &#x2F;&#x2F; 修改              this.updateCourse()          &#125;        &#125;    &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;.tinymce-container &#123;  line-height: 29px;&#125;&lt;&#x2F;style&gt;</code></pre></div><h1 id="课程章节后端接口"><a href="#课程章节后端接口" class="headerlink" title="课程章节后端接口"></a>课程章节后端接口</h1><p>controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 添加章节@PostMapping(&quot;addChapter&quot;)public R addChapter(@RequestBody EduChapter eduChapter)&#123;    eduChapterService.save(eduChapter);    return R.ok();&#125;&#x2F;&#x2F; 根据章节id查询章节@GetMapping(&quot;getChapterInfo&#x2F;&#123;courseId&#125;&quot;)public R getChapterInfo(@PathVariable String courseId)&#123;    eduChapterService.getById(courseId);    return R.ok();&#125;&#x2F;&#x2F; 修改章节@PostMapping(&quot;updateChapter&quot;)public R updateChapter(@RequestBody EduChapter eduChapter)&#123;    eduChapterService.updateById(eduChapter);    return R.ok();&#125;&#x2F;&#x2F; 删除章节@DeleteMapping(&quot;deleteChapter&quot;)public R deleteChapter(@PathVariable String courseId)&#123;    boolean flag &#x3D; eduChapterService.deleteChapter(courseId);    if (flag)&#123;        return R.ok();    &#125; else &#123;        return R.error();    &#125;&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除章节boolean deleteChapter(String courseId);</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 删除章节@Overridepublic boolean deleteChapter(String courseId) &#123;    &#x2F;&#x2F; 先查询是否有小节，如果有就不删除，没有就删除    QueryWrapper&lt;EduVideo&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;chapter_id&quot;,courseId);    int count &#x3D; eduVideoService.count(wrapper);    if (count &gt; 0)&#123;        &#x2F;&#x2F; 说明有小节，不能删除        throw new GuliException(20001,&quot;还有小节，不能删除&quot;);    &#125; else &#123;        &#x2F;&#x2F; 否则没有小节，可以删除章节        int result &#x3D; baseMapper.deleteById(courseId);        &#x2F;&#x2F; 如果result大于0，则为true，否则为false        return result &gt; 0;    &#125;&#125;</code></pre></div><h1 id="课程管理-添加章节前端"><a href="#课程管理-添加章节前端" class="headerlink" title="课程管理-添加章节前端"></a>课程管理-添加章节前端</h1><p>chapter.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 添加课程addChapter(chapter)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;chapter&#x2F;addChapter&#96;,        method: &#39;post&#39;,        data:chapter        &#125;)&#125;,</code></pre></div><p>chapter.vue，添加chapter对象属性</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"> export default &#123;   data() &#123;     return &#123;....       chapter: &#123;&#x2F;&#x2F; 章节对象          title:&#39;&#39;,          sort:0        &#125;     &#125;   &#125;,</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;     &#x2F;&#x2F; 添加课程     saveOrUpdate()&#123;       &#x2F;&#x2F; 设置课程id到chapter对象       this.chapter.courseId &#x3D; this.courseId        chapter.addChapter(this.chapter)        .then(response &#x3D;&gt;&#123;          &#x2F;&#x2F; 提示          this.$message(&#123;                type: &#39;success&#39;,                message: &#39;添加课程成功!&#39;            &#125;);          &#x2F;&#x2F; 关闭弹框          this.dialogChapterFormVisible &#x3D; false          &#x2F;&#x2F; 回到页面          this.getChapterVideo()        &#125;)     &#125;,</code></pre></div><h1 id="课程管理-修改章节前端"><a href="#课程管理-修改章节前端" class="headerlink" title="课程管理-修改章节前端"></a>课程管理-修改章节前端</h1><p>chapter.vue，添加编辑按钮</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 章节 --&gt;&lt;ul class&#x3D;&quot;chanpterList&quot;&gt;    &lt;li        v-for&#x3D;&quot;chapter in chapterVideoList&quot;        :key&#x3D;&quot;chapter.id&quot;&gt;        &lt;p&gt;            &#123;&#123; chapter.title &#125;&#125;          &lt;span class&#x3D;&quot;acts&quot;&gt;              &lt;el-button style&#x3D;&quot;&quot; type&#x3D;&quot;text&quot; @click&#x3D;&quot;openEditChapter(chapter.id)&quot;&gt;编辑&lt;&#x2F;el-button&gt;              &lt;el-button type&#x3D;&quot;text&quot;&gt;删除&lt;&#x2F;el-button&gt;          &lt;&#x2F;span&gt;                    &lt;&#x2F;p&gt;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods: &#123;  &#x2F;&#x2F; 修改章节弹框数据回显  openEditChapter(chapterId)&#123;    &#x2F;&#x2F; 弹框    this.dialogChapterFormVisible &#x3D; true    &#x2F;&#x2F; 调用接口    chapter.getChapter(chapterId)     .then(response &#x3D;&gt;&#123;       this.chapter &#x3D; response.data.chapter     &#125;)  &#125;,  &#x2F;&#x2F; 添加章节弹框  openChapterDialog()&#123;    this.dialogChapterFormVisible &#x3D; true    this.chapter.title &#x3D; &#39;&#39;    this.chapter.sort &#x3D; 0  &#125;,  &#x2F;&#x2F; 添加章节  addChapter()&#123;   &#x2F;&#x2F; 设置课程id到chapter对象    this.chapter.courseId &#x3D; this.courseId     chapter.addChapter(this.chapter)     .then(response &#x3D;&gt;&#123;       &#x2F;&#x2F; 提示       this.$message(&#123;             type: &#39;success&#39;,             message: &#39;添加课程成功!&#39;         &#125;);       &#x2F;&#x2F; 关闭弹框       this.dialogChapterFormVisible &#x3D; false       &#x2F;&#x2F; 回到页面       this.getChapterVideo()     &#125;)      &#125;,  &#x2F;&#x2F; 修改章节 updateChapter()&#123;   chapter.updateChapter(this.chapter)   .then(response &#x3D;&gt;&#123;        &#x2F;&#x2F; 提示       this.$message(&#123;             type: &#39;success&#39;,             message: &#39;修改课程成功!&#39;         &#125;);       &#x2F;&#x2F; 关闭弹框       this.dialogChapterFormVisible &#x3D; false       &#x2F;&#x2F; 回到页面       this.getChapterVideo()   &#125;) &#125; ,   &#x2F;&#x2F; 添加章节  saveOrUpdate()&#123;    if(!this.chapter.id)&#123;      &#x2F;&#x2F; 添加       this.addChapter()    &#125; else &#123;      &#x2F;&#x2F; 修改      this.updateChapter()    &#125;     &#125;,</code></pre></div><h1 id="课程管理-删除章节前端"><a href="#课程管理-删除章节前端" class="headerlink" title="课程管理-删除章节前端"></a>课程管理-删除章节前端</h1><p>chapter.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;removeChapter(chapter.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 删除章节    removeChapter(chapterId)&#123;      this.$confirm(&#39;此操作将永久删除讲师记录, 是否继续?&#39;, &#39;提示&#39;, &#123;           confirmButtonText: &#39;确定&#39;,           cancelButtonText: &#39;取消&#39;,           type: &#39;warning&#39;           &#125;).then(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 确认删除，执行then               &#x2F;&#x2F; 调用删除方法               chapter.deleteChapter(chapterId)                   .then(response &#x3D;&gt;&#123;     &#x2F;&#x2F; 删除成功                       &#x2F;&#x2F; 提示信息                       this.$message(&#123;                           type: &#39;success&#39;,                           message: &#39;删除成功!&#39;                       &#125;);                       &#x2F;&#x2F; 回到页面                       this.getChapterVideo()                   &#125;)                      &#125;)    &#125;,</code></pre></div><h1 id="课程管理-添加小节前端"><a href="#课程管理-添加小节前端" class="headerlink" title="课程管理-添加小节前端"></a>课程管理-添加小节前端</h1><p>api/video.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 添加小节addChapter(video)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;video&#x2F;addVideo&#96;,        method: &#39;post&#39;,        data:video        &#125;)&#125;,</code></pre></div><p>chapter.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;el-button style&#x3D;&quot;&quot; type&#x3D;&quot;text&quot; @click&#x3D;&quot;openEditVideo(chapter.id)&quot;&gt;添加小节&lt;&#x2F;el-button&gt;</code></pre></div><p>template</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 添加和修改课时表单 --&gt;     &lt;el-dialog :visible.sync&#x3D;&quot;dialogVideoFormVisible&quot; title&#x3D;&quot;添加课时&quot;&gt;       &lt;el-form :model&#x3D;&quot;video&quot; label-width&#x3D;&quot;120px&quot;&gt;         &lt;el-form-item label&#x3D;&quot;课时标题&quot;&gt;           &lt;el-input v-model&#x3D;&quot;video.title&quot;&#x2F;&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item label&#x3D;&quot;课时排序&quot;&gt;           &lt;el-input-number v-model&#x3D;&quot;video.sort&quot; :min&#x3D;&quot;0&quot; controls-position&#x3D;&quot;right&quot;&#x2F;&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item label&#x3D;&quot;是否免费&quot;&gt;           &lt;el-radio-group v-model&#x3D;&quot;video.free&quot;&gt;             &lt;el-radio :label&#x3D;&quot;true&quot;&gt;免费&lt;&#x2F;el-radio&gt;             &lt;el-radio :label&#x3D;&quot;false&quot;&gt;默认&lt;&#x2F;el-radio&gt;           &lt;&#x2F;el-radio-group&gt;         &lt;&#x2F;el-form-item&gt;         &lt;el-form-item label&#x3D;&quot;上传视频&quot;&gt;           &lt;!-- TODO --&gt;         &lt;&#x2F;el-form-item&gt;       &lt;&#x2F;el-form&gt;       &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;dialog-footer&quot;&gt;         &lt;el-button @click&#x3D;&quot;dialogVideoFormVisible &#x3D; false&quot;&gt;取 消&lt;&#x2F;el-button&gt;         &lt;el-button :disabled&#x3D;&quot;saveVideoBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdateVideo&quot;&gt;确 定&lt;&#x2F;el-button&gt;       &lt;&#x2F;div&gt;     &lt;&#x2F;el-dialog&gt;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 添加小节弹框      openEditVideo(chapterId)&#123;        &#x2F;&#x2F; 弹框        this.dialogVideoFormVisible &#x3D; true        &#x2F;&#x2F; 设置章节id        this.video.chapterId &#x3D; chapterId        this.video.title &#x3D; &#39;&#39;        this.video.sort &#x3D; 0        this.video.free &#x3D; 0        this.video.videoSourceId &#x3D; &#39;&#39;              &#125;,           &#x2F;&#x2F; 添加小节      addVideo()&#123;        &#x2F;&#x2F; 设置课程id        this.video.courseId &#x3D; this.courseId        video.addChapter(this.video)          .then(response &#x3D;&gt;&#123;          &#x2F;&#x2F; 提示            this.$message(&#123;                  type: &#39;success&#39;,                  message: &#39;添加小节成功!&#39;              &#125;);            &#x2F;&#x2F; 关闭弹框            this.dialogVideoFormVisible &#x3D; false            &#x2F;&#x2F; 回到页面            this.getChapterVideo()          &#125;)      &#125;,      saveOrUpdateVideo()&#123;        this.addVideo()      &#125;,</code></pre></div><h1 id="课程管理-删除小节前端"><a href="#课程管理-删除小节前端" class="headerlink" title="课程管理-删除小节前端"></a>课程管理-删除小节前端</h1><p>api/video.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 删除小节deleteVideo(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;video&#x2F;$&#123;id&#125;&#96;,        method: &#39;delete&#39;      &#125;)&#125;,</code></pre></div><p>chapter.js</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;span class&#x3D;&quot;acts&quot;&gt;    &lt;el-button style&#x3D;&quot;&quot; type&#x3D;&quot;text&quot;&gt;编辑&lt;&#x2F;el-button&gt;    &lt;el-button type&#x3D;&quot;text&quot; @click&#x3D;&quot;removeVideo(video.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;&lt;&#x2F;span&gt;</code></pre></div><p>methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 删除小节      removeVideo(id)&#123;          this.$confirm(&#39;此操作将永久删除小节记录, 是否继续?&#39;, &#39;提示&#39;, &#123;            confirmButtonText: &#39;确定&#39;,            cancelButtonText: &#39;取消&#39;,            type: &#39;warning&#39;            &#125;).then(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 确认删除，执行then                &#x2F;&#x2F; 调用删除方法                video.deleteVideo(id)                    .then(response &#x3D;&gt;&#123;     &#x2F;&#x2F; 删除成功                        &#x2F;&#x2F; 提示信息                        this.$message(&#123;                            type: &#39;success&#39;,                            message: &#39;删除小节成功!&#39;                        &#125;);                        &#x2F;&#x2F; 回到页面                        this.getChapterVideo()                    &#125;)                        &#125;)      &#125;,</code></pre></div><h1 id="课程管理-信息确认后端"><a href="#课程管理-信息确认后端" class="headerlink" title="课程管理-信息确认后端"></a>课程管理-信息确认后端</h1><p>根据信息确认需要返回的数据创建CoursePublishVo类，自己写SQL语句查询结果</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class CoursePublishVo &#123;    private String id;    private String title;    private String cover;    private Integer lessonNum;    private String subjectLevelOne;    private String subjectLevelTwo;    private String teacherName;    private String price;&#x2F;&#x2F;只用于显示&#125;</code></pre></div><p>mapper</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduCourseMapper extends BaseMapper&lt;EduCourse&gt; &#123;    &#x2F;&#x2F; 根据课程id查询课程信息    public CoursePublishVo getCoursePublishInfo(String courseId);&#125;</code></pre></div><p>mapper.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.atguigu.eduservice.mapper.EduCourseMapper&quot;&gt;    &lt;!--根据课程id查询课程信息--&gt;    &lt;select id&#x3D;&quot;getCoursePublishInfo&quot; resultType&#x3D;&quot;com.atguigu.eduservice.entity.vo.CoursePublishVo&quot;&gt;        SELECT          ec.&#96;id&#96;,          ec.&#96;title&#96;,          ec.&#96;price&#96;,          ec.&#96;lesson_num&#96; AS lessonNum,          ec.&#96;cover&#96;,          et.&#96;name&#96; AS teacherName,          es1.&#96;title&#96; AS subjectLevelOne,          es2.&#96;title&#96; AS subjectLevelTwo        FROM          edu_course ec          LEFT OUTER JOIN edu_course_description ecd            ON ec.&#96;id&#96; &#x3D; ecd.&#96;id&#96;          LEFT OUTER JOIN edu_teacher et            ON ec.&#96;teacher_id&#96; &#x3D; et.&#96;id&#96;          LEFT OUTER JOIN edu_subject es1            ON ec.&#96;subject_parent_id&#96; &#x3D; es1.&#96;id&#96;          LEFT OUTER JOIN edu_subject es2            ON ec.&#96;subject_id&#96; &#x3D; es2.&#96;id&#96;        WHERE ec.&#96;id&#96; &#x3D; #&#123;courseId&#125;    &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre></div><p>com.atguigu.eduservice.controller.EduCourseController编写controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询最终发布的课程信息@GetMapping(&quot;getPublishCourseInfo&#x2F;&#123;id&#125;&quot;)public R getPublishCourseInfo(@PathVariable String id)&#123;    CoursePublishVo coursePublishVo &#x3D; eduCourseService.getPublishCourse(id);    return R.ok().data(&quot;courseInfo&quot;,coursePublishVo);&#125;</code></pre></div><p>service</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询最终发布的课程信息CoursePublishVo getPublishCourse(String id);</code></pre></div><p>serviceImpl</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据课程id查询最终发布的课程信息@Overridepublic CoursePublishVo getPublishCourse(String id) &#123;    &#x2F;&#x2F; 调用mapper    CoursePublishVo coursePublishInfo &#x3D; baseMapper.getCoursePublishInfo(id);    return coursePublishInfo;&#125;</code></pre></div><p>测试的时候出现了下面这个错误，原因是maven的默认加载机制是只加载后缀为.java的文件，其他的不加载，所以新加的xml没有加载到target文件中，即没有被编译</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.atguigu.eduservice.mapper.EduCourseMapper.getCoursePublishInfo</code></pre></div><p>解决方法有</p><ol><li>复制xml到target中</li><li>把xml文件放到resources文件中</li><li><strong>推荐使用：通过配置文件加载xml文件</strong><ol><li>pom.xml</li><li>application.properties</li></ol></li></ol><p>pom.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt;&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre></div><p>application.properties</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#配置mapper xml文件的路径mybatis-plus.mapper-locations&#x3D;classpath:com&#x2F;atguigu&#x2F;eduservice&#x2F;mapper&#x2F;xml&#x2F;*.xml</code></pre></div><h1 id="403问题"><a href="#403问题" class="headerlink" title="403问题"></a>403问题</h1><h2 id="跨域或路径写错"><a href="#跨域或路径写错" class="headerlink" title="跨域或路径写错"></a>跨域或路径写错</h2><p>出现这个问题是因为在controller没有加@CrossOrigin的注解，没有开启跨域访问，或者是路径写错了403</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:9001&#x2F;eduservice&#x2F;chapter&#x2F;getAllChapterVideo&#x2F;18&#39; from origin &#39;http:&#x2F;&#x2F;localhost:9528&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day07-课程发布-添加课程信息</title>
    <link href="/myBlog/day07-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/"/>
    <url>/myBlog/day07-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="day07-课程发布-添加课程信息"><a href="#day07-课程发布-添加课程信息" class="headerlink" title="day07-课程发布-添加课程信息"></a>day07-课程发布-添加课程信息</h1><h1 id="课程管理-添加课程信息接口"><a href="#课程管理-添加课程信息接口" class="headerlink" title="课程管理-添加课程信息接口"></a>课程管理-添加课程信息接口</h1><p>课程相关表的关系</p><p><img src="/myBlog/day07-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/05-%E8%AF%BE%E7%A8%8B%E7%9B%B8%E5%85%B3%E8%A1%A8%E5%85%B3%E7%B3%BB.png" alt="05-课程相关表关系"></p><p>课程发布流程</p><p><img src="/myBlog/day07-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/04-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E7%9A%84%E8%AF%B4%E6%98%8E.png" alt="04-课程发布流程的说明"></p><p>执行代码生成器，将这四个表”edu_course”,”edu_course_description”,”edu_chapter”,”edu_video”的相关代码生成</p><h2 id="编写CourseInfoVo"><a href="#编写CourseInfoVo" class="headerlink" title="编写CourseInfoVo"></a>编写CourseInfoVo</h2><p>用于接收传进来的信息</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModel(value &#x3D; &quot;课程基本信息&quot;, description &#x3D; &quot;编辑课程基本信息的表单对象&quot;)@Datapublic class CourseInfoVo &#123;    @ApiModelProperty(value &#x3D; &quot;课程ID&quot;)    private String id;    @ApiModelProperty(value &#x3D; &quot;课程讲师ID&quot;)    private String teacherId;    @ApiModelProperty(value &#x3D; &quot;课程专业ID&quot;)    private String subjectId;    @ApiModelProperty(value &#x3D; &quot;课程专业父级ID&quot;)    private String subjectParentId;    @ApiModelProperty(value &#x3D; &quot;课程标题&quot;)    private String title;    @ApiModelProperty(value &#x3D; &quot;课程销售价格，设置为0则可免费观看&quot;)    &#x2F;&#x2F; 0.01    private BigDecimal price;    @ApiModelProperty(value &#x3D; &quot;总课时&quot;)    private Integer lessonNum;    @ApiModelProperty(value &#x3D; &quot;课程封面图片路径&quot;)    private String cover;    @ApiModelProperty(value &#x3D; &quot;课程简介&quot;)    private String description;&#125;</code></pre></div><h2 id="编写EduCourseController"><a href="#编写EduCourseController" class="headerlink" title="编写EduCourseController"></a>编写EduCourseController</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(description&#x3D;&quot;课程管理&quot;)@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;course&quot;)@CrossOriginpublic class EduCourseController &#123;    @Autowired    private EduCourseService eduCourseService;    &#x2F;&#x2F; 添加课程信息    @ApiOperation(value &#x3D; &quot;新增课程&quot;)    @PostMapping(&quot;addCourseInfo&quot;)    public R addCourseInfo(            @ApiParam(name &#x3D; &quot;CourseInfoForm&quot;, value &#x3D; &quot;课程基本信息&quot;, required &#x3D; true)            @RequestBody CourseInfoVo courseInfoVo)&#123;        eduCourseService.saveCourseInfo(courseInfoVo);        return R.ok();    &#125;&#125;</code></pre></div><h2 id="EduCourseService接口"><a href="#EduCourseService接口" class="headerlink" title="EduCourseService接口"></a>EduCourseService接口</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduCourseService extends IService&lt;EduCourse&gt; &#123;    &#x2F;&#x2F; 添加课程信息    void saveCourseInfo(CourseInfoVo courseInfoVo);&#125;</code></pre></div><h2 id="EduCourseServiceImpl实现类"><a href="#EduCourseServiceImpl实现类" class="headerlink" title="EduCourseServiceImpl实现类"></a>EduCourseServiceImpl实现类</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduCourseServiceImpl extends ServiceImpl&lt;EduCourseMapper, EduCourse&gt; implements EduCourseService &#123;    &#x2F;&#x2F; 为了添加课程描述信息到数据库    @Autowired    private EduCourseDescriptionService eduCourseDescriptionService;    &#x2F;&#x2F; 添加课程信息    @Override    public void saveCourseInfo(CourseInfoVo courseInfoVo) &#123;        &#x2F;&#x2F; 添加课程基本信息        &#x2F;&#x2F; 由于添加到数据库需要的是EduCourse，所以先创建一个EduCourse对象        EduCourse eduCourse &#x3D; new EduCourse();        &#x2F;&#x2F; 将传进来的vo对象赋值给新建的EduCourse对象        BeanUtils.copyProperties(courseInfoVo,eduCourse);        &#x2F;&#x2F; 保存到数据库        int insert &#x3D; baseMapper.insert(eduCourse);        if (insert &#x3D;&#x3D; 0)&#123;            throw new GuliException(20001,&quot;课程信息保存失败&quot;);        &#125;        &#x2F;&#x2F; 获取课程信息的id        String cid &#x3D; eduCourse.getId();        &#x2F;&#x2F; 添加课程描述信息        EduCourseDescription eduCourseDescription &#x3D; new EduCourseDescription();        eduCourseDescription.setDescription(courseInfoVo.getDescription());        eduCourseDescription.setId(cid);        eduCourseDescriptionService.save(eduCourseDescription);    &#125;&#125;</code></pre></div><h2 id="修改EduCourseDescription的主键生成策略"><a href="#修改EduCourseDescription的主键生成策略" class="headerlink" title="修改EduCourseDescription的主键生成策略"></a>修改EduCourseDescription的主键生成策略</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModelProperty(value &#x3D; &quot;创建时间&quot;)@TableField(fill &#x3D; FieldFill.INSERT)private Date gmtCreate;@ApiModelProperty(value &#x3D; &quot;更新时间&quot;)@TableField(fill &#x3D; FieldFill.INSERT_UPDATE)private Date gmtModified;</code></pre></div><h1 id="课程管理-添加课程信息前端"><a href="#课程管理-添加课程信息前端" class="headerlink" title="课程管理-添加课程信息前端"></a>课程管理-添加课程信息前端</h1><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;    path: &#39;&#x2F;course&#39;,    component: Layout,    redirect: &#39;&#x2F;course&#x2F;list&#39;,    name: &#39;Course&#39;,    meta: &#123; title: &#39;课程管理&#39;, icon: &#39;form&#39; &#125;,    children: [      &#123;        path: &#39;list&#39;,        name: &#39;EduCourseList&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;course&#x2F;list&#39;),        meta: &#123; title: &#39;课程列表&#39; &#125;      &#125;,      &#123;        path: &#39;info&#39;,        name: &#39;EduCourseInfo&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;course&#x2F;info&#39;),        meta: &#123; title: &#39;发布课程&#39; &#125;      &#125;,      &#123;        path: &#39;info&#x2F;:id&#39;,        name: &#39;EduCourseInfoEdit&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;course&#x2F;info&#39;),        meta: &#123; title: &#39;编辑课程基本信息&#39;, noCache: true &#125;,        hidden: true      &#125;,      &#123;        path: &#39;chapter&#x2F;:id&#39;,        name: &#39;EduCourseChapterEdit&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;course&#x2F;chapter&#39;),        meta: &#123; title: &#39;编辑课程大纲&#39;, noCache: true &#125;,        hidden: true      &#125;,      &#123;        path: &#39;publish&#x2F;:id&#39;,        name: &#39;EduCoursePublishEdit&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;course&#x2F;publish&#39;),        meta: &#123; title: &#39;发布课程&#39;, noCache: true &#125;,        hidden: true      &#125;    ]  &#125;,</code></pre></div><h2 id="添加vue组件"><a href="#添加vue组件" class="headerlink" title="添加vue组件"></a>添加vue组件</h2><p>chapter.vue,info,vue,list.vue,publish.vue</p><h2 id="课程信息页面"><a href="#课程信息页面" class="headerlink" title="课程信息页面"></a>课程信息页面</h2><p>info.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;h2 style&#x3D;&quot;text-align: center;&quot;&gt;发布新课程&lt;&#x2F;h2&gt;     &lt;el-steps :active&#x3D;&quot;1&quot; process-status&#x3D;&quot;wait&quot; align-center style&#x3D;&quot;margin-bottom: 40px;&quot;&gt;       &lt;el-step title&#x3D;&quot;填写课程基本信息&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;创建课程大纲&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;课程发布&quot;&#x2F;&gt;     &lt;&#x2F;el-steps&gt;     &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;next&quot;&gt;保存并下一步&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;export default &#123;    data()&#123;        return&#123;            saveBtnDisabled:false    &#x2F;&#x2F; 保存按钮是否禁用        &#125;    &#125;,    created()&#123;    &#125;,    methods:&#123;        next()&#123;            this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;chapter&#x2F;1&#39; &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><h2 id="课程大纲页面"><a href="#课程大纲页面" class="headerlink" title="课程大纲页面"></a>课程大纲页面</h2><p>chapter.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;h2 style&#x3D;&quot;text-align: center;&quot;&gt;发布新课程&lt;&#x2F;h2&gt;     &lt;el-steps :active&#x3D;&quot;2&quot; process-status&#x3D;&quot;wait&quot; align-center style&#x3D;&quot;margin-bottom: 40px;&quot;&gt;       &lt;el-step title&#x3D;&quot;填写课程基本信息&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;创建课程大纲&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;最终发布&quot;&#x2F;&gt;     &lt;&#x2F;el-steps&gt;     &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item&gt;         &lt;el-button @click&#x3D;&quot;previous&quot;&gt;上一步&lt;&#x2F;el-button&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;next&quot;&gt;下一步&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;   data() &#123;     return &#123;       saveBtnDisabled: false &#x2F;&#x2F; 保存按钮是否禁用     &#125;   &#125;,   created() &#123;     console.log(&#39;chapter created&#39;)   &#125;,   methods: &#123;     previous() &#123;       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;info&#x2F;1&#39; &#125;)     &#125;,     next() &#123;       console.log(&#39;next&#39;)       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;publish&#x2F;1&#39; &#125;)     &#125;   &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div><h2 id="课程发布页面"><a href="#课程发布页面" class="headerlink" title="课程发布页面"></a>课程发布页面</h2><p>publish.vue</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;h2 style&#x3D;&quot;text-align: center;&quot;&gt;发布新课程&lt;&#x2F;h2&gt;     &lt;el-steps :active&#x3D;&quot;3&quot; process-status&#x3D;&quot;wait&quot; align-center style&#x3D;&quot;margin-bottom: 40px;&quot;&gt;       &lt;el-step title&#x3D;&quot;填写课程基本信息&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;创建课程大纲&quot;&#x2F;&gt;       &lt;el-step title&#x3D;&quot;最终发布&quot;&#x2F;&gt;     &lt;&#x2F;el-steps&gt;     &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item&gt;         &lt;el-button @click&#x3D;&quot;previous&quot;&gt;返回修改&lt;&#x2F;el-button&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;publish&quot;&gt;发布课程&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;   data() &#123;     return &#123;       saveBtnDisabled: false &#x2F;&#x2F; 保存按钮是否禁用     &#125;   &#125;,   created() &#123;   &#125;,   methods: &#123;     previous() &#123;       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;chapter&#x2F;1&#39; &#125;)     &#125;,     publish() &#123;       this.$router.push(&#123; path: &#39;&#x2F;course&#x2F;list&#39; &#125;)     &#125;   &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div><h2 id="讲师下拉列表显示"><a href="#讲师下拉列表显示" class="headerlink" title="讲师下拉列表显示"></a>讲师下拉列表显示</h2><h3 id="组件模板"><a href="#组件模板" class="headerlink" title="组件模板"></a>组件模板</h3><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 课程讲师 TODO --&gt;        &lt;el-form-item label&#x3D;&quot;课程讲师&quot;&gt;        &lt;el-select            v-model&#x3D;&quot;courseInfo.teacherId&quot;            placeholder&#x3D;&quot;请选择&quot;&gt;            &lt;el-option            v-for&#x3D;&quot;teacher in teacherList&quot;            :key&#x3D;&quot;teacher.id&quot;            :label&#x3D;&quot;teacher.name&quot;            :value&#x3D;&quot;teacher.id&quot;&#x2F;&gt;        &lt;&#x2F;el-select&gt;        &lt;&#x2F;el-form-item&gt;</code></pre></div><h3 id="定义api"><a href="#定义api" class="headerlink" title="定义api"></a>定义api</h3><p>vue-admin-template-master\src\api\edu\course.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 查询所有讲师，下拉列表getListTeacher()&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;findAll&#96;,        method: &#39;get&#39;      &#125;)&#125;</code></pre></div><h3 id="组件脚本"><a href="#组件脚本" class="headerlink" title="组件脚本"></a>组件脚本</h3><p>定义data</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">teacherList: [] &#x2F;&#x2F; 讲师列表</code></pre></div><p>表单初始化时获取讲师列表</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created()&#123;    this.findTeacherList()&#125;,methods:&#123;    &#x2F;&#x2F; 下拉列表查询所有讲师    findTeacherList()&#123;        course.getListTeacher()        .then(response &#x3D;&gt;&#123;            this.teacherList  &#x3D; response.data.items        &#125;)    &#125;,</code></pre></div><h2 id="显示课程分类-多级联动"><a href="#显示课程分类-多级联动" class="headerlink" title="显示课程分类(多级联动)"></a>显示课程分类(多级联动)</h2><p><img src="/myBlog/day07-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83-%E6%B7%BB%E5%8A%A0%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/image-20211225171651508.png" alt="image-20211225171651508"></p><h3 id="获取一级分类"><a href="#获取一级分类" class="headerlink" title="获取一级分类"></a>获取一级分类</h3><h4 id="组件数据定义"><a href="#组件数据定义" class="headerlink" title="组件数据定义"></a>组件数据定义</h4><p>定义在data中</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">subjectOneList:[],  &#x2F;&#x2F; 一级分类subjectTwoList:[]   &#x2F;&#x2F; 二级分类</code></pre></div><h4 id="组件模板-1"><a href="#组件模板-1" class="headerlink" title="组件模板"></a>组件模板</h4><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 所属分类：级联下拉列表 --&gt;         &lt;!-- 一级分类 --&gt;         &lt;el-form-item label&#x3D;&quot;课程类别&quot;&gt;         &lt;el-select             v-model&#x3D;&quot;courseInfo.subjectParentId&quot;             placeholder&#x3D;&quot;一级分类&quot;             @change&#x3D;&quot;subjectLevelOneChanged&quot;&gt;             &lt;el-option             v-for&#x3D;&quot;subject in subjectOneList&quot;             :key&#x3D;&quot;subject.id&quot;             :label&#x3D;&quot;subject.title&quot;             :value&#x3D;&quot;subject.id&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;</code></pre></div><h4 id="组件脚本-1"><a href="#组件脚本-1" class="headerlink" title="组件脚本"></a>组件脚本</h4><p>表单初始化时获取一级分类嵌套列表，引入subject api</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import subject from &#39;@&#x2F;api&#x2F;edu&#x2F;subject&#39;</code></pre></div><p>定义方法</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created()&#123;    ...    &#x2F;&#x2F; 初始化一级分类    this.getOneSubjectList()&#125;,methods:&#123;    &#x2F;&#x2F; 查询一级分类    getOneSubjectList()&#123;        subject.getSubjectList()        .then(response &#x3D;&gt;&#123;            this.subjectOneList &#x3D; response.data.list        &#125;)    &#125;,</code></pre></div><h3 id="级联显示二级分类"><a href="#级联显示二级分类" class="headerlink" title="级联显示二级分类"></a>级联显示二级分类</h3><h4 id="组件模板-2"><a href="#组件模板-2" class="headerlink" title="组件模板"></a>组件模板</h4><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 二级分类 --&gt;         &lt;el-select v-model&#x3D;&quot;courseInfo.subjectId&quot; placeholder&#x3D;&quot;二级分类&quot;&gt;             &lt;el-option             v-for&#x3D;&quot;subject in subjectTwoList&quot;             :key&#x3D;&quot;subject.id&quot;             :label&#x3D;&quot;subject.title&quot;             :value&#x3D;&quot;subject.id&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;</code></pre></div><h4 id="注册change事件"><a href="#注册change事件" class="headerlink" title="注册change事件"></a>注册change事件</h4><p>在一级分类的<el-select>组件中注册change事件</el-select></p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;el-select @change&#x3D;&quot;subjectLevelOneChanged&quot; ......</code></pre></div><h4 id="定义change事件方法"><a href="#定义change事件方法" class="headerlink" title="定义change事件方法"></a>定义change事件方法</h4><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 显示二级分类，当选择一级分类时，显示二级分类      subjectLevelOneChanged(value)&#123;          &#x2F;&#x2F; 遍历一级分类的集合          for(var i &#x3D; 0; this.subjectOneList.length; i++)&#123;              &#x2F;&#x2F; 每一个一级分类              var oneSubject &#x3D; this.subjectOneList[i]              &#x2F;&#x2F; 判断一级分类的id是否和传进来的id一样              if(value &#x3D;&#x3D;&#x3D; oneSubject.id)&#123;                  &#x2F;&#x2F; 从一级分类中获取二级分类                  this.subjectTwoList &#x3D; oneSubject.children                  this.courseInfo.subjectId &#x3D; &#39;&#39;              &#125;          &#125;      &#125;,</code></pre></div><h2 id="封面上传"><a href="#封面上传" class="headerlink" title="封面上传"></a>封面上传</h2><h3 id="组件模板-3"><a href="#组件模板-3" class="headerlink" title="组件模板"></a>组件模板</h3><p>在info.vue中添加上传组件模板</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 课程封面--&gt;      &lt;el-form-item label&#x3D;&quot;课程封面&quot;&gt;      &lt;el-upload          :show-file-list&#x3D;&quot;false&quot;          :on-success&#x3D;&quot;handleAvatarSuccess&quot;          :before-upload&#x3D;&quot;beforeAvatarUpload&quot;          :action&#x3D;&quot;BASE_API+&#39;&#x2F;eduoss&#x2F;fileoss&#39;&quot;          class&#x3D;&quot;avatar-uploader&quot;&gt;          &lt;img :src&#x3D;&quot;courseInfo.cover&quot;&gt;      &lt;&#x2F;el-upload&gt;      &lt;&#x2F;el-form-item&gt;</code></pre></div><h3 id="结果回调"><a href="#结果回调" class="headerlink" title="结果回调"></a>结果回调</h3><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;        &#x2F;&#x2F; 上传成功        handleAvatarSuccess(res, file) &#123;            console.log(res)&#x2F;&#x2F; 上传响应            console.log(URL.createObjectURL(file.raw))&#x2F;&#x2F; base64编码            this.courseInfo.cover &#x3D; res.data.url        &#125;,        &#x2F;&#x2F; 上传之前        beforeAvatarUpload(file) &#123;            const isJPG &#x3D; file.type &#x3D;&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;            const isLt2M &#x3D; file.size &#x2F; 1024 &#x2F; 1024 &lt; 2            if (!isJPG) &#123;                this.$message.error(&#39;上传头像图片只能是 JPG 格式!&#39;)            &#125;            if (!isLt2M) &#123;                this.$message.error(&#39;上传头像图片大小不能超过 2MB!&#39;)            &#125;            return isJPG &amp;&amp; isLt2M        &#125;,</code></pre></div><h1 id="Tinymce可视化编辑器"><a href="#Tinymce可视化编辑器" class="headerlink" title="Tinymce可视化编辑器"></a>Tinymce可视化编辑器</h1><h2 id="组件初始化"><a href="#组件初始化" class="headerlink" title="组件初始化"></a>组件初始化</h2><p>Tinymce是一个传统javascript插件，默认不能用于Vue.js因此需要做一些特殊的整合步骤</p><h3 id="复制脚本库"><a href="#复制脚本库" class="headerlink" title="复制脚本库"></a>复制脚本库</h3><p>将脚本库复制到项目的static目录下（在vue-element-admin-master的static路径下）</p><h3 id="配置html变量"><a href="#配置html变量" class="headerlink" title="配置html变量"></a>配置html变量</h3><p>在 guli-admin/build/webpack.dev.conf.js 中添加配置</p><p>使在html页面中可是使用这里定义的BASE_URL变量</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">new HtmlWebpackPlugin(&#123;    ......    templateParameters: &#123;        BASE_URL: config.dev.assetsPublicPath + config.dev.assetsSubDirectory    &#125;&#125;)</code></pre></div><h3 id="引入js脚本"><a href="#引入js脚本" class="headerlink" title="引入js脚本"></a>引入js脚本</h3><p>在guli-admin/index.html 中引入js脚本</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;script src&#x3D;&lt;%&#x3D; BASE_URL %&gt;&#x2F;tinymce4.7.5&#x2F;tinymce.min.js&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&lt;%&#x3D; BASE_URL %&gt;&#x2F;tinymce4.7.5&#x2F;langs&#x2F;zh_CN.js&gt;&lt;&#x2F;script&gt;</code></pre></div><h2 id="组件引入"><a href="#组件引入" class="headerlink" title="组件引入"></a>组件引入</h2><p>为了让Tinymce能用于Vue.js项目，vue-element-admin-master对Tinymce进行了封装，下面我们将它引入到我们的课程信息页面</p><h3 id="复制组件"><a href="#复制组件" class="headerlink" title="复制组件"></a>复制组件</h3><p>src/components/Tinymce</p><h3 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h3><p>课程信息组件中引入 Tinymce</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import Tinymce from &#39;@&#x2F;components&#x2F;Tinymce&#39;export default &#123;    &#x2F;&#x2F; 初始化文本编辑器    components: &#123; Tinymce &#125;,    data()&#123;</code></pre></div><h3 id="组件模板-4"><a href="#组件模板-4" class="headerlink" title="组件模板"></a>组件模板</h3><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;!-- 课程简介--&gt;&lt;el-form-item label&#x3D;&quot;课程简介&quot;&gt;    &lt;tinymce :height&#x3D;&quot;300&quot; v-model&#x3D;&quot;courseInfo.description&quot;&#x2F;&gt;&lt;&#x2F;el-form-item&gt;</code></pre></div><h3 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h3><p>在info.vue文件的最后添加如下代码，调整上传图片按钮的高度</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style scoped&gt;.tinymce-container &#123;  line-height: 29px;&#125;&lt;&#x2F;style&gt;</code></pre></div><p>Tinymce中的图片上传功能直接存储的是图片的base64编码，因此无需图片服务器</p>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day06-整合阿里云oss和Excel导入分类</title>
    <link href="/myBlog/day06-%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8CExcel%E5%AF%BC%E5%85%A5%E5%88%86%E7%B1%BB/"/>
    <url>/myBlog/day06-%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8CExcel%E5%AF%BC%E5%85%A5%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="day06-整合阿里云oss和Excel导入分类"><a href="#day06-整合阿里云oss和Excel导入分类" class="headerlink" title="day06-整合阿里云oss和Excel导入分类"></a>day06-整合阿里云oss和Excel导入分类</h1><h1 id="讲师管理-上传讲师头像后端接口"><a href="#讲师管理-上传讲师头像后端接口" class="headerlink" title="讲师管理-上传讲师头像后端接口"></a>讲师管理-上传讲师头像后端接口</h1><h2 id="后端环境搭建"><a href="#后端环境搭建" class="headerlink" title="后端环境搭建"></a>后端环境搭建</h2><h3 id="搭建阿里云OSS项目环境"><a href="#搭建阿里云OSS项目环境" class="headerlink" title="搭建阿里云OSS项目环境"></a>搭建阿里云OSS项目环境</h3><p>在service模块下创建子模块service_oss</p><p>配置pom.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;        &lt;!-- 阿里云oss依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.aliyun.oss&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;aliyun-sdk-oss&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;!-- 日期工具栏依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;joda-time&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;joda-time&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;</code></pre></div><p>配置application.properties</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#服务端口server.port&#x3D;8002#服务名spring.application.name&#x3D;service-oss#环境设置：dev、test、prodspring.profiles.active&#x3D;dev#阿里云 OSS#不同的服务器，地址不同aliyun.oss.file.endpoint&#x3D;your endpointaliyun.oss.file.keyid&#x3D;your accessKeyIdaliyun.oss.file.keysecret&#x3D;your accessKeySecret#bucket可以在控制台创建，也可以使用java代码创建aliyun.oss.file.bucketname&#x3D;guli-file</code></pre></div><p>创建启动类，启动项目，发现报了一个需要配置数据库的问题</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following:If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</code></pre></div><p>解决方案</p><p>一，在配置文件中加入数据库的配置（由于该模块只做上传功能，不需要加入）。</p><p>二，在启动类上加入@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)这个便可，排除数据库自动装配的文件</p><h2 id="创建常量类"><a href="#创建常量类" class="headerlink" title="创建常量类"></a>创建常量类</h2><p>创建com.atguigu.oss.utils包，创建类ConstantPropertiesUtils</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 项目启动，spring接口，spring加载之后，执行接口一个方法@Componentpublic class ConstantPropertiesUtils implements InitializingBean &#123;    &#x2F;&#x2F; 读取配置文件内容    @Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)    private String keyId;    @Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)    private String keySecret;    @Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)    private String bucketName;    public static String END_POINT;    public static String ACCESS_KEY_ID;    public static String ACCESS_KEY_SECRET;    public static String BUCKET_NAME;    @Override    public void afterPropertiesSet() throws Exception &#123;        END_POINT &#x3D; endpoint;        ACCESS_KEY_ID &#x3D; keyId;        ACCESS_KEY_SECRET &#x3D; keySecret;        BUCKET_NAME &#x3D; bucketName;    &#125;&#125;</code></pre></div><p>InitializingBean这个接口是为了让其他人可以调用里面定义的属性</p><h2 id="后端接口实现"><a href="#后端接口实现" class="headerlink" title="后端接口实现"></a>后端接口实现</h2><p>在com.atguigu.oss.controller创建OssController类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;eduoss&#x2F;fileoss&quot;)@CrossOrigin@Api(description &#x3D; &quot;Oss文件上传&quot;)public class OssController &#123;    @Autowired    private OssService ossService;    &#x2F;&#x2F; 上传头像方法    @ApiOperation(&quot;头像上传&quot;)    @PostMapping    public R uploadFile(@ApiParam(name &#x3D; &quot;file&quot;,value &#x3D; &quot;上传文件&quot;,required &#x3D; false) MultipartFile file)&#123;        &#x2F;&#x2F; 获取上传文件，MultipartFile        &#x2F;&#x2F; 返回上传文件的oss路径        String url &#x3D; ossService.uploadFileAvatar(file);        return R.ok().data(&quot;url&quot;,url);    &#125;&#125;</code></pre></div><p>在com.atguigu.oss.service创建service接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface OssService &#123;    &#x2F;&#x2F; 上传头像方法    String uploadFileAvatar(MultipartFile file);&#125;</code></pre></div><p>在com.atguigu.oss.service.impl实现service接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class OssServiceImpl implements OssService &#123;    &#x2F;&#x2F; 上传头像方法    @Override    public String uploadFileAvatar(MultipartFile file) &#123;        &#x2F;&#x2F; 工具类获取值        String endpoint &#x3D; ConstantPropertiesUtils.END_POINT;        String accessKeyId &#x3D; ConstantPropertiesUtils.ACCESS_KEY_ID;        String accessKeySecret &#x3D; ConstantPropertiesUtils.ACCESS_KEY_SECRET;        String bucketName &#x3D; ConstantPropertiesUtils.BUCKET_NAME;        try &#123;            &#x2F;&#x2F; 创建ossClient实例            OSS ossClient &#x3D; new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);            &#x2F;&#x2F; 上传文件流            InputStream inputStream &#x3D; file.getInputStream();            &#x2F;&#x2F; 获取文件名称            String filename &#x3D; file.getOriginalFilename();            &#x2F;&#x2F; 第一个参数：bucket名称            &#x2F;&#x2F; 第二个参数：上传到oss文件路径和文件名称 &#x2F;aa&#x2F;bb&#x2F;1.jpg            &#x2F;&#x2F; 第三个参数：上传文件流            ossClient.putObject(bucketName, filename, inputStream);            &#x2F;&#x2F; 关闭OSSClient。            ossClient.shutdown();            &#x2F;&#x2F; 返回url            &#x2F;&#x2F; https:&#x2F;&#x2F;project-guli-oss.oss-cn-shenzhen.aliyuncs.com&#x2F;1.png            String url &#x3D; &quot;https:&#x2F;&#x2F;&quot;+bucketName+&quot;.&quot;+endpoint+&quot;&#x2F;&quot;+filename;            return url;        &#125; catch (IOException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;</code></pre></div><p>利用swagger-ui进行测试。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>多次上传相同名称文件，造成最后一次上传会把之前上传的文件覆盖</li><li>把文件进行分类管理</li></ol><p><strong>解决方案</strong></p><ol><li>在文件名称添加随机唯一值，让每个文件名不同</li><li>利用DateTime进行分类</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class OssServiceImpl implements OssService &#123;    &#x2F;&#x2F; 上传头像方法    @Override    public String uploadFileAvatar(MultipartFile file) &#123;        &#x2F;&#x2F; 工具类获取值        String endpoint &#x3D; ConstantPropertiesUtils.END_POINT;        String accessKeyId &#x3D; ConstantPropertiesUtils.ACCESS_KEY_ID;        String accessKeySecret &#x3D; ConstantPropertiesUtils.ACCESS_KEY_SECRET;        String bucketName &#x3D; ConstantPropertiesUtils.BUCKET_NAME;        try &#123;            &#x2F;&#x2F; 创建ossClient实例            OSS ossClient &#x3D; new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);            &#x2F;&#x2F; 上传文件流            InputStream inputStream &#x3D; file.getInputStream();            &#x2F;&#x2F; 获取文件名称            String fileName &#x3D; file.getOriginalFilename();            &#x2F;&#x2F; 1.在文件名里面添加随机唯一值            String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);            &#x2F;&#x2F; 24g501.jpg            fileName &#x3D; uuid+fileName;            &#x2F;&#x2F; 2.将文件按照日期分类管理            &#x2F;&#x2F; 2021&#x2F;1&#x2F;1            String datePath &#x3D; new DateTime().toString(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);            &#x2F;&#x2F; 拼接            &#x2F;&#x2F; 2021&#x2F;1&#x2F;1&#x2F;ge3201.jgp            fileName &#x3D; datePath+&quot;&#x2F;&quot;+fileName;            &#x2F;&#x2F; 第一个参数：bucket名称            &#x2F;&#x2F; 第二个参数：上传到oss文件路径和文件名称 &#x2F;aa&#x2F;bb&#x2F;1.jpg            &#x2F;&#x2F; 第三个参数：上传文件流            ossClient.putObject(bucketName, fileName, inputStream);            &#x2F;&#x2F; 关闭OSSClient。            ossClient.shutdown();            &#x2F;&#x2F; 返回url            &#x2F;&#x2F; https:&#x2F;&#x2F;project-guli-oss.oss-cn-shenzhen.aliyuncs.com&#x2F;1.png            String url &#x3D; &quot;https:&#x2F;&#x2F;&quot;+bucketName+&quot;.&quot;+endpoint+&quot;&#x2F;&quot;+fileName;            return url;        &#125; catch (IOException e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;</code></pre></div><h1 id="Nginx回顾"><a href="#Nginx回顾" class="headerlink" title="Nginx回顾"></a>Nginx回顾</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/myBlog/day06-%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8CExcel%E5%AF%BC%E5%85%A5%E5%88%86%E7%B1%BB/07-nginx%E6%A6%82%E5%BF%B5%E5%9B%9E%E9%A1%BE.png" alt="07-nginx概念回顾"></p><p>下载Nginx压缩包，解压直接使用。使用方式，通过cmd启动，关闭Nginx利用命令Nginx程序名 -s stop</p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>修改Nginx端口，80改为81</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">server &#123;        listen       81;        server_name  localhost;</code></pre></div><p>在http内加入以下转发规则</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">server &#123;listen       9001;server_name  localhost;location ~ &#x2F;eduservice&#x2F; &#123;           proxy_pass http:&#x2F;&#x2F;localhost:8001;&#125;location ~ &#x2F;eduoss&#x2F; &#123;           proxy_pass http:&#x2F;&#x2F;localhost:8002;&#125;&#125;</code></pre></div><p><img src="/myBlog/day06-%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91oss%E5%92%8CExcel%E5%AF%BC%E5%85%A5%E5%88%86%E7%B1%BB/image-20211224141522821.png" alt="image-20211224141522821"></p><p>最后再前端config/dev.env.js中的地址改成Nginx的地址，最后启动服务器测试，观察请求路径是否为Nginx配置的就可以。 </p><h1 id="讲师管理-上传讲师头像前端实现"><a href="#讲师管理-上传讲师头像前端实现" class="headerlink" title="讲师管理-上传讲师头像前端实现"></a>讲师管理-上传讲师头像前端实现</h1><h2 id="复制头像上传组件"><a href="#复制头像上传组件" class="headerlink" title="复制头像上传组件"></a>复制头像上传组件</h2><p><strong>从vue-element-admin复制组件：</strong></p><p>vue-element-admin/src/components/ImageCropper</p><p>vue-element-admin/src/components/PanThumb</p><h2 id="前端添加文件上传组件"><a href="#前端添加文件上传组件" class="headerlink" title="前端添加文件上传组件"></a>前端添加文件上传组件</h2><p><strong>src/views/edu/teacher/save.vue</strong></p><p>template：</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">!-- 讲师头像：TODO --&gt;       &lt;!-- 讲师头像 --&gt;        &lt;el-form-item label&#x3D;&quot;讲师头像&quot;&gt;            &lt;!-- 头衔缩略图 --&gt;            &lt;pan-thumb :image&#x3D;&quot;teacher.avatar&quot;&#x2F;&gt;            &lt;!-- 文件上传按钮 --&gt;            &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-upload&quot; @click&#x3D;&quot;imagecropperShow&#x3D;true&quot;&gt;更换头像            &lt;&#x2F;el-button&gt;            &lt;!--            v-show：是否显示上传组件            :key：类似于id，如果一个页面多个图片上传控件，可以做区分            :url：后台上传的url地址            @close：关闭上传组件            @crop-upload-success：上传成功后的回调 --&gt;            &lt;image-cropper                        v-show&#x3D;&quot;imagecropperShow&quot;                        :width&#x3D;&quot;300&quot;                        :height&#x3D;&quot;300&quot;                        :key&#x3D;&quot;imagecropperKey&quot;                        :url&#x3D;&quot;BASE_API+&#39;&#x2F;eduoss&#x2F;fileoss&#39;&quot;                        field&#x3D;&quot;file&quot;                        @close&#x3D;&quot;close&quot;                        @crop-upload-success&#x3D;&quot;cropSuccess&quot;&#x2F;&gt;        &lt;&#x2F;el-form-item&gt;</code></pre></div><p>引入组件模块</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import ImageCropper from &#39;@&#x2F;components&#x2F;ImageCropper&#39;import PanThumb from &#39;@&#x2F;components&#x2F;PanThumb&#39;</code></pre></div><h2 id="设置默认头像"><a href="#设置默认头像" class="headerlink" title="设置默认头像"></a>设置默认头像</h2><p>config/dev.env.js中添加阿里云oss bucket地址</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">OSS_PATH: &#39;&quot;https:&#x2F;&#x2F;guli-file.oss-cn-beijing.aliyuncs.com&quot;&#39;</code></pre></div><p>组件中初始化头像默认地址</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">const defaultForm &#x3D; &#123;  ......,  avatar: process.env.OSS_PATH + &#39;&#x2F;avatar&#x2F;default.jpg&#39;&#125;</code></pre></div><h2 id="js脚本实现上传和图片回显"><a href="#js脚本实现上传和图片回显" class="headerlink" title="js脚本实现上传和图片回显"></a>js脚本实现上传和图片回显</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">export default &#123;    components: &#123; ImageCropper, PanThumb &#125;,    data()&#123;        return&#123;           ...            BASE_API: process.env.BASE_API, &#x2F;&#x2F; 接口API地址            imagecropperShow: false, &#x2F;&#x2F; 是否显示上传组件            imagecropperKey: 0, &#x2F;&#x2F; 上传组件id            saveBtnDisabled:false    &#x2F;&#x2F; 保存按钮是否禁止        &#125;    &#125;,    ....    methods:&#123;        &#x2F;&#x2F; 上传成功饭的回调函数        cropSuccess(data)&#123;            this.imagecropperShow &#x3D; false            this.teacher.avatar &#x3D; data.url            &#x2F;&#x2F; 上传成功后，重新打开上传组件时初始化组件，否则显示上一次的上传结果            this.imagecropperKey &#x3D; this.imagecropperKey + 1        &#125;,        &#x2F;&#x2F; 关闭上传组件        close()&#123;            this.imagecropperShow &#x3D; false&#x2F;&#x2F; 上传失败后，重新打开上传组件时初始化组件，否则显示上一次的上传结果      this.imagecropperKey &#x3D; this.imagecropperKey + 1        &#125;,      ....    &#125;&#125;</code></pre></div><p>测试</p><h1 id="课程分类管理-添加课程分类后端"><a href="#课程分类管理-添加课程分类后端" class="headerlink" title="课程分类管理-添加课程分类后端"></a>课程分类管理-添加课程分类后端</h1><h2 id="EasyExcel写操作"><a href="#EasyExcel写操作" class="headerlink" title="EasyExcel写操作"></a>EasyExcel写操作</h2><p>出了下面这个，还需要poi依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;easyexcel --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.1.1&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;poi&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.17&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p>编写实体类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class DemoData &#123;&#x2F;&#x2F; 设置Excel表头名称    @ExcelProperty(&quot;学生编号&quot;)    private int sno;    @ExcelProperty(&quot;学生姓名&quot;)    private String sname;&#125;</code></pre></div><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestExcel &#123;    public static void main(String[] args) &#123;        String fileName &#x3D; &quot;E:\\1\\write.xlsx&quot;;        &#x2F;&#x2F; 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭        &#x2F;&#x2F; 如果这里想使用03 则 传入excelType参数即可        EasyExcel.write(fileName,DemoData.class).sheet(&quot;学生信息&quot;).doWrite(getData());    &#125;    public static List&lt;DemoData&gt; getData()&#123;        List&lt;DemoData&gt; list &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 0; i &lt; 10; i++) &#123;            DemoData demoData &#x3D; new DemoData();            demoData.setSno(i);            demoData.setSname(&quot;lucy&quot; + i);            list.add(demoData);        &#125;        return list;    &#125;&#125;</code></pre></div><h2 id="EasyExcel读操作"><a href="#EasyExcel读操作" class="headerlink" title="EasyExcel读操作"></a>EasyExcel读操作</h2><p>编写实体类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class DemoData &#123;    &#x2F;&#x2F; 设置Excel表头名称    @ExcelProperty(value &#x3D; &quot;学生编号&quot;,index &#x3D; 0)    private int sno;    @ExcelProperty(value &#x3D; &quot;学生姓名&quot;,index &#x3D; 1)    private String sname;&#125;</code></pre></div><p>创建监听器</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建监听器public class ExcelListener extends AnalysisEventListener&lt;DemoData&gt; &#123;    &#x2F;&#x2F; 一行一行的读，不读表头    @Override    public void invoke(DemoData data, AnalysisContext analysisContext) &#123;        System.out.println(&quot;****&quot; + data);    &#125;    &#x2F;&#x2F; 读表头    public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123;        System.out.println(&quot;表头&quot; + headMap);    &#125;    &#x2F;&#x2F; 完成读后的操作    @Override    public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123;    &#125;&#125;</code></pre></div><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    &#x2F;&#x2F; 写    &#x2F;*String fileName &#x3D; &quot;E:\\1\\write.xlsx&quot;;    &#x2F;&#x2F; 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭    &#x2F;&#x2F; 如果这里想使用03 则 传入excelType参数即可    EasyExcel.write(fileName,DemoData.class).sheet(&quot;学生信息&quot;).doWrite(getData());*&#x2F;    &#x2F;&#x2F; 读Excel操作    String fileName &#x3D; &quot;E:\\1\\write.xlsx&quot;;    EasyExcel.read(fileName,DemoData.class,new ExcelListener()).sheet().doRead();&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">表头&#123;0&#x3D;学生编号, 1&#x3D;学生姓名&#125;****DemoData(sno&#x3D;0, sname&#x3D;lucy0)****DemoData(sno&#x3D;1, sname&#x3D;lucy1)****DemoData(sno&#x3D;2, sname&#x3D;lucy2)****DemoData(sno&#x3D;3, sname&#x3D;lucy3)****DemoData(sno&#x3D;4, sname&#x3D;lucy4)****DemoData(sno&#x3D;5, sname&#x3D;lucy5)****DemoData(sno&#x3D;6, sname&#x3D;lucy6)****DemoData(sno&#x3D;7, sname&#x3D;lucy7)****DemoData(sno&#x3D;8, sname&#x3D;lucy8)****DemoData(sno&#x3D;9, sname&#x3D;lucy9)</code></pre></div><h2 id="添加课程分类"><a href="#添加课程分类" class="headerlink" title="添加课程分类"></a>添加课程分类</h2><p>导入依赖，上面已经导入了，不需要再次导入</p><p>利用代码生成器生成代码</p><p>编写controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;subject&quot;)@CrossOriginpublic class EduSubjectController &#123;    @Autowired    private EduSubjectService subjectService;    &#x2F;&#x2F; 添加课程分类    &#x2F;&#x2F; 获取上传的文件，把文件内容读取出来    @PostMapping(&quot;addSubject&quot;)    public R addSubject(MultipartFile file)&#123;        &#x2F;&#x2F; 上传过来的Excel文件        subjectService.saveSubject(file, subjectService);        return R.ok();    &#125;&#125;</code></pre></div><p>编写service接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduSubjectService extends IService&lt;EduSubject&gt; &#123;    &#x2F;&#x2F; 添加课程分类    void saveSubject(MultipartFile file,EduSubjectService subjectService);&#125;</code></pre></div><p>编写service实现类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduSubjectServiceImpl extends ServiceImpl&lt;EduSubjectMapper, EduSubject&gt; implements EduSubjectService &#123;    &#x2F;&#x2F; 添加课程分类    @Override    public void saveSubject(MultipartFile file,EduSubjectService subjectService) &#123;        try &#123;            &#x2F;&#x2F; 文件输入流            InputStream in &#x3D; file.getInputStream();            &#x2F;&#x2F; 调用方法进行读取            EasyExcel.read(in, SubjectData.class,new SubjectExcelListener(subjectService)).sheet().doRead();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><p>在com.atguigu.eduservice.entity.excel中编写表格的属性实体类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class SubjectData &#123;    @ExcelProperty(index &#x3D; 0)    private String oneSubjectName;    @ExcelProperty(index &#x3D; 1)    private String twoSubjectName;&#125;</code></pre></div><p>在com.atguigu.eduservice.listener编写监听类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SubjectExcelListener extends AnalysisEventListener&lt;SubjectData&gt; &#123;    &#x2F;&#x2F; 因为SubjectExcelListener不能交给spring管理，需要自己new，不能注入其他对象    &#x2F;&#x2F; 不能实现数据的操作    public EduSubjectService subjectService;    public SubjectExcelListener() &#123;    &#125;    public SubjectExcelListener(EduSubjectService subjectService) &#123;        this.subjectService &#x3D; subjectService;    &#125;    &#x2F;&#x2F; 一行一行读取    @Override    public void invoke(SubjectData subjectData, AnalysisContext analysisContext) &#123;        if (subjectData &#x3D;&#x3D; null)&#123;            throw new GuliException(20001,&quot;文件数据为空&quot;);        &#125;        &#x2F;&#x2F; 一行一行读取，每次读取有两个值，第一个值一级分类，第二值二级分类        &#x2F;&#x2F; 判断一级分类是否重复        EduSubject exitOneSubject &#x3D; this.exitOneSubject(subjectService, subjectData.getOneSubjectName());        if (exitOneSubject &#x3D;&#x3D; null)&#123;    &#x2F;&#x2F; 说明不存在相同的一级分类，可以添加            exitOneSubject &#x3D; new EduSubject();            exitOneSubject.setParentId(&quot;0&quot;);            exitOneSubject.setTitle(subjectData.getOneSubjectName());            subjectService.save(exitOneSubject);        &#125;        &#x2F;&#x2F; 获取一级分类id        String pid &#x3D; exitOneSubject.getId();        &#x2F;&#x2F; 判断二级分类是否重复        EduSubject exitTwoSubject &#x3D; this.exitTwoSubject(subjectService, subjectData.getOneSubjectName(),pid);        if (exitTwoSubject &#x3D;&#x3D; null)&#123;    &#x2F;&#x2F; 说明不存在相同的一级分类，可以添加            exitTwoSubject &#x3D; new EduSubject();            exitTwoSubject.setParentId(pid);            exitTwoSubject.setTitle(subjectData.getTwoSubjectName());            subjectService.save(exitTwoSubject);        &#125;    &#125;    &#x2F;&#x2F; 判断一级分类不能重复添加    private EduSubject exitOneSubject(EduSubjectService subjectService,String name)&#123;        QueryWrapper&lt;EduSubject&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;title&quot;,name);        wrapper.eq(&quot;parent_id&quot;,&quot;0&quot;);        EduSubject oneSubject &#x3D; subjectService.getOne(wrapper);        return oneSubject;    &#125;    &#x2F;&#x2F; 判断二级分类不能重复添加    private EduSubject exitTwoSubject(EduSubjectService subjectService,String name,String pid)&#123;        QueryWrapper&lt;EduSubject&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        wrapper.eq(&quot;title&quot;,name);        wrapper.eq(&quot;parent_id&quot;,pid);        EduSubject twoSubject &#x3D; subjectService.getOne(wrapper);        return twoSubject;    &#125;    @Override    public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123;    &#125;&#125;</code></pre></div><p>利用swagger测试。</p><h1 id="课程分类管理-添加课程分类前端"><a href="#课程分类管理-添加课程分类前端" class="headerlink" title="课程分类管理-添加课程分类前端"></a>课程分类管理-添加课程分类前端</h1><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><p>vue-admin-template-master\src\router\index.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;    path: &#39;&#x2F;subject&#39;,    component: Layout,    redirect: &#39;&#x2F;subject&#x2F;list&#39;,    name: &#39;课程分类管理&#39;,    meta: &#123; title: &#39;课程分类管理&#39;, icon: &#39;example&#39; &#125;,    children: [      &#123;        path: &#39;list&#39;,        name: &#39;课程列表&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;subject&#x2F;list&#39;),        meta: &#123; title: &#39;课程列表&#39;, icon: &#39;table&#39; &#125;      &#125;,      &#123;        path: &#39;save&#39;,        name: &#39;添加课程分类&#39;,        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;subject&#x2F;save&#39;),        meta: &#123; title: &#39;添加课程分类&#39;, icon: &#39;tree&#39; &#125;      &#125;    ]  &#125;,</code></pre></div><h2 id="添加vue组件"><a href="#添加vue组件" class="headerlink" title="添加vue组件"></a>添加vue组件</h2><p>list.vue和save.vue</p><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;信息描述&quot;&gt;         &lt;el-tag type&#x3D;&quot;info&quot;&gt;excel模版说明&lt;&#x2F;el-tag&gt;         &lt;el-tag&gt;           &lt;i class&#x3D;&quot;el-icon- &quot;&#x2F;&gt;           &lt;a :href&#x3D;&quot;&#39;&#x2F;static&#x2F;01.xlsx&#39;&quot;&gt;点击下载模版&lt;&#x2F;a&gt;         &lt;&#x2F;el-tag&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;选择Excel&quot;&gt;         &lt;el-upload           ref&#x3D;&quot;upload&quot;           :auto-upload&#x3D;&quot;false&quot;           :on-success&#x3D;&quot;fileUploadSuccess&quot;           :on-error&#x3D;&quot;fileUploadError&quot;           :disabled&#x3D;&quot;importBtnDisabled&quot;           :limit&#x3D;&quot;1&quot;           :action&#x3D;&quot;BASE_API+&#39;&#x2F;eduservice&#x2F;subject&#x2F;addSubject&#39;&quot;           name&#x3D;&quot;file&quot;           accept&#x3D;&quot;application&#x2F;vnd.ms-excel&quot;&gt;           &lt;el-button slot&#x3D;&quot;trigger&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;选取文件&lt;&#x2F;el-button&gt;           &lt;el-button             :loading&#x3D;&quot;loading&quot;             style&#x3D;&quot;margin-left: 10px;&quot;             size&#x3D;&quot;small&quot;             type&#x3D;&quot;success&quot;             @click&#x3D;&quot;submitUpload&quot;&gt;上传到服务器&lt;&#x2F;el-button&gt;         &lt;&#x2F;el-upload&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;</code></pre></div><h2 id="js定义数据"><a href="#js定义数据" class="headerlink" title="js定义数据"></a>js定义数据</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;script&gt; export default &#123;     data()&#123;         return&#123;            BASE_API: process.env.BASE_API,     &#x2F;&#x2F; 接口API地址            importBtnDisabled: false,           &#x2F;&#x2F; 按钮是否禁用,            loading: false         &#125;     &#125;,     created()&#123;     &#125;,     methods:&#123;         &#x2F;&#x2F; 上传到服务器         submitUpload()&#123;                    &#125;,         &#x2F;&#x2F; 上传成功         fileUploadSuccess()&#123;                    &#125;,         &#x2F;&#x2F; 上传失败         fileUploadError()&#123;                  &#125;     &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div><h2 id="js上传方法"><a href="#js上传方法" class="headerlink" title="js上传方法"></a>js上传方法</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 上传到服务器submitUpload()&#123;    this.fileUploadBtnText &#x3D; &#39;正在上传&#39;    this.importBtnDisabled &#x3D; true    this.loading &#x3D; true    this.$refs.upload.submit()&#125;,</code></pre></div><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 上传成功fileUploadSuccess()&#123;    this.loading &#x3D; false    this.$message(&#123;        type: &#39;success&#39;,        message: &#39;添加课程分类成功&#39;&#125;)&#x2F;&#x2F; 跳转到课程分类列表&#125;,&#x2F;&#x2F; 上传失败fileUploadError()&#123;    this.loading &#x3D; false    this.$message(&#123;        type: &#39;error&#39;,        message: &#39;添加课程分类失败&#39;    &#125;)&#125;</code></pre></div><p>save.vue完整代码</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;   &lt;div class&#x3D;&quot;app-container&quot;&gt;     &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;信息描述&quot;&gt;         &lt;el-tag type&#x3D;&quot;info&quot;&gt;excel模版说明&lt;&#x2F;el-tag&gt;         &lt;el-tag&gt;           &lt;i class&#x3D;&quot;el-icon- &quot;&#x2F;&gt;           &lt;a :href&#x3D;&quot;&#39;&#x2F;static&#x2F;01.xlsx&#39;&quot;&gt;点击下载模版&lt;&#x2F;a&gt;         &lt;&#x2F;el-tag&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;选择Excel&quot;&gt;         &lt;el-upload           ref&#x3D;&quot;upload&quot;           :auto-upload&#x3D;&quot;false&quot;           :on-success&#x3D;&quot;fileUploadSuccess&quot;           :on-error&#x3D;&quot;fileUploadError&quot;           :disabled&#x3D;&quot;importBtnDisabled&quot;           :limit&#x3D;&quot;1&quot;           :action&#x3D;&quot;BASE_API+&#39;&#x2F;eduservice&#x2F;subject&#x2F;addSubject&#39;&quot;           name&#x3D;&quot;file&quot;           accept&#x3D;&quot;application&#x2F;vnd.ms-excel&quot;&gt;           &lt;el-button slot&#x3D;&quot;trigger&quot; size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;选取文件&lt;&#x2F;el-button&gt;           &lt;el-button             :loading&#x3D;&quot;loading&quot;             style&#x3D;&quot;margin-left: 10px;&quot;             size&#x3D;&quot;small&quot;             type&#x3D;&quot;success&quot;             @click&#x3D;&quot;submitUpload&quot;&gt;上传到服务器&lt;&#x2F;el-button&gt;         &lt;&#x2F;el-upload&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;   &lt;&#x2F;div&gt; &lt;&#x2F;template&gt; &lt;script&gt; export default &#123;     data()&#123;         return&#123;            BASE_API: process.env.BASE_API,     &#x2F;&#x2F; 接口API地址            importBtnDisabled: false,           &#x2F;&#x2F; 按钮是否禁用,            loading: false         &#125;     &#125;,     created()&#123;     &#125;,     methods:&#123;         &#x2F;&#x2F; 上传到服务器         submitUpload()&#123;            this.fileUploadBtnText &#x3D; &#39;正在上传&#39;            this.importBtnDisabled &#x3D; true            this.loading &#x3D; true            this.$refs.upload.submit()         &#125;,         &#x2F;&#x2F; 上传成功         fileUploadSuccess()&#123;            this.loading &#x3D; false            this.$message(&#123;            type: &#39;success&#39;,                message: &#39;添加课程分类成功&#39;            &#125;)            &#x2F;&#x2F; 跳转到课程分类列表，路由转发            this.$router.push(&#123;path:&#39;&#x2F;subject&#x2F;list&#39;&#125;)         &#125;,         &#x2F;&#x2F; 上传失败         fileUploadError()&#123;            this.loading &#x3D; false            this.$message(&#123;                type: &#39;error&#39;,                message: &#39;添加课程分类失败&#39;            &#125;)         &#125;     &#125; &#125; &lt;&#x2F;script&gt;</code></pre></div><h1 id="课程分类管理-课程分类显示接口"><a href="#课程分类管理-课程分类显示接口" class="headerlink" title="课程分类管理-课程分类显示接口"></a>课程分类管理-课程分类显示接口</h1><p>树形结构，框架需要的返回数据，进行接口的编写</p><h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><p>在com.atguigu.eduservice.entity.subject下创建对应的实体类</p><p>一级分类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 一级分类@Datapublic class OneSubject &#123;    private String id;    private String title;    &#x2F;&#x2F; 存放二级分类    List&lt;TwoSubject&gt; children &#x3D; new ArrayList&lt;&gt;();&#125;</code></pre></div><p>二级分类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 二级分类@Datapublic class TwoSubject &#123;    private String id;    private String title;&#125;</code></pre></div><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;subject&quot;)@CrossOriginpublic class EduSubjectController &#123;    @Autowired    private EduSubjectService subjectService;....    &#x2F;&#x2F; 查看所有课程分类（树形结构）    @GetMapping(&quot;findAllSubject&quot;)    public R findAllSubject()&#123;        List&lt;OneSubject&gt; allSubjectList &#x3D; subjectService.findOneTwoSubject();        return R.ok().data(&quot;allSubjectList&quot;,allSubjectList);    &#125;&#125;</code></pre></div><h2 id="service接口"><a href="#service接口" class="headerlink" title="service接口"></a>service接口</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface EduSubjectService extends IService&lt;EduSubject&gt; &#123;    ....            &#x2F;&#x2F; 查看所有课程分类（树形结构）    List&lt;OneSubject&gt; findOneTwoSubject();&#125;</code></pre></div><h2 id="serviceImpl实现类"><a href="#serviceImpl实现类" class="headerlink" title="serviceImpl实现类"></a>serviceImpl实现类</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class EduSubjectServiceImpl extends ServiceImpl&lt;EduSubjectMapper, EduSubject&gt; implements EduSubjectService &#123;....                &#x2F;&#x2F; 查看所有课程分类（树形结构）    @Override    public List&lt;OneSubject&gt; findOneTwoSubject() &#123;        &#x2F;&#x2F; 一级分类的parent_id为0，二级的不为0        &#x2F;&#x2F; 1.查询所有一级分类        QueryWrapper&lt;EduSubject&gt; oneSubjectWrapper &#x3D; new QueryWrapper&lt;&gt;();        oneSubjectWrapper.eq(&quot;parent_id&quot;,&quot;0&quot;);        &#x2F;&#x2F; 调用BaseMapper查询数据库        List&lt;EduSubject&gt; oneSubjectsList &#x3D; baseMapper.selectList(oneSubjectWrapper);        &#x2F;&#x2F; 2.查询所有二级分类        QueryWrapper&lt;EduSubject&gt; twoSubjectWrapper &#x3D; new QueryWrapper&lt;&gt;();        twoSubjectWrapper.ne(&quot;parent_id&quot;,&quot;0&quot;);        List&lt;EduSubject&gt; twoSubjectsList &#x3D; baseMapper.selectList(twoSubjectWrapper);        &#x2F;&#x2F; 创建一个最终返回的list集合        List&lt;OneSubject&gt; finalSubjectList &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F; 3.封装一级分类        for (int i &#x3D; 0; i &lt; oneSubjectsList.size(); i++)&#123;            &#x2F;&#x2F; 先从集合中得到一个EduSubject对象            EduSubject eduSubject &#x3D; oneSubjectsList.get(i);            &#x2F;&#x2F; 创建一个OneSubject对象，将从集合中取出的值加入进去oneSubject            OneSubject oneSubject &#x3D; new OneSubject();            &#x2F;&#x2F; 第一种写法            &#x2F;&#x2F;oneSubject.setId(eduSubject.getId());            &#x2F;&#x2F;oneSubject.setTitle(eduSubject.getTitle());            &#x2F;&#x2F; 第二种写法，利用工具类，将eduSubject的值赋给oneSubject，效果和上面的一样            BeanUtils.copyProperties(eduSubject,oneSubject);            &#x2F;&#x2F; 将oneSubject加入到最终的集合finalSubjectList            finalSubjectList.add(oneSubject);            &#x2F;&#x2F; 4.封装二级分类            &#x2F;&#x2F; 先创建一个集合保存二级分类            List&lt;TwoSubject&gt; finalTwoSubjectList &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 遍历twoSubjectsList，拿到数据            for (int m &#x3D; 0; m &lt; twoSubjectsList.size(); m++) &#123;                &#x2F;&#x2F; 从遍历twoSubjectsList中取一个EduSubject对象                EduSubject tSubject &#x3D; twoSubjectsList.get(m);                &#x2F;&#x2F; 创建一个twoSubject，方便从twoSubjectsList取出来的tSubject加入                TwoSubject twoSubject &#x3D; new TwoSubject();                &#x2F;&#x2F; 判断是否需要该一级分类的                if (tSubject.getParentId().equals(eduSubject.getId()))&#123;                    &#x2F;&#x2F; 如果二级分类的ParentId等于一级分类的id就说明是同一分类的，则将tSubject赋值给twoSubject                    BeanUtils.copyProperties(tSubject,twoSubject);                    &#x2F;&#x2F; 将赋值后的twoSubject加入到finalTwoSubjectList中                    finalTwoSubjectList.add(twoSubject);                &#125;            &#125;            &#x2F;&#x2F; 当这个for循环结束后，将二级分类集合加入到当前一级分类            oneSubject.setChildren(finalTwoSubjectList);        &#125;        return finalSubjectList;    &#125;&#125;</code></pre></div><p>测试</p><h1 id="课程分类管理-课程分类显示前端"><a href="#课程分类管理-课程分类显示前端" class="headerlink" title="课程分类管理-课程分类显示前端"></a>课程分类管理-课程分类显示前端</h1><p>在vue-admin-template-master\src\api\edu\subject.js，添加方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">export default&#123;    &#x2F;&#x2F; 查询课程分类列表    getSubjectList()&#123;        return request(&#123;            url: &#96;&#x2F;eduservice&#x2F;subject&#x2F;findAllSubject&#96;,            method: &#39;get&#39;          &#125;)    &#125;   &#125;</code></pre></div><p>在vue-admin-template-master\src\views\edu\subject\list.vue将data2的值置空</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">data() &#123;  return &#123;    filterText: &#39;&#39;,    data2: [],    defaultProps: &#123;      children: &#39;children&#39;,      label: &#39;title&#39;    &#125;  &#125;&#125;s</code></pre></div><p>导入方法</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">import subject from &#39;@&#x2F;api&#x2F;edu&#x2F;subject&#39;</code></pre></div><p>调用方法</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue"> created()&#123;    &#x2F;&#x2F; 调用查询课程分类的方法    this.getAllSubject()  &#125;,...  methods: &#123;    &#x2F;&#x2F; 查询课程分类列表    getAllSubject()&#123;        subject.getSubjectList()        .then(response &#x3D;&gt;&#123;            this.data2 &#x3D; response.data.list        &#125;)    &#125;,</code></pre></div><p>检索功能优化，优化区分大小写，优化后不区分大小写</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">filterNode(value, data) &#123;      if (!value) return true      return data.title.toLowerCase().indexOf(value.toLowerCase()) !&#x3D;&#x3D; -1    &#125;</code></pre></div><p>list.vue完整代码</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;  &lt;div class&#x3D;&quot;app-container&quot;&gt;    &lt;el-input v-model&#x3D;&quot;filterText&quot; placeholder&#x3D;&quot;Filter keyword&quot; style&#x3D;&quot;margin-bottom:30px;&quot; &#x2F;&gt;    &lt;el-tree      ref&#x3D;&quot;tree2&quot;      :data&#x3D;&quot;data2&quot;      :props&#x3D;&quot;defaultProps&quot;      :filter-node-method&#x3D;&quot;filterNode&quot;      class&#x3D;&quot;filter-tree&quot;      default-expand-all    &#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import subject from &#39;@&#x2F;api&#x2F;edu&#x2F;subject&#39;export default &#123;  data() &#123;    return &#123;      filterText: &#39;&#39;,      data2: [],      defaultProps: &#123;        children: &#39;children&#39;,        label: &#39;title&#39;      &#125;    &#125;  &#125;,  created()&#123;    &#x2F;&#x2F; 调用查询课程分类的方法    this.getAllSubject()  &#125;,  watch: &#123;    filterText(val) &#123;      this.$refs.tree2.filter(val)    &#125;  &#125;,  methods: &#123;    &#x2F;&#x2F; 查询课程分类列表    getAllSubject()&#123;        subject.getSubjectList()        .then(response &#x3D;&gt;&#123;            this.data2 &#x3D; response.data.list        &#125;)    &#125;,    filterNode(value, data) &#123;      if (!value) return true      return data.title.toLowerCase().indexOf(value.toLowerCase()) !&#x3D;&#x3D; -1    &#125;  &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day05-讲师管理模块前端开发</title>
    <link href="/myBlog/day05-%E8%AE%B2%E5%B8%88%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/myBlog/day05-%E8%AE%B2%E5%B8%88%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="day05-讲师管理模块前端开发"><a href="#day05-讲师管理模块前端开发" class="headerlink" title="day05-讲师管理模块前端开发"></a>day05-讲师管理模块前端开发</h1><h1 id="后台系统登录功能改造"><a href="#后台系统登录功能改造" class="headerlink" title="后台系统登录功能改造"></a>后台系统登录功能改造</h1><p>在config中的dev.env.js把地址改成下面的</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#39;use strict&#39;const merge &#x3D; require(&#39;webpack-merge&#39;)const prodEnv &#x3D; require(&#39;.&#x2F;prod.env&#39;)module.exports &#x3D; merge(prodEnv, &#123;  NODE_ENV: &#39;&quot;development&quot;&#39;,  &#x2F;&#x2F;BASE_API: &#39;&quot;https:&#x2F;&#x2F;easy-mock.com&#x2F;mock&#x2F;5950a2419adc231f356a6636&#x2F;vue-admin&quot;&#39;,  BASE_API: &#39;&quot;http:&#x2F;&#x2F;localhost:8001&quot;&#39;,&#125;)</code></pre></div><p>在com.atguigu.eduservice.controller包下面，先模拟一个登录controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;user&quot;)@CrossOrigin    &#x2F;&#x2F; 解决跨域public class EduLoginController &#123;    &#x2F;&#x2F; login    @PostMapping(&quot;login&quot;)    public R login()&#123;        return R.ok().data(&quot;token&quot;,&quot;token&quot;);    &#125;    &#x2F;&#x2F; info    @GetMapping(&quot;info&quot;)    public R info()&#123;        return R.ok().data(&quot;roles&quot;,&quot;roles&quot;).data(&quot;name&quot;,&quot;name&quot;).data(&quot;avatar&quot;,&quot;http:&#x2F;&#x2F;img.hb.aicdn.com&#x2F;7378f66599670a3614ce38edf79bf1551dacd8d0f5c70-53yvFv_fw580&quot;);    &#125;&#125;</code></pre></div><p>在vue的api文件夹中修改url</p><p><img src="/myBlog/day05-%E8%AE%B2%E5%B8%88%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/image-20211223104513320.png" alt="image-20211223104513320"></p><p>启动后端服务器和前端页面，这时会报一个跨域的错误，只需要在controller上面加@CrossOrigin，重启服务器即可解决跨域问题。</p><h1 id="前端框架开发过程介绍"><a href="#前端框架开发过程介绍" class="headerlink" title="前端框架开发过程介绍"></a>前端框架开发过程介绍</h1><p><img src="/myBlog/day05-%E8%AE%B2%E5%B8%88%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/03-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D.png" alt="03-前端框架开发过程介绍"></p><h1 id="讲师管理前端"><a href="#讲师管理前端" class="headerlink" title="讲师管理前端"></a>讲师管理前端</h1><h2 id="讲师列表"><a href="#讲师列表" class="headerlink" title="讲师列表"></a>讲师列表</h2><p>添加路由</p><p>在src的router的index.js文件中，添加讲师管理路由</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;  path: &#39;&#x2F;teacher&#39;,  component: Layout,  redirect: &#39;&#x2F;teacher&#x2F;table&#39;,  name: &#39;讲师管理&#39;,  meta: &#123; title: &#39;讲师管理&#39;, icon: &#39;example&#39; &#125;,  children: [    &#123;      path: &#39;table&#39;,      name: &#39;讲师列表&#39;,      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;teacher&#x2F;list&#39;),      meta: &#123; title: &#39;讲师列表&#39;, icon: &#39;table&#39; &#125;    &#125;,    &#123;      path: &#39;save&#39;,      name: &#39;添加讲师&#39;,      component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;teacher&#x2F;save&#39;),      meta: &#123; title: &#39;添加讲师&#39;, icon: &#39;tree&#39; &#125;    &#125;  ]&#125;,</code></pre></div><p>在views/edu/teacher下创建list.vue和save.vue文件</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师列表    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;</code></pre></div><p>在api/edu下面创建teacher.js文件，写方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">import request from &#39;@&#x2F;utils&#x2F;request&#39;export default&#123;    &#x2F;&#x2F; 1.讲师列表（条件查询分页）    &#x2F;&#x2F; current:当前分页，limit每页记录数，teacherQuery条件对象    getTeacherListPage(current,limit,teacherQuery)&#123;        return request(&#123;            &#x2F;&#x2F; 可以拼接            &#x2F;&#x2F;url: &#39;&#x2F;eduservice&#x2F;teacher&#x2F;pageTeacherCondition&#39;+&quot;&#x2F;&quot;+&#39;current&#39;,            url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;pageTeacherCondition&#x2F;$&#123;current&#125;&#x2F;$&#123;limit&#125;&#96;,            method: &#39;post&#39;,            &#x2F;&#x2F; teacherQuery条件对象，后端使用RequestBody获取数据            &#x2F;&#x2F; data表示把对象转成json进行传递到接口里面            data:teacherQuery          &#125;)    &#125;&#125;</code></pre></div><p>回到刚刚创建的list.vue页面将teacher.js文件引入当前页面，开始编码</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师列表    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 引入teacher.js文import teacher from &#39;@&#x2F;api&#x2F;edu&#x2F;teacher&#39;export default &#123;    data()&#123;     &#x2F;&#x2F; 定义变量和初始值        return&#123;            list:null,  &#x2F;&#x2F; 查询之后接口返回集合            page : 1,   &#x2F;&#x2F; 当前页            limit : 10, &#x2F;&#x2F; 每页的记录数            total : 0,  &#x2F;&#x2F; 总记录数            teacherQuery:&#123;&#125;    &#x2F;&#x2F; 条封装对象        &#125;    &#125;,    created()&#123;      &#x2F;&#x2F; 页面渲染之前执行，调用创建的方法        this.getList    &#125;,    methods:&#123;        &#x2F;&#x2F; 讲师列表        getList()&#123;            teacher.getTeacherListPage(this.current,this.limit,this.teacherQuery)            .then(response &#x3D;&gt;&#123;&#x2F;&#x2F; 执行成功                &#x2F;&#x2F; response接口接口返回的数据                console.log(response);            &#125;)                 .catch(error &#x3D;&gt;&#123; &#x2F;&#x2F; 执行失败                console.log(error);            &#125;)           &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p>测试看显示是否正确。正确之后，进行数据显示，完整代码如下</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        &lt;!-- 表格 --&gt;        &lt;el-table        v-loading&#x3D;&quot;listLoading&quot;        :data&#x3D;&quot;list&quot;        element-loading-text&#x3D;&quot;数据加载中&quot;        border        fit        highlight-current-row&gt;        &lt;el-table-column            label&#x3D;&quot;序号&quot;            width&#x3D;&quot;70&quot;            align&#x3D;&quot;center&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &#123;&#123; (page - 1) * limit + scope.$index + 1 &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;名称&quot; width&#x3D;&quot;80&quot; &#x2F;&gt;        &lt;el-table-column label&#x3D;&quot;头衔&quot; width&#x3D;&quot;80&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &#123;&#123; scope.row.level&#x3D;&#x3D;&#x3D;1?&#39;高级讲师&#39;:&#39;首席讲师&#39; &#125;&#125;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;intro&quot; label&#x3D;&quot;资历&quot; &#x2F;&gt;        &lt;el-table-column prop&#x3D;&quot;gmtCreate&quot; label&#x3D;&quot;添加时间&quot; width&#x3D;&quot;160&quot;&#x2F;&gt;        &lt;el-table-column prop&#x3D;&quot;sort&quot; label&#x3D;&quot;排序&quot; width&#x3D;&quot;60&quot; &#x2F;&gt;        &lt;el-table-column label&#x3D;&quot;操作&quot; width&#x3D;&quot;200&quot; align&#x3D;&quot;center&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;            &lt;router-link :to&#x3D;&quot;&#39;&#x2F;edu&#x2F;teacher&#x2F;edit&#x2F;&#39;+scope.row.id&quot;&gt;                &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;修改&lt;&#x2F;el-button&gt;            &lt;&#x2F;router-link&gt;            &lt;el-button type&#x3D;&quot;danger&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-delete&quot; @click&#x3D;&quot;removeDataById(scope.row.id)&quot;&gt;删除&lt;&#x2F;el-button&gt;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;        &lt;&#x2F;el-table&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 引入teacher.js文import teacher from &#39;@&#x2F;api&#x2F;edu&#x2F;teacher&#39;export default &#123;    data()&#123;     &#x2F;&#x2F; 定义变量和初始值        return&#123;            list:null,  &#x2F;&#x2F; 查询之后接口返回集合            page:1,   &#x2F;&#x2F; 当前页            limit:10, &#x2F;&#x2F; 每页的记录数            total:0,  &#x2F;&#x2F; 总记录数            teacherQuery:&#123;&#125;    &#x2F;&#x2F; 条封装对象        &#125;    &#125;,    created()&#123;      &#x2F;&#x2F; 页面渲染之前执行，调用创建的方法        this.getList()    &#125;,    methods:&#123;        &#x2F;&#x2F; 讲师列表        getList()&#123;            teacher.getTeacherListPage(this.page,this.limit,this.teacherQuery)                .then(response &#x3D;&gt;&#123;&#x2F;&#x2F; 执行成功                    &#x2F;&#x2F; response接口接口返回的数据                    &#x2F;&#x2F;console.log(response)                    this.list &#x3D; response.data.rows                    this.total &#x3D; response.data.total                    console.log(this.list)                    console.log(this.total)                &#125;)                     .catch(error &#x3D;&gt;&#123; &#x2F;&#x2F; 执行失败                    console.log(error)                &#125;)           &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p>再次测试。</p><h2 id="讲师分页"><a href="#讲师分页" class="headerlink" title="讲师分页"></a>讲师分页</h2><p>在src/views/edu/teacher/list.vue中的table标签外加分页组件</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;!-- 分页 --&gt;   &lt;el-pagination     :current-page&#x3D;&quot;page&quot;     :page-size&#x3D;&quot;limit&quot;     :total&#x3D;&quot;total&quot;     style&#x3D;&quot;padding: 30px 0; text-align: center;&quot;     layout&#x3D;&quot;total, prev, pager, next, jumper&quot;     @current-change&#x3D;&quot;getList&quot;   &#x2F;&gt;</code></pre></div><p>在getList方法中作下面的修改</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 讲师列表       getList(page &#x3D; 1)&#123;           this.page &#x3D; page           teacher.getTeacherListPage(this.page,this.limit,this.teacherQuery)</code></pre></div><h2 id="讲师条件查询"><a href="#讲师条件查询" class="headerlink" title="讲师条件查询"></a>讲师条件查询</h2><p>在table标签上面添加表单</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;!--查询表单--&gt;     &lt;el-form :inline&#x3D;&quot;true&quot; class&#x3D;&quot;demo-form-inline&quot;&gt;       &lt;el-form-item&gt;         &lt;el-input v-model&#x3D;&quot;teacherQuery.name&quot; placeholder&#x3D;&quot;讲师名&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-form-item&gt;         &lt;el-select v-model&#x3D;&quot;teacherQuery.level&quot; clearable placeholder&#x3D;&quot;讲师头衔&quot;&gt;           &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-form-item label&#x3D;&quot;添加时间&quot;&gt;         &lt;el-date-picker           v-model&#x3D;&quot;teacherQuery.begin&quot;           type&#x3D;&quot;datetime&quot;           placeholder&#x3D;&quot;选择开始时间&quot;           value-format&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;           default-time&#x3D;&quot;00:00:00&quot;         &#x2F;&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-form-item&gt;         &lt;el-date-picker           v-model&#x3D;&quot;teacherQuery.end&quot;           type&#x3D;&quot;datetime&quot;           placeholder&#x3D;&quot;选择截止时间&quot;           value-format&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;           default-time&#x3D;&quot;00:00:00&quot;         &#x2F;&gt;       &lt;&#x2F;el-form-item&gt;          &lt;el-button type&#x3D;&quot;primary&quot; icon&#x3D;&quot;el-icon-search&quot; @click&#x3D;&quot;getList()&quot;&gt;查询&lt;&#x2F;el-button&gt;       &lt;el-button type&#x3D;&quot;default&quot; @click&#x3D;&quot;resetData()&quot;&gt;清空&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form&gt;</code></pre></div><p>在mothods中添加清空方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">methods:&#123;       resetData()&#123;    &#x2F;&#x2F;清空           &#x2F;&#x2F; 清空所有数据           this.teacherQuery &#x3D; &#123;&#125;           &#x2F;&#x2F; 查询所有用户           this.getList()       &#125;   &#125;</code></pre></div><h2 id="讲师删除"><a href="#讲师删除" class="headerlink" title="讲师删除"></a>讲师删除</h2><p>在api/edu下面的teacher.js文件，添加删除讲师方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 删除讲师deleteTeacherId(id) &#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;$&#123;id&#125;&#96;,        method: &#39;delete&#39;    &#125;)&#125;</code></pre></div><p>在src/views/edu/teacher/list.vue中的methods标签里面加删除方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 删除讲师removeDataById(id)&#123;    this.$confirm(&#39;此操作将永久删除讲师记录, 是否继续?&#39;, &#39;提示&#39;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;    &#125;).then(() &#x3D;&gt; &#123;     &#x2F;&#x2F; 确认删除，执行then        &#x2F;&#x2F; 调用删除方法        teacher.deleteTeacherId(id)            .then(response &#x3D;&gt;&#123;     &#x2F;&#x2F; 删除成功            &#x2F;&#x2F; 提示信息            this.$message(&#123;                type: &#39;success&#39;,                message: &#39;删除成功!&#39;            &#125;);            &#x2F;&#x2F; 回到列表页面            this.getList()        &#125;)    &#125;)&#125;</code></pre></div><h2 id="讲师添加"><a href="#讲师添加" class="headerlink" title="讲师添加"></a>讲师添加</h2><p>初始化src/views/edu/teacher/save.vue页面</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师添加        &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;讲师名称&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.name&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师排序&quot;&gt;         &lt;el-input-number v-model&#x3D;&quot;teacher.sort&quot; controls-position&#x3D;&quot;right&quot; min&#x3D;&quot;0&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师头衔&quot;&gt;         &lt;el-select v-model&#x3D;&quot;teacher.level&quot; clearable placeholder&#x3D;&quot;请选择&quot;&gt;           &lt;!--             数据类型一定要和取出的json中的一致，否则没法回填             因此，这里value使用动态绑定的值，保证其数据类型是number           --&gt;           &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师资历&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.career&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师简介&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.intro&quot; :rows&#x3D;&quot;10&quot; type&#x3D;&quot;textarea&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;!-- 讲师头像：TODO --&gt;       &lt;el-form-item&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdate&quot;&gt;保存&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;    data()&#123;        return&#123;        &#125;    &#125;,    create()&#123;    &#125;,    methods:&#123;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p>在api/edu下面的teacher.js文件，编写添加讲师方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F; 添加讲师addTeacher(teacher)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;addTeacher&#96;,        method: &#39;post&#39;,        data:teacher    &#125;)&#125;</code></pre></div><p>完成save.vue中方法的编写和调用，完整代码如下</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师添加        &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;讲师名称&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.name&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师排序&quot;&gt;         &lt;el-input-number v-model&#x3D;&quot;teacher.sort&quot; controls-position&#x3D;&quot;right&quot; min&#x3D;&quot;0&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师头衔&quot;&gt;         &lt;el-select v-model&#x3D;&quot;teacher.level&quot; clearable placeholder&#x3D;&quot;请选择&quot;&gt;           &lt;!--             数据类型一定要和取出的json中的一致，否则没法回填             因此，这里value使用动态绑定的值，保证其数据类型是number           --&gt;           &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师资历&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.career&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师简介&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.intro&quot; :rows&#x3D;&quot;10&quot; type&#x3D;&quot;textarea&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;!-- 讲师头像：TODO --&gt;       &lt;el-form-item&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdate&quot;&gt;保存&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import teacherAPI from &#39;@&#x2F;api&#x2F;edu&#x2F;teacher&#39;export default &#123;    data()&#123;        return&#123;            teacher:&#123;                name: &#39;&#39;,                sort: 0,                level: 1,                career: &#39;&#39;,                intro: &#39;&#39;,                avatar: &#39;&#39;            &#125;        &#125;    &#125;,    create()&#123;    &#125;,    methods:&#123;        &#x2F;&#x2F;         saveOrUpdate()&#123;            &#x2F;&#x2F; 添加            this.saveTeacher()        &#125;,        &#x2F;&#x2F; 添加讲师        saveTeacher()&#123;            teacherAPI.addTeacher(this.teacher)            .then(response &#x3D;&gt;&#123;      &#x2F;&#x2F;添加成功            &#x2F;&#x2F; 提示信息            this.$message(&#123;                type: &#39;success&#39;,                message: &#39;删除成功!&#39;            &#125;);            &#x2F;&#x2F; 返回list页面            this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)            &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><h2 id="讲师修改"><a href="#讲师修改" class="headerlink" title="讲师修改"></a>讲师修改</h2><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><p>在src/router/index.js添加一个隐藏路由</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;  path: &#39;edit&#x2F;:id&#39;,  name: &#39;EduTeacherEdit&#39;,  component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;edu&#x2F;teacher&#x2F;save&#39;),  meta: &#123; title: &#39;编辑讲师&#39;, noCache:true &#125;,  hidden:true&#125;</code></pre></div><p>在src/views/edu/teacher/list.vue中的修改按钮处做修改</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;router-link :to&#x3D;&quot;&#39;&#x2F;teacher&#x2F;edit&#x2F;&#39;+scope.row.id&quot;&gt;    &lt;el-button type&#x3D;&quot;primary&quot; size&#x3D;&quot;mini&quot; icon&#x3D;&quot;el-icon-edit&quot;&gt;修改&lt;&#x2F;el-button&gt;&lt;&#x2F;router-link&gt;</code></pre></div><p>测试效果，实现点击修改按钮，路由跳转到添加的页面</p><h3 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h3><p>在api/edu下面的teacher.js文件，编写根据讲师id查询信息方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 根据id查询讲师    getTeacherInfo(id)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;getTeacher&#x2F;$&#123;id&#125;&#96;,        method: &#39;get&#39;    &#125;)&#125;</code></pre></div><p>在save.vue中添加根据讲师id查询信息</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">methods:&#123;       &#x2F;&#x2F; 根据讲师id查询信息       getInfo(id)&#123;           teacherAPI.getTeacherInfo(id)           .then(response &#x3D;&gt;&#123;               this.teacher &#x3D; response.data.teacher           &#125;)        &#125;,       saveOrUpdate()&#123;           &#x2F;&#x2F; 添加           this.saveTeacher()       &#125;,       &#x2F;&#x2F; 添加讲师       saveTeacher()&#123;           teacherAPI.addTeacher(this.teacher)           .then(response &#x3D;&gt;&#123;      &#x2F;&#x2F;添加成功           &#x2F;&#x2F; 提示信息           this.$message(&#123;               type: &#39;success&#39;,               message: &#39;删除成功!&#39;           &#125;);           &#x2F;&#x2F; 返回list页面           this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)           &#125;)       &#125;   &#125;</code></pre></div><p>由于添加讲师的方法和修改讲师的方法的路径有差别，添加讲师的没有带id，修改讲师的有带id，所以根据路由的参数的id判断是否需要数据回显</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created()&#123;   &#x2F;&#x2F; 页面渲染之前执行    &#x2F;&#x2F; 判断路径是否有id值    if (this.$route.params &amp;&amp; this.$route.params.id) &#123;    &#x2F;&#x2F; 从路径获取id值    const id &#x3D; this.$route.params.id    &#x2F;&#x2F; 调用根据id查询的方法    this.getInfo(id)    &#125;&#125;,</code></pre></div><h3 id="完成修改"><a href="#完成修改" class="headerlink" title="完成修改"></a>完成修改</h3><p>在api/edu下面的teacher.js文件，编写修改讲师方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 修改讲师updateTeacherInfo(teacher)&#123;    return request(&#123;        url: &#96;&#x2F;eduservice&#x2F;teacher&#x2F;updateTeacher&#96;,        method: &#39;post&#39;,        data:teacher    &#125;)&#125;</code></pre></div><p>在save.vue的methods中添加方法</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&#x2F;&#x2F; 修改讲师       updateTeacher()&#123;           teacherAPI.updateTeacherInfo(this.teacher)           .then(response &#x3D;&gt;&#123;               &#x2F;&#x2F; 提示信息               this.$message(&#123;                   type: &#39;success&#39;,                   message: &#39;修改成功!&#39;               &#125;);               &#x2F;&#x2F; 返回list页面               this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)              &#125;)       &#125;,</code></pre></div><p>由于添加和修改都在同一个页面，先判断是哪个方法,在save.vue的methods</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">saveOrUpdate()&#123;    &#x2F;&#x2F; 判断修改还是添加    &#x2F;&#x2F; 根据teacher是否有id    if(!this.teacher.id)&#123;        &#x2F;&#x2F; 添加    this.saveTeacher()    &#125; else&#123;        &#x2F;&#x2F; 修改        this.updateTeacher()    &#125;    &#125;,</code></pre></div><p>save.vue完整代码</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师添加        &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;讲师名称&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.name&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师排序&quot;&gt;         &lt;el-input-number v-model&#x3D;&quot;teacher.sort&quot; controls-position&#x3D;&quot;right&quot; min&#x3D;&quot;0&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师头衔&quot;&gt;         &lt;el-select v-model&#x3D;&quot;teacher.level&quot; clearable placeholder&#x3D;&quot;请选择&quot;&gt;           &lt;!--             数据类型一定要和取出的json中的一致，否则没法回填             因此，这里value使用动态绑定的值，保证其数据类型是number           --&gt;           &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师资历&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.career&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师简介&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.intro&quot; :rows&#x3D;&quot;10&quot; type&#x3D;&quot;textarea&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;!-- 讲师头像：TODO --&gt;       &lt;el-form-item&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdate&quot;&gt;保存&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import teacherAPI from &#39;@&#x2F;api&#x2F;edu&#x2F;teacher&#39;export default &#123;    data()&#123;        return&#123;            teacher:&#123;                name: &#39;&#39;,                sort: 0,                level: 1,                career: &#39;&#39;,                intro: &#39;&#39;,                avatar: &#39;&#39;            &#125;,            saveBtnDisabled:false    &#x2F;&#x2F; 保存按钮是否禁止        &#125;    &#125;,    created()&#123;   &#x2F;&#x2F; 页面渲染之前执行        &#x2F;&#x2F; 判断路径是否有id值        if (this.$route.params &amp;&amp; this.$route.params.id) &#123;        &#x2F;&#x2F; 从路径获取id值        const id &#x3D; this.$route.params.id        &#x2F;&#x2F; 调用根据id查询的方法        this.getInfo(id)        &#125;    &#125;,    methods:&#123;        &#x2F;&#x2F; 根据讲师id查询信息        getInfo(id)&#123;            teacherAPI.getTeacherInfo(id)            .then(response &#x3D;&gt;&#123;                this.teacher &#x3D; response.data.teacher            &#125;)         &#125;,        saveOrUpdate()&#123;            &#x2F;&#x2F; 判断修改还是添加            &#x2F;&#x2F; 根据teacher是否有id            if(!this.teacher.id)&#123;                &#x2F;&#x2F; 添加            this.saveTeacher()            &#125; else&#123;                &#x2F;&#x2F; 修改                this.updateTeacher()            &#125;                    &#125;,        &#x2F;&#x2F; 修改讲师        updateTeacher()&#123;            teacherAPI.updateTeacherInfo(this.teacher)            .then(response &#x3D;&gt;&#123;                &#x2F;&#x2F; 提示信息                this.$message(&#123;                    type: &#39;success&#39;,                    message: &#39;修改成功!&#39;                &#125;);                &#x2F;&#x2F; 返回list页面                this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)                &#125;)        &#125;,        &#x2F;&#x2F; 添加讲师        saveTeacher()&#123;            teacherAPI.addTeacher(this.teacher)            .then(response &#x3D;&gt;&#123;      &#x2F;&#x2F;添加成功            &#x2F;&#x2F; 提示信息            this.$message(&#123;                type: &#39;success&#39;,                message: &#39;删除成功!&#39;            &#125;);            &#x2F;&#x2F; 返回list页面            this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)            &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div><p>测试添加和修改方法都成功</p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>第一次点击修改，进行数据回显</p><p>第二次再去点击 添加讲师，进入表单页面，数据没有清空，正确效果是清空</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>在添加讲师前将表单清空</p><p>在原有的created中添加一个else</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created()&#123;   &#x2F;&#x2F; 页面渲染之前执行    &#x2F;&#x2F; 判断路径是否有id值    if (this.$route.params &amp;&amp; this.$route.params.id) &#123;    &#x2F;&#x2F; 从路径获取id值    const id &#x3D; this.$route.params.id    &#x2F;&#x2F; 调用根据id查询的方法    this.getInfo(id)    &#125; else &#123;    &#x2F;&#x2F; 路径没有id，做添加        &#x2F;&#x2F; 表单清空        this.teacher &#x3D; &#123;&#125;    &#125;&#125;,</code></pre></div><p>发现结果还是不行。这个情况不是代码问题，因为created在页面渲染之前就执行，并且只执行一次，所以当点击修改的时候已经执行了，再次点击添加的时候就不会执行（同一个页面），为了让这个created方法可以再次执行，可以加一个监听watch。</p><p>将created的内容抽取出来，放在methods中init方法，在created调用init，并加监听</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">created()&#123;   &#x2F;&#x2F; 页面渲染之前执行        this.init()    &#125;,    watch:&#123;        $route(to,from)&#123;    &#x2F;&#x2F; 路由变化方式        &#x2F;&#x2F; 路由发生变化时，方法就会被执行            this.init()        &#125;    &#125;,    methods:&#123;        init()&#123;               &#x2F;&#x2F; 判断路径是否有id值            if (this.$route.params &amp;&amp; this.$route.params.id) &#123;            &#x2F;&#x2F; 从路径获取id值            const id &#x3D; this.$route.params.id            &#x2F;&#x2F; 调用根据id查询的方法            this.getInfo(id)            &#125; else &#123;    &#x2F;&#x2F; 路径没有id，做添加                &#x2F;&#x2F; 表单清空                this.teacher &#x3D; &#123;&#125;            &#125;                &#125;,</code></pre></div><p>测试效果，完美解决。</p><p>save.vue完整代码</p><div class="code-wrapper"><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;div class&#x3D;&quot;app-container&quot;&gt;        讲师添加        &lt;el-form label-width&#x3D;&quot;120px&quot;&gt;       &lt;el-form-item label&#x3D;&quot;讲师名称&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.name&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师排序&quot;&gt;         &lt;el-input-number v-model&#x3D;&quot;teacher.sort&quot; controls-position&#x3D;&quot;right&quot; min&#x3D;&quot;0&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师头衔&quot;&gt;         &lt;el-select v-model&#x3D;&quot;teacher.level&quot; clearable placeholder&#x3D;&quot;请选择&quot;&gt;           &lt;!--             数据类型一定要和取出的json中的一致，否则没法回填             因此，这里value使用动态绑定的值，保证其数据类型是number           --&gt;           &lt;el-option :value&#x3D;&quot;1&quot; label&#x3D;&quot;高级讲师&quot;&#x2F;&gt;           &lt;el-option :value&#x3D;&quot;2&quot; label&#x3D;&quot;首席讲师&quot;&#x2F;&gt;         &lt;&#x2F;el-select&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师资历&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.career&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;el-form-item label&#x3D;&quot;讲师简介&quot;&gt;         &lt;el-input v-model&#x3D;&quot;teacher.intro&quot; :rows&#x3D;&quot;10&quot; type&#x3D;&quot;textarea&quot;&#x2F;&gt;       &lt;&#x2F;el-form-item&gt;       &lt;!-- 讲师头像：TODO --&gt;       &lt;el-form-item&gt;         &lt;el-button :disabled&#x3D;&quot;saveBtnDisabled&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;saveOrUpdate&quot;&gt;保存&lt;&#x2F;el-button&gt;       &lt;&#x2F;el-form-item&gt;     &lt;&#x2F;el-form&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import teacherAPI from &#39;@&#x2F;api&#x2F;edu&#x2F;teacher&#39;export default &#123;    data()&#123;        return&#123;            teacher:&#123;                name: &#39;&#39;,                sort: 0,                level: 1,                career: &#39;&#39;,                intro: &#39;&#39;,                avatar: &#39;&#39;            &#125;,            saveBtnDisabled:false    &#x2F;&#x2F; 保存按钮是否禁止        &#125;    &#125;,    created()&#123;   &#x2F;&#x2F; 页面渲染之前执行        this.init()    &#125;,    watch:&#123;        $route(to,from)&#123;    &#x2F;&#x2F; 路由变化方式        &#x2F;&#x2F; 路由发生变化时，方法就会被执行            this.init()        &#125;    &#125;,    methods:&#123;        init()&#123;               &#x2F;&#x2F; 判断路径是否有id值            if (this.$route.params &amp;&amp; this.$route.params.id) &#123;            &#x2F;&#x2F; 从路径获取id值            const id &#x3D; this.$route.params.id            &#x2F;&#x2F; 调用根据id查询的方法            this.getInfo(id)            &#125; else &#123;    &#x2F;&#x2F; 路径没有id，做添加                &#x2F;&#x2F; 表单清空                this.teacher &#x3D; &#123;&#125;            &#125;                &#125;,        &#x2F;&#x2F; 根据讲师id查询信息        getInfo(id)&#123;            teacherAPI.getTeacherInfo(id)            .then(response &#x3D;&gt;&#123;                this.teacher &#x3D; response.data.teacher            &#125;)         &#125;,        saveOrUpdate()&#123;            &#x2F;&#x2F; 判断修改还是添加            &#x2F;&#x2F; 根据teacher是否有id            if(!this.teacher.id)&#123;                &#x2F;&#x2F; 添加            this.saveTeacher()            &#125; else&#123;                &#x2F;&#x2F; 修改                this.updateTeacher()            &#125;                    &#125;,        &#x2F;&#x2F; 修改讲师        updateTeacher()&#123;            teacherAPI.updateTeacherInfo(this.teacher)            .then(response &#x3D;&gt;&#123;                &#x2F;&#x2F; 提示信息                this.$message(&#123;                    type: &#39;success&#39;,                    message: &#39;修改成功!&#39;                &#125;);                &#x2F;&#x2F; 返回list页面                this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)                &#125;)        &#125;,        &#x2F;&#x2F; 添加讲师        saveTeacher()&#123;            teacherAPI.addTeacher(this.teacher)            .then(response &#x3D;&gt;&#123;      &#x2F;&#x2F;添加成功            &#x2F;&#x2F; 提示信息            this.$message(&#123;                type: &#39;success&#39;,                message: &#39;删除成功!&#39;            &#125;);            &#x2F;&#x2F; 返回list页面            this.$router.push(&#123;path:&#39;&#x2F;teacher&#x2F;table&#39;&#125;)            &#125;)        &#125;    &#125;&#125;&lt;&#x2F;script&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day04-项目的前端基本知识二</title>
    <link href="/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/"/>
    <url>/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="day04-项目的前端基本知识二"><a href="#day04-项目的前端基本知识二" class="headerlink" title="day04-项目的前端基本知识二"></a>day04-项目的前端基本知识二</h1><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios是独立于vue的一个项目，基于promise用于浏览器和node.js的http客户端</p><ul><li>在浏览器中可以帮助我们完成 ajax请求的发送</li><li>在node.js中可以向远程接口发送请求</li></ul><ol><li>导入axios.min.js文件</li><li>编写一个json数据，模拟接口</li></ol><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;success&quot;:true,    &quot;code&quot;:20000,    &quot;message&quot;:&quot;成功&quot;,    &quot;data&quot;:&#123;        &quot;items&quot;:[            &#123;&quot;name&quot;:&quot;lucy&quot;,&quot;age&quot;:&quot;10&quot;&#125;,            &#123;&quot;name&quot;:&quot;mary&quot;,&quot;age&quot;:&quot;20&quot;&#125;,            &#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:&quot;30&quot;&#125;        ]    &#125;&#125;</code></pre></div><ol start="4"><li>编写代码</li></ol><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;!--如何显示数据--&gt;        &lt;div v-for&#x3D;&quot;user in userList&quot;&gt;            &#123;&#123;user.name&#125;&#125; -- &#123;&#123;user.age&#125;&#125;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;axios.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                &#x2F;&#x2F; 定义一个空数组                userList:[]            &#125;,            created ()&#123;     &#x2F;&#x2F; 页面渲染之前执行                &#x2F;&#x2F; 调用方法                this.getUserList()            &#125;,            methods:&#123;       &#x2F;&#x2F; 编写具体方法                &#x2F;&#x2F; 创建方法，查询所有用户                getUserList()&#123;                    &#x2F;&#x2F; 使用axios的ajax请求                    &#x2F;&#x2F; axios.提交方式(&quot;请求接口地址&quot;).then().catch()                    axios.get(&quot;data.json&quot;)                        .then(response &#x3D;&gt;&#123;      &#x2F;&#x2F; 请求成功执行then                            &#x2F;&#x2F; response就是请求放回的数据                            &#x2F;&#x2F;console.log(response);                            &#x2F;&#x2F; 通过response获取具体的值，赋值给定义空数组                            this.userList &#x3D; response.data.data.items                            &#x2F;&#x2F;console.log(this.userList);                        &#125;)                             .catch(error &#x3D;&gt;&#123;    &#x2F;&#x2F;  请求失败执行catch                        &#125;)                    &#125;            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>测试</p><h1 id="element-ui"><a href="#element-ui" class="headerlink" title="element-ui"></a>element-ui</h1><p>官网： <a href="http://element-cn.eleme.io/#/zh-CN">http://element-cn.eleme.io/#/zh-CN</a></p><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><p>可以模拟服务器，执行JavaScript代码。</p><p>简单使用</p><p>创建一个js文件</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">console.log(&#39;hello nodejs&#39;);</code></pre></div><p>用cmd进入js文件所在的位置，执行命令node 01.js，即可</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\VSCode\workplace\axiosdemo&gt;node 01.jshello nodejs</code></pre></div><p>在vscode中使用，右键选中文件，在终端中打开，输入启动命令和需要启动的文件即可。</p><p><img src="/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/image-20211222162543838.png" alt="image-20211222162543838"></p><h1 id="npm包管理器"><a href="#npm包管理器" class="headerlink" title="npm包管理器"></a>npm包管理器</h1><p>node package manager，类似后端的maven，maven管理jar包，npm管理js库，如jQuery等</p><h2 id="使用npm项目初始化操作"><a href="#使用npm项目初始化操作" class="headerlink" title="使用npm项目初始化操作"></a>使用npm项目初始化操作</h2><p>npm init</p><p>npm init -y；都默认按照</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS E:\VSCode\workplace\npmdemo&gt; npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See &#96;npm help init&#96; for definitive documentation on these fieldsand exactly what they do.Use &#96;npm install &lt;pkg&gt;&#96; afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (npmdemo)version: (1.0.0)description:entry point: (index.js)test command:git repository:keywords:author:license: (ISC)About to write to E:\VSCode\workplace\npmdemo\package.json:&#123;  &quot;name&quot;: &quot;npmdemo&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;Is this OK? (yes) yesPS E:\VSCode\workplace\npmdemo&gt; </code></pre></div><p>生成package.json文件，类似后端的pom.xml文件</p><h2 id="npm-下载依赖"><a href="#npm-下载依赖" class="headerlink" title="npm 下载依赖"></a>npm 下载依赖</h2><p>npm install 依赖名称</p><p>如下载jQuery ,</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 会下载最新版本install jquery </code></pre></div><p>如果想指定版本，则用</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install jquery@2.1.x</code></pre></div><p>下载完成之后，会出现node_modules文件夹里面会有jQuery的文件和一个package-lock.json文件，package-lock.json文件是锁定当前版本的jQuery版本。</p><p>package.json文件中的dependencies是依赖的版本</p><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&quot;dependencies&quot;: &#123;  &quot;jquery&quot;: &quot;^3.6.0&quot;&#125;</code></pre></div><h2 id="通过package-json下载依赖"><a href="#通过package-json下载依赖" class="headerlink" title="通过package.json下载依赖"></a>通过package.json下载依赖</h2><p>先把原有的node_modules文件删除，接着执行下面的命令（需要再项目根目录）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install</code></pre></div><h1 id="babel转码器"><a href="#babel转码器" class="headerlink" title="babel转码器"></a>babel转码器</h1><p>将es6代码转成es5代码，目的：有些浏览器不兼容es6代码，为了提高兼容性</p><p>新创建一个文件，初始化项目</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm init -y</code></pre></div><p>安装babel工具</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --global babel-cli</code></pre></div><p>查看版本号</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">babel --version</code></pre></div><p>创建es6文件夹，创建js文件</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 转码前&#x2F;&#x2F; 定义数据类型let input &#x3D; [1,2,3]&#x2F;&#x2F; 将数组元素的每一个元素+1input &#x3D; input.map(item &#x3D;&gt; item+1)console.log(input);</code></pre></div><p>在项目根目录创建.babelrc配置文件</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;presets&quot;:[&quot;es2015&quot;],    &quot;plugins&quot;: []&#125;</code></pre></div><p>安装es2015转码器</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --save-dev babel-preset-es2015</code></pre></div><p><strong>根据文件转码</strong></p><p>es6/01.js:源文件</p><p>dist/001.js：生成的文件路径以及文件名字</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">babel es6&#x2F;01.js -o dist&#x2F;001.js</code></pre></div><p><strong>根据文件夹转换</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">babel es6 -d dist</code></pre></div><p>生成的es5文件</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&quot;use strict&quot;;&#x2F;&#x2F; 转码前&#x2F;&#x2F; 定义数据类型var input &#x3D; [1, 2, 3];&#x2F;&#x2F; 将数组元素的每一个元素+1input &#x3D; input.map(function (item) &#123;  return item + 1;&#125;);console.log(input);</code></pre></div><p>==<strong>注意：转码的时候需要在项目的根目录下才可以转码，否则会报文件不存在的错误</strong>==</p><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>开发后端接口时候，开发controller service mapper，controller注入service，service注入mapper，在后端中，类与类之间的调用成为后端模块化操作</p><p>前端模块化，在前端中，js与js之间调用成为前端模块化操作</p><h2 id="es5实现模块化操作"><a href="#es5实现模块化操作" class="headerlink" title="es5实现模块化操作"></a>es5实现模块化操作</h2><p>创建1.js文件，提供方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 1.创能方法const sum &#x3D; function(a,b)&#123;    return parseInt(a) + parseInt(b)&#125;const substract &#x3D; function(a,b)&#123;    return parseInt(a) - parseInt(b)&#125;module.exports &#x3D;&#123;    sum,    substract&#125;</code></pre></div><p>创建2.js文件，调用</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 调用1.js的方法&#x2F;&#x2F; 1.引入js文件const m &#x3D; require(&#39;.&#x2F;1.js&#39;)&#x2F;&#x2F; 调用方法console.log(m.sum(1,1));console.log(m.substract(3,1));</code></pre></div><p>在终端测试</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS E:\VSCode\workplace\moduledemo\es5moduledemo&gt; node 2.js22PS E:\VSCode\workplace\moduledemo\es5moduledemo&gt; </code></pre></div><h2 id="es6模块化"><a href="#es6模块化" class="headerlink" title="es6模块化"></a>es6模块化</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p> 创建1.js文件，提供方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 定义方法export function getList()&#123;    console.log(&quot;getList....&quot;);&#125;export function save()&#123;    console.log(&quot;save....&quot;);&#125;</code></pre></div><p>创建2.js文件，调用方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 调用1.js的方法import &#123; getList,save &#125; from &quot;.&#x2F;1&quot;;getList()save()</code></pre></div><p>由于es6不能直接在nodejs环境下运行，所以先用babel转成es5代码再进行测试</p><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>创建1.js文件，提供方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 定义方法export default&#123;    getList()&#123;        console.log(&#39;getList.....&#39;);    &#125;,    save()&#123;        console.log(&#39;save.....&#39;);    &#125;&#125;</code></pre></div><p>创建2.js文件，调用方法</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 调用1.js的方法import m from &#39;.&#x2F;1&#39;m.getList()m.save()</code></pre></div><p>测试</p><h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h2><p>Webpack 是一个前端<strong>资源加载/打包</strong>工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p><p>从图中我们可以看出，Webpack 可以<strong>将多种静态资源</strong> js、css、less 转<strong>换成一个静态文件</strong>，<strong>减少了页面的请求</strong>。 </p><p><img src="/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/image-20211222203948729.png" alt="image-20211222203948729"></p><h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g webpack webpack-cli</code></pre></div><p>查看版本</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">webpack -v</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS E:\VSCode\workplace\webpackdemo&gt; npm install -g webpack webpack-cliadded 3 packages, removed 4 packages, and changed 117 packages in 9s3 packages are looking for funding  run &#96;npm fund&#96; for detailsPS E:\VSCode\workplace\webpackdemo&gt; webpack -vwebpack: 5.65.0webpack-cli: 4.9.1webpack-dev-server not installedPS E:\VSCode\workplace\webpackdemo&gt; </code></pre></div><h2 id="创建src文件"><a href="#创建src文件" class="headerlink" title="创建src文件"></a>创建src文件</h2><p>src下创建common.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">exports.info &#x3D; function (str) &#123;    document.write(str);&#125;</code></pre></div><p>src下创建utils.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">exports.add &#x3D; function (a, b) &#123;        return a + b;&#125;</code></pre></div><p>src下创建main.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">const common &#x3D; require(&#39;.&#x2F;common&#39;);const utils &#x3D; require(&#39;.&#x2F;utils&#39;);common.info(&#39;Hello world!&#39; + utils.add(100, 200));</code></pre></div><h2 id="打包js"><a href="#打包js" class="headerlink" title="打包js"></a>打包js</h2><h3 id="webpack目录下创建配置文件webpack-config-js"><a href="#webpack目录下创建配置文件webpack-config-js" class="headerlink" title="webpack目录下创建配置文件webpack.config.js"></a><strong>webpack目录下创建配置文件</strong>webpack.config.js</h3><p>以下配置的意思是：读取当前项目目录下src文件夹中的main.js（入口文件）内容，分析资源依赖，把相关的js文件打包，打包后的文件放入当前目录的dist文件夹下，打包后的js文件名为bundle.js</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">const path &#x3D; require(&quot;path&quot;); &#x2F;&#x2F;Node.js内置模块module.exports &#x3D; &#123;    entry: &#39;.&#x2F;src&#x2F;main.js&#39;, &#x2F;&#x2F;配置入口文件    output: &#123;        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#x2F;&#x2F;输出路径，__dirname：当前文件所在路径        filename: &#39;bundle.js&#39; &#x2F;&#x2F;输出文件    &#125;&#125;</code></pre></div><p>打包</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">webpack# 有黄色警告webpack --mode&#x3D;&#x3D;development # 没有警告</code></pre></div><p>警告信息</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PS E:\VSCode\workplace\webpackdemo&gt; webpackasset bundle.js 308 bytes [emitted] [minimized] (name: main).&#x2F;src&#x2F;main.js 124 bytes [built] [code generated].&#x2F;src&#x2F;common.js 60 bytes [built] [code generated].&#x2F;src&#x2F;utils.js 57 bytes [built] [code generated]WARNING in configurationThe &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value.Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.You can also set it to &#39;none&#39; to disable any default behavior. Learn more: https:&#x2F;&#x2F;webpack.js.org&#x2F;configuration&#x2F;mode&#x2F;webpack 5.65.0 compiled with 1 warning in 279 msPS E:\VSCode\workplace\webpackdemo&gt;</code></pre></div><p>测试</p><p>在webpack目录下创建1.html，引用bundle.js，打开浏览器访问即可</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script src&#x3D;&quot;dist&#x2F;bundle.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></div><h2 id="打包css"><a href="#打包css" class="headerlink" title="打包css"></a>打包css</h2><h3 id="安装style-loader和-css-loader"><a href="#安装style-loader和-css-loader" class="headerlink" title="安装style-loader和 css-loader"></a><strong>安装style-loader和 css-loader</strong></h3><p>首先我们需要安装相关Loader插件，css-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识css</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --save-dev style-loader css-loader </code></pre></div><p>创建一个style.css文件</p><div class="code-wrapper"><pre class="line-numbers language-css" data-language="css"><code class="language-css">body&#123;    background-color: red;&#125;</code></pre></div><p>在main.js中引入</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">const common &#x3D; require(&#39;.&#x2F;common&#39;);const utils &#x3D; require(&#39;.&#x2F;utils&#39;);require(&#39;.&#x2F;style.css&#39;);common.info(&#39;Hello world!&#39; + utils.add(100, 200));</code></pre></div><p>在webpack.config.js中加入下面的代码</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">const path &#x3D; require(&quot;path&quot;); &#x2F;&#x2F;Node.js内置模块module.exports &#x3D; &#123;    entry: &#39;.&#x2F;src&#x2F;main.js&#39;, &#x2F;&#x2F;配置入口文件    output: &#123;        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#x2F;&#x2F;输出路径，__dirname：当前文件所在路径        filename: &#39;bundle.js&#39; &#x2F;&#x2F;输出文件    &#125;,    module: &#123;        rules: [              &#123;                  test: &#x2F;\.css$&#x2F;,    &#x2F;&#x2F;打包规则应用到以css结尾的文件上                use: [&#39;style-loader&#39;, &#39;css-loader&#39;]            &#125;          ]      &#125;&#125;</code></pre></div><p>重新打包，最后访问1.html测试。</p><h1 id="搭建项目前端页面"><a href="#搭建项目前端页面" class="headerlink" title="搭建项目前端页面"></a>搭建项目前端页面</h1><h2 id="vue-admin-template"><a href="#vue-admin-template" class="headerlink" title="vue-admin-template"></a>vue-admin-template</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>vueAdmin-template是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为模板进行二次开发。</p><p><strong>GitHub地址：</strong><a href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a></p><p><strong>建议：</strong>你可以在 <code>vue-admin-template</code> 的基础上进行二次开发，把 <code>vue-element-admin</code>当做工具箱，想要什么功能或者组件就去 <code>vue-element-admin</code> 那里复制过来。</p><p>在根目录下执行npm install命令下载依赖，如果下载失败（报一个ERESOLVE unable to resolve dependency tree），可以使用cnpm install下载。如果下载失败，按照提示删除node_modules文件夹，再次下载。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Install fail! RunScriptError: post install error, please remove node_modules before retry!ru</code></pre></div><p>如果报错node-sass不支持当前版本，可以重新卸载，再安装</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm uninstall --save node-sasscnpm install node-sass -D</code></pre></div><p>如果上面还不行就更换nodejs的版本，降低版本，可能是本地的nodejs版本过高导致的，我的由16.13.0降到14.18.2就行了</p><p>下载成功后，利用命令启动</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm run dev</code></pre></div><p><img src="/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/image-20211222232247732.png" alt="image-20211222232247732"></p><p>看到这个页面说明成功</p><h1 id="项目前端框架介绍"><a href="#项目前端框架介绍" class="headerlink" title="项目前端框架介绍"></a>项目前端框架介绍</h1><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">. ├── build &#x2F;&#x2F; 构建脚本├── config &#x2F;&#x2F; 全局配置 ├── node_modules &#x2F;&#x2F; 项目依赖模块├── src &#x2F;&#x2F;项目源代码├── static &#x2F;&#x2F; 静态资源└── package.jspon &#x2F;&#x2F; 项目信息和依赖配置</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">src ├── api &#x2F;&#x2F; 各种接口 ├── assets &#x2F;&#x2F; 图片等资源 ├── components &#x2F;&#x2F; 各种公共组件，非公共组件在各自view下维护 ├── icons &#x2F;&#x2F;svg icon ├── router &#x2F;&#x2F; 路由表 ├── store &#x2F;&#x2F; 存储 ├── styles &#x2F;&#x2F; 各种样式 ├── utils &#x2F;&#x2F; 公共工具，非公共工具，在各自view下维护 ├── views &#x2F;&#x2F; 各种layout├── App.vue &#x2F;&#x2F;***项目顶层组件*** ├── main.js &#x2F;&#x2F;***项目入口文件***└── permission.js &#x2F;&#x2F;认证入口</code></pre></div><p><img src="/myBlog/day04-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%BA%8C/12-%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E.png" alt="12-前端页面框架结构说明"></p>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day03-项目的前端基本知识一</title>
    <link href="/myBlog/day03-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%80/"/>
    <url>/myBlog/day03-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="day03-项目的前端基本知识一"><a href="#day03-项目的前端基本知识一" class="headerlink" title="day03-项目的前端基本知识一"></a>day03-项目的前端基本知识一</h1><h1 id="es6简单使用"><a href="#es6简单使用" class="headerlink" title="es6简单使用"></a>es6简单使用</h1><h2 id="let变量作用范围"><a href="#let变量作用范围" class="headerlink" title="let变量作用范围"></a>let变量作用范围</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; es6如何定义变量     &#x2F;&#x2F; js定义： var a &#x3D; 1;  没有局部    &#x2F;&#x2F; es6定义let：有局部    &#123;        var a &#x3D; 10;        let b &#x3D; 20;    &#125;    &#x2F;&#x2F; 2.在代码块外面输入    console.log(a);    console.log(b);&lt;&#x2F;script&gt;</code></pre></div><h2 id="let定义变量特点"><a href="#let定义变量特点" class="headerlink" title="let定义变量特点"></a>let定义变量特点</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    var a &#x3D; 1;    var a &#x3D; 2;    let b &#x3D; 3;    let b &#x3D; 4; &#x2F;&#x2F;Identifier &#39;b&#39; has already been declared&lt;&#x2F;script&gt;</code></pre></div><h2 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;     &#x2F;&#x2F; 定义常量     const PI &#x3D; &quot;3.1415&quot;;     &#x2F;&#x2F; 常量一旦定义，不能改变     &#x2F;&#x2F;PI &#x3D; 3;    &#x2F;&#x2F; Assignment to constant variable.     &#x2F;&#x2F; 定义常量必须初始化     &#x2F;&#x2F;const AA;  &#x2F;&#x2F; Missing initializer in const declaration&lt;&#x2F;script&gt;</code></pre></div><h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 传统写法    let a &#x3D; 1,b &#x3D; 2, c &#x3D; 3;    console.log(a,b,c);    &#x2F;&#x2F; es6写法    let [x,y,z]&#x3D; [10,20,30];    console.log(x,y,z)&lt;&#x2F;script&gt;</code></pre></div><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 定义对象    let user &#x3D; &#123;&quot;name&quot;:&quot;lucy&quot;,&quot;age&quot;:20&#125;;        &#x2F;&#x2F; 传统的取值    let name1 &#x3D; user.name;    let age1 &#x3D; user.age;    console.log(name1 + &quot;&#x3D;&#x3D;&quot; + age1);    &#x2F;&#x2F; es6获取值    let &#123;name,age&#125; &#x3D; user;    console.log(name + &quot;--&quot; + age);&lt;&#x2F;script&gt;</code></pre></div><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 1使用&#96;实现换行    let str1 &#x3D; &#96;hey,    es6 demo up!&#96;;    console.log(str1);    &#x2F;&#x2F; 2.在符号&#96;里面使用表达式取变量值    let name &#x3D; &quot;Make&quot;;    let age &#x3D; 20;    let str2 &#x3D; &#96;hello , $&#123;name&#125;, age is $&#123;age&#125;&#96;    console.log(str2);    &#x2F;&#x2F; 3.在&#96;符号中调用方法    function f1()&#123;        return &quot;hello f1&quot;;    &#125;    let str3 &#x3D; &#96;demo, $&#123;f1()&#125;&#96;    console.log(str3)&lt;&#x2F;script&gt;</code></pre></div><h2 id="声明对象"><a href="#声明对象" class="headerlink" title="声明对象"></a>声明对象</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    const age &#x3D; 12;    const name &#x3D; &quot;lucy&quot;;    &#x2F;&#x2F; 传统方式定义对象    const p1 &#x3D; &#123;name:name,age:age&#125;;    console.log(p1);    &#x2F;&#x2F; es6定义变量    const p2 &#x3D; &#123;name,age&#125;;    console.log(p2);&lt;&#x2F;script&gt;</code></pre></div><h2 id="定义方法简写方式"><a href="#定义方法简写方式" class="headerlink" title="定义方法简写方式"></a>定义方法简写方式</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 传统的定义方式    const person1  &#x3D; &#123;        sayHi:function()&#123;            console.log(&quot;Hi&quot;);        &#125;    &#125;    person1.sayHi();    &#x2F;&#x2F; es6    const person2 &#x3D; &#123;        sayHi()&#123;            console.log(&quot;Hello&quot;);        &#125;    &#125;    person2.sayHi();&lt;&#x2F;script&gt;</code></pre></div><h2 id="对象拓展运算符"><a href="#对象拓展运算符" class="headerlink" title="对象拓展运算符"></a>对象拓展运算符</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 1.对象复制    let person1 &#x3D; &#123;&quot;name&quot;:&quot;lucy&quot;,&quot;age&quot;:19&#125;    let person2 &#x3D; &#123;...person1&#125;    console.log(person2)    &#x2F;&#x2F; 2.对象合并    let name &#x3D; &#123;name:&quot;mary&quot;&#125;    let age &#x3D; &#123;age:11111&#125;    let p3 &#x3D; &#123;...name,...age&#125;    console.log(p3)&lt;&#x2F;script&gt;</code></pre></div><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;script&gt;    &#x2F;&#x2F; 1.传统的方式创建方法    var f1 &#x3D; function(m)&#123;        return m    &#125;    &#x2F;&#x2F;console.log(f1(1))        &#x2F;&#x2F; 2.使用箭头函数    var f2 &#x3D; a &#x3D;&gt; a    &#x2F;&#x2F;console.log(f2(2))    &#x2F;&#x2F; 3.复杂一点的    var f3 &#x3D; function(a,b)&#123;        return a + b;    &#125;    console.log(f3(1,1))    &#x2F;&#x2F; 使用箭头函数简化    var f4 &#x3D; (a,b) &#x3D;&gt; a + b;    console.log(f4(4,4));&lt;&#x2F;script&gt;</code></pre></div><h1 id="Vue入门案例"><a href="#Vue入门案例" class="headerlink" title="Vue入门案例"></a>Vue入门案例</h1><p>先将vue.js导入，编写一个HTML页面，导入vue.js文件，定义一个div显示数据，在script中new 一个Vue对象</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;&lt;device-width&gt;, initial-scale&#x3D;1.0&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;              &#123;&#123; message &#125;&#125;           &lt;!-- 定义一个div显示数据 --&gt;     &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue (&#123;            el: &quot;#app&quot;,     &#x2F;&#x2F; 判定vue作用的范围            data:&#123;          &#x2F;&#x2F; 定义vue页面中显示的内容                message:&quot;Hello Vue!!&quot;            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h1 id="抽取代码块片段"><a href="#抽取代码块片段" class="headerlink" title="抽取代码块片段"></a>抽取代码块片段</h1><p>在vs code中创建代码片段：<br>文件 =&gt;  首选项 =&gt; 用户代码片段 =&gt; 新建全局代码片段/或文件夹代码片段：vue-html.code-snippets</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&#123;    &quot;vue htm&quot;: &#123;        &quot;scope&quot;: &quot;html&quot;,        &quot;prefix&quot;: &quot;vuehtml&quot;,        &quot;body&quot;: [            &quot;&lt;!DOCTYPE html&gt;&quot;,            &quot;&lt;html lang&#x3D;\&quot;en\&quot;&gt;&quot;,            &quot;&quot;,            &quot;&lt;head&gt;&quot;,            &quot;    &lt;meta charset&#x3D;\&quot;UTF-8\&quot;&gt;&quot;,            &quot;    &lt;meta name&#x3D;\&quot;viewport\&quot; content&#x3D;\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0\&quot;&gt;&quot;,            &quot;    &lt;meta http-equiv&#x3D;\&quot;X-UA-Compatible\&quot; content&#x3D;\&quot;ie&#x3D;edge\&quot;&gt;&quot;,            &quot;    &lt;title&gt;Document&lt;&#x2F;title&gt;&quot;,            &quot;&lt;&#x2F;head&gt;&quot;,            &quot;&quot;,            &quot;&lt;body&gt;&quot;,            &quot;    &lt;div id&#x3D;\&quot;app\&quot;&gt;&quot;,            &quot;&quot;,            &quot;    &lt;&#x2F;div&gt;&quot;,            &quot;    &lt;script src&#x3D;\&quot;vue.min.js\&quot;&gt;&lt;&#x2F;script&gt;&quot;,            &quot;    &lt;script&gt;&quot;,            &quot;        new Vue(&#123;&quot;,            &quot;            el: &#39;#app&#39;,&quot;,            &quot;            data: &#123;&quot;,            &quot;                $1&quot;,            &quot;            &#125;&quot;,            &quot;        &#125;)&quot;,            &quot;    &lt;&#x2F;script&gt;&quot;,            &quot;&lt;&#x2F;body&gt;&quot;,            &quot;&quot;,            &quot;&lt;&#x2F;html&gt;&quot;,        ],        &quot;description&quot;: &quot;my vue template in html&quot;    &#125;&#125;</code></pre></div><h1 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h1><p>单项绑定，取到属性中的值</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h1 v-bind:title&#x3D;&quot;content&quot;&gt;        &#123;&#123;message&#125;&#125;    &lt;&#x2F;h1&gt;      &lt;!-- 单向绑定 --&gt;     &lt;h2 :title &#x3D; &quot;content&quot;&gt;        &#123;&#123;message&#125;&#125;    &lt;&#x2F;h2&gt;     &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            content:&quot;我是标题&quot;,            message:&quot;hello&quot;        &#125;    &#125;)</code></pre></div><h1 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h1><p>双向绑定</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--单向判定，如果值发生改变，只要绑定的变化--&gt;    &lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;searchMap.keyWord&quot;&gt;    &lt;!--双向判定 ，如果值发生改变，所有的都会发生改变--&gt;    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;searchMap.keyWord&quot;&gt;    &lt;p&gt;&#123;&#123;searchMap.keyWord&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            searchMap:&#123;                keyWord: &#39;尚硅谷&#39;            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre></div><h1 id="v-on指令"><a href="#v-on指令" class="headerlink" title="v-on指令"></a>v-on指令</h1><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--绑定事件--&gt;    &lt;button v-on:click&#x3D;&quot;search()&quot;&gt;查询&lt;&#x2F;button&gt;    &lt;!--绑定事件简写--&gt;    &lt;button @click&#x3D;&quot;search()&quot;&gt;查询1&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            searchMap:&#123;                keyWord:&#39;我是keyWord&#39;            &#125;        &#125;,        methods:&#123;            &#x2F;&#x2F; 可以定义多个方法            search()&#123;                console.log(&#39;search...&#39;)            &#125;,            f1()&#123;                console.log(&#39;f1...&#39;)            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre></div><h1 id="Vue修饰符"><a href="#Vue修饰符" class="headerlink" title="Vue修饰符"></a>Vue修饰符</h1><p>阻止原始的条件发生，指定提交事件</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;form action&#x3D;&quot;save&quot; v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; v-model&#x3D;&quot;user.username&quot;&#x2F;&gt;        &lt;button type&#x3D;&quot;submit&quot;&gt;保存&lt;&#x2F;button&gt;    &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            user:&#123;&#125;        &#125;,        methods:&#123;            onSubmit()&#123;                if(this.user.username)&#123;                    console.log(&#39;提交表单&#39;)                &#125; else &#123;                    alert(&#39;请输入用户名&#39;)                &#125;            &#125;        &#125;    &#125;)&lt;&#x2F;script&gt;</code></pre></div><h1 id="vue指令v-if"><a href="#vue指令v-if" class="headerlink" title="vue指令v-if"></a>vue指令v-if</h1><p>条件指令</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;ok&quot;&#x2F;&gt; 是否同意        &lt;h1 v-if&#x3D;&quot;ok&quot;&gt;尚硅谷&lt;&#x2F;h1&gt;        &lt;h1 v-else&gt;谷粒学院&lt;&#x2F;h1&gt;&lt;&#x2F;h1&gt;&lt;&#x2F;h1&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                ok:false            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div><h1 id="vue指令v-for"><a href="#vue指令v-for" class="headerlink" title="vue指令v-for"></a>vue指令v-for</h1><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;ul&gt;            &lt;li v-for&#x3D;&quot;n in 10&quot;&gt;&#123;&#123;n&#125;&#125;&lt;&#x2F;li&gt;        &lt;&#x2F;ul&gt;        &lt;ol&gt;            &lt;li v-for&#x3D;&quot;(n,index) in 10&quot;&gt;&#123;&#123;n&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;&#x2F;li&gt;        &lt;&#x2F;ol&gt;        &lt;!--遍历列表--&gt;        &lt;table border&#x3D;&quot;1&quot;&gt;            &lt;tr v-for&#x3D;&quot;item in userList&quot;&gt;                &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;&#x2F;td&gt;                &lt;td&gt;&#123;&#123;item.username&#125;&#125;&lt;&#x2F;td&gt;                &lt;td&gt;&#123;&#123;item.age&#125;&#125;&lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &lt;&#x2F;table&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                userList:[                    &#123;id:1,username:&#39;halen&#39;,age:10&#125;,                    &#123;id:2,username:&#39;halen&#39;,age:10&#125;,                    &#123;id:3,username:&#39;halen&#39;,age:10&#125;                ]            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;Navbar&gt;&lt;&#x2F;Navbar&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            &#x2F;&#x2F; 定义局部组件，可以定义多个主键            components:&#123;                    &#39;Navbar&#39;:&#123;                        template:&#39;&lt;ul&gt;&lt;li&gt;首页&lt;&#x2F;li&gt;&lt;li&gt;学员管理&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#39;                    &#125;                &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body</code></pre></div><h1 id="vue全局组件"><a href="#vue全局组件" class="headerlink" title="vue全局组件"></a>vue全局组件</h1><p>创建一个components文件，里面再创建一个Navbar.js</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&#x2F;&#x2F; 定义全局组件Vue.component(&#39;Navbar&#39;, &#123;    template: &#39;&lt;ul&gt;&lt;li&gt;首页&lt;&#x2F;li&gt;&lt;li&gt;学员管理&lt;&#x2F;li&gt;&lt;li&gt;讲师管理&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&#39;&#125;)</code></pre></div><p>在需要用的地方直接引用</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;Navbar&gt;&lt;&#x2F;Navbar&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;components&#x2F;Navbar.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div><h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p><img src="/myBlog/day03-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E4%B8%80/image-20211222125545310.png" alt="image-20211222125545310"></p><p>主要用到created和mounted两个方法</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        hello    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                            &#125;,            created()&#123;                debugger                &#x2F;&#x2F; 在渲染之前执行                console.log(&#39;created...&#39;);            &#125;,            mounted()&#123;                debugger                &#x2F;&#x2F; 在渲染之后执行                console.log(&#39;mounted...&#39;);            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div><h1 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h1><p>将vue-router.min.js文件引入，编写路由</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &lt;h1&gt;Hello App!&lt;&#x2F;h1&gt;            &lt;p&gt;                &lt;!-- 使用 router-link 组件来导航. --&gt;                &lt;!-- 通过传入 &#96;to&#96; 属性指定链接. --&gt;                &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &#96;&lt;a&gt;&#96; 标签 --&gt;                &lt;router-link to&#x3D;&quot;&#x2F;&quot;&gt;首页&lt;&#x2F;router-link&gt;                &lt;router-link to&#x3D;&quot;&#x2F;student&quot;&gt;会员管理&lt;&#x2F;router-link&gt;                &lt;router-link to&#x3D;&quot;&#x2F;teacher&quot;&gt;讲师管理&lt;&#x2F;router-link&gt;            &lt;&#x2F;p&gt;            &lt;!-- 路由出口 --&gt;            &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;            &lt;router-view&gt;&lt;&#x2F;router-view&gt;    &lt;&#x2F;div&gt;    &lt;script src&#x3D;&quot;vue.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script src&#x3D;&quot;vue-router.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;            &#x2F;&#x2F; 1. 定义（路由）组件。        &#x2F;&#x2F; 可以从其他文件 import 进来        const Welcome &#x3D; &#123; template: &#39;&lt;div&gt;欢迎&lt;&#x2F;div&gt;&#39; &#125;        const Student &#x3D; &#123; template: &#39;&lt;div&gt;student list&lt;&#x2F;div&gt;&#39; &#125;        const Teacher &#x3D; &#123; template: &#39;&lt;div&gt;teacher list&lt;&#x2F;div&gt;&#39; &#125;        &#x2F;&#x2F; 2. 定义路由        &#x2F;&#x2F; 每个路由应该映射一个组件。        const routes &#x3D; [            &#123; path: &#39;&#x2F;&#39;, redirect: &#39;&#x2F;welcome&#39; &#125;, &#x2F;&#x2F;设置默认指向的路径            &#123; path: &#39;&#x2F;welcome&#39;, component: Welcome &#125;,            &#123; path: &#39;&#x2F;student&#39;, component: Student &#125;,            &#123; path: &#39;&#x2F;teacher&#39;, component: Teacher &#125;        ]        &#x2F;&#x2F; 3. 创建 router 实例，然后传 &#96;routes&#96; 配置        const router &#x3D; new VueRouter(&#123;            routes &#x2F;&#x2F; （缩写）相当于 routes: routes        &#125;)        &#x2F;&#x2F; 4. 创建和挂载根实例。        &#x2F;&#x2F; 从而让整个应用都有路由功能        const app &#x3D; new Vue(&#123;            el: &#39;#app&#39;,            router        &#125;)        &#x2F;&#x2F; 现在，应用已经启动了！    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day02-项目环境搭建</title>
    <link href="/myBlog/day02-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/"/>
    <url>/myBlog/day02-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="day02-项目环境搭建"><a href="#day02-项目环境搭建" class="headerlink" title="day02-项目环境搭建"></a>day02-项目环境搭建</h1><h1 id="逻辑删除讲师功能"><a href="#逻辑删除讲师功能" class="headerlink" title="逻辑删除讲师功能"></a>逻辑删除讲师功能</h1><h2 id="1、在EduConfig中配置逻辑删除插件"><a href="#1、在EduConfig中配置逻辑删除插件" class="headerlink" title="1、在EduConfig中配置逻辑删除插件"></a>1、在EduConfig中配置逻辑删除插件</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 逻辑删除插件 *&#x2F;@Beanpublic ISqlInjector sqlInjector() &#123;    return new LogicSqlInjector();&#125;</code></pre></div><h2 id="2、在实体类添加注解"><a href="#2、在实体类添加注解" class="headerlink" title="2、在实体类添加注解"></a>2、在实体类添加注解</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModelProperty(value &#x3D; &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)@TableLogicprivate Boolean isDeleted;</code></pre></div><h2 id="3、在EduTeacherController添加删除方法"><a href="#3、在EduTeacherController添加删除方法" class="headerlink" title="3、在EduTeacherController添加删除方法"></a>3、在EduTeacherController添加删除方法</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 2.逻辑删除讲师@DeleteMapping(&quot;&#123;id&#125;&quot;)public boolean removeTeacher(@PathVariable String id)&#123;    boolean flag &#x3D; teacherService.removeById(id);    return flag;&#125;</code></pre></div><h1 id="整合Swagger2"><a href="#整合Swagger2" class="headerlink" title="整合Swagger2"></a>整合Swagger2</h1><p>在guli_parent中创建maven项目，名common模块</p><p>在common模块中的pom文件导入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;parent&gt;        &lt;artifactId&gt;guli_parent&lt;&#x2F;artifactId&gt;        &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;&#x2F;parent&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;artifactId&gt;common&lt;&#x2F;artifactId&gt;    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;    &lt;modules&gt;        &lt;module&gt;servicebase&lt;&#x2F;module&gt;    &lt;&#x2F;modules&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;            &lt;scope&gt;provided &lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;!--mybatis-plus--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;            &lt;scope&gt;provided &lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;            &lt;scope&gt;provided &lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;!--swagger--&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;            &lt;scope&gt;provided &lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;            &lt;scope&gt;provided &lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;        &lt;!-- redis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;!-- spring2.X集成redis所需common-pool2        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;            &lt;version&gt;2.6.0&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;--&gt;    &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt;</code></pre></div><p>在common模块中创建servicebase模块，在servicebase模块中创建swagger配置类</p><p>创建包com.atguigu.servicebase，创建类SwaggerConfig</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket webApiConfig()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .groupName(&quot;webApi&quot;)                .apiInfo(webApiInfo())                .select()                .paths(Predicates.not(PathSelectors.regex(&quot;&#x2F;admin&#x2F;.*&quot;)))                .paths(Predicates.not(PathSelectors.regex(&quot;&#x2F;error.*&quot;)))                .build();    &#125;    private ApiInfo webApiInfo()&#123;        return new ApiInfoBuilder()                .title(&quot;网站-课程中心API文档&quot;)                .description(&quot;本文档描述了课程中心微服务接口定义&quot;)                .version(&quot;1.0&quot;)                .contact(new Contact(&quot;Tom&quot;, &quot;http:&#x2F;&#x2F;11111.com&quot;, &quot;11111@qq.com&quot;))                .build();    &#125;&#125;</code></pre></div><p>在service模块中的pom文件引入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;service_base&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>在service_edu模块的启动类加上注解@ComponentScan(basePackages = {“com.atguigu”})，在启动的时候扫描包</p><p><strong>定义接口说明和参数说明</strong></p><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(description &#x3D; &quot;讲师管理&quot;)@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;teacher&quot;)public class EduTeacherController &#123;    @Autowired    private EduTeacherService teacherService;    &#x2F;&#x2F; 1.查询所有的数据    &#x2F;&#x2F; rest风格    @ApiOperation(value &#x3D; &quot;所有讲师列表&quot;)    @GetMapping(&quot;findAll&quot;)    public List&lt;EduTeacher&gt; findAll()&#123;        &#x2F;&#x2F; 调用service的方法查询所有数据        List&lt;EduTeacher&gt; list &#x3D; teacherService.list(null);        return list;    &#125;    &#x2F;&#x2F; 2.逻辑删除讲师    @ApiOperation(&quot;根据ID进行逻辑删除讲师&quot;)    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public boolean removeById(            @ApiParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;讲师ID&quot;,required &#x3D; true)            @PathVariable String id)&#123;        boolean flag &#x3D; teacherService.removeById(id);        return flag;    &#125;&#125;</code></pre></div><p><strong>测试</strong></p><p>启动启动类，在浏览器中访问<a href="http://localhost:8001/swagger-ui.html">http://localhost:8001/swagger-ui.html</a></p><p><img src="/myBlog/day02-%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83/image-20211221120726821.png" alt="image-20211221120726821"></p><h1 id="统一返回结果"><a href="#统一返回结果" class="headerlink" title="统一返回结果"></a>统一返回结果</h1><p>在common模块中创建commonutils子模块，创建包com.atguigu.commonutils，</p><p>创建ResultCode接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ResultCode &#123;    public static Integer SUCCESS &#x3D; 20000;  &#x2F;&#x2F; 成功    public static Integer ERROR &#x3D; 20001;  &#x2F;&#x2F; 失败&#125;</code></pre></div><p>创建R类，统一返回结果</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class R &#123;    @ApiModelProperty(value &#x3D; &quot;是否成功&quot;)    private Boolean success;    @ApiModelProperty(value &#x3D; &quot;返回码&quot;)    private Integer code;    @ApiModelProperty(value &#x3D; &quot;返回消息&quot;)    private String message;    @ApiModelProperty(value &#x3D; &quot;返回数据&quot;)    private Map&lt;String, Object&gt; data &#x3D; new HashMap&lt;String, Object&gt;();    &#x2F;&#x2F; 构造私有化，链式编程R.ok().success().    private R()&#123;&#125;    public static R ok()&#123;        R r &#x3D; new R();        r.setSuccess(true);        r.setCode(ResultCode.SUCCESS);        r.setMessage(&quot;成功&quot;);        return r;    &#125;    public static R error()&#123;        R r &#x3D; new R();        r.setSuccess(false);        r.setCode(ResultCode.ERROR);        r.setMessage(&quot;失败&quot;);        return r;    &#125;    public R success(Boolean success)&#123;        this.setSuccess(success);        return this;    &#125;    public R message(String message)&#123;        this.setMessage(message);        return this;    &#125;    public R code(Integer code)&#123;        this.setCode(code);        return this;    &#125;    public R data(String key, Object value)&#123;        this.data.put(key, value);        return this;    &#125;    public R data(Map&lt;String, Object&gt; map)&#123;        this.setData(map);        return this;    &#125;&#125;</code></pre></div><p>在service模块中引用依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;common_utils&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>在controller中使用返回R类型（不要引错包）</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Api(description &#x3D; &quot;讲师管理&quot;)@RestController@RequestMapping(&quot;&#x2F;eduservice&#x2F;teacher&quot;)public class EduTeacherController &#123;    @Autowired    private EduTeacherService teacherService;    &#x2F;&#x2F; 1.查询所有的数据    &#x2F;&#x2F; rest风格    @ApiOperation(value &#x3D; &quot;所有讲师列表&quot;)    @GetMapping(&quot;findAll&quot;)    public R findAll()&#123;        &#x2F;&#x2F; 调用service的方法查询所有数据        List&lt;EduTeacher&gt; list &#x3D; teacherService.list(null);        return R.ok().data(&quot;items&quot;,list);    &#125;    &#x2F;&#x2F; 2.逻辑删除讲师    @ApiOperation(&quot;根据ID进行逻辑删除讲师&quot;)    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public R removeById(            @ApiParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;讲师ID&quot;,required &#x3D; true)            @PathVariable String id)&#123;        boolean flag &#x3D; teacherService.removeById(id);        if (flag)&#123;            return R.ok();        &#125; else &#123;            return R.error();        &#125;    &#125;&#125;</code></pre></div><h1 id="讲师分页查询"><a href="#讲师分页查询" class="headerlink" title="讲师分页查询"></a>讲师分页查询</h1><p>在EduConfig类中添加分页插件</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;**  * 分页插件  *&#x2F;@Beanpublic PaginationInterceptor paginationInterceptor() &#123;    return new PaginationInterceptor();&#125;</code></pre></div><p>在EduTeacherController类添加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 3.分页查询讲师@ApiOperation(&quot;分页查询讲师&quot;)@GetMapping(&quot;pageTeacher&#x2F;&#123;current&#125;&#x2F;&#123;limit&#125;&quot;)public R pageTeacher(    @ApiParam(name &#x3D; &quot;current&quot;, value &#x3D; &quot;当前页数&quot;,required &#x3D; true)    @PathVariable Long current,    @ApiParam(name &#x3D; &quot;limit&quot;, value &#x3D; &quot;条数&quot;,required &#x3D; true)    @PathVariable Long limit)&#123;    &#x2F;&#x2F; 创建分页对象    Page&lt;EduTeacher&gt; teacherPage &#x3D; new Page&lt;&gt;(current,limit);    &#x2F;&#x2F; 查询数据库    teacherService.page(teacherPage,null);    long total &#x3D; teacherPage.getTotal();    &#x2F;&#x2F; 总记录数    List&lt;EduTeacher&gt; records &#x3D; teacherPage.getRecords();    &#x2F;&#x2F; 所有的讲师list    &#x2F;&#x2F; 或者使用map    &#x2F;* Map map &#x3D; new HashMap();        map.put(&quot;total&quot;,total);        map.put(&quot;rows&quot;,records);        return R.ok().data(map);*&#x2F;    return R.ok().data(&quot;total&quot;,total).data(&quot;rows&quot;,records);&#125;</code></pre></div><p>在swagger中测试接口正确性</p><h1 id="讲师条件查询带分页"><a href="#讲师条件查询带分页" class="headerlink" title="讲师条件查询带分页"></a>讲师条件查询带分页</h1><p>思路：（暂时写在controller，后面所有的业务都写在serviceImpl）</p><ol><li>创建分页对象</li><li>创建wrapper对象<ul><li>填充条件</li></ul></li><li>查询数据库</li><li>获取数据</li><li>返回</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 条件查询带分页    @ApiOperation(value &#x3D; &quot;条件查询讲师列表带分页&quot;)    @PostMapping(&quot;pageTeacherCondition&#x2F;&#123;current&#125;&#x2F;&#123;limit&#125;&quot;)    public R pageTeacherCondition(            @ApiParam(name &#x3D; &quot;current&quot;, value &#x3D; &quot;当前页数&quot;,required &#x3D; true)            @PathVariable Long current,            @ApiParam(name &#x3D; &quot;limit&quot;, value &#x3D; &quot;条数&quot;,required &#x3D; true)            @PathVariable Long limit,            @ApiParam(name &#x3D; &quot;teacherQuery&quot;, value &#x3D; &quot;查询对象&quot;,required &#x3D; false)            @RequestBody(required &#x3D; false) TeacherQuery teacherQuery)&#123;        &#x2F;&#x2F; 创建page分页对象        Page&lt;EduTeacher&gt; teacherPage &#x3D; new Page&lt;&gt;(current,limit);        &#x2F;&#x2F; 创建wrapper对象        QueryWrapper&lt;EduTeacher&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();        String name &#x3D; teacherQuery.getName();        Integer level &#x3D; teacherQuery.getLevel();        String begin &#x3D; teacherQuery.getBegin();        String end &#x3D; teacherQuery.getEnd();        &#x2F;&#x2F; 条件查询        if (!StringUtils.isEmpty(name))&#123;            &#x2F;&#x2F; 模糊查询名字            wrapper.like(&quot;name&quot;,name);        &#125;        if (!StringUtils.isEmpty(level))&#123;            &#x2F;&#x2F; 级别            wrapper.eq(&quot;level&quot;,level);        &#125;        if (!StringUtils.isEmpty(begin))&#123;            &#x2F;&#x2F; 开始时间&gt;&#x3D;            wrapper.ge(&quot;gmt_create&quot;,begin);        &#125;        if (!StringUtils.isEmpty(end))&#123;            &#x2F;&#x2F; 结束时间 &lt;&#x3D;            wrapper.le(&quot;gmt_modified&quot;,end);        &#125;        &#x2F;&#x2F; 查询        teacherService.page(teacherPage,wrapper);        long total &#x3D; teacherPage.getTotal();    &#x2F;&#x2F; 总记录数        List&lt;EduTeacher&gt; records &#x3D; teacherPage.getRecords();    &#x2F;&#x2F; 所有的讲师list        return R.ok().data(&quot;total&quot;,total).data(&quot;rows&quot;,records);    &#125;</code></pre></div><p>测试</p><h1 id="新增讲师"><a href="#新增讲师" class="headerlink" title="新增讲师"></a>新增讲师</h1><p>在EduTeacher类中的创建时间和更新时间添加自动填充注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiModelProperty(value &#x3D; &quot;创建时间&quot;)@TableField(fill &#x3D; FieldFill.INSERT)private Date gmtCreate;@ApiModelProperty(value &#x3D; &quot;更新时间&quot;)@TableField(fill &#x3D; FieldFill.INSERT_UPDATE)private Date gmtModified;</code></pre></div><p>在servicebase模块中创建handler包，并在handler包中创建MyMetaObjectHandler类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    @Override    public void insertFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtCreate&quot;, new Date(), metaObject);        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        this.setFieldValByName(&quot;gmtModified&quot;, new Date(), metaObject);    &#125;&#125;</code></pre></div><p>在EduTeacherController中编写方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 添加讲师@ApiOperation(&quot;添加讲师&quot;)@PostMapping(&quot;addTeacher&quot;)public R addTeacher(    @ApiParam(name &#x3D; &quot;teacher&quot;,value &#x3D; &quot;讲师对象&quot;,required &#x3D; true)    @RequestBody EduTeacher teacher)&#123;    boolean save &#x3D; teacherService.save(teacher);    if (save)&#123;        return R.ok();    &#125; else &#123;        return R.error();    &#125;&#125;</code></pre></div><p>测试</p><h1 id="根据id查询讲师"><a href="#根据id查询讲师" class="headerlink" title="根据id查询讲师"></a>根据id查询讲师</h1><p>在EduTeacherController中编写方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 根据id查询讲师@ApiOperation(&quot;根据id查询讲师&quot;)@GetMapping(&quot;getTeacher&#x2F;&#123;id&#125;&quot;)public R getTeacher(@ApiParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;讲师id&quot;,required &#x3D; true)@PathVariable String id)&#123;    EduTeacher teacher &#x3D; teacherService.getById(id);    return R.ok().data(&quot;teacher&quot;,teacher);&#125;</code></pre></div><h1 id="更新讲师"><a href="#更新讲师" class="headerlink" title="更新讲师"></a>更新讲师</h1><p>在EduTeacherController中编写方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 更新讲师信息@ApiOperation(&quot;更新讲师&quot;)@PostMapping(&quot;updateTeacher&quot;)public R updateTeacher(@ApiParam(name &#x3D; &quot;teacher&quot;,value &#x3D; &quot;讲师对象&quot;)@RequestBody EduTeacher teacher)&#123;    boolean flag &#x3D; teacherService.updateById(teacher);    if (flag)&#123;        return R.ok();    &#125; else &#123;        return R.error();    &#125;&#125;</code></pre></div><p>测试</p><h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在servicebase模块，创建exceptionhandler包，新建GlobalExceptionHandler类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)  &#x2F;&#x2F; 发生什么异常的时候执行    @ResponseBody   &#x2F;&#x2F; 为了返回数据    public R error(Exception e)&#123;        e.getStackTrace();        return R.error().message(&quot;执行了全局异常处理....&quot;);    &#125;&#125;</code></pre></div><p>在service_base的pom文件中添加common_utils依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.atguigu&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;common_utils&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>这个时候需要将service模块中的common_utils依赖去掉，因为依赖会传递，不去掉可能会有问题</p><h2 id="特殊异常处理"><a href="#特殊异常处理" class="headerlink" title="特殊异常处理"></a>特殊异常处理</h2><p>在<code>com.atguigu.servicebase.exceptionhandler</code>的GlobalExceptionHandler类中添加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 特殊异常处理@ExceptionHandler(ArithmeticException.class)  &#x2F;&#x2F; 发生什么异常的时候执行@ResponseBody   &#x2F;&#x2F; 为了返回数据public R error(ArithmeticException e)&#123;    e.getStackTrace();    return R.error().message(&quot;执行了ArithmeticException异常处理....&quot;);&#125;</code></pre></div><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>在com.atguigu.servicebase.exceptionhandler包中创建GuliException类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class GuliException extends RuntimeException &#123;    @ApiModelProperty(value &#x3D; &quot;状态码&quot;)    private Integer code;   &#x2F;&#x2F; 状态码    private String msg;     &#x2F;&#x2F; 异常信息&#125;</code></pre></div><p>在<code>com.atguigu.servicebase.exceptionhandler</code>的GlobalExceptionHandler类中添加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 自定义异常处理@ExceptionHandler(GuliException.class)  &#x2F;&#x2F; 发生什么异常的时候执行@ResponseBody   &#x2F;&#x2F; 为了返回数据public R error(GuliException e)&#123;    e.getStackTrace();    return R.error().code(e.getCode()).message(e.getMsg());&#125;</code></pre></div><p>在会发生异常的地方进行下面处理</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;    int a &#x3D; 10 &#x2F; 0;&#125; catch (Exception e) &#123;    throw new GuliException(20001,&quot;执行了自定义异常&quot;);&#125;</code></pre></div><p>测试</p><h1 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h1><p>先把application.properties中的日志配置文件去掉</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">## 设置日志级别#logging.level.root&#x3D;WARN##mybatis日志#mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div><p> 在resources包下创建logback-spring.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;configuration  scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;10 seconds&quot;&gt;    &lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;    &lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&gt;    &lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;    &lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;    &lt;contextName&gt;logback&lt;&#x2F;contextName&gt;    &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 --&gt;    &lt;property name&#x3D;&quot;log.path&quot; value&#x3D;&quot;E:&#x2F;1&#x2F;guli_log&#x2F;edu&quot; &#x2F;&gt;    &lt;!-- 彩色日志 --&gt;    &lt;!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --&gt;    &lt;!-- magenta:洋红 --&gt;    &lt;!-- boldMagenta:粗红--&gt;    &lt;!-- cyan:青色 --&gt;    &lt;!-- white:白色 --&gt;    &lt;!-- magenta:洋红 --&gt;    &lt;property name&#x3D;&quot;CONSOLE_LOG_PATTERN&quot;              value&#x3D;&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)&quot;&#x2F;&gt;    &lt;!--输出到控制台--&gt;    &lt;appender name&#x3D;&quot;CONSOLE&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;        &lt;!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --&gt;        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;            &lt;level&gt;INFO&lt;&#x2F;level&gt;        &lt;&#x2F;filter&gt;        &lt;encoder&gt;            &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;&#x2F;Pattern&gt;            &lt;!-- 设置字符集 --&gt;            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;        &lt;&#x2F;encoder&gt;    &lt;&#x2F;appender&gt;    &lt;!--输出到文件--&gt;    &lt;!-- 时间滚动输出 level为 INFO 日志 --&gt;    &lt;appender name&#x3D;&quot;INFO_FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文件的路径及文件名 --&gt;        &lt;file&gt;$&#123;log.path&#125;&#x2F;log_info.log&lt;&#x2F;file&gt;        &lt;!--日志文件输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;        &lt;&#x2F;encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!-- 每天日志归档路径以及格式 --&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;info&#x2F;log-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;&#x2F;fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;&#x2F;maxFileSize&gt;            &lt;&#x2F;timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文件保留天数--&gt;            &lt;maxHistory&gt;15&lt;&#x2F;maxHistory&gt;        &lt;&#x2F;rollingPolicy&gt;        &lt;!-- 此日志文件只记录info级别的 --&gt;        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;INFO&lt;&#x2F;level&gt;            &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;            &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;        &lt;&#x2F;filter&gt;    &lt;&#x2F;appender&gt;    &lt;!-- 时间滚动输出 level为 WARN 日志 --&gt;    &lt;appender name&#x3D;&quot;WARN_FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文件的路径及文件名 --&gt;        &lt;file&gt;$&#123;log.path&#125;&#x2F;log_warn.log&lt;&#x2F;file&gt;        &lt;!--日志文件输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt; &lt;!-- 此处设置字符集 --&gt;        &lt;&#x2F;encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;warn&#x2F;log-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;&#x2F;fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;&#x2F;maxFileSize&gt;            &lt;&#x2F;timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文件保留天数--&gt;            &lt;maxHistory&gt;15&lt;&#x2F;maxHistory&gt;        &lt;&#x2F;rollingPolicy&gt;        &lt;!-- 此日志文件只记录warn级别的 --&gt;        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;warn&lt;&#x2F;level&gt;            &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;            &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;        &lt;&#x2F;filter&gt;    &lt;&#x2F;appender&gt;    &lt;!-- 时间滚动输出 level为 ERROR 日志 --&gt;    &lt;appender name&#x3D;&quot;ERROR_FILE&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文件的路径及文件名 --&gt;        &lt;file&gt;$&#123;log.path&#125;&#x2F;log_error.log&lt;&#x2F;file&gt;        &lt;!--日志文件输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;&#x2F;pattern&gt;            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt; &lt;!-- 此处设置字符集 --&gt;        &lt;&#x2F;encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;&#x2F;error&#x2F;log-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;&#x2F;fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;&#x2F;maxFileSize&gt;            &lt;&#x2F;timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文件保留天数--&gt;            &lt;maxHistory&gt;15&lt;&#x2F;maxHistory&gt;        &lt;&#x2F;rollingPolicy&gt;        &lt;!-- 此日志文件只记录ERROR级别的 --&gt;        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;ERROR&lt;&#x2F;level&gt;            &lt;onMatch&gt;ACCEPT&lt;&#x2F;onMatch&gt;            &lt;onMismatch&gt;DENY&lt;&#x2F;onMismatch&gt;        &lt;&#x2F;filter&gt;    &lt;&#x2F;appender&gt;    &lt;!--        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。        &lt;logger&gt;仅有一个name属性，        一个可选的level和一个可选的addtivity属性。        name:用来指定受此logger约束的某一个包或者具体的某一个类。        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，              如果未设置此属性，那么当前logger将会继承上级的级别。    --&gt;    &lt;!--        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：        第一种把&lt;root level&#x3D;&quot;INFO&quot;&gt;改成&lt;root level&#x3D;&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：     --&gt;    &lt;!--开发环境:打印控制台--&gt;    &lt;springProfile name&#x3D;&quot;dev&quot;&gt;        &lt;!--可以输出项目中的debug日志，包括mybatis的sql日志--&gt;        &lt;logger name&#x3D;&quot;com.guli&quot; level&#x3D;&quot;INFO&quot; &#x2F;&gt;        &lt;!--            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG            可以包含零个或多个appender元素。        --&gt;        &lt;root level&#x3D;&quot;INFO&quot;&gt;            &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;INFO_FILE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;WARN_FILE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;ERROR_FILE&quot; &#x2F;&gt;        &lt;&#x2F;root&gt;    &lt;&#x2F;springProfile&gt;    &lt;!--生产环境:输出到文件--&gt;    &lt;springProfile name&#x3D;&quot;pro&quot;&gt;        &lt;root level&#x3D;&quot;INFO&quot;&gt;            &lt;appender-ref ref&#x3D;&quot;CONSOLE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;DEBUG_FILE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;INFO_FILE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;ERROR_FILE&quot; &#x2F;&gt;            &lt;appender-ref ref&#x3D;&quot;WARN_FILE&quot; &#x2F;&gt;        &lt;&#x2F;root&gt;    &lt;&#x2F;springProfile&gt;&lt;&#x2F;configuration&gt;</code></pre></div><p>在com.atguigu.servicebase.exceptionhandler包的GlobalExceptionHandler类上面添加注解@Slf4j</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.servicebase.exceptionhandler;import com.atguigu.commonutils.R;import lombok.extern.slf4j.Slf4j;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;...    &#x2F;&#x2F; 自定义异常处理    @ExceptionHandler(GuliException.class)  &#x2F;&#x2F; 发生什么异常的时候执行    @ResponseBody   &#x2F;&#x2F; 为了返回数据    public R error(GuliException e)&#123;        log.info(e.getMessage());&#x2F;&#x2F; 输出日志        e.getStackTrace();        return R.error().code(e.getCode()).message(e.getMsg());    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>day01-MybatisPlus入门</title>
    <link href="/myBlog/day01-MybatisPlus%E5%85%A5%E9%97%A8/"/>
    <url>/myBlog/day01-MybatisPlus%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="day01-MybatisPlus入门"><a href="#day01-MybatisPlus入门" class="headerlink" title="day01 MybatisPlus入门"></a>day01 MybatisPlus入门</h1><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>官网：<a href="http://mp.baomidou.com/">http://mp.baomidou.com/</a></p><p>参考教程：<a href="http://mp.baomidou.com/guide/">http://mp.baomidou.com/guide/</a></p><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h1 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h1><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 XML 热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>支持关键词自动转义</strong>：支持数据库关键词（order、key……）自动转义，还可自定义关键词</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li><li><strong>内置 Sql 注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目|谷粒学院|笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据结构和算法</title>
    <link href="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <url>/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构和算法"><a href="#Java数据结构和算法" class="headerlink" title="Java数据结构和算法"></a>Java数据结构和算法</h1><h1 id="第2章-数据结构和算法概述"><a href="#第2章-数据结构和算法概述" class="headerlink" title="第2章 数据结构和算法概述"></a>第2章 数据结构和算法概述</h1><h2 id="2-1-1数据结构和算法的关系"><a href="#2-1-1数据结构和算法的关系" class="headerlink" title="2.1.1数据结构和算法的关系"></a><strong>2.1.1数据结构和算法的关系</strong></h2><ol><li><p>数据data结构(structure)是一<strong>门研究组织数据方式的学科</strong>，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。</p></li><li><p>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.</p></li><li><p><strong>程序 = 数据结构 + 算法</strong></p></li><li><p><strong>数据结构是算法的基础,</strong> 换言之，想要学好算法，需要把数据结构学到位。</p></li></ol><h2 id="2-2看几个实际编程中遇到的问题"><a href="#2-2看几个实际编程中遇到的问题" class="headerlink" title="2.2看几个实际编程中遇到的问题"></a>2.2看几个实际编程中遇到的问题</h2><h3 id="2-2-1问题一-字符串替换问题"><a href="#2-2-1问题一-字符串替换问题" class="headerlink" title="2.2.1问题一-字符串替换问题"></a>2.2.1问题一-字符串替换问题</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118100458420.png" alt="image-20211118100458420"></p><p>小结：需要使用到单链表数据结构</p><h3 id="2-2-2一个五子棋程序"><a href="#2-2-2一个五子棋程序" class="headerlink" title="2.2.2一个五子棋程序"></a>2.2.2一个五子棋程序</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118101408875.png" alt="image-20211118101408875"></p><p>如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能</p><ol><li>棋盘  <strong>二维数组=&gt;(稀疏数组)</strong>-&gt; 写入文件 【存档功能】</li><li>读取文件-&gt;稀疏数组-&gt;二维数组 -&gt; 棋盘 【接上局】</li></ol><h3 id="2-2-3约瑟夫-Josephu问题-丢手帕问题"><a href="#2-2-3约瑟夫-Josephu问题-丢手帕问题" class="headerlink" title="2.2.3约瑟夫(Josephu问题(丢手帕问题)"></a>2.2.3约瑟夫(Josephu问题(丢手帕问题)</h3><ol><li><p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p></li><li><p><strong>提示：</strong>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表（<strong>单向环形链表</strong>），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p></li><li><p>小结：完成约瑟夫问题，需要使用单向环形链表这个数据结构。</p></li></ol><h3 id="2-2-4其他常见问题"><a href="#2-2-4其他常见问题" class="headerlink" title="2.2.4其他常见问题"></a>2.2.4其他常见问题</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118101808981.png" alt="image-20211118101808981"></p><ol><li>修路问题 =&gt; 最小生成<strong>树</strong>(<strong>加权值</strong>)【<strong>数据结构</strong>】+ 普利姆算法</li><li>最短路径问题 =&gt; 图+弗洛伊德算法</li><li><strong>汉诺塔</strong> <strong>=&gt;</strong> <strong>分支算法</strong></li><li>八皇后问题 =&gt; 回溯法</li></ol><h3 id="2-3线性结构和非线性结构"><a href="#2-3线性结构和非线性结构" class="headerlink" title="2.3线性结构和非线性结构"></a>2.3线性结构和非线性结构</h3><p>数据结构包括：<strong>线性结构</strong>和<strong>非线性结构</strong>。</p><h4 id="2-3-1线性结构"><a href="#2-3-1线性结构" class="headerlink" title="2.3.1线性结构"></a>2.3.1<strong>线性结构</strong></h4><ol><li>线性结构作为最常用的数据结构，其特点是<strong>数据元素之间存在一对一</strong>的线性关系</li><li>线性结构有两种不同的存储结构，即<strong>顺序存储结构（数组）和链式存储结构（链表）</strong>。顺序存储的线性表称为顺序表，顺序表中的<strong>存储元素是连续</strong>的</li><li>链式存储的线性表称为链表，链表中的<strong>存储元素不一定是连续的</strong>，元素节点中存放数据元素以及相邻元素的地址信息</li><li>线性结构常见的有：<strong>数组、队列、链表和栈</strong>，后面我们会详细讲解.</li></ol><h4 id="2-3-2非线性结构"><a href="#2-3-2非线性结构" class="headerlink" title="2.3.2非线性结构"></a>2.3.2<strong>非线性结构</strong></h4><p>非线性结构包括：二维数组，多维数组，广义表，<strong>树结构，图结构</strong></p><h1 id="第3章-稀疏数组和队列"><a href="#第3章-稀疏数组和队列" class="headerlink" title="第3章 稀疏数组和队列"></a><strong>第3章 稀疏数组和队列</strong></h1><h2 id="3-1稀疏sparsearray数组"><a href="#3-1稀疏sparsearray数组" class="headerlink" title="3.1稀疏sparsearray数组"></a>3.1稀疏sparsearray数组</h2><h3 id="3-1-1先看一个实际的需求"><a href="#3-1-1先看一个实际的需求" class="headerlink" title="3.1.1先看一个实际的需求"></a>3.1.1先看一个实际的需求</h3><p>编写的五子棋程序中，有<strong>存盘退出</strong>和续上盘的功能。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118104504920.png" alt="image-20211118104504920"></p><p><strong>分析问题</strong>: </p><p>因为该二维数组的很多值是默认值0, 因此记录了<strong>很多没有意义的数据</strong>.-&gt;<strong>稀疏数组</strong>。</p><h3 id="3-1-2基本介绍"><a href="#3-1-2基本介绍" class="headerlink" title="3.1.2基本介绍"></a>3.1.2<strong>基本介绍</strong></h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是:</p><ol><li>记录数组<strong>一共有几行几列，有多少个不同</strong>的值</li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118104658636.png" alt="image-20211118104658636"></p><h3 id="3-1-3应用实例"><a href="#3-1-3应用实例" class="headerlink" title="3.1.3应用实例"></a>3.1.3应用实例</h3><ol><li>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</li><li>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</li><li>整体思路分析</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118110050134.png" alt="image-20211118110050134"></p><ol start="4"><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sparsearray;public class SparseArray &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个原始的二维数组11*11        int chessArr1[][] &#x3D; new int[11][11];        &#x2F;&#x2F; 0表示没有，1表示黑子，2表示蓝色        chessArr1[1][2]&#x3D;1;        chessArr1[2][3]&#x3D;2;        &#x2F;&#x2F; 输出原来的二维数组        System.out.println(&quot;原来的二维数组：&quot;);        for (int[] row : chessArr1) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;,data);            &#125;            System.out.println();        &#125;        &#x2F;&#x2F; 将二维数组转稀疏数组的思路        &#x2F;&#x2F; 1.遍历原来的二维数组得到非零数据的个数        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; chessArr1.length; i++) &#123;            for (int j &#x3D; 0; j &lt; chessArr1.length; j++) &#123;                if (chessArr1[i][j] !&#x3D; 0)&#123;                    sum++;                &#125;            &#125;        &#125;        System.out.println(&quot;sum&#x3D;&quot;+sum);        &#x2F;&#x2F; 2.创建对应的稀疏数组        int[][] sparseArr &#x3D; new int[sum + 1][3];        &#x2F;&#x2F; 给稀疏数组赋值        sparseArr[0][0] &#x3D;11;        sparseArr[0][1] &#x3D;11;        sparseArr[0][2] &#x3D;sum;        &#x2F;&#x2F; 遍历二维数组，将非0的值存放到sparseArr中        &#x2F;&#x2F; count 用于记录是第几个非0数据        int count &#x3D; 0;        for (int i &#x3D; 0; i &lt; chessArr1.length; i++) &#123;            for (int j &#x3D; 0; j &lt; chessArr1.length; j++) &#123;                if (chessArr1[i][j] !&#x3D; 0)&#123;                    count++;                    sparseArr[count][0]&#x3D;i;                    sparseArr[count][1]&#x3D;j;                    sparseArr[count][2]&#x3D;chessArr1[i][j];                &#125;            &#125;        &#125;        &#x2F;&#x2F; 输出稀疏数组的形式        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;得到的希尔数组为：&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        for (int i &#x3D; 0; i &lt; sparseArr.length; i++) &#123;            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;,sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);        &#125;        System.out.println();        &#x2F;&#x2F; 将稀疏数组恢复成原始的二维数组        &#x2F;&#x2F; 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组        int[][] chessArr2 &#x3D; new int[sparseArr[0][0]][sparseArr[0][1]];        &#x2F;&#x2F; 2.读取稀疏数组后几行（从第二行开始），并赋值给原始的二维数组        for (int i &#x3D; 1; i &lt; sparseArr.length; i++) &#123;            chessArr2[ sparseArr[i][0]] [sparseArr[i][1] ]&#x3D;sparseArr[i][2];        &#125;        System.out.println(&quot;恢复后的数组&quot;);        &#x2F;&#x2F; 遍历二维数组，得到原始的数组        for (int[] row : chessArr2) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;,data);            &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="3-1-4课后练习"><a href="#3-1-4课后练习" class="headerlink" title="3.1.4课后练习"></a>3.1.4<strong>课后练习</strong></h3><p>要求：</p><ol><li>在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data</li><li>恢复原来的数组时，读取map.data 进行恢复</li></ol><h2 id="3-2队列"><a href="#3-2队列" class="headerlink" title="3.2队列"></a>3.2队列</h2><h3 id="3-2-1队列的一个使用场景"><a href="#3-2-1队列的一个使用场景" class="headerlink" title="3.2.1队列的一个使用场景"></a>3.2.1队列的一个使用场景</h3><p>银行排队的案例：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118150027962.png" alt="image-20211118150027962"></p><h3 id="3-2-2队列介绍"><a href="#3-2-2队列介绍" class="headerlink" title="3.2.2队列介绍"></a>3.2.2<strong>队列介绍</strong></h3><ol><li>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li><li>示意图：(使用数组模拟队列示意图)</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118150123141.png" alt="image-20211118150123141"></p><h3 id="3-2-3数组模拟队列思路"><a href="#3-2-3数组模拟队列思路" class="headerlink" title="3.2.3数组模拟队列思路"></a>3.2.3数组模拟队列思路</h3><ol><li>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</li><li>因为队列的输出、输入是分别从前后端来处理，因此需要两个<strong>变量front</strong>及 <strong>rear</strong>分别<strong>记录队列前后端</strong>的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示:</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118150812030.png" alt="image-20211118150812030"></p><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：<strong>思路分析</strong> </p><ol><li>将尾指针往后移：rear+1 , 当front == rear 【空】</li><li>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满]</li></ol><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.queue;import java.util.Scanner;public class ArrayQueueDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建一个队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        char key &#x3D; &#39; &#39;;     &#x2F;&#x2F; 接收用户输入        boolean loop &#x3D; true;        Scanner scanner &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 输出一个菜单        while (loop)&#123;            System.out.println(&quot;s(show)：显示队列&quot;);            System.out.println(&quot;e(exit)：退出队列&quot;);            System.out.println(&quot;a(add)：添加数据到队列&quot;);            System.out.println(&quot;g(get)：从队列取出数据&quot;);            System.out.println(&quot;h(head)：查看队列头的数据&quot;);            key &#x3D; scanner.next().charAt(0);     &#x2F;&#x2F; 接收一个数据            switch (key)&#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;请输入您要添加的数据：&quot;);                    int value &#x3D; scanner.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.println(&quot;取出的数据为：&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;h&#39;:                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.println(&quot;头队列为：&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序退出~~&quot;);    &#125;&#125;&#x2F;&#x2F; 使用数组模拟队列，编写一个ArrayQueue类class ArrayQueue&#123;    private int maxSize;        &#x2F;&#x2F; 表示数组最大容量    private int rear;           &#x2F;&#x2F; 头队列    private int front;          &#x2F;&#x2F; 尾队列    private int []arr;          &#x2F;&#x2F; 该数据用于存放数据，模拟队列    &#x2F;&#x2F; 创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;             &#x2F;&#x2F; 指向队列头部，分析出front是指向队列的前一个位置        rear &#x3D; -1;              &#x2F;&#x2F; 指向队列尾部，即就是队列最后一个数据    &#125;    &#x2F;&#x2F; 判断队列是否已满    public boolean isFull()&#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F; 判断队列是否为空    public boolean isEmpty()&#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F; 添加数据到队列    public void addQueue(int n)&#123;        if (isFull())&#123;            System.out.println(&quot;队列已满~&quot;);            return;        &#125;        rear++;        arr[rear]&#x3D;n;    &#125;    &#x2F;&#x2F; 从队列中取出数据，出队列    public int getQueue()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空，没有数据&quot;);        &#125;        front++;        return arr[front];    &#125;    &#x2F;&#x2F; 显示所有数据    public void showQueue()&#123;        if (isEmpty())&#123;            System.out.println(&quot;队列为空，没有数据&quot;);        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i,arr[i]);        &#125;    &#125;    &#x2F;&#x2F; 显示头数据，不是取出。    public int headQueue()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空，没有数据&quot;);        &#125;        return arr[front + 1];    &#125;&#125;</code></pre></div><p>问题分析并优化</p><ol><li>目前数组使用一次就不能使用，没有达到复用的效果</li><li>将这个数组使用算法，改进成一个<strong>环形的队列</strong> 取模： %</li></ol><h3 id="3-2-4数组模拟环形队列"><a href="#3-2-4数组模拟环形队列" class="headerlink" title="3.2.4数组模拟环形队列"></a>3.2.4<strong>数组模拟环形队列</strong></h3><p>对前面的数组模拟队列的优化，充分利用数组。因此将数组看做是一个环形的。(通过<strong>取模</strong>的方式来实现即可)</p><p>分析说明：</p><ol><li>尾索引的下一个为头索引时表示队列满，即将<strong>队列容量空出一个作为约定</strong>,这个在做判断队列满的<br> 时候需要注意 (rear + 1) % maxSize == front 满] </li><li>rear == front [空]</li><li>测试示意图:</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211118195515282.png" alt="image-20211118195515282"></p><ol start="4"><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.queue;import java.util.Scanner;public class CircleArrayQueueDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;测试数组模拟环形队列的案例~~&quot;);                &#x2F;&#x2F; 创建一个队列        CircleQueue queue &#x3D; new CircleQueue(3);        &#x2F;&#x2F; 接收用户输入        char key &#x3D; &#39; &#39;;        boolean loop &#x3D; true;        Scanner scanner &#x3D; new Scanner(System.in);        &#x2F;&#x2F; 输出一个菜单        while (loop)&#123;            System.out.println(&quot;s(show)：显示队列&quot;);            System.out.println(&quot;e(exit)：退出队列&quot;);            System.out.println(&quot;a(add)：添加数据到队列&quot;);            System.out.println(&quot;g(get)：从队列取出数据&quot;);            System.out.println(&quot;h(head)：查看队列头的数据&quot;);            key &#x3D; scanner.next().charAt(0);     &#x2F;&#x2F; 接收一个数据            switch (key)&#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;请输入您要添加的数据：&quot;);                    int value &#x3D; scanner.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.println(&quot;取出的数据为：&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;h&#39;:                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.println(&quot;头队列为：&quot;+res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序退出~~&quot;);    &#125;&#125;class CircleQueue&#123;    private int maxSize;        &#x2F;&#x2F; 表示数组最大容量    &#x2F;&#x2F;1.front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素    &#x2F;&#x2F;front 的初始值 &#x3D; 0    private int front;          &#x2F;&#x2F; 尾队列    &#x2F;&#x2F;2.  rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.    &#x2F;&#x2F;rear 的初始值 &#x3D; 0    private int rear;           &#x2F;&#x2F; 头队列    private int []arr;          &#x2F;&#x2F; 该数据用于存放数据，模拟队列    &#x2F;&#x2F; 创建队列的构造器    public CircleQueue(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];    &#125;    &#x2F;&#x2F; 判断队列是否已满    public boolean isFull()&#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F; 判断队列是否为空    public boolean isEmpty()&#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F; 添加数据到队列    public void addQueue(int n)&#123;        if (isFull())&#123;            System.out.println(&quot;队列已满~&quot;);            return;        &#125;        arr[rear] &#x3D; n;        rear &#x3D; (rear + 1) % maxSize;    &#125;    &#x2F;&#x2F; 从队列中取出数据，出队列    public int getQueue()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空，没有数据&quot;);        &#125;        &#x2F;&#x2F; 这里需要分析出front是指向队列的第一个元素        &#x2F;&#x2F; 1.先把front的值存入一个临时的变量        &#x2F;&#x2F; 2.将front后移，考虑取模        &#x2F;&#x2F; 3.将临时保存的值返回        int value &#x3D; arr[front];        front &#x3D; (front + 1) % maxSize;        return value;    &#125;    &#x2F;&#x2F; 显示所有数据    public void showQueue()&#123;        if (isEmpty())&#123;            System.out.println(&quot;队列为空，没有数据&quot;);        &#125;        for (int i &#x3D; front; i &lt; front + size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;,i % maxSize,arr[i % maxSize]);        &#125;    &#125;    &#x2F;&#x2F; 获取有效个数    public int size()&#123;        &#x2F;&#x2F; rear &#x3D; 1        &#x2F;&#x2F; maxSize &#x3D; 3        &#x2F;&#x2F; front &#x3D; 0        return (rear +maxSize -front) % maxSize;    &#125;    &#x2F;&#x2F; 显示头数据，不是取出。    public int headQueue()&#123;        if (isEmpty())&#123;            throw new RuntimeException(&quot;队列为空，没有数据&quot;);        &#125;        return arr[front];    &#125;&#125;</code></pre></div></li></ol><h1 id="第4章-链表"><a href="#第4章-链表" class="headerlink" title="第4章 链表"></a>第4章 链表</h1><h2 id="4-1链表-Linked-List-介绍"><a href="#4-1链表-Linked-List-介绍" class="headerlink" title="4.1链表(Linked List)介绍"></a>4.1链表(Linked List)介绍</h2><p>链表是有序的列表，但是它在内存中是存储如下</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211119170837446.png" alt="image-20211119170837446"></p><p>小结:</p><ol><li>链表是以节点的方式来存储,是<strong>链式存储</strong></li><li>每个节点包含 data 域， next 域：指向下一个节点.</li><li>如图：发现链表的<strong>各个节点不一定是连续存储</strong>.</li><li>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定</li></ol><p>单链表(带头结点) <strong>逻辑结构</strong>示意图如下</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211119170944928.png" alt="image-20211119170944928"></p><h2 id="4-2单链表的应用实例"><a href="#4-2单链表的应用实例" class="headerlink" title="4.2单链表的应用实例"></a>4.2单链表的应用实例</h2><p>使用带head头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的<strong>增删改查</strong>操作， 注: <strong>删除和修改</strong>,查找<br>可以考虑学员独立完成，也可带学员完成</p><ol><li><p>第一种方法在添加英雄时，直接添加到链表的尾部</p><p>思路分析示意图：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211119171148813.png" alt="image-20211119171148813"></p></li><li><p>第二种方式在添加英雄时，<strong>根据排名</strong>将英雄插入到指定位置 (如果有这个排名，则添加失败，并给出提示)</p><p>思路分析示意图：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211119171307003.png" alt="image-20211119171307003"></p></li><li><p>修改节点功能</p><p>思路：1.先找到节点，通过遍历，2.temp.name = newHeroNode.name ;temp.nickName = newHeroNode.nickName</p></li><li><p>删除节点</p><p>思路分析示意图：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211119171544791.png" alt="image-20211119171544791"></p></li><li><p>代码演示：</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.linkedlist;public class SingleLinkedListDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建节点        HeroNode hero1 &#x3D; new HeroNode(1, &quot;张三&quot;, &quot;法外狂徒&quot;);        HeroNode hero2 &#x3D; new HeroNode(2, &quot;李四&quot;, &quot;法外狂徒2&quot;);        HeroNode hero3 &#x3D; new HeroNode(3, &quot;王五&quot;, &quot;法外狂徒3&quot;);        HeroNode hero4 &#x3D; new HeroNode(4, &quot;阿六&quot;, &quot;法外狂徒4&quot;);        HeroNode hero5 &#x3D; new HeroNode(5, &quot;阿六5&quot;, &quot;法外狂徒5&quot;);        &#x2F;&#x2F; 创建链表        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();&#x2F;*        singleLinkedList.add(hero1);        singleLinkedList.add(hero2);        singleLinkedList.add(hero3);        singleLinkedList.add(hero4);        singleLinkedList.add(hero5);*&#x2F;        &#x2F;&#x2F; 第二种方法，通过no排序        singleLinkedList.addByOrder(hero1);        singleLinkedList.addByOrder(hero3);        singleLinkedList.addByOrder(hero2);        singleLinkedList.addByOrder(hero4);        singleLinkedList.addByOrder(hero5);        System.out.println(&quot;更新前~~~&quot;);        &#x2F;&#x2F; 输出        singleLinkedList.list();        HeroNode newHeroNode &#x3D; new HeroNode(2, &quot;小李&quot;, &quot;法外狂徒2~~~&quot;);        &#x2F;&#x2F; 更新        singleLinkedList.update(newHeroNode);        System.out.println(&quot;更新后~~~&quot;);        singleLinkedList.list();        singleLinkedList.delete(1);        singleLinkedList.delete(2);        singleLinkedList.delete(3);        singleLinkedList.delete(4);        singleLinkedList.delete(5);        System.out.println(&quot;删除后~~&quot;);        singleLinkedList.list();    &#125;&#125;&#x2F;&#x2F; 定义SingleLinkedList管理我的英雄class SingleLinkedList&#123;    &#x2F;&#x2F; 头结点    private HeroNode head &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);    &#x2F;&#x2F; 添加节点到单向链表    &#x2F;&#x2F; 1.因为头结点不能动，定义一个临时变量，用来遍历    &#x2F;&#x2F; 2.先找到next为null的节点    &#x2F;&#x2F; 3.将头节点的next值指向下一个节点    public void add(HeroNode heroNode)&#123;        HeroNode temp &#x3D; head;        &#x2F;&#x2F; 遍历，寻找最后一个next为空的节点        while (true)&#123;            &#x2F;&#x2F; 找到链表最后            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 如果没有找到，继续往后移            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F; temp.next指向heroNode       temp.next &#x3D; heroNode;    &#125;    &#x2F;&#x2F; 第二种方式在添加英雄时，根据排名将英雄插入到指定位置    &#x2F;&#x2F; (如果有这个排名，则添加失败，并给出提示    public void addByOrder(HeroNode heroNode)&#123;        HeroNode temp &#x3D; head;        &#x2F;&#x2F; 定义flag，默认为false，表示插入的节点不存在        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 最后一个，直接返回            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 找到位置了，直接插入            if (temp.next.no &gt; heroNode.no)&#123;                break;            &#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;                &#x2F;&#x2F; 说明节点已经存在                flag &#x3D; true;                break;            &#125;            &#x2F;&#x2F; 如果当前节点不符合，则将temp往后移            temp &#x3D; temp.next;        &#125;        if (flag)&#123;  &#x2F;&#x2F; 不能添加，节点已经存在            System.out.printf(&quot;插入的节点 %d 已经存在，请重新插入！\n&quot;,heroNode.no);        &#125; else &#123;            &#x2F;&#x2F; 将节点插到temp的后面            heroNode.next &#x3D; temp.next;            temp.next &#x3D; heroNode;        &#125;    &#125;    &#x2F;&#x2F; 修改    &#x2F;&#x2F; 找到原来的no，根据no修改名字和昵称    public void update(HeroNode newHeroNode)&#123;        if (head.next &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        HeroNode temp &#x3D; head.next;        &#x2F;&#x2F; 默认没有找到no        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 已经是最后一个节点            if (temp &#x3D;&#x3D; null )&#123;                break;            &#125;            if (temp.no &#x3D;&#x3D; newHeroNode.no)&#123;                &#x2F;&#x2F; 说明已经找到了                flag &#x3D; true;                break;            &#125;            &#x2F;&#x2F; 往后移            temp &#x3D; temp.next;        &#125;        if (flag)&#123;            &#x2F;&#x2F; 如果找到了，修改名字和昵称            temp.name &#x3D; newHeroNode.name;            temp.nickName &#x3D; newHeroNode.nickName;        &#125; else &#123;            System.out.printf(&quot;没有找到编号为 %d 的数据&quot;,newHeroNode.no);        &#125;    &#125;    &#x2F;&#x2F; 删除    public void delete(int no)&#123;        HeroNode temp &#x3D; head;        &#x2F;&#x2F; 标志是否找到        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 最后一个节点            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            if (temp.next.no &#x3D;&#x3D; no)&#123;                &#x2F;&#x2F; 找到了节点                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag)&#123;            &#x2F;&#x2F; 如果找到了，temp的下一个节点将指向删掉的节点的下一个节点            &#x2F;&#x2F; 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收            temp.next&#x3D; temp.next.next;            &#x2F;&#x2F;System.out.println(&quot;删除成功&quot;);        &#125; else &#123;            System.out.printf(&quot;没有找到编号为 %d 的节点&quot;,no);        &#125;    &#125;    &#x2F;&#x2F; 显示链表，遍历    public void list()&#123;        &#x2F;&#x2F; 判断是否为空        if (head.next &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        &#x2F;&#x2F; 通过一个辅助变量，遍历        HeroNode temp &#x3D; head.next;        while (true)&#123;            &#x2F;&#x2F; 判断是否到链表最后            if (temp &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 输出节点信息            System.out.println(temp);            &#x2F;&#x2F; temp 后移            temp &#x3D; temp.next;        &#125;    &#125;    &#125;&#x2F;&#x2F; 定于HeroNode，每个HeroNode对象就是一个节点class HeroNode&#123;    public int no;    public String name;    public String nickName;    public HeroNode next;       &#x2F;&#x2F; 指向下一个节点    &#x2F;&#x2F; 有参构造    public HeroNode(int no, String name, String nickName) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.nickName &#x3D; nickName;    &#125;    &#x2F;&#x2F; 重写toString    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, nickName&#x3D;&#39;&quot; + nickName +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h2 id="4-3单链表面试题-新浪、百度、腾讯）"><a href="#4-3单链表面试题-新浪、百度、腾讯）" class="headerlink" title="4.3单链表面试题(新浪、百度、腾讯）"></a>4.3单链表面试题(新浪、百度、腾讯）</h2><p>单链表的常见面试题有如下:</p><ol><li><p>求单链表中有效节点的个数</p><p>代码演示：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 方法：获取到单链表的节点个数（如果是带头节点的链表，需要不统计头节点）&#x2F;**     *     * @param head  链表的头结点     * @return      返回的就是有效节点的个数     *&#x2F;public static int getLength(HeroNode head)&#123;    if (head.next &#x3D;&#x3D; null)&#123;        return 0;    &#125;    int length &#x3D; 0;    &#x2F;&#x2F; 定义一个辅助的变量，这里我们没有统计头节点    HeroNode cur &#x3D; head.next;    while (cur !&#x3D; null)&#123;        length++;        cur &#x3D; cur.next;    &#125;    return length;&#125;</code></pre></div></li><li><p>查找单链表中的倒数第k个结点 【新浪面试题】</p><p>代码演示：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 查找单链表中的倒数第K个节点【新浪面试题】&#x2F;&#x2F; 思路&#x2F;&#x2F; 1.编写一个方法，接收head节点，同时接收一个index&#x2F;&#x2F; 2.index表示是倒数的第index个节点&#x2F;&#x2F; 3.先把链表从头到尾遍历，得到链表的总的长度getLength&#x2F;&#x2F; 4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到&#x2F;&#x2F; 5.如果找到了，则返回节点，否则返回nullpublic static HeroNode findLastIndexNode(HeroNode head,int index)&#123;    &#x2F;&#x2F; 判断如果链表为空，返回null    if (head.next &#x3D;&#x3D; null)&#123;        return null;    &#125;    &#x2F;&#x2F; 第一遍历得到链表的长度（节点个数）    int size &#x3D; getLength(head);    &#x2F;&#x2F; 第二次遍历 size - index 位置，就是我们倒数的第k个节点    &#x2F;&#x2F; 先做一个index的检验    if (index &lt;&#x3D; 0 || index &gt; size)&#123;        return null;    &#125;    HeroNode cur &#x3D; head.next;    &#x2F;&#x2F; 定义一个辅助变量，for 循环到倒数的index    for (int i &#x3D; 0 ; i &lt; size - index ; i++ )&#123;        cur &#x3D; cur.next;    &#125;    return cur;&#125;</code></pre></div></li><li><p>单链表的反转【腾讯面试题，有点难度】</p><p>思路分析：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120094842379.png" alt="image-20211120094842379"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120094902571.png" alt="image-20211120094902571"></p><p>代码演示：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 实现单链表反转public static void reverseList(HeroNode head)&#123;    &#x2F;&#x2F; 判断链表是否为空,或者只有一个节点，无需反转，直接返回    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D;null)&#123;        return;    &#125;    &#x2F;&#x2F; 定义一个辅助的指针（变量），帮助我们遍历原来的链表    HeroNode cur &#x3D; head.next;    HeroNode next &#x3D; null;       &#x2F;&#x2F; 当前节点[cur]的下一个节点    HeroNode reverseHead &#x3D; new HeroNode(0,&quot;&quot;,&quot;&quot;);    &#x2F;&#x2F; 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead中 的最前端    while (cur !&#x3D; null)&#123;        next &#x3D; cur.next;                &#x2F;&#x2F; 先暂时保存当前节点的下一个节点，后面会用到        cur.next &#x3D; reverseHead.next;    &#x2F;&#x2F; 将cur的下一个节点指向reverseHead的最前端        reverseHead.next &#x3D; cur;         &#x2F;&#x2F; 将reverseHead和第一节点连接起来        cur &#x3D; next;                     &#x2F;&#x2F; cur 下移一个    &#125;    &#x2F;&#x2F; 将head.next指向reverseHead.next，实现单链表反转    head.next &#x3D; reverseHead.next;&#125;</code></pre></div></li><li><p>从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p><p>思路分析：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120095007137.png" alt="image-20211120095007137"></p><p>代码演示：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 逆序打印单链表public static void reversePrint(HeroNode head)&#123;    &#x2F;&#x2F; 判断是否为空,或者是否只有一个    if (head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;        return;    &#125;    HeroNode cur &#x3D; head.next;    Stack&lt;HeroNode&gt; stack &#x3D; new Stack&lt;&gt;();    while (cur !&#x3D; null)&#123;        stack.push(cur);    &#x2F;&#x2F; 入栈        cur &#x3D; cur.next;     &#x2F;&#x2F; 下移    &#125;    &#x2F;&#x2F; 出栈    while (stack.size()&gt;0)&#123;        System.out.println(stack.pop());    &#125;&#125;</code></pre></div></li><li><p>合并两个有序的单链表，合并之后的链表依然有序【课后练习.】</p></li></ol><h2 id="4-4双向链表应用实例"><a href="#4-4双向链表应用实例" class="headerlink" title="4.4双向链表应用实例"></a>4.4双向链表应用实例</h2><h3 id="4-4-1双向链表的操作分析帝和实现"><a href="#4-4-1双向链表的操作分析帝和实现" class="headerlink" title="4.4.1双向链表的操作分析帝和实现"></a>4.4.1双向链表的操作分析帝和实现</h3><p>使用带head头的<strong>双向链表</strong>实现 –水浒英雄排行榜</p><p>管理单向链表的缺点分析: </p><ol><li>单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链表可以向前或者向后查找。</li><li>单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li><li>示意图帮助理解删除</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120155727097.png" alt="image-20211120155727097"></p><p>对上图的说明：</p><p>分析 双向链表的遍历，添加，修改，删除的操作思路===》代码实现</p><ol><li><p>遍历 方和 单链表一样，只是可以向前，也可以向后查找</p></li><li><p>添加 (默认添加到双向链表的最后)</p></li></ol><p>(1) 先找到双向链表的最后这个节点</p><p>(2) temp.next = newHeroNode</p><p>(3) newHeroNode.pre = temp;</p><ol start="3"><li><p><strong>修改</strong> 思路和 原来的单向链表一样.</p></li><li><p><strong>删除</strong></p></li></ol><p>(1) 因为是双向链表，因此，我们可以实现自我删除某个节点</p><p>(2) 直接找到要删除的这个节点，比如temp</p><p>(3) temp.pre.next = temp.next</p><p>(4) temp.next.pre = temp.pre;</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.linkedlist;public class DoubleLinkedListDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建节点        HeroNode2 hero1 &#x3D; new HeroNode2(1, &quot;张三&quot;, &quot;法外狂徒&quot;);        HeroNode2 hero2 &#x3D; new HeroNode2(2, &quot;李四&quot;, &quot;法外狂徒2&quot;);        HeroNode2 hero3 &#x3D; new HeroNode2(3, &quot;王五&quot;, &quot;法外狂徒3&quot;);        HeroNode2 hero4 &#x3D; new HeroNode2(4, &quot;阿六&quot;, &quot;法外狂徒4&quot;);        HeroNode2 hero5 &#x3D; new HeroNode2(5, &quot;阿六5&quot;, &quot;法外狂徒5&quot;);        HeroNode2 hero7 &#x3D; new HeroNode2(7, &quot;阿7&quot;, &quot;法外狂徒5&quot;);        DoubleLinkedList doubleLinkedList &#x3D; new DoubleLinkedList();        &#x2F;&#x2F; 按照顺序插入        doubleLinkedList.addByOrder(hero7);        doubleLinkedList.addByOrder(hero5);        doubleLinkedList.addByOrder(hero1);        doubleLinkedList.addByOrder(hero3);        doubleLinkedList.addByOrder(hero4);        doubleLinkedList.addByOrder(hero2);        System.out.println(&quot;按照编号顺序插入&quot;);        doubleLinkedList.list();      &#x2F;*  doubleLinkedList.add(hero1);        doubleLinkedList.add(hero2);        doubleLinkedList.add(hero3);        doubleLinkedList.add(hero4);        doubleLinkedList.add(hero5);        System.out.println(&quot;双向链表的便遍历&quot;);        doubleLinkedList.list();        HeroNode2 newHeroNode &#x3D; new HeroNode2(2, &quot;111111&quot;, &quot;法外狂徒2&quot;);        doubleLinkedList.update(newHeroNode);        System.out.println(&quot;修改过后的链表&quot;);        doubleLinkedList.list();        doubleLinkedList.delete(2);        System.out.println(&quot;删除过后的链表&quot;);        doubleLinkedList.list();*&#x2F;    &#125;&#125;&#x2F;&#x2F; 创建一个双链表class DoubleLinkedList&#123;    &#x2F;&#x2F; 初始化头结点，头结点不要动，不存放具体的数据    private HeroNode2 head &#x3D; new HeroNode2(0,&quot;&quot;,&quot;&quot;);    &#x2F;&#x2F; 返回头结点    public HeroNode2 getHead() &#123;        return head;    &#125;    &#x2F;&#x2F; 按照编号顺序添加    &#x2F;&#x2F; (如果有这个排名，则添加失败，并给出提示    public void addByOrder(HeroNode2 heroNode)&#123;        HeroNode2 temp &#x3D; head;        &#x2F;&#x2F; 定义flag，默认为false，表示插入的节点不存在        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 最后一个，直接返回            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 找到位置了，直接插入            if (temp.next.no &gt; heroNode.no)&#123;                break;            &#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;                &#x2F;&#x2F; 说明节点已经存在                flag &#x3D; true;                break;            &#125;            &#x2F;&#x2F; 如果当前节点不符合，则将temp往后移            temp &#x3D; temp.next;        &#125;        if (flag)&#123;  &#x2F;&#x2F; 不能添加，节点已经存在            System.out.printf(&quot;插入的节点 %d 已经存在，请重新插入！\n&quot;,heroNode.no);        &#125; else &#123;            &#x2F;&#x2F; 将节点插到temp的后面            &#x2F;&#x2F; heroNode.next &#x3D; temp.next;            &#x2F;&#x2F; temp.next &#x3D; heroNode;            if (temp.next !&#x3D; null)&#123;                heroNode.next &#x3D; temp.next;                temp.next.pre &#x3D; heroNode;                temp.next &#x3D; heroNode;                heroNode.pre &#x3D; temp;            &#125; else &#123;                temp.next &#x3D; heroNode;                heroNode.pre &#x3D; temp;            &#125;                    &#125;    &#125;    &#x2F;&#x2F; 遍历双向链表的方法    public void list()&#123;        &#x2F;&#x2F; 判断是否为空        if (head.next &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        &#x2F;&#x2F; 通过一个辅助变量，遍历        HeroNode2 temp &#x3D; head.next;        while (true)&#123;            &#x2F;&#x2F; 判断是否到链表最后            if (temp &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 输出节点信息            System.out.println(temp);            &#x2F;&#x2F; temp 后移            temp &#x3D; temp.next;        &#125;    &#125;    &#x2F;&#x2F; 添加一个 节点到链表最后    public void add(HeroNode2 heroNode)&#123;        HeroNode2 temp &#x3D; head;        &#x2F;&#x2F; 遍历，寻找最后一个next为空的节点        while (true)&#123;            &#x2F;&#x2F; 找到链表最后            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 如果没有找到，继续往后移            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F; 当退出while循环是，temp指向了链表的最后        &#x2F;&#x2F; 形成了一个双向链表        temp.next &#x3D; heroNode;        heroNode.pre &#x3D; temp;    &#125;    &#x2F;&#x2F; 修改一个节点的内容，可以看到双向链表的节点内容修改和单链表一样    &#x2F;&#x2F; 找到原来的no，根据no修改名字和昵称    public void update(HeroNode2 newHeroNode)&#123;        if (head.next &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        HeroNode2 temp &#x3D; head.next;        &#x2F;&#x2F; 默认没有找到no        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 已经是最后一个节点            if (temp &#x3D;&#x3D; null )&#123;                break;            &#125;            if (temp.no &#x3D;&#x3D; newHeroNode.no)&#123;                &#x2F;&#x2F; 说明已经找到了                flag &#x3D; true;                break;            &#125;            &#x2F;&#x2F; 往后移            temp &#x3D; temp.next;        &#125;        if (flag)&#123;            &#x2F;&#x2F; 如果找到了，修改名字和昵称            temp.name &#x3D; newHeroNode.name;            temp.nickName &#x3D; newHeroNode.nickName;        &#125; else &#123;            System.out.printf(&quot;没有找到编号为 %d 的数据&quot;,newHeroNode.no);        &#125;    &#125;    &#x2F;&#x2F; 从双向链表中删除一个节点    &#x2F;&#x2F; 1 对于双向链表，我们可以直接找到要删除的这个节点    &#x2F;&#x2F; 2 找到后，自我删除    &#x2F;&#x2F; 删除    public void delete(int no)&#123;        if (head.next &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空，无法删除&quot;);            return;        &#125;        HeroNode2 temp &#x3D; head.next;        &#x2F;&#x2F; 标志是否找到        boolean flag &#x3D; false;        while (true)&#123;            &#x2F;&#x2F; 指向链表的最后            if (temp &#x3D;&#x3D; null)&#123;                break;            &#125;            if (temp.no &#x3D;&#x3D; no)&#123;                &#x2F;&#x2F; 找到了节点                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if (flag)&#123;            &#x2F;&#x2F; 如果找到了，temp的下一个节点将指向删掉的节点的下一个节点            &#x2F;&#x2F; 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收            &#x2F;&#x2F; temp.next&#x3D; temp.next.next; [单链表]            &#x2F;&#x2F;System.out.println(&quot;删除成功&quot;);            temp.pre.next &#x3D; temp.next;            &#x2F;&#x2F; 有问题，如果是最后一个，出现null.pre空指针，所以先判断是否是最后一个            if (temp.next !&#x3D; null)&#123;                temp.next.pre &#x3D; temp.pre;            &#125;        &#125; else &#123;            System.out.printf(&quot;没有找到编号为 %d 的节点&quot;,no);        &#125;    &#125;&#125;&#x2F;&#x2F; 定于HeroNode，每个HeroNode对象就是一个节点class HeroNode2&#123;    public int no;    public String name;    public String nickName;    public HeroNode2 next;       &#x2F;&#x2F; 指向下一个节点    public HeroNode2 pre;        &#x2F;&#x2F; 指向前一个节点    &#x2F;&#x2F; 有参构造    public HeroNode2(int no, String name, String nickName) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.nickName &#x3D; nickName;    &#125;    &#x2F;&#x2F; 重写toString    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, nickName&#x3D;&#39;&quot; + nickName +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h3 id="4-4-2课堂作业和思路提示"><a href="#4-4-2课堂作业和思路提示" class="headerlink" title="4.4.2课堂作业和思路提示:"></a>4.4.2<strong>课堂作业和思路提示</strong>:</h3><p> 双向链表的第二种添加方式,按照编号顺序 [示意图]按照单链表的顺序添加，稍作修改即可(已经加在4.4.1的代码中63-107行)。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 按照编号顺序添加&#x2F;&#x2F; (如果有这个排名，则添加失败，并给出提示public void addByOrder(HeroNode2 heroNode)&#123;    HeroNode2 temp &#x3D; head;    &#x2F;&#x2F; 定义flag，默认为false，表示插入的节点不存在    boolean flag &#x3D; false;    while (true)&#123;        &#x2F;&#x2F; 最后一个，直接返回        if (temp.next &#x3D;&#x3D; null)&#123;            break;        &#125;        &#x2F;&#x2F; 找到位置了，直接插入        if (temp.next.no &gt; heroNode.no)&#123;            break;        &#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no)&#123;            &#x2F;&#x2F; 说明节点已经存在            flag &#x3D; true;            break;        &#125;        &#x2F;&#x2F; 如果当前节点不符合，则将temp往后移        temp &#x3D; temp.next;    &#125;    if (flag)&#123;  &#x2F;&#x2F; 不能添加，节点已经存在        System.out.printf(&quot;插入的节点 %d 已经存在，请重新插入！\n&quot;,heroNode.no);    &#125; else &#123;        &#x2F;&#x2F; 将节点插到temp的后面        &#x2F;&#x2F; heroNode.next &#x3D; temp.next;        &#x2F;&#x2F; temp.next &#x3D; heroNode;        if (temp.next !&#x3D; null)&#123;            heroNode.next &#x3D; temp.next;            temp.next.pre &#x3D; heroNode;            temp.next &#x3D; heroNode;            heroNode.pre &#x3D; temp;        &#125; else &#123;            temp.next &#x3D; heroNode;            heroNode.pre &#x3D; temp;        &#125;    &#125;&#125;</code></pre></div><h2 id="4-5单向环形链表应用场景"><a href="#4-5单向环形链表应用场景" class="headerlink" title="4.5单向环形链表应用场景"></a>4.5单向环形链表应用场景</h2><p>Josephu(约瑟夫、约瑟夫环) 问题</p><p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p>提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120163522352.png" alt="image-20211120163522352"></p><h2 id="4-6-单向环形链表介绍"><a href="#4-6-单向环形链表介绍" class="headerlink" title="4.6 单向环形链表介绍"></a>4.6 单向环形链表介绍</h2><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120163548522.png" alt="image-20211120163548522"></p><h2 id="4-7-Josephu问题"><a href="#4-7-Josephu问题" class="headerlink" title="4.7 Josephu问题"></a>4.7 Josephu问题</h2><p>约瑟夫问题的示意图 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120163756115.png" alt="image-20211120163756115"></p><p><strong>Josephu问题</strong></p><p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p><strong>提示</strong></p><p>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p><p><strong>约瑟夫问题-创建环形链表的思路图解</strong></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120202037626.png" alt="image-20211120202037626"></p><p><strong>约瑟夫问题-小孩出圈的思路分析图</strong></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120202123633.png" alt="image-20211120202123633"></p><h2 id="4-8-Josephu问题的代码实现"><a href="#4-8-Josephu问题的代码实现" class="headerlink" title="4.8 Josephu问题的代码实现"></a>4.8 Josephu问题的代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.linkedlist;public class Josephu &#123;    public static void main(String[] args) &#123;        CircleSingleLinkedList circleSingleLinkedList &#x3D; new CircleSingleLinkedList();        circleSingleLinkedList.addBoy(5);        circleSingleLinkedList.showBoy();        circleSingleLinkedList.countBoy(1,2,5);    &#125;&#125;class CircleSingleLinkedList&#123;    &#x2F;&#x2F; 先创建第一个节点，当前没有编号    private Boy first &#x3D; null;    &#x2F;&#x2F; 添加小孩节点，构建成一个环形的链表    public void addBoy(int nums)&#123;        &#x2F;&#x2F; 校验输入的数据是否正确        if (nums &lt; 1)&#123;            System.out.println(&quot;输入个数不正确&quot;);            return;        &#125;        &#x2F;&#x2F; 辅助指针        Boy curBoy &#x3D; null;        &#x2F;&#x2F; 使用for来创建我们的环形链表        for (int i &#x3D; 1; i &lt;&#x3D; nums; i++) &#123;            &#x2F;&#x2F; 根据编号创建小孩节点            Boy boy &#x3D; new Boy(i);            &#x2F;&#x2F; 如果是第一个小孩            if (i &#x3D;&#x3D; 1)&#123;                first &#x3D; boy;                first.setNext(first);   &#x2F;&#x2F; 构成环                curBoy &#x3D; first;         &#x2F;&#x2F; 指向第一个小孩            &#125; else &#123;                curBoy.setNext(boy);                boy.setNext(first);                curBoy &#x3D; boy;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 遍历当前的环形单链表    public void showBoy()&#123;        &#x2F;&#x2F; 判断链表是否为空        if (first &#x3D;&#x3D; null)&#123;            System.out.println(&quot;没有任何小孩&quot;);            return;        &#125;        &#x2F;&#x2F; 因为first不能动，我们仍然使用一个辅助指针完成遍历        Boy curBoy &#x3D; first;        while (true)&#123;            System.out.printf(&quot;小孩的编号 %d \n&quot;,curBoy.getNo());            &#x2F;&#x2F; 遍历完毕            if (curBoy.getNext() &#x3D;&#x3D; first)&#123;                break;            &#125;            &#x2F;&#x2F; curBoy后移            curBoy &#x3D; curBoy.getNext();        &#125;    &#125;    &#x2F;&#x2F; 根据用户的输入，计算出小孩出圈的顺序    &#x2F;**     *     * @param startNo   表示从第几个孩子开始数数     * @param countNum  表示数几下     * @param nums      表示最初有多少个孩子     *&#x2F;    public void countBoy(int startNo ,int countNum ,int nums)&#123;        &#x2F;&#x2F; 先对数据校验        if (first &#x3D;&#x3D; null || startNo &lt;1 || countNum &gt; nums)&#123;            System.out.println(&quot;参数有误，请重新输入&quot;);            return;        &#125;        &#x2F;&#x2F; 创建一个辅助节点，帮忙完成小孩出圈        Boy helper &#x3D; first;        &#x2F;&#x2F; 遍历，让helper指向链表的最后        while (true)&#123;            &#x2F;&#x2F; 说明helper已经指向最后小孩节点            if (helper.getNext() &#x3D;&#x3D; first)&#123;                break;            &#125;            &#x2F;&#x2F; 往后移            helper &#x3D; helper.getNext();        &#125;        &#x2F;&#x2F; 报数前，先移动到指定的个数作为开始        for (int j &#x3D; 0; j &lt; startNo - 1; j++) &#123;            first &#x3D; first.getNext();            helper &#x3D; helper.getNext();        &#125;        &#x2F;&#x2F; 报数时，遍历链表，从指定开始的数，根据要移动的次数（countNum -1）开始遍历，数数        while (true)&#123;            &#x2F;&#x2F; 说明圈中只有一个小孩            if (helper &#x3D;&#x3D; first)&#123;                break;            &#125;            &#x2F;&#x2F; 开始数数,让first 和 helper 同时移动到countNum -1            for (int i &#x3D; 0; i &lt; countNum - 1; i++) &#123;                first &#x3D; first.getNext();                helper &#x3D; helper.getNext();            &#125;            &#x2F;&#x2F; 这是first指向的节点就是要出圈的节点            System.out.printf(&quot;小孩 %d 已经出圈 \n&quot;,first.getNo());            first &#x3D; first.getNext();    &#x2F;&#x2F; 后移            helper.setNext(first);      &#x2F;&#x2F; 指向first        &#125;        System.out.printf(&quot;最后留在圈中的小孩编号 %d \n&quot;,first.getNo());    &#125;&#125;&#x2F;&#x2F; 创建一个Boy类，表示一个节点class Boy&#123;    private int no ;        &#x2F;&#x2F; 编号    private Boy next;       &#x2F;&#x2F; 指向下一个节点，默认为null    public Boy(int no) &#123;        this.no &#x3D; no;    &#125;    public int getNo() &#123;        return no;    &#125;    public void setNo(int no) &#123;        this.no &#x3D; no;    &#125;    public Boy getNext() &#123;        return next;    &#125;    public void setNext(Boy next) &#123;        this.next &#x3D; next;    &#125;&#125;</code></pre></div><h1 id="第5章-栈"><a href="#第5章-栈" class="headerlink" title="第5章 栈"></a>第5章 栈</h1><h2 id="5-1-栈的一个实际需求"><a href="#5-1-栈的一个实际需求" class="headerlink" title="5.1 栈的一个实际需求"></a>5.1 栈的一个实际需求</h2><p>请输入一个表达式</p><p>计算式:[<strong>7*2*2-5+1-5+3-3</strong>] <strong>点击计算<strong><strong>【</strong></strong>如下图****】</strong></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120211638901.png" alt="image-20211120211638901"></p><p>请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算,因为我们看这个算式 7 * 2 * 2 - 5, 但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题**。-&gt; **栈</p><h2 id="5-2-栈的介绍"><a href="#5-2-栈的介绍" class="headerlink" title="5.2 栈的介绍"></a>5.2 栈的介绍</h2><ol><li><p>栈的英文为(stack)</p></li><li><p>栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</p></li><li><p>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一端，称为<strong>栈底</strong>(Bottom)。</p></li><li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p></li><li><p>出栈(pop)和入栈(push)的概念(如图所示)</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120211803381.png" alt="image-20211120211803381"></p><h2 id="5-3-栈的应用场景"><a href="#5-3-栈的应用场景" class="headerlink" title="5.3 栈的应用场景"></a>5.3 栈的应用场景</h2><ol><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。  </li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图形的深度优先(depth一first)搜索法。</li></ol><h2 id="5-4栈的快速入门"><a href="#5-4栈的快速入门" class="headerlink" title="5.4栈的快速入门"></a>5.4栈的快速入门</h2><ol><li><p>用<strong>数组模拟栈</strong>的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的<strong>出栈</strong>，<strong>入栈</strong>等操作。</p></li><li><p>实现思路分析,并画出示意图</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211120221232413.png" alt="image-20211120221232413"></p><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack;import java.util.Scanner;public class ArrayStackDemo &#123;    public static void main(String[] args) &#123;        ArrayStack stack &#x3D; new ArrayStack(4);        String key &#x3D; &quot;&quot;;        &#x2F;&#x2F; 控制程序是否退出        boolean loop &#x3D; true;        Scanner scanner &#x3D; new Scanner(System.in);        while (loop)&#123;            System.out.println(&quot;show：表示展示栈的所有的数据&quot;);            System.out.println(&quot;exit：表示退出程序&quot;);            System.out.println(&quot;push：表示添加数据到栈（入栈）&quot;);            System.out.println(&quot;pop：表示出栈&quot;);            System.out.println(&quot;请输入您的选择：&quot;);            key &#x3D; scanner.next();            switch (key)&#123;                case &quot;show&quot;:                    stack.list();                    break;                case &quot;push&quot;:                    System.out.println(&quot;请输入您要添加的数据&quot;);                    int value &#x3D; scanner.nextInt();                    stack.push(value);                    break;                case &quot;pop&quot;:                    try &#123;                        int res &#x3D; stack.pop();                        System.out.printf(&quot;您要出栈的数据是 %d \n&quot;,res);                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &quot;exit&quot;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序已退出~~&quot;);    &#125;&#125;&#x2F;&#x2F; 定义一个ArrayStack 表示栈class ArrayStack&#123;    private int maxSize;    &#x2F;&#x2F; 栈的大小    private int[] stack;    &#x2F;&#x2F; 数组，数组模拟栈，数据就放在该数组    private int top &#x3D; -1;   &#x2F;&#x2F; 栈顶，初始化为-1    &#x2F;&#x2F; 构造器    public ArrayStack (int maxSize)&#123;        this.maxSize &#x3D; maxSize;        stack &#x3D; new int[maxSize];    &#125;    &#x2F;&#x2F; 栈满    public boolean isFull()&#123;        return top &#x3D;&#x3D; maxSize -1;    &#125;    &#x2F;&#x2F; 栈空    public boolean isEmpty()&#123;        return top &#x3D;&#x3D; -1;    &#125;    &#x2F;&#x2F; 入栈    public void push(int value)&#123;        if (isFull())&#123;            System.out.println(&quot;栈已经满啦&quot;);        &#125;        top++;        stack[top]&#x3D;value;    &#125;    &#x2F;&#x2F; 出栈，将栈顶的数据返回    public int pop()&#123;        if (isEmpty())&#123;            &#x2F;&#x2F; 抛出异常            throw new RuntimeException(&quot;栈为空，出栈失败&quot;);        &#125;        int value &#x3D; stack[top];        top--;        return value;    &#125;    &#x2F;&#x2F; 显示栈的情况[遍历栈]，遍历时，需要从栈顶开始显示数据    public void list()&#123;        if (isEmpty())&#123;            System.out.println(&quot;栈为空，显示栈失败&quot;);            return;        &#125;        &#x2F;&#x2F; 需要从栈顶开始显示数据        for (int i &#x3D; top; i&gt;&#x3D;0 ; i--)&#123;            System.out.printf(&quot;stack[%d] &#x3D; %d \n&quot;,i,stack[i]);        &#125;    &#125;&#125;</code></pre></div></li><li><p><strong>课堂练习</strong>，将老师写的程序改成使用<strong>链表来模拟栈</strong>.[单链表]</p><p>思路分析：</p><ol><li>先定义一个节点类Node<ul><li>int no：节点编号</li><li>Node next：下一个节点</li></ul></li><li>再定义一个单链表模拟数组<ul><li>maxSize:存储节点的最大个数（既是模拟栈的大小）</li><li>isEmpty：判断栈是否为空</li><li>isFull：判断栈是否已满</li><li>add:模拟出栈（push）</li><li>pop：模拟出栈</li><li>list：查看栈的情况（使用了单链表的逆序输出：方式一：数组，方式二：栈）</li></ul></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack.practice;import java.util.ArrayList;import java.util.Scanner;import java.util.Stack;public class TestStackByLinkedList &#123;    public static void main(String[] args) &#123;        SingleLinkedList singleLinkedList &#x3D; new SingleLinkedList();        singleLinkedList.setMaxSize(4);     &#x2F;&#x2F; 设置最大节点数，模拟栈的最大数        String key &#x3D; &quot;&quot;;                    &#x2F;&#x2F; 用户输入的字符串        boolean loop &#x3D; true;                &#x2F;&#x2F; 控制循环        Scanner scanner &#x3D; new Scanner(System.in);        while (loop)&#123;            System.out.println(&quot;add：添加节点，模拟入栈&quot;);            System.out.println(&quot;exit：退出&quot;);            System.out.println(&quot;pop：弹出节点，模拟出栈&quot;);            System.out.println(&quot;list：遍历链表，模拟展示所以数据&quot;);            System.out.println(&quot;请输入您要选择的选项：&quot;);            key &#x3D; scanner.next();            switch (key)&#123;                case &quot;add&quot;:                    System.out.println(&quot;请输入您要添加的数据(数字)：&quot;);                    int value &#x3D; scanner.nextInt();                    Node node &#x3D; new Node(value);                    singleLinkedList.add(node);                    break;                case &quot;pop&quot;:                    try &#123;                        singleLinkedList.pop();                    &#125; catch (Exception e) &#123;                        e.printStackTrace();                        System.out.println(e.getMessage());                    &#125;                    break;                case &quot;list&quot;:                    singleLinkedList.list();                    break;                case &quot;exit&quot;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序已退出~~&quot;);    &#125;&#125;&#x2F;&#x2F; 定义单链表模拟栈class SingleLinkedList&#123;    private int maxSize;    &#x2F;&#x2F; 表示链表最大存储的节点    public void setMaxSize(int maxSize) &#123;        this.maxSize &#x3D; maxSize;    &#125;    &#x2F;&#x2F; 创建一个头head    Node head &#x3D; new Node(0);    &#x2F;&#x2F; 为空    public boolean isEmpty()&#123;        return head.next &#x3D;&#x3D; null;    &#125;    &#x2F;&#x2F; 判断是否已达到最大数量    public boolean isFull()&#123;        Node temp &#x3D; head;        int count &#x3D; 0;      &#x2F;&#x2F; 定义一个count，,记录节点个数，用到判断是否已满        while (true)&#123;            &#x2F;&#x2F; 说明已经找到了            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 下移            count++;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F; 将count和maxSize比较        if (maxSize !&#x3D; count)&#123;            return false;        &#125;        &#x2F;&#x2F;System.out.println(&quot;链表模拟栈已满~~&quot;);        return true;    &#125;    &#x2F;&#x2F; 添加节点    public void add(Node node)&#123;        &#x2F;&#x2F; 判断是否已满        if (isFull())&#123;            System.out.println(&quot;栈已经满啦~~~&quot;);        &#125;        &#x2F;&#x2F; 定义一个辅助变量        Node temp &#x3D; head;        while (true)&#123;            &#x2F;&#x2F; 说明找到了最后一个            if (temp.next &#x3D;&#x3D;null)&#123;                break;            &#125;            &#x2F;&#x2F; 后移            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F; 将添加的节点加到链表中        temp.next &#x3D; node;    &#125;    &#x2F;&#x2F; 模拟出栈，将链表最后的一个元素弹出去，模拟栈的先进后出    public void pop ()&#123;        &#x2F;&#x2F; 判断是否为空        if (isEmpty())&#123;            throw new RuntimeException(&quot;模拟栈为空~~&quot;);        &#125;        Node temp &#x3D; head;        while (true)&#123;            &#x2F;&#x2F; 说明已经 找到最后一个的前一个            if (temp.next.next &#x3D;&#x3D; null)&#123;                break;            &#125;            &#x2F;&#x2F; 下移            temp &#x3D; temp.next;        &#125;        System.out.printf(&quot;出栈的节点是 %d \n&quot;,temp.next.no);        temp.next &#x3D; null;    &#125;    &#x2F;&#x2F; 展示所以的【遍历】，模拟栈的先进后出，即逆序输出链表    &#x2F;&#x2F; 方法一：用数组    &#x2F;&#x2F; 方法二：用栈    public void list()&#123;        if (isEmpty())&#123;            System.out.println(&quot;模拟栈为空哦~~&quot;);            return;        &#125;        Node temp &#x3D; head;        &#x2F;&#x2F; 方法一：利用数组        ArrayList&lt;Node&gt; arrayList &#x3D; new ArrayList&lt;&gt;();        while (true)&#123;            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            arrayList.add(temp.next);            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F; 遍历数组        for (int i &#x3D; arrayList.size() -1 ; i&gt;&#x3D;0 ; i--)&#123;            System.out.println(&quot;栈的情况为（利用栈）：&quot;+arrayList.get(i));        &#125;        &#x2F;&#x2F; 方法二：利用栈       &#x2F;* Stack&lt;Node&gt; stack &#x3D; new Stack&lt;&gt;();        while (true)&#123;            if (temp.next &#x3D;&#x3D; null)&#123;                break;            &#125;            stack.push(temp.next);            temp &#x3D; temp.next;            &#x2F;&#x2F;System.out.println(&quot;栈的情况为：&quot;+temp.no);        &#125;        while (stack.size()&gt;0)&#123;            System.out.println(&quot;栈的情况为（利用栈）：&quot;+stack.pop());        &#125;*&#x2F;    &#125;&#125;&#x2F;&#x2F; 定义链表节点class Node&#123;    public int no;      &#x2F;&#x2F; 编号    public Node next;   &#x2F;&#x2F; 下一个节点    public Node(int no)&#123;        this.no &#x3D; no;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div></li></ol><h2 id="5-5-栈实现综合计数器（中缀表达式）"><a href="#5-5-栈实现综合计数器（中缀表达式）" class="headerlink" title="5.5 栈实现综合计数器（中缀表达式）"></a>5.5 栈实现综合计数器（中缀表达式）</h2><p>使用栈来实现综合计算器-</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211121142000076.png" alt="image-20211121142000076"></p><p>思路分析：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211121142045475.png" alt="image-20211121142045475"></p><ul><li><p>代码实现[先实现一位运算，再扩展到多位运算]</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack;public class Calculator &#123;    public static void main(String[] args) &#123;        String expression &#x3D; &quot;300+20*6-2&quot;;  &#x2F;&#x2F; 如果做多位数的为题？        &#x2F;&#x2F; 创建两个栈，数栈，一个符号栈        ArrayStack2 numStack &#x3D; new ArrayStack2(10);        ArrayStack2 operStack &#x3D; new ArrayStack2(10);        &#x2F;&#x2F; 定义相关的变量        int index &#x3D; 0;  &#x2F;&#x2F; 用于扫描        int num1 &#x3D; 0;        int num2 &#x3D; 0;        int oper &#x3D; 0;        int res &#x3D; 0;        char ch &#x3D; &#39; &#39;;      &#x2F;&#x2F; 将每次扫描得到的存到ch        String keepNum &#x3D; &quot;&quot;;    &#x2F;&#x2F; 用于拼接，多位数        while (true)&#123;            &#x2F;&#x2F; 依次得到expression的每一个字符            ch &#x3D; expression.substring(index,index+1).charAt(0);            &#x2F;&#x2F; 判断ch是什么，然后做相应的操作            if (operStack.isOper(ch))&#123;      &#x2F;&#x2F; 如果是运算符                if (!operStack.isEmpty())&#123;  &#x2F;&#x2F; 判断当前符号是否为空                    &#x2F;&#x2F;如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，                    &#x2F;&#x2F; 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，                    &#x2F;&#x2F; 进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，                    if (operStack.priority(ch) &lt;&#x3D; operStack.priority(operStack.peek()))&#123;                        num1 &#x3D; numStack.pop();                        num2 &#x3D; numStack.pop();                        oper &#x3D; operStack.pop();                        res &#x3D; numStack.cal(num1,num2,oper);                        &#x2F;&#x2F; 将运算结果入数栈                        numStack.push(res);                        operStack.push(ch);                    &#125; else &#123;                        &#x2F;&#x2F; 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.                        operStack.push(ch);                    &#125;                &#125; else &#123;                    &#x2F;&#x2F; 如果发现当前的符号栈为 空，就直接入栈                    operStack.push(ch);                &#125;            &#125; else &#123;                &#x2F;&#x2F; 如果是数字，直接入数栈                &#x2F;&#x2F; numStack.push(ch -48);  &#x2F;&#x2F; ?&quot;1+3&quot; char 型的ASCLL码，1 --&gt; 48                &#x2F;&#x2F; 分析思路                &#x2F;&#x2F; 1.当处理多位数时，不能发现是一个数入栈，因为他可能是多位数                &#x2F;&#x2F; 2.在处理数，需要向expression的表达式index后再看一位，如果是数就进行扫描，如果是符号就直接入栈                &#x2F;&#x2F; 3.因此需要定义一个字符串，用于拼接                keepNum +&#x3D; ch;  &#x2F;&#x2F; 拼接字符串，处理多位数                &#x2F;&#x2F; 如果ch是最后一个，直接入栈                if (index &#x3D;&#x3D; expression.length() -1)&#123;                    numStack.push(Integer.parseInt(keepNum));                &#125; else &#123;                    &#x2F;&#x2F; 入栈前判断表达式下一个是否为符号，如果是符号，直接入栈，不是符号，拼接字符串                    &#x2F;&#x2F; 注意：是看后一位，不是index++                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) &#123;                        numStack.push(Integer.parseInt(keepNum));                        &#x2F;&#x2F; 重要！！！！清空keepNum                        keepNum &#x3D; &quot;&quot;;                    &#125;                &#125;            &#125;            &#x2F;&#x2F; 下移判断下一个字符            index++;            if (index &gt;&#x3D; expression.length())&#123;                break;            &#125;        &#125;        &#x2F;&#x2F; 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.        while (true)&#123;            &#x2F;&#x2F; 如果运算符是空，数栈只有一个，说明是最后一个            if (operStack.isEmpty())&#123;                break;            &#125;            num1 &#x3D; numStack.pop();            num2 &#x3D; numStack.pop();            oper &#x3D; operStack.pop();            res &#x3D; numStack.cal(num1,num2,oper);            numStack.push(res);        &#125;        int res2 &#x3D; numStack.pop();        System.out.printf(&quot;表达式 %s &#x3D; %d&quot;,expression,res2);    &#125;&#125;&#x2F;&#x2F; 定义一个ArrayStack 表示栈class ArrayStack2&#123;    private int maxSize;    &#x2F;&#x2F; 栈的大小    private int[] stack;    &#x2F;&#x2F; 数组，数组模拟栈，数据就放在该数组    private int top &#x3D; -1;   &#x2F;&#x2F; 栈顶，初始化为-1    &#x2F;&#x2F; 构造器    public ArrayStack2 (int maxSize)&#123;        this.maxSize &#x3D; maxSize;        stack &#x3D; new int[maxSize];    &#125;    &#x2F;&#x2F; 增加一个方法，返回当前栈顶的值，但不是真正的pop    public int peek()&#123;        return stack[top];    &#125;    &#x2F;&#x2F; 栈满    public boolean isFull()&#123;        return top &#x3D;&#x3D; maxSize -1;    &#125;    &#x2F;&#x2F; 栈空    public boolean isEmpty()&#123;        return top &#x3D;&#x3D; -1;    &#125;    &#x2F;&#x2F; 入栈    public void push(int value)&#123;        if (isFull())&#123;            System.out.println(&quot;栈已经满啦&quot;);        &#125;        top++;        stack[top]&#x3D;value;    &#125;    &#x2F;&#x2F; 出栈，将栈顶的数据返回    public int pop()&#123;        if (isEmpty())&#123;            &#x2F;&#x2F; 抛出异常            throw new RuntimeException(&quot;栈为空，出栈失败&quot;);        &#125;        int value &#x3D; stack[top];        top--;        return value;    &#125;    &#x2F;&#x2F; 显示栈的情况[遍历栈]，遍历时，需要从栈顶开始显示数据    public void list()&#123;        if (isEmpty())&#123;            System.out.println(&quot;栈为空，显示栈失败&quot;);            return;        &#125;        &#x2F;&#x2F; 需要从栈顶开始显示数据        for (int i &#x3D; top; i&gt;&#x3D;0 ; i--)&#123;            System.out.printf(&quot;stack[%d] &#x3D; %d \n&quot;,i,stack[i]);        &#125;    &#125;    &#x2F;&#x2F; 返回运算符的优先级别    public int priority(int oper)&#123;        if (oper &#x3D;&#x3D; &#39;*&#39; || oper &#x3D;&#x3D; &#39;&#x2F;&#39;)&#123;            return 1;        &#125;        if (oper &#x3D;&#x3D; &#39;+&#39; || oper &#x3D;&#x3D; &#39;-&#39;)&#123;            return 0;        &#125;else &#123;            return -1;  &#x2F;&#x2F; 假设只有+,-,*, &#x2F;        &#125;    &#125;    &#x2F;&#x2F; 判断是否是运算符    public boolean isOper(int val)&#123;        return val &#x3D;&#x3D; &#39;+&#39; || val &#x3D;&#x3D; &#39;-&#39; || val &#x3D;&#x3D; &#39;*&#39; || val &#x3D;&#x3D; &#39;&#x2F;&#39;;    &#125;    &#x2F;&#x2F; 运算    public int cal(int num1,int num2,int oper)&#123;        int res &#x3D; 0;    &#x2F;&#x2F; 用于保存计算结果        switch (oper)&#123;            case &#39;+&#39;:                res &#x3D; num1 + num2;                break;            case &#39;-&#39;:                res &#x3D; num2 - num1;                break;            case &#39;*&#39;:                res &#x3D; num1 * num2;                break;            case &#39;&#x2F;&#39;:                res &#x3D; num2 &#x2F; num1;                break;            default:                break;        &#125;        return res;    &#125;&#125;</code></pre></div><p>课后练习：给表达式加入小括号</p></li></ul><h2 id="5-6-逆波兰计算器"><a href="#5-6-逆波兰计算器" class="headerlink" title="5.6 逆波兰计算器"></a>5.6 逆波兰计算器</h2><p>前缀：从右向左扫描</p><p>中缀：平常的运算</p><p>后缀：从左向右扫描，下面的元素减去上面的元素</p><p>我们完成一个逆波兰计算器，要求完成如下任务</p><ol><li><p>输入一个逆波兰表达(后缀表达式)，使用栈(Stack),计算其结果</p></li><li><p>支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。</p></li><li><p>思路分析</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - ,针对后缀表达式求值步骤如下:1. 从左至右扫描，将3和4压入堆栈；2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；3. 将5入栈；4. 接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；5. 将6入栈；6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果</code></pre></div></li><li><p>代码完成</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 定义一个后缀表达式&#x2F;&#x2F; 为了方便，逆波兰表达式 的数字和符号使用空格隔开        &#x2F;&#x2F; String suffixExpression &#x3D; &quot;3 4 + 5 * 6 -&quot;;  &#x2F;&#x2F; 29        String suffixExpression &#x3D; &quot;4 5 * 8 - 60 + 8 2 &#x2F; +&quot;;  &#x2F;&#x2F; 76        &#x2F;&#x2F; 思路：        &#x2F;&#x2F; 1.先将3 4 + 5 * 6 - &#x3D;&gt; 放到ArrayList中        &#x2F;&#x2F; 2.将ArrayList传递给一个方法，遍历 ArrayList 配合栈 完成计算        List&lt;String&gt; list &#x3D; getListString(suffixExpression);        System.out.println(&quot;list&#x3D;&quot;+list);        int res &#x3D; calculate(list);        System.out.println(&quot;计算结果是&#x3D;&quot;+res);    &#125;    &#x2F;&#x2F; 将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中，分割字符串    public static List&lt;String&gt; getListString(String suffixExpression)&#123;        &#x2F;&#x2F; 以空格分割        String[] split &#x3D; suffixExpression.split(&quot; &quot;);        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        for (String ele : split) &#123;            list.add(ele);        &#125;        return list;    &#125;    &#x2F;**     * 例如: (3+4)×5-6 对应的后缀表达式就是 **3 4 + 5 × 6 - ,** **针对后缀表达式求值步骤如下**:     * 从左至右扫描，将3和4压入堆栈；     * 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；     * 将5入栈；     * 接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；     * 将6入栈；     * 最后是-运算符，计算出35-6的值，即29，由此得出最终结果     *&#x2F;    public static int calculate(List&lt;String&gt; ls)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        for (String item : ls) &#123;            &#x2F;&#x2F; 正则表达式            if (item.matches(&quot;\\d+&quot;))&#123; &#x2F;&#x2F; 匹配多位数                stack.push(item);            &#125; else &#123;                int num2 &#x3D; Integer.parseInt(stack.pop());                int num1 &#x3D; Integer.parseInt(stack.pop());                int res &#x3D; 0;                if (item.equals(&quot;+&quot;))&#123;                    res &#x3D; num1 + num2;                &#125; else if (item.equals(&quot;-&quot;))&#123;                    res &#x3D; num1 - num2;                &#125; else if (item.equals(&quot;*&quot;))&#123;                    res &#x3D; num1 * num2;                &#125; else if (item.equals(&quot;&#x2F;&quot;))&#123;                    res &#x3D; num1 &#x2F; num2;                &#125; else &#123;                    throw new RuntimeException(&quot;运算符有误&quot;);                &#125;                &#x2F;&#x2F; 把res入栈                stack.push(&quot;&quot;+res);            &#125;        &#125;        &#x2F;&#x2F; 最后留在stack栈中的数据是运算结果        return Integer.parseInt(stack.pop());    &#125;&#125;</code></pre></div></li></ol><h2 id="5-7-中缀表达式转为后缀表达式"><a href="#5-7-中缀表达式转为后缀表达式" class="headerlink" title="5.7 中缀表达式转为后缀表达式"></a>5.7 中缀表达式转为后缀表达式</h2><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将 <strong>中缀表达式</strong>转成<strong>后缀表达式</strong>。</p><h3 id="5-7-1具体步骤如下"><a href="#5-7-1具体步骤如下" class="headerlink" title="5.7.1具体步骤如下:"></a>5.7.1<strong>具体步骤如下</strong>:</h3><ol><li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p></li><li><p>从左至右扫描中缀表达式；</p></li><li><p>遇到<strong>操作数</strong>时，将其压s2；</p></li><li><p>遇到<strong>运算符</strong>时，比较其与s1栈顶运算符的优先级：</p><p>(1)如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</p><p>(2)否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p><p>(3)否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较； </p></li><li><p>遇到<strong>括号</strong>时：<br> (1) 如果是左括号“(”，则直接压入s1<br> (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</p></li><li><p>重复步骤2至5，直到表达式的最右边</p></li><li><p>将s1中剩余的运算符依次弹出并压入s2</p></li><li><p>依次弹出s2中的元素并输出，<strong>结果的逆序即为中缀表达式对应的后缀表达式</strong></p></li></ol><h3 id="5-7-2举例说明"><a href="#5-7-2举例说明" class="headerlink" title="5.7.2举例说明"></a>5.7.2<strong>举例说明</strong></h3><p>将中缀表达式1+((2+3)×4)-5转换为后缀表达式的过程如下</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122012047826.png" alt="image-20211122012047826"></p><p><strong>因此结果为</strong> <strong>“1 2 3 + 4 × + 5 –”</strong></p><h3 id="5-7-3-代码实现中缀表达式转为后缀表达式"><a href="#5-7-3-代码实现中缀表达式转为后缀表达式" class="headerlink" title="5.7.3 代码实现中缀表达式转为后缀表达式"></a>5.7.3 <strong>代码实现中缀表达式转为后缀表达式</strong></h3><p>思路分析示意图：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122012234772.png" alt="image-20211122012234772"></p><p><strong>代码实现</strong>：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;public class PolandNotation &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 先定义一个中缀表达式        String expression &#x3D; &quot;1+((2+3)*4)-5&quot;;        List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(expression);        System.out.println(&quot;中缀表达式的List&#x3D;&quot;+infixExpressionList);        List&lt;String&gt; suffixExpressionList &#x3D; paresSuffixExpressionList(infixExpressionList);        System.out.println(&quot;后缀表达式的List&#x3D;&quot;+suffixExpressionList);        System.out.printf(&quot;后缀表达式运算结果：%d&quot;,calculate(suffixExpressionList));        &#x2F;&#x2F; 定义一个后缀表达式        &#x2F;&#x2F; 为了方便，逆波兰表达式 的数字和符号使用空格隔开        &#x2F;&#x2F; String suffixExpression &#x3D; &quot;3 4 + 5 * 6 -&quot;;  &#x2F;&#x2F; 29        &#x2F;*String suffixExpression &#x3D; &quot;4 5 * 8 - 60 + 8 2 &#x2F; +&quot;;  &#x2F;&#x2F; 76        &#x2F;&#x2F; 思路：        &#x2F;&#x2F; 1.先将3 4 + 5 * 6 - &#x3D;&gt; 放到ArrayList中        &#x2F;&#x2F; 2.将ArrayList传递给一个方法，遍历 ArrayList 配合栈 完成计算        List&lt;String&gt; list &#x3D; getListString(suffixExpression);        System.out.println(&quot;list&#x3D;&quot;+list);        int res &#x3D; calculate(list);        System.out.println(&quot;计算结果是&#x3D;&quot;+res);*&#x2F;    &#125;    &#x2F;&#x2F; 将传进来的中缀表达式的list，转成后缀表达式的list    public static List&lt;String&gt; paresSuffixExpressionList(List&lt;String&gt; ls)&#123;        Stack&lt;String&gt; s1 &#x3D; new Stack&lt;&gt;();           &#x2F;&#x2F; 符号        List&lt;String&gt; s2 &#x3D; new ArrayList&lt;&gt;();   &#x2F;&#x2F; 因为这个s2，只存数据，不取出(pop)数字，所以用list比用栈方便        for (String item : ls) &#123;            &#x2F;&#x2F; 如果是一个数            if (item.matches(&quot;\\d+&quot;))&#123;                s2.add(item);            &#125; else if (item.equals(&quot;(&quot;))&#123;                s1.push(item);            &#125; else if (item.equals(&quot;)&quot;))&#123;                &#x2F;&#x2F; 在s1中遍历。直到找到了左括号，将左括号之前的都弹出                while (!s1.peek().equals(&quot;(&quot;))&#123;                    s2.add(s1.pop());                &#125;                &#x2F;&#x2F; 弹出左括号                s1.pop();            &#125; else &#123;                &#x2F;&#x2F; 如果是运算符,当item的运算符优先级小于等于s1栈顶的运算符优先级时，将s1中的弹出，加到s2中                while (s1.size() !&#x3D; 0 &amp;&amp; Operation.getValue(item) &lt;&#x3D; Operation.getValue(s1.peek()) )&#123;                    s2.add(s1.pop());                &#125;                s1.push(item);            &#125;        &#125;        &#x2F;&#x2F; 将剩余的运算符都加到s2中        while (s1.size() !&#x3D; 0)&#123;            s2.add(s1.pop());        &#125;        &#x2F;&#x2F; 注意是因为存放到list中，按顺序出来就是对应的后缀表达式        return s2;    &#125;    &#x2F;&#x2F; 方法：将中缀表达式转成对应的list    public static List&lt;String&gt; toInfixExpressionList(String s)&#123;        &#x2F;&#x2F; 定义一个List，存放中缀表达式对应的内容        ArrayList&lt;String&gt; ls &#x3D; new ArrayList&lt;&gt;();        int i &#x3D; 0;      &#x2F;&#x2F; 定义一个指针        String str;     &#x2F;&#x2F; 用于拼接多位数        char c;         &#x2F;&#x2F; 每遍历到一个字符，就放在c中        do &#123;            &#x2F;&#x2F; 如果是非数字，需要加入到ls中            if ( (c &#x3D; s.charAt(i)) &lt;48 || (c &#x3D; s.charAt(i)) &gt;57 )&#123;                ls.add(&quot;&quot;+c);                i++;            &#125; else &#123;    &#x2F;&#x2F; 如果是一个数，需要考虑多位数                str &#x3D; &quot;&quot;;   &#x2F;&#x2F; 先将str置空0-9:[48]-[57]                while ( i &lt; s.length() &amp;&amp; (c &#x3D; s.charAt(i)) &gt;&#x3D;48 &amp;&amp; (c &#x3D; s.charAt(i)) &lt;&#x3D; 57)&#123;                    str +&#x3D; c;                    i++;        &#x2F;&#x2F; i后移                &#125;                ls.add(str);            &#125;        &#125; while (i&lt;s.length());        return ls;    &#125;    &#x2F;&#x2F; 将一个逆波兰表达式（后缀表达式），依次将数据和运算符放入到ArrayList中，分割字符串    public static List&lt;String&gt; getListString(String suffixExpression)&#123;        &#x2F;&#x2F; 以空格分割        String[] split &#x3D; suffixExpression.split(&quot; &quot;);        ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();        for (String ele : split) &#123;            list.add(ele);        &#125;        return list;    &#125;    &#x2F;&#x2F; 完成对逆波兰表达式的运算    &#x2F;**     * 从左至右扫描，将3和4压入堆栈；     * 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；     * 将5入栈；     * 接下来是×运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈；     * 将6入栈；     * 最后是-运算符，计算出35-6的值，即29，由此得出最终结果     *&#x2F;    public static int calculate(List&lt;String&gt; ls)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        for (String item : ls) &#123;            &#x2F;&#x2F; 这里使用正则表达式来取出数            if (item.matches(&quot;\\d+&quot;))&#123; &#x2F;&#x2F; 匹配的是多位数                stack.push(item);            &#125; else &#123;                int num2 &#x3D; Integer.parseInt(stack.pop());                int num1 &#x3D; Integer.parseInt(stack.pop());                int res &#x3D; 0;                if (item.equals(&quot;+&quot;))&#123;                    res &#x3D; num1 + num2;                &#125; else if (item.equals(&quot;-&quot;))&#123;                    res &#x3D; num1 - num2;                &#125; else if (item.equals(&quot;*&quot;))&#123;                    res &#x3D; num1 * num2;                &#125; else if (item.equals(&quot;&#x2F;&quot;))&#123;                    res &#x3D; num1 &#x2F; num2;                &#125; else &#123;                    throw new RuntimeException(&quot;运算符有误&quot;);                &#125;                &#x2F;&#x2F; 把res入栈                stack.push(&quot;&quot;+res);            &#125;        &#125;        &#x2F;&#x2F; 最后留在stack栈中的数据是运算结果        return Integer.parseInt(stack.pop());    &#125;&#125;&#x2F;&#x2F; 编写一个类，返回运算符优先级class Operation&#123;    public static int ADD &#x3D; 1;    public static int SUB &#x3D; 1;    public static int MUL &#x3D; 1;    public static int DIV &#x3D; 1;    public static int getValue(String operation)&#123;        int result &#x3D; 0;        switch (operation)&#123;            case &quot;+&quot;:                result &#x3D; ADD;                break;            case &quot;-&quot;:                result &#x3D; SUB;                break;            case &quot;*&quot;:                result &#x3D; MUL;                break;            case &quot;&#x2F;&quot;:                result &#x3D; DIV;                break;            default:                System.out.println(&quot;运算符不存在&quot;);                break;        &#125;        return result;    &#125;&#125;</code></pre></div><h3 id="5-8-逆波兰计算器完整版"><a href="#5-8-逆波兰计算器完整版" class="headerlink" title="5.8 逆波兰计算器完整版"></a>5.8 逆波兰计算器完整版</h3><h4 id="5-8-1-完整版的逆波兰计算器，功能包括"><a href="#5-8-1-完整版的逆波兰计算器，功能包括" class="headerlink" title="5.8.1 完整版的逆波兰计算器，功能包括"></a>5.8.1 完整版的逆波兰计算器，功能包括</h4><ol><li>支持 + - * / ( ) </li><li>多位数，支持小数,</li><li>兼容处理, 过滤任何空白字符，包括空格、制表符、换页符</li></ol><p>逆波兰计算器完整版考虑的因素较多，下面给出完整版代码供同学们学习，其基本思路和前面一样，也是使用到：<strong>中缀表达式转后缀表达式</strong>。</p><div class="code-wrapper"><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">package com.atguigu.stack;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Stack;import java.util.regex.Pattern;public class ReversePolishMultiCalc &#123; &#x2F;**     * 匹配 + - * &#x2F; ( ) 运算符     *&#x2F;    static final String SYMBOL &#x3D; &quot;\\+|-|\\*|&#x2F;|\\(|\\)&quot;;    static final String LEFT &#x3D; &quot;(&quot;;    static final String RIGHT &#x3D; &quot;)&quot;;    static final String ADD &#x3D; &quot;+&quot;;    static final String MINUS&#x3D; &quot;-&quot;;    static final String TIMES &#x3D; &quot;*&quot;;    static final String DIVISION &#x3D; &quot;&#x2F;&quot;;    &#x2F;**     * 加減 + -     *&#x2F;    static final int LEVEL_01 &#x3D; 1;    &#x2F;**     * 乘除 * &#x2F;     *&#x2F;    static final int LEVEL_02 &#x3D; 2;    &#x2F;**     * 括号     *&#x2F;    static final int LEVEL_HIGH &#x3D; Integer.MAX_VALUE;    static Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();    static List&lt;String&gt; data &#x3D; Collections.synchronizedList(new ArrayList&lt;String&gt;());    &#x2F;**     * 去除所有空白符     * @param s     * @return     *&#x2F;    public static String replaceAllBlank(String s )&#123;        &#x2F;&#x2F; \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]        return s.replaceAll(&quot;\\s+&quot;,&quot;&quot;);    &#125;    &#x2F;**     * 判断是不是数字 int double long float     * @param s     * @return     *&#x2F;    public static boolean isNumber(String s)&#123;        Pattern pattern &#x3D; Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;);        return pattern.matcher(s).matches();    &#125;    &#x2F;**     * 判断是不是运算符     * @param s     * @return     *&#x2F;    public static boolean isSymbol(String s)&#123;        return s.matches(SYMBOL);    &#125;    &#x2F;**     * 匹配运算等级     * @param s     * @return     *&#x2F;    public static int calcLevel(String s)&#123;        if(&quot;+&quot;.equals(s) || &quot;-&quot;.equals(s))&#123;            return LEVEL_01;        &#125; else if(&quot;*&quot;.equals(s) || &quot;&#x2F;&quot;.equals(s))&#123;            return LEVEL_02;        &#125;        return LEVEL_HIGH;    &#125;    &#x2F;**     * 匹配     * @param s     * @throws Exception     *&#x2F;    public static List&lt;String&gt; doMatch (String s) throws Exception&#123;        if(s &#x3D;&#x3D; null || &quot;&quot;.equals(s.trim())) throw new RuntimeException(&quot;data is empty&quot;);        if(!isNumber(s.charAt(0)+&quot;&quot;)) throw new RuntimeException(&quot;data illeagle,start not with a number&quot;);        s &#x3D; replaceAllBlank(s);        String each;        int start &#x3D; 0;        for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;            if(isSymbol(s.charAt(i)+&quot;&quot;))&#123;                each &#x3D; s.charAt(i)+&quot;&quot;;                &#x2F;&#x2F;栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈                if(stack.isEmpty() || LEFT.equals(each)                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;                    stack.push(each);                &#125;else if( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;&#x3D; calcLevel(stack.peek()))&#123;                    &#x2F;&#x2F;栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈                    while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;&#x3D; calcLevel(stack.peek()) )&#123;                        if(calcLevel(stack.peek()) &#x3D;&#x3D; LEVEL_HIGH)&#123;                            break;                        &#125;                        data.add(stack.pop());                    &#125;                    stack.push(each);                &#125;else if(RIGHT.equals(each))&#123;                    &#x2F;&#x2F; ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈                    while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;&#x3D; calcLevel(stack.peek()))&#123;                        if(LEVEL_HIGH &#x3D;&#x3D; calcLevel(stack.peek()))&#123;                            stack.pop();                            break;                        &#125;                        data.add(stack.pop());                    &#125;                &#125;                start &#x3D; i ;    &#x2F;&#x2F;前一个运算符的位置            &#125;else if( i &#x3D;&#x3D; s.length()-1 || isSymbol(s.charAt(i+1)+&quot;&quot;) )&#123;                each &#x3D; start &#x3D;&#x3D; 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);                if(isNumber(each)) &#123;                    data.add(each);                    continue;                &#125;                throw new RuntimeException(&quot;data not match number&quot;);            &#125;        &#125;        &#x2F;&#x2F;如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为&#x2F;，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列        Collections.reverse(stack);        data.addAll(new ArrayList&lt;&gt;(stack));        System.out.println(data);        return data;    &#125;    &#x2F;**     * 算出结果     * @param list     * @return     *&#x2F;    public static Double doCalc(List&lt;String&gt; list)&#123;        Double d &#x3D; 0d;        if(list &#x3D;&#x3D; null || list.isEmpty())&#123;            return null;        &#125;        if (list.size() &#x3D;&#x3D; 1)&#123;            System.out.println(list);            d &#x3D; Double.valueOf(list.get(0));            return d;        &#125;        ArrayList&lt;String&gt; list1 &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;            list1.add(list.get(i));            if(isSymbol(list.get(i)))&#123;                Double d1 &#x3D; doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));                list1.remove(i);                list1.remove(i-1);                list1.set(i-2,d1+&quot;&quot;);                list1.addAll(list.subList(i+1,list.size()));                break;            &#125;        &#125;        doCalc(list1);        return d;    &#125;    &#x2F;**     * 运算     * @param s1     * @param s2     * @param symbol     * @return     *&#x2F;    public static Double doTheMath(String s1,String s2,String symbol)&#123;        Double result ;        switch (symbol)&#123;            case ADD : result &#x3D; Double.valueOf(s1) + Double.valueOf(s2); break;            case MINUS : result &#x3D; Double.valueOf(s1) - Double.valueOf(s2); break;            case TIMES : result &#x3D; Double.valueOf(s1) * Double.valueOf(s2); break;            case DIVISION : result &#x3D; Double.valueOf(s1) &#x2F; Double.valueOf(s2); break;            default : result &#x3D; null;        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F;String math &#x3D; &quot;9+(3-1)*3+10&#x2F;2&quot;;        String math &#x3D; &quot;12.8 + (2 - 3.55)*4+10&#x2F;5.0&quot;;        try &#123;            doCalc(doMatch(math));        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre></div><h3 id="复盘写的逆波兰计算器代码"><a href="#复盘写的逆波兰计算器代码" class="headerlink" title="复盘写的逆波兰计算器代码"></a>复盘写的逆波兰计算器代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.stack.practice;import java.util.ArrayList;import java.util.List;import java.util.Stack;&#x2F;** * 自己完成逆波兰计算器 * 思路：中缀表达式 -&gt; 后缀表达式 -&gt; 计算 * 中缀表达式 -&gt; 后缀表达式： *      将中缀表达式转为InfixExpressionList，方便遍历 *      创建两个栈，符号栈s1，和数栈s2，遍历中缀表达式 *      当是操作数时，直接入数栈s2 *      如果是左括号时，直接入s1 *      如果是右括号，依次弹出s1栈顶的元素，直到找到左括号 *      如果是运算符，与s1的栈顶运算符比较，如果s1为空，直接入栈；如果当前运算符优先级大于s1栈顶的，直接入栈， *      如果当前的运算符小于等于s1栈顶的，将s1栈顶的运算符弹出，压进s2中，再判断 * *      处理完毕之后，将s1中剩余的运算符依次弹出加到s2中 *      最后输出s2中的数据，他的结果的逆序就是后缀表达式 * *      注意：这里需要更改一下，因为s2只做存数据，没有pop数据，所以这里将s2换成list，方便后面的遍历，不用逆序打印 * * 计算： *      定义一个逆波兰计算器 * *&#x2F;public class TestPolandNotation &#123;    public static void main(String[] args) &#123;        String infixExpression &#x3D; &quot;1+((2+3)*4)-5&quot;;        List&lt;String&gt; infixExpressionList &#x3D; toInfixExpressionList(infixExpression);        System.out.println(&quot;中缀表达式的list&#x3D;&quot;+infixExpressionList);        List&lt;String&gt; suffixExpressionList &#x3D; toSuffixExpressionList(infixExpressionList);        System.out.println(&quot;中缀转后缀的list&#x3D;&quot;+suffixExpressionList);        int result &#x3D; calculate(suffixExpressionList);        System.out.println(&quot;逆波兰的运算结果：&quot;+result); &#x2F;&#x2F; 16    &#125;    &#x2F;&#x2F; 定义一个逆波兰计算器    public static int calculate(List&lt;String&gt; ls)&#123;        Stack&lt;String&gt; stack &#x3D; new Stack&lt;&gt;();        for (String item : ls) &#123;            &#x2F;&#x2F; 如果是数字，考虑多位数            if (item.matches(&quot;\\d+&quot;))&#123;                stack.push(item);            &#125; else &#123;                &#x2F;&#x2F; 如果不是数字,pop出两个数据，                int num2 &#x3D; Integer.parseInt(stack.pop());                int num1 &#x3D; Integer.parseInt(stack.pop());                int res &#x3D; 0;                &#x2F;&#x2F; 判断运算符                if (item.equals(&quot;+&quot;))&#123;                    res &#x3D; num1 + num2;                &#125; else if (item.equals(&quot;-&quot;))&#123;                    &#x2F;&#x2F; 注意：是将后面pop出来的数据减去前一个pop出来的！！！！                    res &#x3D; num1 - num2;                &#125; else if (item.equals(&quot;*&quot;))&#123;                    res &#x3D; num1 * num2;                &#125; else if (item.equals(&quot;&#x2F;&quot;))&#123;                    res &#x3D; num1 &#x2F; num2;                &#125; else &#123;                    throw new RuntimeException(&quot;运算符有误&quot;);                &#125;                &#x2F;&#x2F; 将得到的结果压入栈                stack.push(&quot;&quot;+res);            &#125;        &#125;        &#x2F;&#x2F; 最后留在栈的数据就是运算结果        return Integer.parseInt(stack.pop());    &#125;    &#x2F;&#x2F; 将中缀表达式对应的list转为后缀表达式对应的list    public static List&lt;String&gt; toSuffixExpressionList(List&lt;String&gt; ls)&#123;        &#x2F;&#x2F; 创建栈        Stack&lt;String&gt; s1 &#x3D; new Stack&lt;&gt;();        &#x2F;&#x2F; 这里不用栈，因为不需要pop数据 用list，方便后面遍历输出        ArrayList&lt;String&gt; s2 &#x3D; new ArrayList&lt;&gt;();        for (String item : ls) &#123;            &#x2F;&#x2F; 如果是操作数            if (item.matches(&quot;\\d+&quot;))&#123;                s2.add(item);            &#125; else if (item.equals(&quot;(&quot;))&#123;                &#x2F;&#x2F; 如果是左括号                s1.push(item);            &#125; else if (item.equals(&quot;)&quot;))&#123;                &#x2F;&#x2F; 如果是右括号                while (!s1.peek().equals(&quot;(&quot;))&#123;                    &#x2F;&#x2F; 将s1中的栈顶依次弹出，并添加到s2中                    s2.add(s1.pop());                &#125;                &#x2F;&#x2F; 去掉左括号                s1.pop();            &#125; else &#123;                &#x2F;&#x2F; 如果是运算符,s1为空，直接入栈，s1不为空，当前运算符大于s1栈顶的，直接入栈，                &#x2F;&#x2F; 否则将s1栈顶弹出，并添加到s2，最后将当前符号入s1栈                while (s1.size() !&#x3D; 0 &amp;&amp; Operation.getOperation(item) &lt;&#x3D; Operation.getOperation(s1.peek()))&#123;                    s2.add(s1.pop());                &#125;                &#x2F;&#x2F; 将s1栈顶弹出，并添加到s2中                s1.push(item);            &#125;        &#125;        &#x2F;&#x2F; 最后将s1中剩余的运算符依次加到s2中        while (s1.size()&gt;0)&#123;            s2.add(s1.pop());        &#125;        &#x2F;&#x2F; 返回s2        return s2;    &#125;    &#x2F;&#x2F; 中缀表达式转为list    public static List&lt;String&gt; toInfixExpressionList(String s)&#123;        &#x2F;&#x2F; 创建一个list        ArrayList&lt;String&gt; ls &#x3D; new ArrayList&lt;&gt;();        int i &#x3D; 0;      &#x2F;&#x2F; 用于遍历的指针        String str;     &#x2F;&#x2F; 拼接多位数        char c;         &#x2F;&#x2F; 保存遍历的数据        do &#123;            &#x2F;&#x2F; 如果不是数字，直接添加进去            if ((c&#x3D;s.charAt(i))&lt;48 || (c&#x3D;s.charAt(i))&gt;57 )&#123;                ls.add(&quot;&quot;+c);                i++;    &#x2F;&#x2F; 往后移            &#125; else &#123;                &#x2F;&#x2F; 如果是数字，需要考虑多位数                str &#x3D; &quot;&quot;;   &#x2F;&#x2F; 将str置空               while (i&lt;s.length() &amp;&amp; (c &#x3D; s.charAt(i))&gt;&#x3D;48 &amp;&amp; (c&#x3D;s.charAt(i))&lt;&#x3D;57)&#123;                   str +&#x3D; c;                   &#x2F;&#x2F; 拼接完之后需要往后移                   i++;               &#125;               &#x2F;&#x2F; 添加到list中               ls.add(str);            &#125;        &#125; while (i&lt;s.length());        return ls;    &#125;&#125;&#x2F;&#x2F; 写一个返回运算符优先级的类class Operation&#123;    private static int ADD &#x3D; 1;    private static int SUB &#x3D; 1;    private static int MUL &#x3D; 2;    private static int DIV &#x3D; 2;    public static int getOperation(String operation)&#123;        int result &#x3D; 0;        switch (operation)&#123;            case &quot;+&quot;:                result &#x3D; ADD;                break;            case &quot;-&quot;:                result &#x3D; SUB;                break;            case &quot;*&quot;:                result &#x3D; MUL;                break;            case &quot;&#x2F;&quot;:                result &#x3D; DIV;                break;            default:                System.out.println(&quot;操作符有误&quot;);                break;        &#125;        return result;    &#125;&#125;</code></pre></div><h1 id="第6章-递归"><a href="#第6章-递归" class="headerlink" title="第6章 递归"></a>第6章 递归</h1><h2 id="6-1-递归应用场景"><a href="#6-1-递归应用场景" class="headerlink" title="6.1 递归应用场景"></a>6.1 递归应用场景</h2><p>看个实际应用场景，迷宫问题(回溯)， 递归(Recursion)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122115031320.png" alt="image-20211122115031320"></p><h2 id="6-2-递归的概念"><a href="#6-2-递归的概念" class="headerlink" title="6.2 递归的概念"></a>6.2 递归的概念</h2><p>简单的说: 递归就是<strong>方法自己调用自己</strong>，每次调用时传入<strong>不同的变量</strong>。递归有助于编程者<strong>解决复杂的问题</strong>，同时可以让代码变得简洁。</p><h2 id="6-3-递归调用机制"><a href="#6-3-递归调用机制" class="headerlink" title="6.3 递归调用机制"></a>6.3 递归调用机制</h2><p>我列举两个小案例,来帮助大家理解递归，部分学员已经学习过递归了，这里在给大家回顾一下<strong>递归调用机制</strong></p><ol><li><p>打印问题</p></li><li><p>阶乘问题</p></li><li><p>使用图解方式说明了递归的调用机制</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122115353251.png" alt="image-20211122115353251"></p></li><li><p>代码演示</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.Recursion;public class RecursionTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;test(4);        int result &#x3D; factorial(3);        System.out.println(&quot;result&#x3D;&quot;+result);    &#125;    &#x2F;&#x2F; 阶乘问题    public static int factorial(int n) &#123;        if (n &#x3D;&#x3D; 1) &#123;            return 1;        &#125; else &#123;            return factorial(n - 1) * n;        &#125;    &#125;    &#x2F;&#x2F; 打印    public static void test(int n) &#123;        if (n &gt; 2) &#123;            test(n - 1);        &#125; else &#123;            System.out.println(&quot;n&#x3D;&quot; + n);        &#125;    &#125;&#125;</code></pre></div></li></ol><h2 id="6-4-递归能解决什么样的问题"><a href="#6-4-递归能解决什么样的问题" class="headerlink" title="6.4 递归能解决什么样的问题"></a>6.4 递归能解决什么样的问题</h2><p>递归用于解决什么样的问题</p><ol><li>各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li><li>将用栈解决的问题–&gt;第归代码比较简洁</li></ol><h2 id="6-5-递归需要遵守的重要规则"><a href="#6-5-递归需要遵守的重要规则" class="headerlink" title="6.5 递归需要遵守的重要规则"></a>6.5 递归需要遵守的重要规则</h2><p>递归需要遵守的重要规则</p><ol><li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li><li>方法的局部变量是独立的，不会相互影响, 比如n变量</li><li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li><li>递归<strong>必须向退出递归的条件逼近</strong>，否则就是无限递归,出现StackOverflowError，死龟了:)</li><li>当一个方法执行完毕，或者遇到return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li></ol><h2 id="6-6-递归-迷宫问题"><a href="#6-6-递归-迷宫问题" class="headerlink" title="6.6  递归-迷宫问题"></a>6.6  递归-迷宫问题</h2><h3 id="6-6-1-迷宫问题"><a href="#6-6-1-迷宫问题" class="headerlink" title="6.6.1 迷宫问题"></a>6.6.1 迷宫问题</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122194805660.png" alt="image-20211122194805660"></p><h3 id="6-6-2-代码实现"><a href="#6-6-2-代码实现" class="headerlink" title="6.6.2 代码实现"></a>6.6.2 代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.Recursion;public class MiGong &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 先创建一个二维数组 8*7的 ，模拟迷宫        int[][] map &#x3D; new int[8][7];        &#x2F;&#x2F; 让第1行和第8行都设置为1        for (int i &#x3D; 0; i &lt; 7; i++) &#123;            map[0][i]&#x3D;1;            map[7][i]&#x3D;1;        &#125;        &#x2F;&#x2F; 让第1列和第7列都设置为1        for (int i &#x3D; 0;i&lt;8;i++)&#123;            map[i][0] &#x3D; 1;            map[i][6] &#x3D; 1;        &#125;        map[3][1] &#x3D; 1;        map[3][2] &#x3D; 1;        &#x2F;&#x2F; map[1][2] &#x3D; 1;        &#x2F;&#x2F; map[2][2] &#x3D; 1;        &#x2F;&#x2F; 输出迷宫        for (int i &#x3D; 0; i &lt; 8; i++) &#123;            for (int j &#x3D; 0; j &lt; 7; j++) &#123;                System.out.printf(&quot;%d\t&quot;,map[i][j]);            &#125;            System.out.println();        &#125;        &#x2F;&#x2F; setWay(map,1,1);        setWay2(map,1,1);        System.out.println(&quot;已经找到路径的迷宫：&quot;);        &#x2F;&#x2F; 输出迷宫        for (int i &#x3D; 0; i &lt; 8; i++) &#123;            for (int j &#x3D; 0; j &lt; 7; j++) &#123;                System.out.printf(&quot;%d\t&quot;,map[i][j]);            &#125;            System.out.println();        &#125;    &#125;    &#x2F;&#x2F; 1.0表示没有走过，1表示墙，2表示可以走，3表示可以走，但是走不通，回溯    &#x2F;&#x2F; 下-&gt;右-&gt;上-&gt;左    &#x2F;&#x2F; map[6][5] &#x3D; 1结束    &#x2F;**     *     * @param map   地图     * @param i     从第几行开始     * @param j     从第几列开始     * @return      有路就返回true，否则false     *&#x2F;    public static boolean setWay(int map[][],int i,int j)&#123;        &#x2F;&#x2F; 到达终点        if (map[6][5] &#x3D;&#x3D; 2)&#123;            return true;        &#125; else &#123;            &#x2F;&#x2F; 如果是0，说明没走过，可以走            if (map[i][j] &#x3D;&#x3D; 0)&#123;                &#x2F;&#x2F; 先假设他可以走                map[i][j] &#x3D; 2;                if (setWay(map, i + 1, j))&#123;         &#x2F;&#x2F; 向下走                    return true;                &#125; else if (setWay(map, i, j + 1))&#123;  &#x2F;&#x2F; 向右走                    return true;                &#125; else if (setWay(map, i - 1, j))&#123;  &#x2F;&#x2F; 向上走                    return true;                &#125; else if (setWay(map, i, j - 1))&#123;  &#x2F;&#x2F; 向左走                    return true;                &#125; else &#123;                    &#x2F;&#x2F; 都走不了，设置为3                    map[i][j] &#x3D; 3;                    return false;                &#125;            &#125; else &#123;                &#x2F;&#x2F; 如果map[i][j] !&#x3D; 0,则有1,2,3                return false;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 上，右，下，左    public static boolean setWay2(int map[][],int i,int j)&#123;        &#x2F;&#x2F; 到达终点        if (map[6][5] &#x3D;&#x3D; 2)&#123;            return true;        &#125; else &#123;            &#x2F;&#x2F; 如果是0，说明没走过，可以走            if (map[i][j] &#x3D;&#x3D; 0)&#123;                &#x2F;&#x2F; 先假设他可以走                map[i][j] &#x3D; 2;                if (setWay2(map, i - 1, j))&#123;         &#x2F;&#x2F; 向上走                    return true;                &#125; else if (setWay2(map, i, j + 1))&#123;  &#x2F;&#x2F; 向右走                    return true;                &#125; else if (setWay2(map, i + 1, j))&#123;  &#x2F;&#x2F; 向下走                    return true;                &#125; else if (setWay2(map, i, j - 1))&#123;  &#x2F;&#x2F; 向左走                    return true;                &#125; else &#123;                    &#x2F;&#x2F; 都走不了，设置为3                    map[i][j] &#x3D; 3;                    return false;                &#125;            &#125; else &#123;                &#x2F;&#x2F; 如果map[i][j] !&#x3D; 0,则有1,2,3                return false;            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="6-6-3-对迷宫问题的讨论"><a href="#6-6-3-对迷宫问题的讨论" class="headerlink" title="6.6.3 对迷宫问题的讨论"></a>6.6.3 对迷宫问题的讨论</h3><ol><li>小球得到的路径，和程序员设置的找路策略有关即：找路的<strong>上下左右</strong>的顺序相关</li><li>再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化</li><li>测试回溯现象</li><li><strong>思考</strong>: <strong>如何求出最短路径</strong>?</li></ol><h2 id="6-7-递归-八皇后问题-回溯算法）"><a href="#6-7-递归-八皇后问题-回溯算法）" class="headerlink" title="6.7 递归-八皇后问题(回溯算法）"></a>6.7 递归-八皇后问题(回溯算法）</h2><h3 id="6-7-1八皇后问题介绍"><a href="#6-7-1八皇后问题介绍" class="headerlink" title="6.7.1八皇后问题介绍"></a>6.7.1<strong>八皇后问题介绍</strong></h3><p>八皇后问题，是一个古老而著名的问题，是<strong>回溯算法的典型案例</strong>。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</strong>。92</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122200617542.png" alt="image-20211122200617542"></p><h3 id="6-7-2-八皇后问题算法思路分析"><a href="#6-7-2-八皇后问题算法思路分析" class="headerlink" title="6.7.2 八皇后问题算法思路分析"></a>6.7.2 <strong>八皇后问题算法思路分析</strong></h3><ol><li><p>第一个皇后先放第一行第一列</p></li><li><p>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</p></li><li><p>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</p></li><li><p>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</p></li><li><p>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 【示意图】</p></li><li><p>示意图</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211122201723176.png" alt="image-20211122201723176"></p></li></ol><p><strong>说明</strong>：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p><h3 id="6-7-3-八皇后问题算法代码实现"><a href="#6-7-3-八皇后问题算法代码实现" class="headerlink" title="6.7.3 八皇后问题算法代码实现"></a>6.7.3 八皇后问题算法代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.Recursion;public class Queue8 &#123;    &#x2F;&#x2F; 定义一个max，共有多少个皇后    int max &#x3D; 8;    &#x2F;&#x2F; 定义数组array，保存皇后放置位置的结果，如arr&#x3D;&#123;0,4,7,5,2,6,1,3&#125;    int[] array &#x3D; new int[max];    &#x2F;&#x2F; 统计有多少个方法    static int count &#x3D; 0;    &#x2F;&#x2F; 统计判断了多少次    static int judgeCount &#x3D; 0;    public static void main(String[] args) &#123;        long start &#x3D; System.currentTimeMillis();        Queue8 queue8 &#x3D; new Queue8();        queue8.check(0);        long end &#x3D; System.currentTimeMillis();        System.out.printf(&quot;一共有 %d 个方法\n&quot;,count);        &#x2F;&#x2F; 92种        System.out.printf(&quot;一共判断了 %d 次\n&quot;,judgeCount);   &#x2F;&#x2F;15720次        System.out.println(&quot;一共耗时（毫秒）：&quot;+(end-start));    &#125;    &#x2F;&#x2F; 放置第n个皇后    &#x2F;&#x2F; 注意：check是每一次递归是，进入到check中都有  for (int i &#x3D; 0; i &lt;max; i++) 因此会有回溯    private void check(int n)&#123;        &#x2F;&#x2F; n&#x3D;8的时候说明已经是第9个了，已经全部放完了        if (n &#x3D;&#x3D; max)&#123;            printf();            return;        &#125;        &#x2F;&#x2F; 如果还没到第8个，继续遍历，放置皇后        &#x2F;&#x2F; 需要遍历max次，即8行        for (int i &#x3D; 0; i &lt;max; i++) &#123;            &#x2F;&#x2F; 先把第一个皇后n，放在该行的第一列            array[n] &#x3D; i;            &#x2F;&#x2F; 判断当前放置的第n个皇后到i列时，是否冲突            if (judge(n))&#123;                &#x2F;&#x2F; 如果不冲突，就放置下一个，进行递归                check(n + 1);            &#125;            &#x2F;&#x2F; 如果冲突了，就会i++, 接着运行array[n] &#x3D; i;，将该皇后移去下一位置（列）        &#125;    &#125;    &#x2F;&#x2F; 检查放置的第n个皇后是否和前面的 i个冲突    &#x2F;&#x2F; 同一斜线，同一列    &#x2F;**     *     * @param n     放置的第n个皇后     * @return      如果不冲突，放回true，否则返回false     *&#x2F;    private boolean judge(int n)&#123;        judgeCount++;        &#x2F;&#x2F; 判断第n个皇后之前        for (int i &#x3D; 0; i &lt; n; i++) &#123;            &#x2F;&#x2F; array[i] &#x3D;&#x3D; array[n]：如果同一列            &#x2F;&#x2F; Math.abs(n - i) &#x3D;&#x3D; Math.abs(array[n] - array[i]):在同一斜线上，            &#x2F;&#x2F; 行与行相减的绝对值，列与列相减的绝对值，如果两者相等，则同一斜线上            if (array[i] &#x3D;&#x3D; array[n] || Math.abs(n - i) &#x3D;&#x3D; Math.abs(array[n] - array[i]))&#123;                return false;            &#125;        &#125;        &#x2F;&#x2F; 因为每一行只放一个皇后，放完之后就会n+1，所以在这里不存在同一行        return true;    &#125;    &#x2F;&#x2F; 遍历数组    private void printf()&#123;        count++;        for (int i &#x3D; 0; i &lt; array.length; i++) &#123;            System.out.print(array[i]+&quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre></div><h1 id="第7章-排序算法"><a href="#第7章-排序算法" class="headerlink" title="第7章 排序算法"></a>第7章 排序算法</h1><h2 id="7-1-排序算法的介绍"><a href="#7-1-排序算法的介绍" class="headerlink" title="7.1 排序算法的介绍"></a>7.1 排序算法的介绍</h2><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p><h2 id="7-2-排序的分类："><a href="#7-2-排序的分类：" class="headerlink" title="7.2 排序的分类："></a>7.2 <strong>排序的分类：</strong></h2><ol><li><p>内部排序:</p><p>指将需要处理的所有数据都加载到内部存储器中进行排序。</p></li><li><p>外部排序法：</p><p>数据量过大，无法全部加载到内 存中，需要借助外部存储进行排序。</p></li><li><p>常见的排序算法分类(见右图):</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123111932947.png" alt="image-20211123111932947"></p><h2 id="7-3-算法的时间复杂度"><a href="#7-3-算法的时间复杂度" class="headerlink" title="7.3 算法的时间复杂度"></a>7.3 算法的时间复杂度</h2><h3 id="7-3-1-度量一个程序-算法-执行时间的两种方法"><a href="#7-3-1-度量一个程序-算法-执行时间的两种方法" class="headerlink" title="7.3.1 度量一个程序(算法)执行时间的两种方法"></a>7.3.1 度量一个程序(算法)执行时间的两种方法</h3><ol><li><p>事后统计的方法</p><p>这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, <strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快</strong>。</p></li><li><p>事前估算的方法<br> 通过分析某个算法的<strong>时间复杂度</strong>来判断哪个算法更优.</p></li></ol><h3 id="7-3-2-时间频度"><a href="#7-3-2-时间频度" class="headerlink" title="7.3.2 时间频度"></a>7.3.2 时间频度</h3><ul><li><p>基本介绍</p><p><strong>时间频度</strong>：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为T(n)。[举例说明]</p></li><li><p>举例说明-基本案例</p><p>比如计算1-100所有数字之和, 我们设计两种算法：</p></li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153104575.png" alt="image-20211123153104575"></p><ul><li>举例说明-忽略常数项</li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153150269.png" alt="image-20211123153150269"></p><p>结论: </p><ol><li>2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略</li><li>3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略</li></ol><ul><li>举例说明-忽略低次项</li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153256460.png" alt="image-20211123153256460"></p><p>结论: </p><ol><li>2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10</li><li>n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ol><ul><li>举例说明-忽略系数</li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153343925.png" alt="image-20211123153343925"></p><p>结论: </p><ol><li>随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略。</li><li>而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键</li></ol><h3 id="7-3-3-时间复杂度"><a href="#7-3-3-时间复杂度" class="headerlink" title="7.3.3  时间复杂度"></a>7.3.3  时间复杂度</h3><ol><li>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</li><li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li><li>计算时间复杂度的方法：<ul><li>用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></li></ol><h3 id="7-3-4-常见的时间复杂度"><a href="#7-3-4-常见的时间复杂度" class="headerlink" title="7.3.4 常见的时间复杂度"></a>7.3.4 <strong>常见的时间复杂度</strong></h3><ol><li>常数阶O(1)</li><li>对数阶O(log2n)</li><li>线性阶O(n)</li><li>线性对数阶O(nlog2n)</li><li>平方阶O(n^2)</li><li>立方阶O(n^3)</li><li>k次方阶O(n^k)</li><li>指数阶O(2^n)</li></ol><p><strong>常见的时间复杂度对应的图</strong>：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153842058.png" alt="image-20211123153842058"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123153957059.png" alt="image-20211123153957059"></p><ol><li><p>常数阶O(1)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154048580.png" alt="image-20211123154048580"></p></li><li><p>对数阶O(log2n)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154142267.png" alt="image-20211123154142267"></p></li><li><p>线性阶O(n)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154218149.png" alt="image-20211123154218149"></p></li><li><p>线性对数阶O(nlogN)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154252592.png" alt="image-20211123154252592"></p></li><li><p>平方阶O(n²)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154400143.png" alt="image-20211123154400143"></p></li><li><p>立方阶O(n³)<strong>、</strong>K次方阶O(n^k)</p><p><strong>说明</strong>：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似</p></li></ol><h3 id="7-3-5-平均时间复杂度和最坏时间复杂度"><a href="#7-3-5-平均时间复杂度和最坏时间复杂度" class="headerlink" title="7.3.5 平均时间复杂度和最坏时间复杂度"></a>7.3.5 平均时间复杂度和最坏时间复杂度</h3><ol><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123154515184.png" alt="image-20211123154515184"></p><h2 id="7-4-算法的空间复杂度简介"><a href="#7-4-算法的空间复杂度简介" class="headerlink" title="7.4 算法的空间复杂度简介"></a>7.4 算法的空间复杂度简介</h2><h3 id="7-4-1基本介绍"><a href="#7-4-1基本介绍" class="headerlink" title="7.4.1基本介绍"></a>7.4.1<strong>基本介绍</strong></h3><ol><li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li><li>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。<strong>从用户使用体验上看，更看重的程序执行的速度</strong>。一些缓存产品(redis, memcache)和算法(基数排序)<strong>本质就是用空间换时间</strong>.</li></ol><h2 id="7-5-冒泡排序"><a href="#7-5-冒泡排序" class="headerlink" title="7.5  冒泡排序"></a>7.5  冒泡排序</h2><h3 id="7-5-1基本介绍"><a href="#7-5-1基本介绍" class="headerlink" title="7.5.1基本介绍"></a>7.5.1<strong>基本介绍</strong></h3><p>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换</strong>，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><p>优化：</p><p>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序</strong>，因此要在排序过程中设置</p><p>一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)</p><h3 id="7-5-2-演示冒泡过程的例子（图解）"><a href="#7-5-2-演示冒泡过程的例子（图解）" class="headerlink" title="7.5.2 演示冒泡过程的例子（图解）"></a>7.5.2 演示冒泡过程的例子（图解）</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211123184420297.png" alt="image-20211123184420297"></p><p>小结冒泡排序规则</p><p>(1) 一共进行 数组的大小-1 次 大的循环</p><p>(2)每一趟排序的次数在逐渐的减少</p><p>(3) 如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</p><h3 id="7-5-3-冒泡排序应用实例"><a href="#7-5-3-冒泡排序应用实例" class="headerlink" title="7.5.3 冒泡排序应用实例"></a>7.5.3 <strong>冒泡排序应用实例</strong></h3><p>我们举一个具体的案例来说明冒泡法。我们将五个无序的数：**3, 9, -1, 10, -2 **使用冒泡排序法将其排成一个从小到大的有序数列。</p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class BubbleSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 定义一个数组        &#x2F;&#x2F; int[] arr &#x3D; &#123;3, 9, -1, 10, -2&#125;;        &#x2F;&#x2F; int[] arr &#x3D; &#123;3, 9, -1, 10, 20&#125;;        int [] arr &#x3D; new int[80000];        &#x2F;&#x2F; 测试：排序80000个数据的数组需要多长时间        for (int i &#x3D; 0; i &lt; 80000; i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);       &#x2F;&#x2F; [0,80000)的随机数字        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String date1Str &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;开始排序前时间：&quot;+date1Str);        bubbleSort(arr);        &#x2F;&#x2F;System.out.println(Arrays.toString(arr));        Date date2 &#x3D; new Date();        String date2Str &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;开始排序后时间：&quot;+date2Str);    &#x2F;&#x2F; 约10秒      &#x2F;*  &#x2F;&#x2F; 临时变量        int temp &#x3D; 0;        boolean flag &#x3D; false;   &#x2F;&#x2F; 判断是否执行过        &#x2F;&#x2F; 可以理解为第几大趟        for (int i &#x3D; 0; i&lt;arr.length -1; i++)&#123;            &#x2F;&#x2F; 每遍历一趟，遍历次数就少一次            for (int j &#x3D; 0; j&lt;arr.length - 1 -i; j++)&#123;                &#x2F;&#x2F; 如果当前的数，比后面一个的要大，则交换位置                if (arr[j]&gt;arr[j+1])&#123;                    flag &#x3D; true;                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+1];                    arr[j+1] &#x3D; temp;                &#125;            &#125;            if (!flag)&#123;     &#x2F;&#x2F; 如果flag&#x3D;&#x3D; false，说明没有进行排序，则直接放回                break;            &#125; else &#123;                &#x2F;&#x2F; 如果进行排序了，需要将flag置为false                flag &#x3D; false;            &#125;            System.out.println(&quot;第&quot;+(i+1)+&quot;次遍历结果为：&quot;+Arrays.toString(arr));        &#125;*&#x2F;        &#x2F;&#x2F; 以下为推到过程       &#x2F;* &#x2F;&#x2F; 第二趟        for (int i &#x3D; 0; i &lt; array.length -1 -1; i++)&#123;            &#x2F;&#x2F; 如果前面的数，比后面一个要大，则将前面的数放到后面            if (array[i]&gt;array[i+1])&#123;                temp &#x3D; array[i];                array[i] &#x3D; array[i+1];                array[i+1] &#x3D; temp;            &#125;        &#125;        System.out.println(&quot;第二趟排序的结果：&quot;+ Arrays.toString(array));        &#x2F;&#x2F; 第三趟        for (int i &#x3D; 0; i &lt; array.length -1 -2; i++)&#123;            &#x2F;&#x2F; 如果前面的数，比后面一个要大，则将前面的数放到后面            if (array[i]&gt;array[i+1])&#123;                temp &#x3D; array[i];                array[i] &#x3D; array[i+1];                array[i+1] &#x3D; temp;            &#125;        &#125;        System.out.println(&quot;第三趟排序的结果：&quot;+ Arrays.toString(array));        &#x2F;&#x2F; 第四趟        for (int i &#x3D; 0; i &lt; array.length -1 -3; i++)&#123;            &#x2F;&#x2F; 如果前面的数，比后面一个要大，则将前面的数放到后面            if (array[i]&gt;array[i+1])&#123;                temp &#x3D; array[i];                array[i] &#x3D; array[i+1];                array[i+1] &#x3D; temp;            &#125;        &#125;        System.out.println(&quot;第四趟排序的结果：&quot;+ Arrays.toString(array));*&#x2F;    &#125;    &#x2F;&#x2F; 将冒泡排序抽取出来    public static void bubbleSort(int[] arr)&#123;        &#x2F;&#x2F; 定义一个变量        int temp &#x3D; 0;        &#x2F;&#x2F; 为了优化定义一个变量用作判断是否有交换        boolean flag &#x3D; false;        &#x2F;&#x2F; 进行第几趟排序        for (int i &#x3D; 0; i&lt;arr.length - 1; i++)&#123;            &#x2F;&#x2F; 在该趟中，比较多少次            for (int j &#x3D; 0; j&lt;arr.length - 1 - i; j++)&#123;                &#x2F;&#x2F; 如果当前的数，比后面一个要大，则交换位置                if (arr[j]&gt;arr[j+1])&#123;                    flag &#x3D; true;        &#x2F;&#x2F; 如果有交换                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+1];                    arr[j+1] &#x3D; temp;                &#125;            &#125;            if (!flag)&#123;         &#x2F;&#x2F; flag &#x3D;&#x3D; false                break;          &#x2F;&#x2F; 如果没有交换，直接退出            &#125; else &#123;                flag &#x3D; false;   &#x2F;&#x2F; 如果有交换，则将flag置成false            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="复盘冒泡排序完整的代码"><a href="#复盘冒泡排序完整的代码" class="headerlink" title="复盘冒泡排序完整的代码"></a>复盘冒泡排序完整的代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 完整冒泡排序public class TestBubbleSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 定义数组        int [] arr &#x3D; &#123; 3, 9, -1, 10, 20&#125;;        &#x2F;&#x2F; 定义临时变量        int temp &#x3D; 0;        &#x2F;&#x2F; 判断是否有发生交换        boolean flag &#x3D; false;        &#x2F;&#x2F; 第几趟        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;            &#x2F;&#x2F; 该趟中，交换多少次            for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;                if (arr[j]&gt;arr[j+1])&#123;                    flag &#x3D; true;           &#x2F;&#x2F; 如果发生交换                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+1];                    arr[j+1] &#x3D; temp;                &#125;            &#125;            if (!flag)&#123;                    &#x2F;&#x2F; 既flag &#x3D;&#x3D; false，没有交换                break;            &#125; else &#123;                flag &#x3D; false;              &#x2F;&#x2F; 如果发生了交换，重置flag            &#125;        &#125;        System.out.println(&quot;排序结果为：&quot;+ Arrays.toString(arr));    &#125;&#125;</code></pre></div><h2 id="7-6-选择排序"><a href="#7-6-选择排序" class="headerlink" title="7.6 选择排序"></a>7.6 选择排序</h2><h3 id="7-6-1-基本介绍"><a href="#7-6-1-基本介绍" class="headerlink" title="7.6.1 基本介绍"></a>7.6.1 基本介绍</h3><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p><h3 id="7-6-2-选择排序思想"><a href="#7-6-2-选择排序思想" class="headerlink" title="7.6.2 选择排序思想:"></a>7.6.2 选择排序思想:</h3><p>选择排序（select sorting）也是一种简单的排序方法。它的<strong>基本思想</strong>是：第一次从arr[0]<del>arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]</del>arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]<del>arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]</del>arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p><h3 id="7-6-3-选择排序思路分析图"><a href="#7-6-3-选择排序思路分析图" class="headerlink" title="7.6.3  选择排序思路分析图:"></a>7.6.3  选择排序思路分析图:</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211124204836373.png" alt="image-20211124204836373"></p><p>对一个数组的选择排序再进行讲解</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211124204943796.png" alt="image-20211124204943796"></p><h3 id="7-6-4-选择排序应用实例"><a href="#7-6-4-选择排序应用实例" class="headerlink" title="7.6.4 选择排序应用实例:"></a>7.6.4 选择排序应用实例:</h3><p>有一群牛 <strong>,</strong> 颜值分别是 101, 34, 119, 1 请使用选择排序从低到高进行排序 <strong>[<strong>101, 34, 119, 1</strong>]</strong> 说明: 测试效率的数据 80000，看耗时</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211124205041930.png" alt="image-20211124205041930"></p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class SelectSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; int[] arr &#x3D; &#123;3,65,4,14&#125;;        int[] arr &#x3D; new int[80000];        for (int i &#x3D; 0;i&lt;80000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        selectSort(arr);        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序前的时间：&quot;+dateStr2);         &#x2F;&#x2F; 相差2秒        &#x2F;*System.out.println(&quot;选择排序前的数组：&quot;+Arrays.toString(arr));        selectSort(arr);        System.out.println(&quot;选择排序后的数组：&quot;+Arrays.toString(arr));*&#x2F;    &#125;    &#x2F;&#x2F; 选择排序    public static void selectSort(int [] arr)&#123;        &#x2F;&#x2F; 只需要走arr.length -1 趟，最后一个数不用排序        for (int i &#x3D; 0; i &lt; arr.length -1; i++) &#123;            &#x2F;&#x2F; 定义一个最小值索引            int minIndex &#x3D; i;            &#x2F;&#x2F; 假设第一个为最小的            int min &#x3D; arr[i];            &#x2F;&#x2F; 从第二个开始比较，找到最小值            for (int j &#x3D; i + 1; j &lt; arr.length; j++)&#123;                &#x2F;&#x2F; 判断第一个和第二个的大小，并记录了当前位置                if (min &gt;arr[j])&#123;     &#x2F;&#x2F; 说明第一个比第二个大，则将最小的值赋值给min，并重置minIndex                    min &#x3D; arr[j];                    minIndex &#x3D; j;                &#125;            &#125;            &#x2F;&#x2F; 交换位置，将最小的放到第一位            if (minIndex !&#x3D; i)&#123;                arr[minIndex] &#x3D; arr[i];                arr[i] &#x3D; min;            &#125;        &#125;       &#x2F;* &#x2F;&#x2F; 定义一个最小值索引        int minIndex &#x3D; 0;        &#x2F;&#x2F; 假设第一个为最小的        int min &#x3D; arr[0];        &#x2F;&#x2F; 从第二个开始比较，找到最小值        for (int j &#x3D; 0 + 1; j &lt; arr.length; j++)&#123;            &#x2F;&#x2F; 判断第一个和第二个的大小，并记录了当前位置            if (min &gt;arr[j])&#123;     &#x2F;&#x2F; 说明第一个比第二个大，则将最小的值赋值给min，并重置minIndex                min &#x3D; arr[j];                minIndex &#x3D; j;            &#125;        &#125;        &#x2F;&#x2F; 交换位置，将最小的放到第一位        arr[minIndex] &#x3D; arr[0];        arr[0] &#x3D; min;        System.out.println(&quot;第一个排序结果为：&quot;+ Arrays.toString(arr));        minIndex &#x3D; 1;        min &#x3D; arr[1];        for (int j &#x3D; 1 + 1; j&lt;arr.length; j++)&#123;            if (min&gt; arr[j])&#123;                min &#x3D; arr[j];                minIndex &#x3D;j;            &#125;        &#125;        arr[minIndex] &#x3D; arr[1];        arr[1] &#x3D; min;        System.out.println(&quot;第二个排序结果为：&quot;+ Arrays.toString(arr));        minIndex &#x3D; 2;        min &#x3D; arr[2];        for (int j &#x3D; 2 + 1; j&lt;arr.length; j++)&#123;            if (min&gt; arr[j])&#123;                min &#x3D; arr[j];                minIndex &#x3D;j;            &#125;        &#125;        if (minIndex !&#x3D; 2)&#123;            arr[minIndex] &#x3D; arr[2];            arr[2] &#x3D; min;        &#125;        System.out.println(&quot;第三个排序结果为：&quot;+ Arrays.toString(arr));*&#x2F;    &#125;&#125;</code></pre></div><h3 id="选择排序复盘代码"><a href="#选择排序复盘代码" class="headerlink" title="选择排序复盘代码"></a>选择排序复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;public class TestSelectSort &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1,121,-21,1,14541,2341,0&#125;;        &#x2F;&#x2F; 从索引为0开始比较第一趟，比较的次数为数组的长度 -1        for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;            &#x2F;&#x2F; 假设当前的索引为最小的索引            int minIndex &#x3D; i;            &#x2F;&#x2F; 假设当前的值为最小的值            int min &#x3D; arr[i];            &#x2F;&#x2F; 将第i个值后面的依次进行比较            for (int j &#x3D; i+1; j &lt; arr.length; j++) &#123;                if (min &gt; arr[j])&#123;                    min &#x3D; arr[j];                    minIndex &#x3D; j;                &#125;            &#125;            &#x2F;&#x2F; 优化：如果当前的值不相等，则先将最小的放到i位置上，如果相等，则不需再换位，已经在最小的位置上了            if (minIndex !&#x3D; i)&#123;                arr[minIndex] &#x3D; arr[i];                arr[i] &#x3D; min;            &#125;        &#125;        System.out.println(&quot;排序后的数组为：&quot;+ Arrays.toString(arr));    &#125;&#125;</code></pre></div><h2 id="7-7-插入排序"><a href="#7-7-插入排序" class="headerlink" title="7.7 插入排序"></a>7.7 插入排序</h2><h3 id="7-7-1-插入排序法介绍"><a href="#7-7-1-插入排序法介绍" class="headerlink" title="7.7.1 插入排序法介绍:"></a>7.7.1 插入排序法介绍:</h3><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p><h3 id="7-7-2-插入排序法思想"><a href="#7-7-2-插入排序法思想" class="headerlink" title="7.7.2 插入排序法思想:"></a>7.7.2 插入排序法思想:</h3><p>插入排序（Insertion Sorting）的基本思想是：<strong>把n个待排序的元素看成为一个有序表和一个无序表</strong>，开始时<strong>有序表中只包含一个元素</strong>，<strong>无序表中包含有n-1个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><h3 id="7-7-3-插入排序思路图"><a href="#7-7-3-插入排序思路图" class="headerlink" title="7.7.3  插入排序思路图:"></a>7.7.3  插入排序思路图:</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211124234419890.png" alt="image-20211124234419890"></p><h3 id="7-7-4-插入排序法应用实例"><a href="#7-7-4-插入排序法应用实例" class="headerlink" title="7.7.4 插入排序法应用实例:"></a>7.7.4 插入排序法应用实例:</h3><p>有一群小牛, 考试成绩分别是 101, 34, 119, 1  请从小到大排序</p><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;&#x2F;&#x2F; 直接插入排序，将第一个为有序的，后面的为无序的public class InsertSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int[] arr &#x3D; &#123;100,33,46,74,2,646,4,74,4,9,-1,-38&#125;;        int[] arr &#x3D; new int[80000];        for (int i &#x3D; 0;i&lt;80000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        insertSort(arr);        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序后的时间：&quot;+dateStr2);         &#x2F;&#x2F; 相差1秒    &#125;    public static void insertSort(int[] arr)&#123;        for (int i &#x3D; 1; i &lt; arr.length; i++)&#123;            int insertVal &#x3D; arr[i];            int insertIndex &#x3D; i - 1;            while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex])&#123;                arr[insertIndex + 1] &#x3D;arr[insertIndex];                insertIndex--;            &#125;            arr[insertIndex + 1] &#x3D; insertVal;            &#x2F;&#x2F; System.out.println(&quot;第&quot;+i+&quot;次排序结果为：&quot;+Arrays.toString(arr));        &#125;        &#x2F;*&#x2F;&#x2F; 第一轮        int insertVal &#x3D; arr[1];        int insertIndex &#x3D; 1 - 1;        &#x2F;&#x2F; insertIndex &gt;&#x3D; 0 :防止下标越界        &#x2F;&#x2F; insertVal &lt; arr[insertIndex]：无序表的第一个如果小于前面一个，则说明没找到位置，        while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;            &#x2F;&#x2F; 没有找到位置，则将arr[insertIndex]的向后移            arr[insertIndex + 1] &#x3D; arr[insertIndex];            &#x2F;&#x2F; 索引减一            insertIndex--;        &#125;        &#x2F;&#x2F; 如果这时是第一个元素了，insertIndex--之后就等于-1，insertIndex&lt;0了，找到位置了，直接插入        &#x2F;&#x2F; 但是，索引需要加一        arr[insertIndex + 1] &#x3D; insertVal;        System.out.println(&quot;第一次排序的结果为：&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第二轮        insertVal &#x3D; arr[2];        insertIndex &#x3D; 2 - 1;        &#x2F;&#x2F; insertIndex &gt;&#x3D; 0 :防止下标越界        &#x2F;&#x2F; insertVal &lt; arr[insertIndex]：无序表的第一个如果小于前面一个，则说明没找到位置，        while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;            &#x2F;&#x2F; 没有找到位置，则将arr[insertIndex]的向后移            arr[insertIndex + 1] &#x3D; arr[insertIndex];            &#x2F;&#x2F; 索引减一            insertIndex--;        &#125;        &#x2F;&#x2F; 如果这时是第一个元素了，insertIndex--之后就等于-1，insertIndex&lt;0了，找到位置了，直接插入        &#x2F;&#x2F; 但是，索引需要加一        arr[insertIndex + 1] &#x3D; insertVal;        System.out.println(&quot;第二次排序的结果为：&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第三轮        insertVal &#x3D; arr[3];        insertIndex &#x3D; 3 - 1;        &#x2F;&#x2F; insertIndex &gt;&#x3D; 0 :防止下标越界        &#x2F;&#x2F; insertVal &lt; arr[insertIndex]：无序表的第一个如果小于前面一个，则说明没找到位置，        while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;            &#x2F;&#x2F; 没有找到位置，则将arr[insertIndex]的向后移            arr[insertIndex + 1] &#x3D; arr[insertIndex];            &#x2F;&#x2F; 索引减一            insertIndex--;        &#125;        &#x2F;&#x2F; 如果这时是第一个元素了，insertIndex--之后就等于-1，insertIndex&lt;0了，找到位置了，直接插入        &#x2F;&#x2F; 但是，索引需要加一        arr[insertIndex + 1] &#x3D; insertVal;        System.out.println(&quot;第三次排序的结果为：&quot;+ Arrays.toString(arr));*&#x2F;    &#125;&#125;</code></pre></div><h3 id="复盘插入排序代码"><a href="#复盘插入排序代码" class="headerlink" title="复盘插入排序代码"></a>复盘插入排序代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 测试插入排序public class TestInsertSort &#123;    public static void main(String[] args) &#123;        int [] arr &#x3D; &#123;64,22,2,56,-1,36,4,777,5&#125;;        &#x2F;&#x2F; 定义待插入的数        int insertVal &#x3D; 0;        &#x2F;&#x2F; arr[i]前面一个数的下标（索引）        int insertIndex &#x3D; 0;        &#x2F;&#x2F; 从无序表的第一个，开始第i轮排序        for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;            &#x2F;&#x2F; 要插入的值            insertVal &#x3D; arr[i];            &#x2F;&#x2F; arr[i]前面一个数的下标（索引）            insertIndex &#x3D; i - 1;            &#x2F;&#x2F; 给insertVal找到要插入的位置            while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex])&#123;                arr[insertIndex + 1] &#x3D; arr[insertIndex];                insertIndex--;            &#125;            &#x2F;&#x2F; 如果不满足上面的条件，就说明已经找到位置了            &#x2F;&#x2F; 注意，索引应该加一，比如当insertIndex&#x3D;-1的时候，需要加一到0 的位置            &#x2F;&#x2F; 优化：先判断是否需要换位,即判断索引是否相等            if (insertIndex !&#x3D; i)&#123;                arr[insertIndex + 1] &#x3D; insertVal;            &#125;        &#125;        System.out.println(&quot;插入排序的结果为：&quot;+ Arrays.toString(arr));    &#125;&#125;</code></pre></div><h2 id="7-8-希尔排序"><a href="#7-8-希尔排序" class="headerlink" title="7.8 希尔排序"></a>7.8 希尔排序</h2><h3 id="7-8-1简单插入排序存在的问题"><a href="#7-8-1简单插入排序存在的问题" class="headerlink" title="7.8.1简单插入排序存在的问题"></a>7.8.1<strong>简单插入排序存在的问题</strong></h3><p>我们看简单的插入排序可能存在的问题.</p><p>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：</p><p>{2,3,4,5,6,6}</p><p>{2,3,4,5,5,6}</p><p>{2,3,4,4,5,6}</p><p>{2,3,3,4,5,6}</p><p>{2,2,3,4,5,6}</p><p>{1,2,3,4,5,6}</p><p><strong>结论</strong>:当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p><h3 id="7-8-2希尔排序法介绍"><a href="#7-8-2希尔排序法介绍" class="headerlink" title="7.8.2希尔排序法介绍"></a>7.8.2<strong>希尔排序法介绍</strong></h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p><h3 id="7-8-3希尔排序法基本思想"><a href="#7-8-3希尔排序法基本思想" class="headerlink" title="7.8.3希尔排序法基本思想"></a>7.8.3<strong>希尔排序法基本思想</strong></h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至1时</strong>，整个文件恰被分成一组，算法便终止</p><h3 id="7-8-4希尔排序法的示意图"><a href="#7-8-4希尔排序法的示意图" class="headerlink" title="7.8.4希尔排序法的示意图"></a>7.8.4<strong>希尔排序法的示意图</strong></h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128104420464.png" alt="image-20211128104420464"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128104437836.png" alt="image-20211128104437836"></p><h3 id="7-8-5-希尔排序法应用实例"><a href="#7-8-5-希尔排序法应用实例" class="headerlink" title="7.8.5 希尔排序法应用实例:"></a>7.8.5 <strong>希尔排序法应用实例</strong>:</h3><p>有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序. 请分别使用</p><ol><li><p>希尔排序时， 对有序序列在插入时采用<strong>交换法</strong>, 并测试排序速度.</p></li><li><p>希尔排序时， 对有序序列在插入时<strong>采用移动法</strong>, 并测试排序速度</p></li><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class ShellSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int[] arr &#x3D; &#123;8,9,1,7,2,3,5,4,6,0&#125;;        int[] arr &#x3D; new int[80000];        for (int i &#x3D; 0;i&lt;80000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        &#x2F;&#x2F;shellSort(arr);     &#x2F;&#x2F; 6~8秒        shellSort2(arr);      &#x2F;&#x2F; 1秒左右        &#x2F;&#x2F;System.out.println(&quot;希尔排序的结果为：&quot;+ Arrays.toString(arr));        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序后的时间：&quot;+dateStr2);    &#125;    &#x2F;&#x2F; 使用逐步推导的方式来编写希尔排序    &#x2F;&#x2F; 希尔排序时，对有序序列在插入是采用交换法    public static void shellSort(int [] arr)&#123;        int temp &#x3D; 0;        &#x2F;&#x2F; 根据前面的逐步分析，使用循环处理，分组        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt;0; gap &#x2F;&#x3D; 2)&#123;            for (int i &#x3D; gap; i &lt; arr.length; i++)&#123;                &#x2F;&#x2F; 遍历每组中所有的元素（共gap组，每组个元素），步长为gap                for (int j &#x3D; i - gap; j &gt;&#x3D; 0; j -&#x3D; gap)&#123;                    &#x2F;&#x2F; 如果当前元素大于加上步长后的那个元素，说明交换                    if (arr[j] &gt; arr[j+gap])&#123;                        temp &#x3D; arr[j];                        arr[j] &#x3D; arr[j+gap];                        arr[j+gap] &#x3D; temp;                    &#125;                &#125;            &#125;           &#x2F;&#x2F; System.out.println(&quot;希尔排序的结果为：&quot;+ Arrays.toString(arr));        &#125;        &#x2F;*&#x2F;&#x2F; 第一轮将10个数组分成5组        for (int i &#x3D; 5; i &lt; arr.length; i++)&#123;            &#x2F;&#x2F; 遍历每组中所有的元素（共5组，每组2个元素），步长为5            for (int j &#x3D; i - 5; j &gt;&#x3D; 0; j -&#x3D; 5)&#123;                if (arr[j] &gt; arr[j+5])&#123;                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+5];                    arr[j+5] &#x3D; temp;                &#125;            &#125;        &#125;        System.out.println(&quot;第1轮希尔排序的结果为：&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第2轮将5个数组分成2组        for (int i &#x3D; 2; i &lt; arr.length; i++)&#123;            &#x2F;&#x2F; 遍历每组中所有的元素（共5组，每组2个元素），步长为5            for (int j &#x3D; i - 2; j &gt;&#x3D; 0; j -&#x3D; 2)&#123;                if (arr[j] &gt; arr[j+2])&#123;                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+2];                    arr[j+2] &#x3D; temp;                &#125;            &#125;        &#125;        System.out.println(&quot;第2轮希尔排序的结果为：&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第3轮将2个数组分成1组        for (int i &#x3D; 1; i &lt; arr.length; i++)&#123;            &#x2F;&#x2F; 遍历每组中所有的元素（共5组，每组2个元素），步长为5            for (int j &#x3D; i - 1; j &gt;&#x3D; 0; j -&#x3D; 1)&#123;                if (arr[j] &gt; arr[j+1])&#123;                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+1];                    arr[j+1] &#x3D; temp;                &#125;            &#125;        &#125;        System.out.println(&quot;第3轮希尔排序的结果为：&quot;+ Arrays.toString(arr));*&#x2F;    &#125;    &#x2F;&#x2F; 对交换式的希尔排序进行优化--&gt; 移位法    public static void shellSort2(int[] arr)&#123;        &#x2F;&#x2F; 分组，增量gap，并逐步的缩小增量        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt;0; gap &#x2F;&#x3D; 2)&#123;            &#x2F;&#x2F; 从第gap个元素开始，逐个对其所在的组进行直接插入排序            for (int i &#x3D; gap; i&lt;arr.length; i ++)&#123;                &#x2F;&#x2F; 用直接插入排序                int j &#x3D; i;                int temp &#x3D; arr[j];                if (arr[j] &lt; arr[j -gap])&#123;                    while (j - gap &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j - gap])&#123;                        &#x2F;&#x2F; 移动                        arr[j] &#x3D; arr[j - gap];                        j -&#x3D; gap;                    &#125;                    &#x2F;&#x2F; 退出while说明已经找到了，直接移动                   arr[j] &#x3D; temp;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="希尔排序复盘代码-交换法-移位法"><a href="#希尔排序复盘代码-交换法-移位法" class="headerlink" title="希尔排序复盘代码(交换法+移位法)"></a>希尔排序复盘代码(交换法+移位法)</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 希尔排序public class TestShellSort &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;5,57,2,0,3,-1,4,6,47&#125;;        shellSort(arr);        System.out.println(&quot;希尔排序（交换法）的结果为：&quot; + Arrays.toString(arr));        shellSort2(arr);        System.out.println(&quot;希尔排序（移动法）的结果为：&quot; + Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 方式一：交换法    public static void shellSort(int[] arr)&#123;        &#x2F;&#x2F; 分组        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)&#123;            &#x2F;&#x2F; 遍历每组中所有的元素，步长为grap            for (int i &#x3D; gap; i &lt; arr.length; i++)&#123;                &#x2F;&#x2F; j为从第一个开始，即i - gap步长                for (int j &#x3D;i - gap ; j &gt;&#x3D; 0; j -&#x3D; gap)&#123;                    &#x2F;&#x2F; 判断arr[j]是否小于arr[j - grap]                    if (arr[j] &gt; arr[j + gap])&#123;                        &#x2F;&#x2F; 交换                        int temp &#x3D; arr[j + gap];                        arr[j + gap] &#x3D; arr[j];                        arr[j] &#x3D; temp;                    &#125;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 方式二：移动法，直接插入    public static void shellSort2(int[] arr)&#123;        &#x2F;&#x2F; 分组        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)&#123;            &#x2F;&#x2F; 遍历每组            for (int i &#x3D; gap; i&lt; arr.length; i++)&#123;                &#x2F;&#x2F; 遍历每组的元素，采用直接插入法                &#x2F;&#x2F; 先判断，再while循环找到位置直接插入                &#x2F;&#x2F; 直接插入法                int j &#x3D; i;                int temp &#x3D; arr[j];                if (arr[j] &lt; arr[j - gap])&#123;                    &#x2F;&#x2F; 找位置                    while (j - gap &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j -gap])&#123;                        &#x2F;&#x2F; 移动                        arr[j] &#x3D; arr[j - gap];                        j -&#x3D; gap;                    &#125;                    arr[j] &#x3D; temp;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="7-9-快速排序"><a href="#7-9-快速排序" class="headerlink" title="7.9 快速排序"></a>7.9 快速排序</h2><h3 id="7-9-1-快速排序法介绍"><a href="#7-9-1-快速排序法介绍" class="headerlink" title="7.9.1 快速排序法介绍:"></a>7.9.1 <strong>快速排序法介绍</strong>:</h3><p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，<strong>整个排序过程可以递归进行</strong>，以此达到整个数据变成有序序列</p><h3 id="7-9-2-快速排序法示意图"><a href="#7-9-2-快速排序法示意图" class="headerlink" title="7.9.2 快速排序法示意图:"></a>7.9.2 快速排序法示意图:</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128131501036.png" alt="image-20211128131501036"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128131537170.png" alt="image-20211128131537170"></p><h3 id="7-9-3-快速排序法应用实例"><a href="#7-9-3-快速排序法应用实例" class="headerlink" title="7.9.3  快速排序法应用实例:"></a>7.9.3  快速排序法应用实例:</h3><p><strong>要求</strong>: 对 [-9,78,0,23,-567,70] 进行<strong>从小到大</strong>的<br> 排序，要求使用快速排序法。【测试8w和800w】 </p><p>说明[验证分析]:</p><ol><li><p>如果取消左右递归，结果是 <strong>-9 -567 0 23 78 70</strong></p></li><li><p>如果取消右递归,结果是**-567 -9 0 23 78 70**</p></li><li><p>如果取消左递归,结果是 <strong>-9 -567 0 23 70 78</strong></p></li><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class QuickSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int[] arr &#x3D; &#123;-9,78,0,23,-567,70&#125;;        int[] arr &#x3D; new int[800000];        for (int i &#x3D; 0;i&lt;800000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        quickSort(arr,0,arr.length - 1);        &#x2F;&#x2F;System.out.println(&quot;快速排序的结果为：&quot;+ Arrays.toString(arr));        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序前的时间：&quot;+dateStr2);         &#x2F;&#x2F; 8千万，耗时9秒    &#125;    public static void quickSort(int[] arr,int left,int right)&#123;        &#x2F;&#x2F; 左下标        int l &#x3D; left;        &#x2F;&#x2F; 右下标        int r &#x3D; right;        &#x2F;&#x2F; pivot中轴值        int pivot &#x3D; arr[(left + right) &#x2F;2 ];        &#x2F;&#x2F; 临时变量，作为交换时使用        int temp &#x3D; 0;        &#x2F;&#x2F; 以中轴pivot中心，将大于pivot的放在右边，小于pivot的放在左边        while (l&lt;r)&#123;            &#x2F;&#x2F; 在pivot的左边一直找，找到大于等于pivot值，才退出            while (arr[l] &lt; pivot)&#123;                l +&#x3D; 1;     &#x2F;&#x2F; l后移            &#125;            &#x2F;&#x2F; 在pivot的右边一直找，找到小于等于pivot值，才退出            while (arr[r] &gt; pivot)&#123;                r -&#x3D; 1;     &#x2F;&#x2F; r前移            &#125;            &#x2F;&#x2F; 当l&gt;&#x3D;r时，pivot左边的已经全部小于等于pivot的值了，右边的全部都是大于等于pivot的值            if (l &gt;&#x3D; r)&#123;                break;            &#125;            &#x2F;&#x2F; 交换            temp &#x3D; arr[l];            arr[l] &#x3D; arr[r];            arr[r] &#x3D; temp;            &#x2F;&#x2F; 交换完之后，如果arr[l] &#x3D;&#x3D; pivot ，r--，前移            if (arr[l] &#x3D;&#x3D; pivot)&#123;                r -&#x3D; 1;            &#125;            &#x2F;&#x2F; 交换完之后，如果arr[r] &#x3D;&#x3D; pivot ，l--，后移            if (arr[r] &#x3D;&#x3D; pivot)&#123;                l +&#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F; 如果l &#x3D;&#x3D; r ，必须l++ ,r--,否则为出现栈溢出，右递归会出现死循环        if (l &#x3D;&#x3D; r)&#123;            l +&#x3D; 1;            r -&#x3D; 1;        &#125;        &#x2F;&#x2F; 向左递归        if (left &lt; r)&#123;            quickSort(arr,left,r);        &#125;        &#x2F;&#x2F; 向右递归        if (right &gt; l)&#123;            quickSort(arr,l,right);        &#125;    &#125;&#125;</code></pre></div></li></ol><h3 id="快速排序复盘代码"><a href="#快速排序复盘代码" class="headerlink" title="快速排序复盘代码"></a>快速排序复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;public class TestQuickSort &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;-9,78,0,23,-567,70&#125;;        quickSort(arr,0,arr.length -1);        System.out.println(&quot;arr&#x3D;&quot;+ Arrays.toString(arr));    &#125;    public static void quickSort(int[] arr , int left ,int right)&#123;        int l &#x3D; left;       &#x2F;&#x2F; 左下标        int r &#x3D; right;      &#x2F;&#x2F; 右下标        int pivot &#x3D; arr[( left + right) &#x2F; 2];   &#x2F;&#x2F; 中轴值        int temp &#x3D; 0;       &#x2F;&#x2F; 临时变量        &#x2F;&#x2F; 找到比pivot小的值放到左边，比pivot大的值放到右边        while (l&lt;r)&#123;            while (arr[l] &lt; pivot)&#123;                l +&#x3D; 1;     &#x2F;&#x2F; l后移            &#125;            while (arr[r] &gt; pivot)&#123;                r -&#x3D; 1;     &#x2F;&#x2F; r前移            &#125;            &#x2F;&#x2F; 如果l &#x3D;&#x3D; r 说明左右两边的值已经归为，退出循环            if (l &#x3D;&#x3D; r)&#123;                break;            &#125;            &#x2F;&#x2F; 交换            temp &#x3D; arr[l];            arr[l] &#x3D; arr[r];            arr[r] &#x3D; temp;            &#x2F;&#x2F; 交换完之后，如果 arr[l] &#x3D;&#x3D; pivot ,则需r--            if (arr[l] &#x3D;&#x3D; pivot)&#123;                r -&#x3D; 1;            &#125;            if (arr[r] &#x3D;&#x3D; pivot)&#123;                l +&#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F; 如果l &#x3D;&#x3D; r 了，需要将l往后移和r往前移动，否则会在右递归的时候出现死循环        if (l &#x3D;&#x3D; r)&#123;            l +&#x3D; 1;            r -&#x3D; 1;        &#125;        &#x2F;&#x2F; 左递归        if (left &lt; r) &#123;            quickSort(arr, left, r);        &#125;        &#x2F;&#x2F; 右递归        if (right &gt; l)&#123;            quickSort(arr,l,right);        &#125;    &#125;&#125;</code></pre></div><h2 id="7-10-归并排序"><a href="#7-10-归并排序" class="headerlink" title="7.10 归并排序"></a>7.10 归并排序</h2><h3 id="7-10-1-归并排序介绍"><a href="#7-10-1-归并排序介绍" class="headerlink" title="7.10.1 归并排序介绍:"></a>7.10.1 归并排序介绍:</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治（divide-and-conquer）策略</strong>（分治法将问题分(divide)成一些<strong>小的问题然后递归求解</strong>，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><h3 id="7-10-2-归并排序思想示意图1-基本思想"><a href="#7-10-2-归并排序思想示意图1-基本思想" class="headerlink" title="7.10.2 归并排序思想示意图1-基本思想:"></a>7.10.2 归并排序思想示意图1-基本思想:</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128203157177.png" alt="image-20211128203157177"></p><p><strong>说明</strong>:</p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。</p><h3 id="7-10-3-归并排序思想示意图2-合并相邻有序子序列"><a href="#7-10-3-归并排序思想示意图2-合并相邻有序子序列" class="headerlink" title="7.10.3 归并排序思想示意图2-合并相邻有序子序列:"></a>7.10.3 归并排序思想示意图2-合并相邻有序子序列:</h3><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211128203300190.png" alt="image-20211128203300190"></p><h3 id="7-10-4-归并排序的应用实例"><a href="#7-10-4-归并排序的应用实例" class="headerlink" title="7.10.4 归并排序的应用实例:"></a>7.10.4 <strong>归并排序的应用实例</strong>:</h3><p>给你一个数组,  val arr = Array(9,8,7,6,5,4,3,2,1),  请使用归并排序完成排序。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class MergeSort &#123;    public static void main(String[] args) &#123;       &#x2F;&#x2F; int [] arr &#x3D; &#123;3,6,2,1,7,5,8,4&#125;;        int[] arr &#x3D; new int[80000000];        for (int i &#x3D; 0;i&lt;80000000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        int [] temp &#x3D; new int[arr.length];        mergeSort(arr,0,arr.length - 1,temp);       &#x2F;&#x2F; System.out.println(&quot;arr&#x3D;&quot;+ Arrays.toString(arr));        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序前的时间：&quot;+dateStr2);         &#x2F;&#x2F; 8千万，耗时11秒    &#125;    &#x2F;&#x2F; 分+合方法    public static void mergeSort(int[] arr, int left,int right,int[] temp)&#123;        if (left &lt; right)&#123;            int mid &#x3D; (left + right) &#x2F; 2;   &#x2F;&#x2F; 中间索引            &#x2F;&#x2F; 向左递归进行分解            mergeSort(arr, left, mid, temp);            &#x2F;&#x2F; 向右递归进行分解            mergeSort(arr, mid + 1, right, temp);            &#x2F;&#x2F; 合并            merge(arr,left,mid,right,temp);        &#125;    &#125;    &#x2F;&#x2F; 合并的方法    &#x2F;**     *     * @param arr   排序的原数组     * @param left  左边有序序列的初始索引     * @param mid   中间索引     * @param right 右边索引     * @param temp  中转的数组     *&#x2F;    public static void merge(int [] arr , int left ,int mid, int right, int[] temp)&#123;        &#x2F;&#x2F;System.out.println(&quot;xxxx&quot;);        int i &#x3D; left;       &#x2F;&#x2F; 初始化i，左边有序序列的初始索引        int j &#x3D; mid + 1;    &#x2F;&#x2F; 初始化j，右边有序序列的初始化索引        int t &#x3D; 0;          &#x2F;&#x2F; 指向temp数组的当前索引        &#x2F;&#x2F; (一) 将左右两边的数据按照规则放到temp中，直到两边的有序序列有一边处理完毕为止        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right)&#123;            &#x2F;&#x2F; 如果左边的有序序列的当前元素小于等于右边的，则将左边的数据加到temp中            &#x2F;&#x2F; 然后 t++，i++            if (arr[i] &lt; arr[j])&#123;                temp[t] &#x3D; arr[i];                i +&#x3D; 1;                t +&#x3D; 1;            &#125; else &#123;    &#x2F;&#x2F; 反之，则将右边的加到temp中                temp[t] &#x3D; arr[j];                j +&#x3D; 1;                t +&#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F; (二) 将剩余的一边数据全部依次填充到temp中        &#x2F;&#x2F; 左边剩余        while (i &lt;&#x3D; mid)&#123;            temp[t] &#x3D; arr[i];            i +&#x3D; 1;            t +&#x3D; 1;        &#125;        &#x2F;&#x2F; 右边剩余        while (j &lt;&#x3D; right)&#123;            temp[t] &#x3D; arr[j];            j +&#x3D; 1;            t +&#x3D; 1;        &#125;        &#x2F;&#x2F; (三) 将temp中的数据copy到arr中        t &#x3D; 0;        int tempLeft &#x3D; left;        &#x2F;&#x2F; 并不是每次都是合并8个数据，最后一次才是8个数据        &#x2F;&#x2F; 第一次合并tempLeft &#x3D; 0 right &#x3D; 1,tempLeft &#x3D; 2 right &#x3D; 3        &#x2F;&#x2F; 最后一次tempLeft &#x3D; 0 right &#x3D; 7       &#x2F;&#x2F; System.out.println(&quot;tempLeft&#x3D;&quot;+tempLeft+&quot; right&#x3D;&quot;+right);        while (tempLeft &lt;&#x3D; right)&#123;            arr[tempLeft] &#x3D; temp[t];            t +&#x3D; 1;            tempLeft +&#x3D; 1;        &#125;    &#125;&#125;</code></pre></div><h3 id="复盘归并排序代码"><a href="#复盘归并排序代码" class="headerlink" title="复盘归并排序代码"></a>复盘归并排序代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 归并排序&#x2F;&#x2F; 分而治之public class TestMergeSort &#123;    public static void main(String[] args) &#123;        int [] arr &#x3D; &#123;2,5,7,4,8,6,1,0,9&#125;;        int [] temp &#x3D; new int[arr.length];        mergeSort(arr,0,arr.length - 1,temp);        System.out.println(&quot;arr&#x3D;&quot; + Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 分+合    public static void mergeSort(int [] arr ,int left ,int right,int [] temp)&#123;        if (left &lt; right)&#123;            int mid &#x3D; (left + right) &#x2F; 2;            &#x2F;&#x2F; 向左递归            mergeSort(arr, left, mid, temp);            &#x2F;&#x2F; 向右递归            mergeSort(arr, mid + 1, right, temp);            &#x2F;&#x2F; 合并            merge(arr,left,mid,right,temp);        &#125;    &#125;    &#x2F;&#x2F; 合并    public static void merge(int[] arr, int left, int mid, int right, int[] temp)&#123;        int i &#x3D; left;       &#x2F;&#x2F; 初始化左边有序序列的索引i        int j &#x3D; mid + 1;    &#x2F;&#x2F; 初始化中间索引        int t &#x3D; 0;          &#x2F;&#x2F; temp的下标        &#x2F;&#x2F; 1.将有序序列的值依次加到temp中，直到一边的有序序列处理完毕为止        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right)&#123;            &#x2F;&#x2F; 如果arr[i]的值比arr[j]的小，则将arr[i]加到temp中            if (arr[i] &lt; arr[j])&#123;                temp[t] &#x3D; arr[i];                t +&#x3D; 1;                i +&#x3D; 1;            &#125; else &#123;        &#x2F;&#x2F; 否则将arr[j]加到temp中                temp[t] &#x3D; arr[j];                t +&#x3D; 1;                j +&#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F; 2.将剩余的一边的有序序列依次加到temp中        &#x2F;&#x2F; 左边剩余        while (i &lt;&#x3D; mid)&#123;            temp[t] &#x3D; arr[i];            t +&#x3D; 1;            i +&#x3D; 1;        &#125;        &#x2F;&#x2F; 右边剩余        while (j &lt;&#x3D; right)&#123;            temp[t] &#x3D; arr[j];            t +&#x3D; 1;            j +&#x3D; 1;        &#125;        &#x2F;&#x2F; 3.将temp数组copy到arr        t &#x3D; 0;      &#x2F;&#x2F; 从第一个开始        int tempLeft &#x3D; left;    &#x2F;&#x2F; 辅助变量        while (tempLeft &lt;&#x3D; right)&#123;            arr[tempLeft] &#x3D; temp[t];            t +&#x3D; 1;            tempLeft +&#x3D; 1;        &#125;    &#125;&#125;</code></pre></div><h2 id="7-11-基数排序"><a href="#7-11-基数排序" class="headerlink" title="7.11 基数排序"></a>7.11 基数排序</h2><h3 id="7-11-1-基数排序-桶排序-介绍"><a href="#7-11-1-基数排序-桶排序-介绍" class="headerlink" title="7.11.1 基数排序(桶排序)介绍"></a>7.11.1 基数排序(桶排序)介绍</h3><ol><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li><li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ol><h3 id="7-11-2-基数排序基本思想"><a href="#7-11-2-基数排序基本思想" class="headerlink" title="7.11.2 基数排序基本思想"></a>7.11.2 基数排序基本思想</h3><ol><li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li><li>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</li></ol><h3 id="7-11-3-基数排序图文说明"><a href="#7-11-3-基数排序图文说明" class="headerlink" title="7.11.3 基数排序图文说明"></a>7.11.3 基数排序图文说明</h3><p>将数组 {53, 3, 542, 748, 14, 214 } 使用基数排序, 进行升序排序</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211129171212514.png" alt="image-20211129171212514"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211129171229440.png" alt="image-20211129171229440"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211129171309608.png" alt="image-20211129171309608"></p><h3 id="7-11-4-基数排序代码实现"><a href="#7-11-4-基数排序代码实现" class="headerlink" title="7.11.4 基数排序代码实现"></a>7.11.4 <strong>基数排序代码实现</strong></h3><p> <strong>要求：</strong>将数组 {53, 3, 542, 748, 14, 214 } 使用基数排序, 进行升序排序</p><p><strong>思路分析：</strong>前面的图文已经讲明确</p><p><strong>代码实现：</strong>看老师演示</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class RadixSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int [] arr &#x3D;  &#123;53,3,542,748,14,214&#125;;        int[] arr &#x3D; new int[8000000];        for (int i &#x3D; 0;i&lt;8000000;i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String dateStr1 &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;排序前的时间：&quot;+dateStr1);        radixSort(arr);        Date date2 &#x3D; new Date();        String dateStr2 &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;排序前的时间：&quot;+dateStr2);         &#x2F;&#x2F; 8百万，耗时1~2秒    &#125;    &#x2F;&#x2F; 基数排序方法    public static void radixSort(int[] arr)&#123;        &#x2F;&#x2F; 根据前面的推到过程，我们可以得到最终的基数排序代码        &#x2F;&#x2F; 1.得到数组中最大的数的位数        int max &#x3D; arr[0];   &#x2F;&#x2F; 假设arr[0]为最大的        &#x2F;&#x2F; 找出数组中最大的元素        for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;            if (arr[i] &gt; arr[0])&#123;                max &#x3D; arr[i];            &#125;        &#125;        &#x2F;&#x2F; 获取最大元素是几位数        int maxLength &#x3D; (max + &quot;&quot;).length();        &#x2F;&#x2F; 定义一个二维数组，表示10个捅，每个捅就是一个一维数组        &#x2F;&#x2F; 1.二维数组包含10个一维数组        &#x2F;&#x2F; 2.为了防止在放入数的时候，数据溢出，则每个一维数组（捅），大小定义为arr.length        &#x2F;&#x2F; 3.明确，基数排序是使用空间换时间的经典算法        &#x2F;&#x2F; 十个捅        int[][] bucket &#x3D; new int[10][arr.length];        &#x2F;&#x2F; 每个捅中的数据个数 bucketElementCounts[0] 记录的就是bucket[0]捅放入的数据        int[] bucketElementCounts &#x3D; new int[10];        &#x2F;&#x2F; 这里使用循环代码处理        for (int i &#x3D; 0, n &#x3D; 1; i &lt; maxLength; i++, n *&#x3D; 10)&#123;            &#x2F;&#x2F; 第i+1轮，对应的位数，第一次是个位，第二次是十位....            &#x2F;&#x2F; 往捅里面放数据            for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;                &#x2F;&#x2F; 取到个位数                int digitOfElement &#x3D; arr[j] &#x2F;n % 10;                &#x2F;&#x2F; 放到对应的捅中                bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];                bucketElementCounts[digitOfElement]++;            &#125;            &#x2F;&#x2F; 从捅里取出数据到arr中            &#x2F;&#x2F; 遍历每个捅            int index &#x3D; 0;  &#x2F;&#x2F; 辅助变量，辅助遍历数组，取出数据            for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;                &#x2F;&#x2F; 判断捅中是否有元素                if (bucketElementCounts[k] !&#x3D; 0)&#123;                    &#x2F;&#x2F; 遍历捅中的每个数据，就是bucketElementCounts[k]的个数                    for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++)&#123;                        arr[index++] &#x3D; bucket[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 置空 bucketElementCounts[k]，否则会报ArrayIndexOutOfBoundsException的错                bucketElementCounts[k] &#x3D; 0;            &#125;           &#x2F;&#x2F; System.out.println(&quot;第&quot;+(i+1)+&quot;轮基数排序结果为：arr&#x3D;&quot;+ Arrays.toString(arr));        &#125;       &#x2F;* &#x2F;&#x2F; 十个捅        int[][] bucket &#x3D; new int[10][arr.length];        &#x2F;&#x2F; 每个捅中的数据个数        int[] bucketElementCounts &#x3D; new int[10];        &#x2F;&#x2F; 第1轮，个位数        &#x2F;&#x2F; 往捅里面放数据        for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;            &#x2F;&#x2F; 取到个位数            int digitOfElement &#x3D; arr[j] % 10;            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];            bucketElementCounts[digitOfElement]++;        &#125;        &#x2F;&#x2F; 从捅里取出数据到arr中        &#x2F;&#x2F; 遍历每个捅        int index &#x3D; 0;  &#x2F;&#x2F; 辅助变量，辅助遍历数组，取出数据        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;            &#x2F;&#x2F; 判断捅中是否有元素            if (bucketElementCounts[k] !&#x3D; 0)&#123;                &#x2F;&#x2F; 遍历捅中的每个数据，就是bucketElementCounts[k]的个数                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++)&#123;                    arr[index++] &#x3D; bucket[k][l];                &#125;            &#125;            &#x2F;&#x2F; 置空 bucketElementCounts[k]，否则会报ArrayIndexOutOfBoundsException的错            bucketElementCounts[k] &#x3D; 0;        &#125;        System.out.println(&quot;第1轮基数排序结果为：arr&#x3D;&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第2轮，十位数        &#x2F;&#x2F; 往捅里面放数据        for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;            &#x2F;&#x2F; 取到个位数            int digitOfElement &#x3D; arr[j] &#x2F;10 % 10;            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];            bucketElementCounts[digitOfElement]++;        &#125;        &#x2F;&#x2F; 从捅里取出数据到arr中        &#x2F;&#x2F; 遍历每个捅        index &#x3D; 0;  &#x2F;&#x2F; 辅助变量，辅助遍历数组，取出数据        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;            &#x2F;&#x2F; 判断捅中是否有元素            if (bucketElementCounts[k] !&#x3D; 0)&#123;                &#x2F;&#x2F; 遍历捅中的每个数据，就是bucketElementCounts[k]的个数                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++)&#123;                    arr[index++] &#x3D; bucket[k][l];                &#125;            &#125;            &#x2F;&#x2F; 置空 bucketElementCounts[k]，否则会报ArrayIndexOutOfBoundsException的错            bucketElementCounts[k] &#x3D; 0;        &#125;        System.out.println(&quot;第2轮基数排序结果为：arr&#x3D;&quot;+ Arrays.toString(arr));        &#x2F;&#x2F; 第3轮，百位数        &#x2F;&#x2F; 往捅里面放数据        for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;            &#x2F;&#x2F; 取到个位数            int digitOfElement &#x3D; arr[j] &#x2F;100 % 10;            bucket[digitOfElement][bucketElementCounts[digitOfElement]] &#x3D; arr[j];            bucketElementCounts[digitOfElement]++;        &#125;        &#x2F;&#x2F; 从捅里取出数据到arr中        &#x2F;&#x2F; 遍历每个捅        index &#x3D; 0;  &#x2F;&#x2F; 辅助变量，辅助遍历数组，取出数据        for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;            &#x2F;&#x2F; 判断捅中是否有元素            if (bucketElementCounts[k] !&#x3D; 0)&#123;                &#x2F;&#x2F; 遍历捅中的每个数据，就是bucketElementCounts[k]的个数                for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++)&#123;                    arr[index++] &#x3D; bucket[k][l];                &#125;            &#125;            &#x2F;&#x2F; 置空 bucketElementCounts[k]，否则会报ArrayIndexOutOfBoundsException的错            bucketElementCounts[k] &#x3D; 0;        &#125;        System.out.println(&quot;第3轮基数排序结果为：arr&#x3D;&quot;+ Arrays.toString(arr));*&#x2F;    &#125;&#125;</code></pre></div><h3 id="7-11-5-基数排序的说明"><a href="#7-11-5-基数排序的说明" class="headerlink" title="7.11.5 基数排序的说明:"></a>7.11.5 基数排序的说明:</h3><ol><li>基数排序是对传统桶排序的扩展，速度很快.</li><li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的</li><li>有负数的数组，我们不用基数排序来进行排序,如果要支持负数，参考: <strong><a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></strong></li></ol><h3 id="复盘基数排序代码"><a href="#复盘基数排序代码" class="headerlink" title="复盘基数排序代码"></a>复盘基数排序代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 基数排序public class TestRadixSort &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;53, 3, 542, 748, 14, 214&#125;;        radixSort(arr);        System.out.println(&quot;基数排序的结果为：&quot;+ Arrays.toString(arr));    &#125;    public static void radixSort(int[] arr)&#123;        &#x2F;&#x2F; 假设第一个为最大的        int max &#x3D; arr[0];        &#x2F;&#x2F; 找到最大的元素        for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;            if (arr[i] &gt; arr[0])&#123;                max &#x3D; arr[i];            &#125;        &#125;        &#x2F;&#x2F; 最大的位数        int maxLength &#x3D; (max + &quot;&quot;).length();        &#x2F;&#x2F; 10个捅        int[][] bucket &#x3D; new int[10][arr.length];        &#x2F;&#x2F; 每个捅记录的数据        int[] bucketElementCounts &#x3D; new int[10];        for (int i &#x3D; 0, n &#x3D; 1; i &lt; maxLength; i++, n *&#x3D; 10)&#123;            &#x2F;&#x2F; 遍历数组往捅里放数据            for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;                &#x2F;&#x2F; 取到个位数，找到对应的捅                int digitElement &#x3D; arr[j] &#x2F;n % 10;                &#x2F;&#x2F; 放数据                bucket[digitElement][bucketElementCounts[digitElement]] &#x3D; arr[j];                bucketElementCounts[digitElement]++;            &#125;            &#x2F;&#x2F; 从捅里取出数据            int index &#x3D; 0;  &#x2F;&#x2F; 辅助变量，辅助将数据放到arr数组中            &#x2F;&#x2F; 遍历每个捅            for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;                &#x2F;&#x2F; 判断捅里是否有数据                if (bucketElementCounts[k] !&#x3D; 0)&#123;                    &#x2F;&#x2F; 遍历捅里的每一个数据                    for (int l &#x3D; 0; l &lt; bucketElementCounts[k]; l++)&#123;                        &#x2F;&#x2F; 这里记得index++ 否则会出错                        arr[index++] &#x3D; bucket[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 将bucketElementCounts[k]置空                bucketElementCounts[k] &#x3D; 0;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="7-12-常用排序算法总结和对比"><a href="#7-12-常用排序算法总结和对比" class="headerlink" title="7.12 常用排序算法总结和对比"></a>7.12 常用排序算法总结和对比</h2><h3 id="7-12-1-一张排序算法的比较图"><a href="#7-12-1-一张排序算法的比较图" class="headerlink" title="7.12.1 一张排序算法的比较图"></a>7.12.1 一张排序算法的比较图</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211130110255900.png" alt="image-20211130110255900"></p><h3 id="7-12-2-相关术语解释"><a href="#7-12-2-相关术语解释" class="headerlink" title="7.12.2 相关术语解释"></a>7.12.2 相关术语解释</h3><ol><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小。</li><li><strong>n:</strong> 数据规模</li><li><strong>k:</strong> “桶”的个数</li><li><strong>In-place:</strong>  不占用额外内存</li><li><strong>Out-place:</strong> 占用额外内存</li></ol><h2 id="7-13-复盘以上所学的排序代码"><a href="#7-13-复盘以上所学的排序代码" class="headerlink" title="7.13 复盘以上所学的排序代码"></a>7.13 复盘以上所学的排序代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.sort.practice;import java.util.Arrays;&#x2F;&#x2F; 回顾常见的算法public class ReviewAllSort &#123;    public static void main(String[] args) &#123;        int [] bubbleArr &#x3D; &#123;3,9,-1,10,20&#125;;        int[] arr &#x3D; &#123;101,34,119,1&#125;;       &#x2F;* bubbleSort(bubbleArr);        selectSort(arr);        insertSort(arr);        shellSort(arr);        shellSort2(arr);        quickSort(arr,0,arr.length - 1);        int[] temp &#x3D; new int[arr.length];        margeSort(arr,0,arr.length - 1,temp);        System.out.println(&quot;归并排序的结果为：&quot;+ Arrays.toString(arr));*&#x2F;       radixSort(arr);    &#125;    &#x2F;&#x2F; 基数排序（捅排序）    public static void radixSort(int[] arr)&#123;        int max &#x3D; arr[0];   &#x2F;&#x2F; 假设第一位为最大的位数        &#x2F;&#x2F; 找到最大的数        for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;            if (arr[i] &gt; max)&#123;                max &#x3D; arr[i];            &#125;        &#125;        &#x2F;&#x2F; 获取最大位数        int maxLength &#x3D; (max + &quot;&quot;).length();        &#x2F;&#x2F; 定义一个二维数组，模拟十个捅        int[][] bucket &#x3D; new int[10][arr.length];        &#x2F;&#x2F; 定义一个一维数组，记录每个捅的数据个数        int[] bucketElementCounts &#x3D; new int[10];        for (int i &#x3D; 0, n &#x3D; 1; i &lt; maxLength; i++, n *&#x3D; 10)&#123;            &#x2F;&#x2F; 第一轮，个位数            &#x2F;&#x2F; 遍历数组，拿到个位数，放到对应的捅中            for (int j &#x3D; 0; j &lt; arr.length; j++)&#123;                &#x2F;&#x2F; 取到个位数                int digitElement &#x3D; arr[j] &#x2F; n % 10;                bucket[digitElement][bucketElementCounts[digitElement]] &#x3D; arr[j];                bucketElementCounts[digitElement]++;            &#125;            &#x2F;&#x2F; 从捅里拿出数据            int index &#x3D; 0;      &#x2F;&#x2F; 指向捅的索引，方便从桶里取出数据            &#x2F;&#x2F; 遍历每个捅            for (int k &#x3D; 0; k &lt; bucketElementCounts.length; k++)&#123;                &#x2F;&#x2F; 判断捅里是否有数据                if (bucketElementCounts[k] !&#x3D; 0)&#123;                    &#x2F;&#x2F; 遍历捅里面的每一个数据，并放到arr中                    for (int l &#x3D; 0; l &lt;bucketElementCounts[k]; l++)&#123;                        arr[index++] &#x3D; bucket[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 将捅置空                bucketElementCounts[k] &#x3D; 0;            &#125;        &#125;        System.out.println(&quot;基数排序结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 归并排序    &#x2F;&#x2F; 分+合    public static void margeSort(int[] arr, int left, int right,int[] temp)&#123;        if (left &lt; right)&#123;            int mid &#x3D; (left + right) &#x2F; 2;            &#x2F;&#x2F; 向左拆分            margeSort(arr, left, mid, temp);            &#x2F;&#x2F; 向右拆分            margeSort(arr, mid + 1, right, temp);            &#x2F;&#x2F; 合并            marge(arr,left,mid,right,temp);        &#125;    &#125;    &#x2F;&#x2F; 归并排序（分而治之）    &#x2F;&#x2F; 合并    public static void marge(int[]arr , int left ,int mid, int right, int[] temp)&#123;        int i &#x3D; left;           &#x2F;&#x2F; 初始化左边有序序列的初始索引        int j &#x3D; mid + 1;        &#x2F;&#x2F; 初始化右边有序序列的索引        int t &#x3D; 0;              &#x2F;&#x2F; temp的索引        &#x2F;&#x2F; 一.将arr的数据按照规则依次放到temp中，直到一边处理完毕为止        while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right)&#123;            if (arr[i] &lt; arr[j])&#123;                temp[t] &#x3D; arr[i];                t +&#x3D; 1;                i +&#x3D; 1;            &#125; else &#123;                temp[t] &#x3D; arr[j];                t +&#x3D; 1;                j +&#x3D; 1;            &#125;        &#125;        &#x2F;&#x2F; 二.将剩余的一边的数据依次放到temp中        &#x2F;&#x2F; 左边剩余        if (i &lt;&#x3D; mid)&#123;            temp[t] &#x3D; arr[i];            t +&#x3D; 1;            i +&#x3D; 1;        &#125;        &#x2F;&#x2F; 右边剩余        if (j &lt;&#x3D; right)&#123;            temp[t] &#x3D; arr[j];            t +&#x3D; 1;            j +&#x3D; 1;        &#125;        &#x2F;&#x2F; 3.将temp的数据copy回到arr中        t &#x3D; 0;                  &#x2F;&#x2F; 从temp的第一个开始        int tempLeft &#x3D; left;    &#x2F;&#x2F; 定义一个辅助变量，方便从temp中取出数据放到arr中        while (tempLeft &lt;&#x3D; right )&#123;            arr[tempLeft] &#x3D; temp[t];            tempLeft +&#x3D; 1;            t +&#x3D; 1;        &#125;    &#125;    &#x2F;&#x2F; 快速排序: 中轴值pivot    public static void quickSort(int[]arr ,int left, int right)&#123;        int l &#x3D; left;                       &#x2F;&#x2F; 初始化左边的下标        int r &#x3D; right;                      &#x2F;&#x2F; 初始化右边的下标        int pivot &#x3D; arr[(left + right) &#x2F; 2];     &#x2F;&#x2F; 中轴值        int temp &#x3D; 0;        &#x2F;&#x2F; 以pivot为中轴，大的放在右边，小的放在左边        while (l &lt; r)&#123;            &#x2F;&#x2F; 在左边找到比pivot大的才退出循环            while (arr[l] &lt; pivot)&#123;                l +&#x3D; 1;            &#125;            &#x2F;&#x2F; 在pivot右边找到比pivot小的才退出循环            while (arr[r] &gt; pivot)&#123;                r -&#x3D; 1;            &#125;            &#x2F;&#x2F; 如果下标l大于等于r了，说明已经全部找到了，退出            if (l &gt;&#x3D; r)&#123;                break;            &#125;            &#x2F;&#x2F; 找到之后就交换            temp &#x3D; arr[l];            arr[l] &#x3D; arr[r];            arr[r] &#x3D; temp;            &#x2F;&#x2F; 交换完之后，如果一边有剩余，多的一边往对应的方向移动            if (arr[l] &#x3D;&#x3D; pivot)&#123;                r -&#x3D; 1;     &#x2F;&#x2F; 前移            &#125;            if (arr[r] &#x3D;&#x3D; pivot)&#123;                l +&#x3D; 1;     &#x2F;&#x2F; 后移            &#125;        &#125;        &#x2F;&#x2F; 如果l &#x3D;&#x3D; r，则需要移动l和r，否则右递归不正确        if (l &#x3D;&#x3D; r)&#123;            l +&#x3D; 1;            r -&#x3D; 1;        &#125;        &#x2F;&#x2F; 退出循环后，左右两边的值都已经按照规则归为，但是还不是有序的        &#x2F;&#x2F; 左递归        if (left &lt; r)&#123;            quickSort(arr, left, r);        &#125;        &#x2F;&#x2F; 右递归        if (right &gt; l)&#123;            quickSort(arr, l, right);        &#125;        System.out.println(&quot;快速排序的结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 希尔排序：除2，缩小排量    &#x2F;&#x2F; 方法一：交换法    public static void shellSort(int[] arr)&#123;        int temp &#x3D; 0;   &#x2F;&#x2F; 辅助变量        &#x2F;&#x2F; 第几轮        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)&#123;            &#x2F;&#x2F; 遍历每组（分组），步长为gap            for (int i &#x3D; gap; i &lt; arr.length; i++)&#123;                &#x2F;&#x2F; 遍历每组的所有数据                for (int j &#x3D; i - gap; j &gt;&#x3D; 0; j -&#x3D; gap)&#123;                    &#x2F;&#x2F; 比较两个数                    if (arr[j] &gt; arr[j + gap])&#123;                        &#x2F;&#x2F; 交换                        temp &#x3D; arr[j];                        arr[j] &#x3D; arr[j+gap];                        arr[j+gap] &#x3D; temp;                    &#125;                &#125;            &#125;        &#125;        System.out.println(&quot;希尔排序方法一（交换法）的结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 希尔排序    &#x2F;&#x2F; 方法二：移位法（直接插入）    public static void shellSort2(int[] arr)&#123;        &#x2F;&#x2F; 第几轮        for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2)&#123;            &#x2F;&#x2F; 分组            for (int i &#x3D; gap; i &lt; arr.length; i++)&#123;                int j &#x3D; i;          &#x2F;&#x2F; 要插入的下标                int temp &#x3D; arr[j];  &#x2F;&#x2F; 要插入的值                &#x2F;&#x2F; 遍历每个组所有的数据，找到要插入的位置                while (j - gap &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j-gap])&#123;                    arr[j] &#x3D; arr[j - gap];                    j -&#x3D; gap;                &#125;                &#x2F;&#x2F; 退出之后就找到了，交换                arr[j] &#x3D; temp;            &#125;        &#125;        System.out.println(&quot;希尔排序方法二；（移位法即直接插入）结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 插入排序:一个有序表，一个无序表，将无序表中的第一个插入到有序中相对应的位置    public static void insertSort(int[] arr)&#123;        &#x2F;&#x2F; 第i轮，从下标为1（无序表第一个）开始遍历        for (int i &#x3D; 1; i &lt; arr.length; i++)&#123;            &#x2F;&#x2F; 要插入的值            int insertVal &#x3D; arr[i];            &#x2F;&#x2F; 要插入地方的下标（索引）            int insertIndex &#x3D; i - 1;            &#x2F;&#x2F; 循环遍历比较有序表和无序表的大小,先找到位置            while (insertIndex &gt;&#x3D; 0 &amp;&amp; insertVal &lt; arr[insertIndex])&#123;                arr[insertIndex + 1] &#x3D; arr[insertIndex];                &#x2F;&#x2F; 索引向前移动                insertIndex--;            &#125;            &#x2F;&#x2F; 退出循环后，已找到位置,退出时insertIndex为-1            arr[insertIndex + 1] &#x3D; insertVal;        &#125;        System.out.println(&quot;插入排序结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 选择排序：第一次在arr.length - 1中找到最小的，并放在第一个    public static void selectSort(int[] arr)&#123;        int min &#x3D; 0;   &#x2F;&#x2F; 拿到最小值        int minIndex &#x3D; 0;   &#x2F;&#x2F; 最小值的索引        &#x2F;&#x2F; 第i轮        for (int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;            min &#x3D; arr[i];   &#x2F;&#x2F; 假设第一个为最小            minIndex &#x3D; i;   &#x2F;&#x2F; 最小索引为i            &#x2F;&#x2F; 遍历数组，找出最小值，从第二个开始比较            for (int j &#x3D; i + 1; j &lt; arr.length; j++)&#123;                if (min &gt; arr[j])&#123;                    &#x2F;&#x2F; 记录最小值的索引和值                    min &#x3D; arr[j];                    minIndex &#x3D; j;                &#125;            &#125;            &#x2F;&#x2F; 交换，优化，如果索引不相等再交换            if (minIndex !&#x3D; i)&#123;                arr[minIndex] &#x3D; arr[i];                arr[i] &#x3D; min;            &#125;        &#125;        System.out.println(&quot;选择排序结果为：&quot;+Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 冒泡，找到最大的放到最后一个    public static void bubbleSort(int[] arr)&#123;        &#x2F;&#x2F; 定义索引，方便遍历        int temp &#x3D; 0;        &#x2F;&#x2F; 优化，标志是否有交换        boolean flag &#x3D; false;        &#x2F;&#x2F; 第i大轮        for (int i &#x3D; 0; i &lt; arr.length - 1; i++)&#123;            &#x2F;&#x2F; 第i大论里面的第j小轮，既是比较两个数，找出最大的一个放到最后            for (int j &#x3D; 0; j &lt; arr.length - i - 1; j++)&#123;                &#x2F;&#x2F; 如果前一个比后一个大，则交换                if (arr[j] &gt; arr[j+1])&#123;                    flag &#x3D; true;                    temp &#x3D; arr[j];                    arr[j] &#x3D; arr[j+1];                    arr[j+1] &#x3D; temp;                &#125;            &#125;            &#x2F;&#x2F; 如果flag &#x3D;&#x3D; false,则没有交换，直接退出循环            if (!flag)&#123;                break;            &#125; else &#123;                flag &#x3D; false;            &#125;        &#125;        System.out.println(&quot;冒泡排序结果为：&quot;+ Arrays.toString(arr));    &#125;&#125;</code></pre></div><h1 id="第8章-查找算法"><a href="#第8章-查找算法" class="headerlink" title="第8章 查找算法"></a>第8章 查找算法</h1><h2 id="8-1-查找算法介绍"><a href="#8-1-查找算法介绍" class="headerlink" title="8.1 查找算法介绍"></a>8.1 查找算法介绍</h2><p> 在java中，我们常用的查找有四种:</p><ol><li> 顺序(线性)查找</li><li> 二分查找/折半查找</li><li>  插值查找</li><li>  斐波那契查找</li></ol><h2 id="8-2-线性查找算法"><a href="#8-2-线性查找算法" class="headerlink" title="8.2 线性查找算法"></a>8.2 线性查找算法</h2><p>有一个数列 {1,8, 10, 89, 1000, 1234}，判断数列中是否包含此名称【顺序查找】要求:如果找到了，就提示找到，并给出下标值。</p><p>思路：如果查找到全部符合条件的值。[思路分析]</p><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search;public class SeqSearch &#123;    public static void main(String[] args) &#123;        int arr[] &#x3D; &#123;2,53,23,64,6,4,7,-1&#125;;&#x2F;&#x2F; 没有顺序的数组        int index &#x3D; seqSearch(arr, 3);        if (index &#x3D;&#x3D; -1)&#123;            System.out.println(&quot;没有找到&quot;);        &#125; else &#123;            System.out.println(&quot;找到，下标为：&quot;+index);        &#125;    &#125;    &#x2F;**     * 这里我们实现的线性查找是找到一个满足条件的值，就返回     * @param arr     * @param value     * @return     *&#x2F;    public static int seqSearch(int arr[] ,int value)&#123;        &#x2F;&#x2F; 线性查找是逐一对比，发现有相同的值，就返回下标        for (int i &#x3D; 0; i &lt; arr.length; i++)&#123;            if (arr[i] &#x3D;&#x3D; value)&#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre></div><h2 id="8-3-二分查找算法"><a href="#8-3-二分查找算法" class="headerlink" title="8.3 二分查找算法"></a>8.3 二分查找算法</h2><h3 id="8-3-1-二分查找："><a href="#8-3-1-二分查找：" class="headerlink" title="8.3.1 二分查找："></a>8.3.1 二分查找：</h3><p>请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。</p><h3 id="8-3-2-二分查找算法的思路："><a href="#8-3-2-二分查找算法的思路：" class="headerlink" title="8.3.2 二分查找算法的思路："></a>8.3.2 二分查找算法的思路：</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211204174925493.png" alt="image-20211204174925493"></p><h3 id="8-3-3-二分查找的代码"><a href="#8-3-3-二分查找的代码" class="headerlink" title="8.3.3 二分查找的代码"></a>8.3.3 二分查找的代码</h3><p>说明：增加了找到所有满足田条件的元素下标：</p><p>课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search;import java.util.ArrayList;import java.util.List;&#x2F;&#x2F; 注意：使用二分查找的前提是该数组是有序的public class BinarySearch &#123;    public static void main(String[] args) &#123;        int arr[] &#x3D; &#123;1,8,10,89,1000,1000,1000,1234&#125;;        &#x2F;*int indexVal &#x3D; binarySearch(arr, 0, arr.length - 1, 123);        System.out.println(&quot;indexVal &#x3D; &quot; + indexVal);*&#x2F;        List&lt;Integer&gt; list &#x3D; binarySearch2(arr, 0, arr.length - 1, 1000);        System.out.println(&quot;list &#x3D; &quot;+ list);    &#125;    &#x2F;&#x2F; 二分查找    &#x2F;**     *     * @param arr       数组     * @param left      左边的索引     * @param right     右边的索引     * @param findVal   要查找的值     * @return          如果找到就返回下标，如果没有找到就返回-1     *&#x2F;    public static int binarySearch(int[] arr,int left, int right, int findVal)&#123;        &#x2F;&#x2F; 当left &gt; right时，说明没有找到，退出递归        if (left &gt; right)&#123;            return -1;        &#125;        int mid &#x3D; (left + right) &#x2F; 2;        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;      &#x2F;&#x2F; 向右递归            return binarySearch(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;   &#x2F;&#x2F; 向左递归            return binarySearch(arr, left, mid - 1, findVal);        &#125; else &#123;            return mid;        &#125;    &#125;    &#x2F;&#x2F; 完成一个课后思考题    &#x2F;**     * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，     * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.     * 思路分析：     * 1.在找到temp索引值，不要马上返回     * 2.向mid索引值的左边扫描，将所有满足1000的元素的下标，加入到集合ArrayList中     * 3.向mid索引值的右边扫描，将所有满足1000的元素的下标，加入到集合ArrayList中     * 4.将ArrayList返回     * @param arr     * @param left     * @param right     * @param findVal     * @return     *&#x2F;    public static List&lt;Integer&gt; binarySearch2(int[] arr,int left, int right, int findVal)&#123;        &#x2F;&#x2F; 当left &gt; right时，说明没有找到，退出递归        if (left &gt; right)&#123;            return new ArrayList&lt;Integer&gt;();        &#125;        int mid &#x3D; (left + right) &#x2F; 2;        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;      &#x2F;&#x2F; 向右递归            return binarySearch2(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;   &#x2F;&#x2F; 向左递归            return binarySearch2(arr, left, mid - 1, findVal);        &#125; else &#123;            List&lt;Integer&gt; resIndexList &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 向左边扫描            int temp &#x3D; mid - 1;            while (true)&#123;                &#x2F;&#x2F; 说明没有找到，退出循环                if (temp &lt; 0 || findVal !&#x3D; arr[temp])&#123;                    break;                &#125;                &#x2F;&#x2F; 否则，将temp放入到resIndexList中                resIndexList.add(temp);                temp -&#x3D; 1;      &#x2F;&#x2F; temp左移            &#125;            resIndexList.add(mid);            &#x2F;&#x2F; 向右边扫描            temp &#x3D; mid + 1;            while (true)&#123;                if (temp &gt; arr.length - 1 || findVal !&#x3D; arr[temp])&#123;                    break;                &#125;                resIndexList.add(temp);                temp +&#x3D; 1;      &#x2F;&#x2F; temp右移            &#125;            return resIndexList;        &#125;    &#125;&#125;</code></pre></div><h3 id="二分查找复盘代码"><a href="#二分查找复盘代码" class="headerlink" title="二分查找复盘代码"></a>二分查找复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search.practice;import java.util.ArrayList;import java.util.List;&#x2F;&#x2F; 二分查找（有序数组） public class TestBinarySearch &#123;    public static void main(String[] args) &#123;        int [] arr &#x3D; &#123;1,1,1,1,36,74,567,3467&#125;;       &#x2F;* int index &#x3D; binarySearch(arr, 0, arr.length - 1, 1);        System.out.println(&quot;index &#x3D; &quot;+ index);*&#x2F;        List&lt;Integer&gt; list &#x3D; binarySearch2(arr, 0, arr.length - 1, 1);        System.out.println(&quot;list &#x3D; &quot;+ list);    &#125;    &#x2F;&#x2F; 二分查找（有序数组），找到值，返回下标，    &#x2F;&#x2F; 方法一：不考虑重复的值    &#x2F;**     *     * @param arr       数组     * @param left      左边索引     * @param right     右边索引     * @param findVal   要找的值     * @return          返回找到的值的下标     *&#x2F;    public static int binarySearch(int[] arr, int left ,int right,int findVal)&#123;        &#x2F;&#x2F; 退出递归条件        if (left &gt; right)&#123;            return -1;        &#125;        &#x2F;&#x2F; 中间的索引        int mid &#x3D; (left + right) &#x2F; 2;        &#x2F;&#x2F; 中间的值        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;      &#x2F;&#x2F; 向右递归            return binarySearch(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;   &#x2F;&#x2F; 向左递归            return binarySearch(arr, left, mid - 1, findVal);        &#125; else &#123;            &#x2F;&#x2F; 否则，返回下标            return mid;        &#125;    &#125;    &#x2F;&#x2F; 方法二：考虑重复的，利用ArrayList记录下来    public static List&lt;Integer&gt; binarySearch2(int arr[],int left,int right,int findVal)&#123;        &#x2F;&#x2F; 没有找到，返回空集合，退出递归        if (left &gt; right)&#123;            return new ArrayList&lt;&gt;();        &#125;        &#x2F;&#x2F; 中间索引        int mid &#x3D; (left + right) &#x2F; 2;        &#x2F;&#x2F; 中间值        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;            &#x2F;&#x2F; 向右递归            return binarySearch2(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;            &#x2F;&#x2F; 向左递归            return binarySearch2(arr, left, mid - 1, findVal);        &#125; else &#123;            &#x2F;&#x2F; 不直接返回下标，先记录起来，放到ArrayList中，最后返回ArrayList            List&lt;Integer&gt; resIndexList &#x3D; new ArrayList&lt;&gt;();            &#x2F;&#x2F; 向左边扫描            int temp &#x3D; mid - 1;            while (true)&#123;                &#x2F;&#x2F; 如果没有找到，则退出                if (temp &lt; 0 || findVal !&#x3D; arr[temp])&#123;                    break;                &#125;                &#x2F;&#x2F; 如果找到了，则将下标加到ArrayList中                resIndexList.add(temp);                temp -&#x3D; 1;      &#x2F;&#x2F; temp 前移            &#125;            &#x2F;&#x2F; 将中间值也加到集合中            resIndexList.add(mid);            &#x2F;&#x2F; 向右边扫描            temp &#x3D; mid + 1;            while (true)&#123;                &#x2F;&#x2F; 如果没有找到，退出循环                if (temp &gt; right || findVal !&#x3D; arr[temp])&#123;                    break;                &#125;                &#x2F;&#x2F; 找到了，将入集合                resIndexList.add(temp);                temp +&#x3D; 1;      &#x2F;&#x2F; temp后移            &#125;            return resIndexList;        &#125;    &#125;&#125;</code></pre></div><h2 id="8-4-插值查找算法"><a href="#8-4-插值查找算法" class="headerlink" title="8.4 插值查找算法"></a>8.4 插值查找算法</h2><ol><li><p>插值查找原理介绍:</p><p>插值查找算法类似于二分查找，不同的是插值查找每次从<strong>自适应****mid</strong>处开始查找。</p></li><li><p>将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.<br> key 就是前面我们讲的 findVal</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211204220310170.png" alt="image-20211204220310170"></p></li><li><p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/<em>插值索引</em>/<br> 对应前面的代码公式：<br> int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p></li><li><p>举例说明插值查找算法 1-100 的数组</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211204220335175.png" alt="image-20211204220335175"></p><h3 id="8-4-1-插值查找应用案例"><a href="#8-4-1-插值查找应用案例" class="headerlink" title="8.4.1 插值查找应用案例"></a>8.4.1 插值查找应用案例</h3><p>请对一个有序数组进行插值查找 <strong>{1,8, 10, 89, 1000, 1234}</strong> ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。</p><ul><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search;import java.util.Arrays;public class insertValueSearch &#123;    public static void main(String[] args) &#123;&#x2F;*        int arr[] &#x3D; new int[100];        for (int i &#x3D; 0; i &lt; 100; i++)&#123;            arr[i] &#x3D; i + 1;        &#125;*&#x2F;        &#x2F;&#x2F; System.out.println(Arrays.toString(arr));        int arr[] &#x3D; &#123;1,8,10,89,1000,1000,1000,1234&#125;;        int index &#x3D; insertValueSearch(arr, 0, arr.length - 1, 1234);       &#x2F;&#x2F;int index &#x3D; binarySearch(arr, 0, arr.length - 1, 1234);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; 二分查找    &#x2F;**     *     * @param arr       数组     * @param left      左边的索引     * @param right     右边的索引     * @param findVal   要查找的值     * @return          如果找到就返回下标，如果没有找到就返回-1     *&#x2F;    public static int binarySearch(int[] arr,int left, int right, int findVal)&#123;        System.out.println(&quot;二分查找次数~~&quot;);        &#x2F;&#x2F; 当left &gt; right时，说明没有找到，退出递归        if (left &gt; right)&#123;            return -1;        &#125;        int mid &#x3D; (left + right) &#x2F; 2;        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;      &#x2F;&#x2F; 向右递归            return binarySearch(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;   &#x2F;&#x2F; 向左递归            return binarySearch(arr, left, mid - 1, findVal);        &#125; else &#123;            return mid;        &#125;    &#125;    &#x2F;&#x2F; 插值查找（有序），数据量大，关键字比较均匀，关键字不均匀的前提下不一定比二分查找要好    &#x2F;**     *     * @param arr       数组     * @param left      左边索引     * @param right     右边索引     * @param findVal   查找值     * @return          如果找到，就返回对应的下标，如果没有，返回-1     *&#x2F;    public static int insertValueSearch(int [] arr, int left, int right, int findVal)&#123;        System.out.println(&quot;插值查找次数~&quot;);        &#x2F;&#x2F; 不存在，退出递归，返回-1        &#x2F;&#x2F; findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1] 必须要加，否则mid可能会越界        if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1])&#123;            return -1;        &#125;        &#x2F;&#x2F; 求出mid 自适应        int mid &#x3D; left + (right - left) * (findVal - arr[left]) &#x2F; (arr[right] - arr[left]);        int midVal &#x3D; arr[mid];        if (findVal &gt; midVal)&#123;            &#x2F;&#x2F; 向右递归            return insertValueSearch(arr, mid + 1, right, findVal);        &#125; else if (findVal &lt; midVal)&#123;            &#x2F;&#x2F; 向左递归            return insertValueSearch(arr, left, mid - 1, findVal);        &#125; else &#123;            return mid;        &#125;    &#125;&#125;</code></pre></div></li></ul><h3 id="8-4-2-插值查找注意事项："><a href="#8-4-2-插值查找注意事项：" class="headerlink" title="8.4.2 插值查找注意事项："></a>8.4.2 插值查找注意事项：</h3><ol><li>对于数据量较大，<strong>关键字分布比较均匀</strong>的查找表来说，采用<strong>插值查找</strong>,速度较快.</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li></ol><h2 id="8-5-斐波那契-黄金分割法-查找算法"><a href="#8-5-斐波那契-黄金分割法-查找算法" class="headerlink" title="8.5 斐波那契(黄金分割法)查找算法"></a>8.5 斐波那契(黄金分割法)查找算法</h2><h3 id="8-5-1-斐波那契-黄金分割法-查找基本介绍"><a href="#8-5-1-斐波那契-黄金分割法-查找基本介绍" class="headerlink" title="8.5.1 斐波那契(黄金分割法)查找基本介绍:"></a>8.5.1 斐波那契(黄金分割法)查找基本介绍:</h3><ol><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li><li><strong>斐波那契数列</strong> {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li></ol><h3 id="8-5-2-斐波那契-黄金分割法-原理"><a href="#8-5-2-斐波那契-黄金分割法-原理" class="headerlink" title="8.5.2 斐波那契(黄金分割法)原理"></a>8.5.2 斐波那契(黄金分割法)原理</h3><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即<strong>mid=low+F(k-1)-1</strong> （F代表斐波那契数列），如下图所示</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211205150847685.png" alt="image-20211205150847685"></p><p><strong>对F(k-1)-1的理解：</strong></p><ol><li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为<strong>F[k]-1</strong>，则可以将该表分成长度为<strong>F[k-1]-1</strong>和<strong>F[k-2]-1</strong>的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">while(n&gt;fib(k)-1)    k++;</code></pre></div><h3 id="8-5-3-斐波那契查找应用案例："><a href="#8-5-3-斐波那契查找应用案例：" class="headerlink" title="8.5.3 斐波那契查找应用案例："></a>8.5.3 斐波那契查找应用案例：</h3><p>请对一个有序数组进行斐波那契查找 <strong>{1,8, 10, 89, 1000, 1234}</strong> ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数”。</p><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search;import java.util.Arrays;public class FibonacciSearch &#123;    public static int maxSize &#x3D; 20;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1,8,10,89,1000,1234&#125;;        int index &#x3D; fibSearch(arr, 1234);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; 获取斐波那契数列    &#x2F;&#x2F; 非递归    public static int[] fib()&#123;        int[] f &#x3D; new int[maxSize];        f[0] &#x3D; 1;        f[1] &#x3D; 1;        for (int i &#x3D; 2; i &lt; maxSize; i++)&#123;            f[i] &#x3D; f[i - 1] + f[i - 2];        &#125;        return f;    &#125;    &#x2F;&#x2F; 编写斐波那契查找方法    &#x2F;&#x2F; 使用非递归    &#x2F;**     * mid &#x3D; low + f[k - 1] - 1;     * @param a 数组     * @param key 要查找的关键值     * @return 找到就返回下标，否则返回-1     *&#x2F;    public static int fibSearch(int [] a, int key)&#123;        int low &#x3D; 0;        int high &#x3D; a.length - 1;        int mid &#x3D; 0;        &#x2F;&#x2F; 保存mid的值        int k &#x3D; 0;          &#x2F;&#x2F; 保存斐波那契分割点的下标        int[] f &#x3D; fib();    &#x2F;&#x2F; 斐波那契数组        &#x2F;&#x2F; 获取到斐波那契分割值的下标        while (high &gt; f[k] -1)&#123;            k++;        &#125;        &#x2F;&#x2F; 将a数组copy到temp中        int[] temp &#x3D; Arrays.copyOf(a, f[k]);        &#x2F;&#x2F; 由于temp的长度可能大于a的长度，直接copy过来后面多出来的是用0补齐，实际上需要用最后一个high来补齐        for (int i &#x3D; high + 1; i &lt; temp.length; i++)&#123;            temp[i] &#x3D; a[high];        &#125;        &#x2F;&#x2F; 开始循环处理，找到我们的key        while (low &lt;&#x3D; high)&#123;            mid &#x3D;low + f[k - 1] - 1;            if (key &lt; temp[mid])&#123;                &#x2F;&#x2F; 向左边查找                high &#x3D; mid - 1;                &#x2F;&#x2F; 因为前面有k-1个元素，下次从f[k - 1]开始拆分，即下次的mid &#x3D; low + f[k - 1 - 1] - 1                &#x2F;&#x2F; 后面有k - 2个元素，从f[k - 2]开始拆分，mid &#x3D; low + f[k - 1 - 2] - 1                &#x2F;&#x2F; 1.说明：全部元素 &#x3D; 前面的元素 + 后边的元素                &#x2F;&#x2F; 2.f[k] &#x3D; f[k-1] + f[f - 2]                &#x2F;&#x2F; 因为前面有f[k-1]个元素，所以可以继续拆分f[f-1] &#x3D; f[k -2] + f[k - 3]                &#x2F;&#x2F; 即在f[k-1]的前面继续查找k--，下次循环mid &#x3D; f[k-1-1] -1;                k--;            &#125; else if (key &gt; temp[mid])&#123;                &#x2F;&#x2F; 向右边查找                low &#x3D; mid + 1;                &#x2F;&#x2F; 说明                &#x2F;&#x2F; 1.全部元素 &#x3D; 前面的元素 + 后边的元素                &#x2F;&#x2F; 2.f[k] &#x3D; f[k - 1] + f[k -2]                &#x2F;&#x2F; 3.因为后面我们有f[k-2]所以继续拆分f[k-1] &#x3D; f[k - 3] + f[k - 4]                &#x2F;&#x2F; 4.即在f[k-2]的前面进行查找 k -&#x3D; 2                &#x2F;&#x2F; 5.下次循环mid &#x3D; f[k - 1 - 2] - 1                k -&#x3D; 2;            &#125; else &#123;                &#x2F;&#x2F; 返回较小的一个                if (mid &lt;&#x3D; high)&#123;                    return mid;                &#125; else &#123;                    return high;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 找不到返回-1        return -1;    &#125;&#125;</code></pre></div><h3 id="斐波那契算法复盘代码"><a href="#斐波那契算法复盘代码" class="headerlink" title="斐波那契算法复盘代码"></a>斐波那契算法复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.search.practice;import java.util.Arrays;&#x2F;&#x2F; 斐波那契算法查找（有序列表）public class TestFibonacciSearch &#123;    public static int maxSize &#x3D; 20;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1,35,65,745,856,3456&#125;;        int index &#x3D; fibSearch(arr, 1);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; 获取斐波那契数列    public static int[] fib()&#123;        int[] f &#x3D; new int[maxSize];        f[0] &#x3D; 1;        f[1] &#x3D; 1;        for (int i &#x3D; 2; i &lt; maxSize; i++)&#123;            f[i] &#x3D; f[i -1] + f[i -2];        &#125;        return f;    &#125;    &#x2F;&#x2F; 编写斐波那契算法,有序列表    &#x2F;**     *     * @param arr 数组     * @param key 要查找的值     * @return 找到就返回下标，没有就返回-1     *&#x2F;    public static int fibSearch(int[] arr, int key)&#123;        int low &#x3D; 0;                &#x2F;&#x2F; 左rr边的索引        int high &#x3D; arr.length - 1;  &#x2F;&#x2F; 右边的索引        int mid &#x3D; 0;                &#x2F;&#x2F; 保存mid的值        int k &#x3D; 0;                  &#x2F;&#x2F; 斐波那契的分割值的下标（索引）        int[] f &#x3D; fib();            &#x2F;&#x2F; 获得斐波那契数列        &#x2F;&#x2F; 获取斐波那契分割值的下标k        while (high &gt; f[k] - 1)&#123;            k++;        &#125;        &#x2F;&#x2F; 将数组arr copy到temp中        int[] temp &#x3D; Arrays.copyOf(arr, f[k]);        &#x2F;&#x2F; 因为temp中的长度可能大于arr的长度，copy过去之后会在后面填充0，但实际上是填充arr最后的一个值        for (int i &#x3D; high + 1; i &lt; temp.length; i++)&#123;            temp[i] &#x3D; arr[high];        &#125;        &#x2F;&#x2F; 数组准备完毕后，开始循环，查找我们要找的key        while (low &lt;&#x3D; high)&#123;            &#x2F;&#x2F; 找到分割点mid的值            mid &#x3D; low + f[k - 1] - 1;            &#x2F;&#x2F; 判断key的值与temp[mid]的值的大小            if (key &lt; temp[mid])&#123;                &#x2F;&#x2F; 向左边查找                high &#x3D; mid - 1;                &#x2F;&#x2F; 以f[k - 1]为开始拆分                k--;            &#125; else if (key &gt; temp[mid])&#123;                &#x2F;&#x2F; 向右边查找                low &#x3D; mid + 1;                &#x2F;&#x2F; 以f[k - 2]开始拆分                k -&#x3D; 2;            &#125; else &#123;                &#x2F;&#x2F; 找到之后，返回比较小的值                if (mid &lt;&#x3D; high)&#123;                    return mid;                &#125; else &#123;                    return high;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 都没有找到返回-1        return -1;    &#125;&#125;</code></pre></div><h1 id="第9章-哈希表"><a href="#第9章-哈希表" class="headerlink" title="第9章 哈希表"></a>第9章 哈希表</h1><h2 id="9-1-哈希表-散列-Google上机题"><a href="#9-1-哈希表-散列-Google上机题" class="headerlink" title="9.1 哈希表(散列)-Google上机题"></a>9.1 哈希表(散列)-Google上机题</h2><ol><li><p>看一个实际需求，google公司的一个上机题: </p></li><li><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.</p></li><li><p>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p></li></ol><h2 id="9-2-哈希表的基本介绍"><a href="#9-2-哈希表的基本介绍" class="headerlink" title="9.2 哈希表的基本介绍"></a>9.2 哈希表的基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206003950955.png" alt="image-20211206003950955"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206004248016.png" alt="image-20211206004248016"></p><h2 id="9-3-google公司的一个上机题"><a href="#9-3-google公司的一个上机题" class="headerlink" title="9.3 google公司的一个上机题:"></a>9.3 google公司的一个上机题:</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的 所有信息。</p><p><strong>要求:</strong> </p><ol><li><p>不使用数据库,,速度越快越好=&gt;哈希表(散列)</p></li><li><p>添加时，保证按照id从低到高插入  [课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]</p></li><li><p>使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] </p></li><li><p>思路分析并画出示意图</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206004005244.png" alt="image-20211206004005244"></p></li><li><p>代码实现[增删改查(显示所有员工，按id查询)]</p><p>已经加入删除和按照顺序添加的功能。</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.hashtab;import javax.management.StandardEmitterMBean;import java.awt.event.ItemEvent;import java.util.Scanner;public class HashTalDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建哈希表        HashTab hashTab &#x3D; new HashTab(7);        String key &#x3D; &quot;&quot;;        Scanner scanner &#x3D; new Scanner(System.in);        while (true)&#123;            System.out.println(&quot;add: 添加雇员&quot;);            System.out.println(&quot;asc: 按照顺序添加雇员&quot;);            System.out.println(&quot;list:遍历雇员&quot;);            System.out.println(&quot;find:查找雇员&quot;);            System.out.println(&quot;del: 删除雇员&quot;);            System.out.println(&quot;exit:退出系统&quot;);            System.out.println(&quot;请输入您的操作：&quot;);            key &#x3D; scanner.next();            switch (key)&#123;                case &quot;add&quot;:                    System.out.println(&quot;请输入id&quot;);                    int id &#x3D; scanner.nextInt();                    System.out.println(&quot;请输入名字&quot;);                    String name &#x3D; scanner.next();                    Emp emp &#x3D; new Emp(id, name);                    hashTab.add(emp);                    break;                case &quot;asc&quot;:                    System.out.println(&quot;请输入id&quot;);                    id &#x3D; scanner.nextInt();                    System.out.println(&quot;请输入名字&quot;);                    name &#x3D; scanner.next();                    emp &#x3D; new Emp(id, name);                    hashTab.addByAsc(emp);                    break;                case &quot;list&quot;:                    hashTab.list();                    break;                case &quot;find&quot;:                    System.out.println(&quot;请输入要查找的id&quot;);                    id &#x3D; scanner.nextInt();                    hashTab.findEmpById(id);                    break;                case &quot;del&quot;:                    System.out.println(&quot;请输入您要删除的id&quot;);                    id &#x3D; scanner.nextInt();                    hashTab.delEmpById(id);                    break;                case &quot;exit&quot;:                    scanner.close();                    System.exit(0);                default:                    break;            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 创建HashTab 管理多条链表class HashTab&#123;    private EmpLinkedList[] empLinkedListArray;    private int size;       &#x2F;&#x2F; 表示有多少条链表    &#x2F;&#x2F; 构造器    public HashTab(int size)&#123;        this.size &#x3D; size;        &#x2F;&#x2F; 初始化数组        empLinkedListArray &#x3D; new EmpLinkedList[size];        &#x2F;&#x2F; 初始化每一条链表        for (int i &#x3D; 0; i &lt; size; i++)&#123;            empLinkedListArray[i] &#x3D; new EmpLinkedList();        &#125;    &#125;    &#x2F;&#x2F; 添加    public void add(Emp emp)&#123;        &#x2F;&#x2F; 根据id得到员工应该加到哪条链表        int empLinkedListNO &#x3D; hashFan(emp.id);        &#x2F;&#x2F; 将emp添加到对应的链表中        empLinkedListArray[empLinkedListNO].add(emp);    &#125;    &#x2F;&#x2F; 遍历所有的链表，遍历hashtab    public void list()&#123;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            empLinkedListArray[i].list(i);        &#125;    &#125;    &#x2F;&#x2F; 根据id查找雇员    public void findEmpById(int id)&#123;        int empLinkedListNO &#x3D; hashFan(id);        Emp emp &#x3D; empLinkedListArray[empLinkedListNO].findEmpById(id);        if (emp !&#x3D; null)&#123;            &#x2F;&#x2F; 找到了            System.out.printf(&quot;在第 %d 条链表中找到了雇员,id &#x3D; %d \n&quot;,(empLinkedListNO+1),id);        &#125; else &#123;            System.out.println(&quot;在哈希表中，没有找到该雇员~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 根据id删除雇员    public void delEmpById(int id)&#123;        int empLinkedListNO &#x3D; hashFan(id);        empLinkedListArray[empLinkedListNO].delById(id);    &#125;    &#x2F;&#x2F; 按照顺序添加    public void addByAsc(Emp emp)&#123;        &#x2F;&#x2F; 根据id得到员工应该加到哪条链表        int empLinkedListNO &#x3D; hashFan(emp.id);        &#x2F;&#x2F; 将emp添加到对应的链表中        empLinkedListArray[empLinkedListNO].addByAsc(emp);    &#125;    &#x2F;&#x2F; 编写一个散列函数，使用一个简单取模法    public int hashFan(int id)&#123;        return id % size;    &#125;&#125;&#x2F;&#x2F; 创建EmpLinkedList，表示链表class EmpLinkedList&#123;    &#x2F;&#x2F; 头指针，执行第一个Emp，因此我们这个链表的head是直接指向第一个Emp    private Emp head;    &#x2F;&#x2F; 头结点，默认为null    &#x2F;&#x2F; 添加    &#x2F;&#x2F; 假定，当添加雇员时，id是自增长的，即id的分配总是从小到大的    &#x2F;&#x2F; 因此我们将该雇员直接加入到本链表的最后即可    public void add(Emp emp)&#123;        &#x2F;&#x2F; 如果是第一个雇员        if (head &#x3D;&#x3D; null)&#123;            head &#x3D; emp;            return;        &#125;        &#x2F;&#x2F; 如果不是第一个雇员，则使用一个辅助指针，帮忙定位到最后，添加到最后        Emp curEmp &#x3D; head;        &#x2F;&#x2F; 找到最后一个        while (true)&#123;            if (curEmp.next &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 说明已经到链表最后                break;            &#125;            curEmp &#x3D; curEmp.next;   &#x2F;&#x2F; 后移        &#125;        curEmp.next &#x3D; emp;    &#125;    &#x2F;&#x2F; 遍历链表雇员的信息    public void list(int no)&#123;        &#x2F;&#x2F; 说明链表为空        if (head &#x3D;&#x3D; null)&#123;            System.out.println(&quot;第&quot;+(no + 1)+&quot;链表为空&quot;);            return;        &#125;        System.out.print(&quot;第&quot;+(no + 1)+&quot;条链表信息为&quot;);        Emp curEmp &#x3D; head;  &#x2F;&#x2F; 辅助变量，方便遍历        while (true)&#123;            System.out.printf(&quot; &#x3D;&gt; id &#x3D; %d  name &#x3D; %s \t&quot;,curEmp.id,curEmp.name);            if (curEmp.next &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 说明已经到链表最后                break;            &#125;            curEmp &#x3D; curEmp.next;   &#x2F;&#x2F; 后移        &#125;        System.out.println();    &#125;    &#x2F;&#x2F; 根据id查找    &#x2F;&#x2F; 如果查找到，就返回Emp，如果没有找到，就返回null    public Emp findEmpById(int id)&#123;        &#x2F;&#x2F; 判断是否为空        if (head &#x3D;&#x3D; null)&#123;            System.out.println(&quot;链表为空&quot;);            return null;        &#125;        &#x2F;&#x2F; 辅助变量        Emp curEmp &#x3D; head;        while (true)&#123;            &#x2F;&#x2F; 已经找到            if (curEmp.id &#x3D;&#x3D; id)&#123;                break;            &#125;            &#x2F;&#x2F; 退出            &#x2F;&#x2F; 说明遍历完当前链表没有找到该雇员            if (curEmp.next &#x3D;&#x3D; null)&#123;                curEmp &#x3D; null;                break;            &#125;            curEmp &#x3D; curEmp.next;   &#x2F;&#x2F; 后移        &#125;        return curEmp;    &#125;    &#x2F;&#x2F; 根据id删除Emp    public void delById(int id)&#123;        &#x2F;&#x2F; 判断是否为空        if (head &#x3D;&#x3D; null)&#123;            System.out.println(&quot;删除失败，链表为空&quot;);            return;     &#x2F;&#x2F; 注意：如果删除失败，需要放回，否则空指针异常        &#125;        &#x2F;&#x2F; 辅助指针，方便遍历        Emp curEmp &#x3D; head;        int res &#x3D; 0;        &#x2F;&#x2F; 定位到需要删除的id        while (true)&#123;            &#x2F;&#x2F; 如果链表只有一个元素，先判断当前curEmp的id与传进来的id是否相等            if (curEmp.id &#x3D;&#x3D; id)&#123;                res &#x3D; 1;                break;            &#125;            &#x2F;&#x2F; 如果当前链表不是一个元素，再判断curEmp下一个id，空出一个来删除            if (curEmp.next !&#x3D; null &amp;&amp; curEmp.next.id &#x3D;&#x3D; id)&#123;                res &#x3D; 2;                break;            &#125;            if (curEmp.next &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 已经到链表最后                break;            &#125;            curEmp &#x3D; curEmp.next;   &#x2F;&#x2F; 后移        &#125;        if (res &#x3D;&#x3D; 1)&#123;            if (curEmp.next &#x3D;&#x3D; null)&#123;                head &#x3D; null;            &#125; else &#123;                head &#x3D; curEmp.next;            &#125;            System.out.println(&quot;删除成功&quot;);        &#125; else if (res &#x3D;&#x3D; 2)&#123;            curEmp.next &#x3D; curEmp.next.next;            System.out.println(&quot;删除成功&quot;);        &#125; else &#123;            System.out.println(&quot;该链表没有您要查到的雇员~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 按id从小到大的顺序添加雇员    public void addByAsc(Emp emp)&#123;        &#x2F;&#x2F; 如果是第一个雇员        if (head &#x3D;&#x3D; null)&#123;            head &#x3D; emp;            return;        &#125;        &#x2F;&#x2F; 如果不是第一个，则根据id，找到位置，再插入即可        Emp curEmp &#x3D; head;        boolean flag &#x3D; false;   &#x2F;&#x2F; 表示插入节点不存在        int res &#x3D; 0;        while (true)&#123;            &#x2F;&#x2F; 如果id相等            if (curEmp.id &#x3D;&#x3D; emp.id) &#123;                flag &#x3D; true;                break;            &#125;            &#x2F;&#x2F; 在第一个位置插入            if (curEmp.id &gt; emp.id) &#123;                &#x2F;&#x2F; 已经找到                res &#x3D; 1;                break;            &#125;            &#x2F;&#x2F; 在最后一个位置插入            if (curEmp.next &#x3D;&#x3D; null) &#123;                &#x2F;&#x2F; 已经是最后一个，直接插入                res &#x3D; 2;                break;            &#125;            &#x2F;&#x2F; 在中间插入            if (curEmp.id &lt; emp.id &amp;&amp; curEmp.next.id &gt; emp.id) &#123;                &#x2F;&#x2F; 说明已经找到                res &#x3D; 3;                break;            &#125;            curEmp &#x3D; curEmp.next;    &#x2F;&#x2F; 后移        &#125;        if (flag)&#123;            System.out.printf(&quot;id &#x3D; %d 已经存在，请重新输入~~ \n&quot;,emp.id);        &#125; else &#123;            if (res &#x3D;&#x3D; 1)&#123;                emp.next &#x3D; curEmp;                head &#x3D; emp;            &#125;            if (res &#x3D;&#x3D; 2)&#123;                curEmp.next &#x3D; emp;            &#125;            if (res &#x3D;&#x3D; 3)&#123;                emp.next &#x3D; curEmp.next;                curEmp.next &#x3D; emp;            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 创建Emp，表示一个雇员class Emp&#123;    public int id;    public String name;    public Emp next;    &#x2F;&#x2F; next 默认为null    public Emp(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;&#125;</code></pre></div><h1 id="第10章-树结构基础部分"><a href="#第10章-树结构基础部分" class="headerlink" title="第10章 树结构基础部分"></a>第10章 树结构基础部分</h1><h2 id="10-1-二叉树"><a href="#10-1-二叉树" class="headerlink" title="10.1 二叉树"></a>10.1 二叉树</h2><h3 id="10-1-1-为什么需要树这种数据结构"><a href="#10-1-1-为什么需要树这种数据结构" class="headerlink" title="10.1.1 为什么需要树这种数据结构"></a>10.1.1 为什么需要树这种数据结构</h3><ol><li><p>数组存储方式的分析</p><p><strong>优点</strong>：通过<strong>下标方式访问</strong>元素，速度快。对于有序数组，还可使用<strong>二分查找</strong>提高检索速度。</p><p><strong>缺点</strong>：如果要检索具体某个值，或者<strong>插入值(按一定顺序)会整体移动</strong>，效率较低 [示意图]</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206114427743.png" alt="image-20211206114427743"></p></li><li><p>链式存储方式的分析</p><p><strong>优点</strong>：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将<strong>插入</strong>节点，链接到链表中即可， <strong>删除</strong>效率也很好)。</p><p><strong>缺点：</strong>在进行<strong>检索时</strong>，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 【示意图】</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206114621242.png" alt="image-20211206114621242"></p></li><li><p>树存储方式的分析</p><p>能提高数据<strong>存储，读取</strong>的效率,  比如利用 <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的<strong>插入，删除，修改</strong>的速度。【示意图,后面详讲】</p><p>案例: [7, 3, 10, 1, 5, 9, 12]</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206114714109.png" alt="image-20211206114714109"></p><h3 id="10-1-2-树示意图"><a href="#10-1-2-树示意图" class="headerlink" title="10.1.2 树示意图"></a>10.1.2 树示意图</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206130203345.png" alt="image-20211206130203345"></p><p>树的常用术语(结合示意图理解):</p><p>1)节点</p><p>2)根节点</p><p>3)父节点</p><p>4)子节点</p><p>5)叶子节点 (没有子节点的节点)</p><p>6)节点的权(节点值)</p><p>7)路径(从root节点找到该节点的路线)</p><p>8)层</p><p>9)子树</p><p>10)树的高度(最大层数)</p><p>11)森林 :多颗子树构成森林</p><h3 id="10-1-3-二叉树的概念"><a href="#10-1-3-二叉树的概念" class="headerlink" title="10.1.3 二叉树的概念"></a>10.1.3 二叉树的概念</h3><ol><li><p>树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。</p></li><li><p>二叉树的子节点分为左节点和右节点。</p></li><li><p>示意图</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206130333490.png" alt="image-20211206130333490"></p></li><li><p>如果该二叉树的<strong>所有叶子节点都在最后一层</strong>，并且结点总数= 2^n -1 , n 为层数，则我们称为<strong>满二叉树。</strong></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206130410039.png" alt="image-20211206130410039"></p></li><li><p>如果该二叉树的<strong>所有叶子节点都在最后一层或者倒数第二层</strong>，而且<strong>最后一层</strong>的叶子节点在<strong>左边连</strong>续，<strong>倒数第二层</strong>的叶子节点在<strong>右边连续</strong>，我们称<strong>为完全二叉树</strong>。</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206130431063.png" alt="image-20211206130431063"></p><h3 id="10-1-4-二叉树遍历的说明"><a href="#10-1-4-二叉树遍历的说明" class="headerlink" title="10.1.4 二叉树遍历的说明"></a>10.1.4 二叉树遍历的说明</h3><p>使用前序，中序和后序对下面的二叉树进行遍历.</p><ol><li>前序遍历: <strong>先输出父节点</strong>，再遍历左子树和右子树</li><li>中序遍历: 先遍历左子树，<strong>再输出父节点</strong>，再遍历右子树</li><li>后序遍历: 先遍历左子树，再遍历右子树，<strong>最后输出父节点</strong></li><li><strong>小结</strong>: 看输出父节点的顺序，就确定是前序，中序还是后序</li></ol><h3 id="10-1-5-二叉树遍历应用实例-前序-中序-后序"><a href="#10-1-5-二叉树遍历应用实例-前序-中序-后序" class="headerlink" title="10.1.5 二叉树遍历应用实例(前序,中序,后序)"></a>10.1.5 二叉树遍历应用实例(前序,中序,后序)</h3><p>应用实例的说明和思路</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211206130640610.png" alt="image-20211206130640610"></p><ul><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.binaryTree;public class BinaryTreeDemo &#123;    public static void main(String[] args) &#123;        BinaryTree binaryTree &#x3D; new BinaryTree();        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);        root.setLeft(node2);        root.setRight(node3);        node3.setRight(node4);        node3.setLeft(node5);        binaryTree.setRoot(root);        System.out.println(&quot;前序遍历&quot;);        binaryTree.preOrder();  &#x2F;&#x2F; 1,2,3,5,4        System.out.println(&quot;中序遍历&quot;);        binaryTree.infixOrder();    &#x2F;&#x2F; 2,1,5,3,4        System.out.println(&quot;后序遍历&quot;);        binaryTree.postOrder();     &#x2F;&#x2F; 2,5,4,3,1    &#125;&#125;&#x2F;&#x2F; 创建二叉树class BinaryTree&#123;    private HeroNode root;    public void setRoot(HeroNode root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.preOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.infixOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.postOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;&#125;&#x2F;&#x2F; 创建英雄结点class HeroNode&#123;    private int id;    private String name;    private HeroNode left;  &#x2F;&#x2F; 默认为空    private HeroNode right; &#x2F;&#x2F; 默认为空    public HeroNode(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        &#x2F;&#x2F; 先输入当前节点        System.out.println(this);        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.preOrder();        &#125;        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.preOrder();        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.infixOrder();        &#125;        &#x2F;&#x2F; 当前        System.out.println(this);        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.infixOrder();        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.postOrder();        &#125;        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.postOrder();        &#125;        System.out.println(this);    &#125;&#125;</code></pre></div></li></ul><h3 id="10-1-6-二叉树-查找指定节点"><a href="#10-1-6-二叉树-查找指定节点" class="headerlink" title="10.1.6 二叉树-查找指定节点"></a>10.1.6 二叉树-查找指定节点</h3><p>要求</p><ol><li><p>请编写前序查找，中序查找和后序查找的方法。</p></li><li><p>并分别使用三种查找方式，查找 heroNO = 5 的节点</p></li><li><p>并分析各种查找方式，分别比较了多少次</p></li><li><p>思路分析图解</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211208122439985.png" alt="image-20211208122439985"></p></li><li><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.binaryTree;public class BinaryTreeDemo &#123;    public static void main(String[] args) &#123;        BinaryTree binaryTree &#x3D; new BinaryTree();        HeroNode root &#x3D; new HeroNode(1, &quot;宋江&quot;);        HeroNode node2 &#x3D; new HeroNode(2, &quot;吴用&quot;);        HeroNode node3 &#x3D; new HeroNode(3, &quot;卢俊义&quot;);        HeroNode node4 &#x3D; new HeroNode(4, &quot;林冲&quot;);        HeroNode node5 &#x3D; new HeroNode(5, &quot;关胜&quot;);        root.setLeft(node2);        root.setRight(node3);        node3.setRight(node4);        node3.setLeft(node5);        binaryTree.setRoot(root);        System.out.println(&quot;前序遍历&quot;);        binaryTree.preOrder();  &#x2F;&#x2F; 1,2,3,5,4        System.out.println(&quot;中序遍历&quot;);        binaryTree.infixOrder();    &#x2F;&#x2F; 2,1,5,3,4        System.out.println(&quot;后序遍历&quot;);        binaryTree.postOrder();     &#x2F;&#x2F; 2,5,4,3,1&#x2F;*        &#x2F;&#x2F; 前序遍历查找        &#x2F;&#x2F; 比较次数4        HeroNode resNode &#x3D; binaryTree.preOrderSearch(5);        if (resNode !&#x3D; null)&#123;            System.out.printf(&quot;该结点信息为：id &#x3D; %d name &#x3D; %s&quot;,resNode.getId(),resNode.getName());        &#125; else &#123;            System.out.println(&quot;结点不存在&quot;);        &#125;*&#x2F;&#x2F;*        &#x2F;&#x2F; 中序遍历查找        &#x2F;&#x2F; 比较次数3        HeroNode resNode &#x3D; binaryTree.infixOrderSearch(5);        if (resNode !&#x3D; null)&#123;            System.out.printf(&quot;该结点信息为：id &#x3D; %d name &#x3D; %s&quot;,resNode.getId(),resNode.getName());        &#125; else &#123;            System.out.println(&quot;结点不存在&quot;);        &#125;*&#x2F;        &#x2F;&#x2F; 后序遍历查找        &#x2F;&#x2F; 比较次数2        HeroNode resNode &#x3D; binaryTree.postOrderSearch(5);        if (resNode !&#x3D; null)&#123;            System.out.printf(&quot;该结点信息为：id &#x3D; %d name &#x3D; %s&quot;,resNode.getId(),resNode.getName());        &#125; else &#123;            System.out.println(&quot;结点不存在&quot;);        &#125;    &#125;&#125;&#x2F;&#x2F; 创建二叉树class BinaryTree&#123;    private HeroNode root;    public void setRoot(HeroNode root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.preOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.infixOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.postOrder();        &#125; else &#123;            System.out.println(&quot;二叉树为空，无法遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 前序遍历查找    public HeroNode preOrderSearch(int no)&#123;        &#x2F;&#x2F; 判断当前根节点是否为空        if (this.root !&#x3D; null)&#123;            &#x2F;&#x2F; 不为空，调用前序遍历查找，返回结点            return this.root.preOrderSearch(no);        &#125; else &#123;            &#x2F;&#x2F; 如果根结点为空，返回null            return null;        &#125;    &#125;    &#x2F;&#x2F; 中序遍历查找    public HeroNode infixOrderSearch(int no )&#123;        if (this.root !&#x3D; null)&#123;            return this.root.infixOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    &#x2F;&#x2F; 后序遍历查找    public HeroNode postOrderSearch(int no)&#123;        if (this.root !&#x3D; null)&#123;            return this.root.postOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;&#125;&#x2F;&#x2F; 创建英雄结点class HeroNode&#123;    private int id;    private String name;    private HeroNode left;  &#x2F;&#x2F; 默认为空    private HeroNode right; &#x2F;&#x2F; 默认为空    public HeroNode(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        &#x2F;&#x2F; 先输入当前节点        System.out.println(this);        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.preOrder();        &#125;        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.preOrder();        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.infixOrder();        &#125;        &#x2F;&#x2F; 当前        System.out.println(this);        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.infixOrder();        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        &#x2F;&#x2F; 左边        if (this.left !&#x3D; null)&#123;            this.left.postOrder();        &#125;        &#x2F;&#x2F; 右边        if (this.right !&#x3D; null)&#123;            this.right.postOrder();        &#125;        System.out.println(this);    &#125;    &#x2F;&#x2F; 前序查找    public HeroNode preOrderSearch(int no )&#123;        System.out.println(&quot;进入前序查找~&quot;);        &#x2F;&#x2F; 先判断当前结点是否相等        if (this.id &#x3D;&#x3D; no)&#123;            return this;        &#125;        &#x2F;&#x2F; 判断左边是否为空        HeroNode resNode &#x3D; null;        if (this.left !&#x3D; null)&#123;     &#x2F;&#x2F; 不为空，则进行左边前序查找            resNode &#x3D; this.left.preOrderSearch(no);        &#125;        &#x2F;&#x2F; 如果不为空，则说明左子树已经找到了，返回当前结点        if (resNode !&#x3D; null)&#123;            return resNode;        &#125;        &#x2F;&#x2F; 如果没找到，进行右边前序查找        if (this.right !&#x3D; null)&#123;            resNode &#x3D; this.right.preOrderSearch(no);        &#125;        return resNode;    &#125;    &#x2F;&#x2F; 中序查找    public HeroNode infixOrderSearch(int no)&#123;        HeroNode resNode &#x3D; null;        &#x2F;&#x2F; 先判断左子树是否为空        if (this.left !&#x3D; null)&#123;            &#x2F;&#x2F; 如果不为空，进行左子树的中序遍历            resNode &#x3D; this.left.infixOrderSearch(no);        &#125;        if (resNode !&#x3D; null)&#123;            &#x2F;&#x2F; 说明左子树已经找到，返回            return resNode;        &#125;        System.out.println(&quot;进入中序查找~&quot;);        &#x2F;&#x2F; 判断当前结点是否相等        if (this.id &#x3D;&#x3D; no)&#123;            return this;        &#125;        &#x2F;&#x2F; 判断右子树是否为空        if (this.right !&#x3D; null)&#123;            resNode &#x3D; this.right.infixOrderSearch(no);        &#125;        return resNode;    &#125;    &#x2F;&#x2F; 后序查找    public HeroNode postOrderSearch(int no)&#123;        HeroNode resNode &#x3D; null;        &#x2F;&#x2F; 判断左子树是否为空        if (this.left !&#x3D; null)&#123;            &#x2F;&#x2F; 左子树进行后序查找            resNode &#x3D; this.left.postOrderSearch(no);        &#125;        if (resNode !&#x3D; null)&#123;            &#x2F;&#x2F; 如果不为空，说明左子树已经找到，返回结点            return resNode;        &#125;        &#x2F;&#x2F; 判断右子树是否为空        if (this.right !&#x3D; null)&#123;            &#x2F;&#x2F; 不为空，则向右子树进行后序查找，返回结点            resNode &#x3D; this.right.postOrderSearch(no);        &#125;        &#x2F;&#x2F; 判断返回的结点是否为空        if (resNode !&#x3D; null)&#123;            return resNode;        &#125;        System.out.println(&quot;进入后序查找&quot;);        &#x2F;&#x2F; 判断当前结点的id是否与传入的id相等        if (this.id &#x3D;&#x3D; no)&#123;            &#x2F;&#x2F; 相等则返回当前结点            return this;        &#125;        &#x2F;&#x2F; 不管有没有找到，返回结点，有找到就返回结点，没有就返回的是null        return resNode;    &#125;&#125;</code></pre></div></li></ol><h3 id="10-1-7-二叉树-删除节点"><a href="#10-1-7-二叉树-删除节点" class="headerlink" title="10.1.7 二叉树-删除节点"></a>10.1.7 二叉树-删除节点</h3><p>要求</p><ol><li>如果删除的节点是叶子节点，则删除该节点</li><li>如果删除的节点是非叶子节点，则删除该子树.</li><li>测试，删除掉 5号叶子节点 和 3号子树.</li><li>思路分析</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211208162253051.png" alt="image-20211208162253051"></p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 在HeroNode类添加删除方法 &#x2F;&#x2F; 删除结点    public void delNode(int no)&#123;        &#x2F;&#x2F; 如果当前结点的左结点不为空，并且就是要删除的结点，则置空，返回结束递归        if (this.left !&#x3D; null &amp;&amp; this.left.id &#x3D;&#x3D; no)&#123;            this.left &#x3D; null;            return;        &#125;        &#x2F;&#x2F; 如果当前节点的右结点不为空，并且就是要删除的结点，则置空，返回结束递归        if (this.right !&#x3D; null &amp;&amp; this.right.id &#x3D;&#x3D; no)&#123;            this.right &#x3D; null;            return;        &#125;        &#x2F;&#x2F; 上面两步都没有扎到，则左递归删除        if (this.left !&#x3D; null)&#123;            this.left.delNode(no);        &#125;        &#x2F;&#x2F; 向右递归删除        if (this.right !&#x3D; null)&#123;            this.right.delNode(no);        &#125;    &#125;&#x2F;&#x2F; 在BinaryTree类中添加删除方法&#x2F;&#x2F; 删除结点    public void delNode(int no)&#123;        &#x2F;&#x2F; 如果当前的root不为空，        if (this.root !&#x3D; null)&#123;            &#x2F;&#x2F; 判断是否是需要删除的            if (this.root.getId() &#x3D;&#x3D; no)&#123;                this.root &#x3D; null;            &#125; else &#123;                &#x2F;&#x2F; 否则，从root开始递归删除                root.delNode(no);            &#125;        &#125; else &#123;            System.out.println(&quot;空树，无法删除~&quot;);        &#125;    &#125;&#x2F;&#x2F; 在主方法测试        &#x2F;&#x2F; 测试删除        System.out.println(&quot;删除前，前序遍历&quot;);     &#x2F;&#x2F; 1,2,3,5,4        binaryTree.preOrder();        &#x2F;&#x2F;binaryTree.delNode(5);        binaryTree.delNode(3);        System.out.println(&quot;删除后，前序遍历&quot;);     &#x2F;&#x2F; 1,2,3,4        binaryTree.preOrder();</code></pre></div><h3 id="10-1-8-思考题-课后练习"><a href="#10-1-8-思考题-课后练习" class="headerlink" title="10.1.8 思考题(课后练习)"></a>10.1.8 思考题(课后练习)</h3><ol><li>如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则, 假如规定如下:</li><li>如果该非叶子节点A只有一个子节点B，则子节点B替代节点A</li><li>如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。</li><li>请大家思考，如何完成该删除功能, 老师给出提示.(课后练习)</li><li>后面在讲解 二叉排序树时，在给大家讲解具体的删除方法</li></ol><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 在HeroNode类添加按照规则删除的方法&#x2F;&#x2F; 指定规则删除    &#x2F;**      如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除，需要指定规则, 假如规定如下:      如果该非叶子节点A只有一个子节点B，则子节点B替代节点A      如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。     *&#x2F;    public void delByRule(int no)&#123;        &#x2F;&#x2F; 临时变量，方便保存需要删除的结点的下一个节点        HeroNode temp &#x3D; null;        &#x2F;&#x2F; 如果左结点不为空，并且为要删除的节点        if (this.left !&#x3D; null &amp;&amp; this.left.id &#x3D;&#x3D; no)&#123;            &#x2F;&#x2F; 如果要删除的结点的左结点不为空，右结点为空，既是只有一个节点            if (this.left.left !&#x3D; null &amp;&amp; this.left.right &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 则将左结点替换要删除的节点的位置                this.left &#x3D; this.left.left;            &#125; else if(this.left.left &#x3D;&#x3D; null &amp;&amp; this.left.right !&#x3D; null)&#123;                &#x2F;&#x2F; 如果要删除的结点的左结点为空，右结点不为空，则将要删除的右结点放到删除的位置                this.left &#x3D; this.left.right;            &#125; else if (this.left.left !&#x3D; null &amp;&amp; this.left.right !&#x3D; null)&#123;                &#x2F;&#x2F; 要删除的左右结点都不为空，则将要删除的结点的左结点替换要删除的结点，                &#x2F;&#x2F; 并将要删除结点的右结点挂在新的结点上面                temp &#x3D; this.left.right;                this.left &#x3D; this.left.left;                this.left.right &#x3D; temp;            &#125; else &#123;                &#x2F;&#x2F; 要删除的左右结点都为空，则直接置空                this.left &#x3D; null;            &#125;        &#125;        &#x2F;&#x2F; 如果当前结点的右结点不为空，并且为要删除的节点        if (this.right !&#x3D; null &amp;&amp; this.right.id &#x3D;&#x3D; no)&#123;            &#x2F;&#x2F; 如果要删除的结点只有左结点            if (this.right.left !&#x3D; null &amp;&amp; this.right.right &#x3D;&#x3D; null)&#123;                this.right &#x3D; this.right.left;            &#125; else if (this.right.left &#x3D;&#x3D; null &amp;&amp; this.right.right !&#x3D; null)&#123;                &#x2F;&#x2F; 只有右结点                this.right &#x3D; this.right.right;            &#125; else if (this.right.left !&#x3D; null &amp;&amp; this.right.right !&#x3D; null)&#123;                &#x2F;&#x2F; 有左右两个节点，将左结点作为新的节点                temp &#x3D; this.right.right;                this.right &#x3D; this.right.left;                this.right.right &#x3D; temp;            &#125; else &#123;                this.right &#x3D; null;            &#125;        &#125;        &#x2F;&#x2F; 进行左递归删除        if (this.left !&#x3D; null)&#123;            this.left.delByRule(no);        &#125;        &#x2F;&#x2F; 进行右递归删除        if (this.right !&#x3D; null)&#123;            this.right.delByRule(no);        &#125;    &#125;&#x2F;&#x2F; 在BinaryTree类中添加按照规则的方法&#x2F;&#x2F; 按照规则删除，只限用在当前的规则下和例子下面，否则会有bug    public void delByRule(int no)&#123;        if (this.root !&#x3D; null)&#123;            &#x2F;&#x2F; 如果要删除根节点，则将整棵树删除            if (this.root.getId() &#x3D;&#x3D; no)&#123;                this.root &#x3D; null;            &#125; else &#123;                &#x2F;&#x2F; 否则递归删除                this.root.delByRule(no);            &#125;        &#125; else &#123;            System.out.println(&quot;空树，无法删除~~~&quot;);        &#125;    &#125;&#x2F;&#x2F; 在主方法测试</code></pre></div><h3 id="二叉树复盘代码"><a href="#二叉树复盘代码" class="headerlink" title="二叉树复盘代码"></a>二叉树复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.binaryTree.practice;public class BinaryTreeReview &#123;    public static void main(String[] args) &#123;        BinaryTree1 binaryTree &#x3D; new BinaryTree1();        HeroNode1 node1 &#x3D; new HeroNode1(1, &quot;宋江&quot;);        HeroNode1 node2 &#x3D; new HeroNode1(2, &quot;吴用&quot;);        HeroNode1 node3 &#x3D; new HeroNode1(3, &quot;卢俊义&quot;);        HeroNode1 node4 &#x3D; new HeroNode1(4, &quot;林冲&quot;);        HeroNode1 node5 &#x3D; new HeroNode1(5, &quot;关胜&quot;);        binaryTree.setRoot(node1);        node1.setLeft(node2);        node1.setRight(node3);        node3.setLeft(node5);        node3.setRight(node4);        &#x2F;&#x2F; 前序遍历        System.out.println(&quot;前序遍历~~&quot;);        binaryTree.preOrder();        &#x2F;&#x2F; 中序遍历        System.out.println(&quot;中序遍历~~&quot;);        binaryTree.infixOrder();        &#x2F;&#x2F; 后序遍历        System.out.println(&quot;后序遍历&quot;);        binaryTree.postOrder();        HeroNode1 resNode &#x3D; binaryTree.postOrderSearch(1);        if (resNode !&#x3D; null)&#123;            System.out.printf(&quot;结果为：id &#x3D; %d name &#x3D; %s&quot;,resNode.getId(),resNode.getName());        &#125; else &#123;            System.out.println(&quot;没有找到结果&quot;);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        System.out.println(&quot;删除前，前序遍历&quot;);        binaryTree.preOrder();        binaryTree.delNode(5);        System.out.println(&quot;删除后，前序遍历&quot;);        binaryTree.preOrder();    &#125;&#125;&#x2F;&#x2F; 创建树class BinaryTree1&#123;    private HeroNode1 root;    public void setRoot(HeroNode1 root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 删除    public void delNode(int no)&#123;        if (this.root !&#x3D; null)&#123;            &#x2F;&#x2F; 如果只有一个节点，判断是否要删除的            if (this.root.getId() &#x3D;&#x3D; no)&#123;                this.root &#x3D; null;            &#125; else &#123;                &#x2F;&#x2F; 如果root不是要删除的，则递归删除                this.root.delNode(no);            &#125;        &#125; else &#123;            System.out.println(&quot;树为空，无法删除~~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 前序遍历查找，有则返回结点，无则返回null    public HeroNode1 preOrderSearch(int no)&#123;        if (this.root !&#x3D; null)&#123;            return this.root.preOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    &#x2F;&#x2F; 中序遍历查找    public HeroNode1 infixOrderSearch(int no)&#123;        if (this.root !&#x3D; null)&#123;            return this.root.infixOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    &#x2F;&#x2F; 后序遍历查找    public HeroNode1 postOrderSearch(int no)&#123;        if (this.root !&#x3D; null)&#123;            return this.root.postOrderSearch(no);        &#125; else &#123;            return null;        &#125;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        &#x2F;&#x2F; 如果根结点不为空        if (this.root !&#x3D; null)&#123;            this.root.preOrder();        &#125; else &#123;            System.out.println(&quot;树为空，无法遍历~~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.infixOrder();        &#125; else &#123;            System.out.println(&quot;树为空，无法遍历~~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        if (this.root !&#x3D; null)&#123;            this.root.postOrder();        &#125; else &#123;            System.out.println(&quot;树为空，无法遍历~~&quot;);        &#125;    &#125;&#125;&#x2F;&#x2F; 先创建结点class HeroNode1&#123;    private int id;    private String name;    private HeroNode1 left;    private HeroNode1 right;    public HeroNode1(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode1 getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode1 left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode1 getRight() &#123;        return right;    &#125;    public void setRight(HeroNode1 right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode1&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    &#x2F;&#x2F; 删除：如果是结点，直接删除，如果是子树，将整颗树删除    public void delNode(int no)&#123;        &#x2F;&#x2F; 先判断左结点不为空，并且等于要删除的，则直接删除        if (this.left !&#x3D; null &amp;&amp; this.left.id &#x3D;&#x3D; no)&#123;            this.left &#x3D; null;            return;        &#125;        &#x2F;&#x2F; 判断右结点不为空，并且等于要删除的，直接删除，返回        if (this.right !&#x3D; null &amp;&amp; this.right.id &#x3D;&#x3D; no)&#123;            this.right &#x3D; null;            return;        &#125;        &#x2F;&#x2F; 向左边递归删除        if (this.left !&#x3D; null)&#123;            this.left.delNode(no);        &#125;        &#x2F;&#x2F; 向右边递归删除        if (this.right !&#x3D; null)&#123;            this.right.delNode(no);        &#125;    &#125;    &#x2F;&#x2F; 前序遍历查找    public HeroNode1 preOrderSearch(int no)&#123;        &#x2F;&#x2F; 判断当前的        if (this.id &#x3D;&#x3D; no)&#123;            return this;        &#125;        &#x2F;&#x2F; 判断左结点是否为空       HeroNode1 resNode &#x3D; null;        if (this.left !&#x3D; null)&#123;            resNode &#x3D; this.left.preOrderSearch(no);        &#125;        &#x2F;&#x2F; 判断左递归返回的值是否为空        if (resNode !&#x3D; null)&#123;            return resNode;        &#125;        &#x2F;&#x2F; 右递归        if (this.right !&#x3D; null)&#123;            resNode &#x3D; this.right.preOrderSearch(no);        &#125;        return resNode;    &#125;    &#x2F;&#x2F; 中序遍历查找    public HeroNode1 infixOrderSearch(int no)&#123;        HeroNode1 resNode &#x3D; null;        &#x2F;&#x2F; 先判断左结点，不为空，则进行左递归查找        if (this.left !&#x3D; null)&#123;            resNode &#x3D; this.left.infixOrderSearch(no);        &#125;        if (resNode !&#x3D; null)&#123;            return resNode;        &#125;        &#x2F;&#x2F; 当前        if (this.id &#x3D;&#x3D; no)&#123;            return this;        &#125;        &#x2F;&#x2F; 判断右结点，不为空，则向右递归查找        if (this.right !&#x3D; null)&#123;            resNode &#x3D; this.right.infixOrderSearch(no);        &#125;        return resNode;    &#125;    &#x2F;&#x2F; 后序遍历查找    public HeroNode1 postOrderSearch(int no)&#123;        &#x2F;&#x2F; 接收递归的返回值        HeroNode1 resNode &#x3D; null;        &#x2F;&#x2F; 左结点不为空，向左递归进行后序查找        if (this.left !&#x3D; null)&#123;            resNode &#x3D; this.left.postOrderSearch(no);        &#125;        if (resNode !&#x3D; null)&#123;            return resNode;        &#125;        &#x2F;&#x2F; 右结点不为空，则向右递归进行后序查找        if (this.right !&#x3D; null)&#123;            resNode &#x3D; this.right.postOrderSearch(no);        &#125;        if (this.id &#x3D;&#x3D; no)&#123;            return this;        &#125;        return resNode;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        &#x2F;&#x2F; 先输出当前结点        System.out.println(this);        &#x2F;&#x2F; 左递归        if (this.left !&#x3D; null)&#123;            this.left.preOrder();        &#125;        &#x2F;&#x2F; 右递归        if (this.right !&#x3D; null)&#123;            this.right.preOrder();        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        &#x2F;&#x2F; 左递归        if (this.left !&#x3D; null)&#123;            this.left.infixOrder();        &#125;        &#x2F;&#x2F; 输出当前结点        System.out.println(this);        &#x2F;&#x2F; 右递归        if (this.right !&#x3D; null)&#123;            this.right.infixOrder();        &#125;    &#125;    &#x2F;&#x2F; 后序遍历    public void postOrder()&#123;        &#x2F;&#x2F; 左递归        if (this.left !&#x3D; null)&#123;            this.left.postOrder();        &#125;        &#x2F;&#x2F; 右递归        if (this.right !&#x3D; null)&#123;            this.right.postOrder();        &#125;        System.out.println(this);    &#125;&#125;</code></pre></div><h2 id="10-2-顺序存储二叉树"><a href="#10-2-顺序存储二叉树" class="headerlink" title="10.2 顺序存储二叉树"></a>10.2 顺序存储二叉树</h2><h3 id="10-2-1-顺序存储二叉树的概念"><a href="#10-2-1-顺序存储二叉树的概念" class="headerlink" title="10.2.1 顺序存储二叉树的概念"></a>10.2.1 顺序存储二叉树的概念</h3><p>基本说明</p><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，看右面的示意图。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211208212636640.png" alt="image-20211208212636640"></p><p>要求:</p><ol><li>右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]</li><li>要求在遍历数组 arr时，仍然可以以<strong>前序遍历</strong>，<strong>中序遍历</strong>和<strong>后序遍历</strong>的方式完成结点的遍历</li></ol><p>顺序存储二叉树的<strong>特点</strong>:</p><ol><li>顺序二叉树通常只考虑完全二叉树</li><li>第n个元素的左子节点为 2 * n + 1 </li><li>第n个元素的右子节点为 2 * n + 2</li><li>第n个元素的父节点为 (n-1) / 2</li><li>n : 表示二叉树中的第几个元素(按0开始编号<br> 如图所示)</li></ol><h3 id="10-2-2-顺序存储二叉树遍历"><a href="#10-2-2-顺序存储二叉树遍历" class="headerlink" title="10.2.2 顺序存储二叉树遍历"></a>10.2.2 顺序存储二叉树遍历</h3><p>需求: 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为 1,2,4,5,3,6,7</p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree;public class ArrBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;        ArrBinaryTree arrBinaryTree &#x3D; new ArrBinaryTree(arr);        System.out.println(&quot;顺序存储二叉树，前序遍历~~&quot;);        arrBinaryTree.preOrder();      &#x2F;&#x2F; 1,2,4,5,3,6,7    &#125;&#125;&#x2F;&#x2F; 编写一个ArrBinaryTree类，实现顺序存储二叉树&#x2F;&#x2F; 第n个结点的左子结点：2*n + 1&#x2F;&#x2F; 第n个结点的右子结点：2*n + 2&#x2F;&#x2F; 第n个结点的父节点为：(n - 1) &#x2F; 2class ArrBinaryTree&#123;    private int[] arr;    public ArrBinaryTree(int[] arr) &#123;        this.arr &#x3D; arr;    &#125;    &#x2F;&#x2F; 重载preOrder    public void preOrder()&#123;        this.preOrder(0);    &#125;    &#x2F;&#x2F; 顺序存储二叉树，前序遍历    public void preOrder(int index)&#123;        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;            System.out.println(&quot;数组为空，无法前序遍历&quot;);        &#125;        &#x2F;&#x2F; 先输出当前的结点        System.out.println(arr[index]);        &#x2F;&#x2F; 向左递归        if (2 * index + 1 &lt; arr.length)&#123;            preOrder(2 * index + 1);        &#125;        &#x2F;&#x2F; 向右递归        if (2 * index + 2 &lt; arr.length)&#123;            preOrder(2 * index + 2);        &#125;    &#125;&#125;</code></pre></div><h4 id="课后练习："><a href="#课后练习：" class="headerlink" title="课后练习："></a>课后练习：</h4><p>请同学们完成对数组以二叉树中序，后序遍历方式的代码。</p><p><strong>完整代码：</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree;public class ArrBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1,2,3,4,5,6,7&#125;;        ArrBinaryTree arrBinaryTree &#x3D; new ArrBinaryTree(arr);        System.out.println(&quot;顺序存储二叉树，前序遍历~~&quot;);        arrBinaryTree.preOrder();      &#x2F;&#x2F; 1,2,4,5,3,6,7        System.out.println(&quot;顺序存储二叉树，中序遍历~~&quot;);        arrBinaryTree.infixOrder(0);        &#x2F;&#x2F; 4,2,5,1,6,3,7        System.out.println(&quot;顺序存储二叉树，后续遍历~~&quot;);        arrBinaryTree.postOrder(0);         &#x2F;&#x2F; 4,5,2,6,7,3,1    &#125;&#125;&#x2F;&#x2F; 编写一个ArrBinaryTree类，实现顺序存储二叉树&#x2F;&#x2F; 第n个结点的左子结点：2*n + 1&#x2F;&#x2F; 第n个结点的右子结点：2*n + 2&#x2F;&#x2F; 第n个结点的父节点为：(n - 1) &#x2F; 2class ArrBinaryTree&#123;    private int[] arr;    public ArrBinaryTree(int[] arr) &#123;        this.arr &#x3D; arr;    &#125;    &#x2F;&#x2F; 重载preOrder    public void preOrder()&#123;        this.preOrder(0);    &#125;    &#x2F;&#x2F; 顺序存储二叉树，前序遍历    public void preOrder(int index)&#123;        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;            System.out.println(&quot;数组为空，无法前序遍历&quot;);        &#125;        &#x2F;&#x2F; 先输出当前的结点        System.out.println(arr[index]);        &#x2F;&#x2F; 向左递归        if (2 * index + 1 &lt; arr.length)&#123;            preOrder(2 * index + 1);        &#125;        &#x2F;&#x2F; 向右递归        if (2 * index + 2 &lt; arr.length)&#123;            preOrder(2 * index + 2);        &#125;    &#125;    &#x2F;&#x2F; 顺序存储二叉树，中序遍历    public void infixOrder(int index)&#123;        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;            System.out.println(&quot;二叉树为空，无法中序遍历&quot;);        &#125;        &#x2F;&#x2F; 先向左边递归        if (2 * index + 1 &lt; arr.length)&#123;            infixOrder(2 * index + 1);        &#125;        &#x2F;&#x2F; 输入当前结点        System.out.println(arr[index]);        &#x2F;&#x2F; 向右边递归        if (2 * index + 2 &lt; arr.length)&#123;            infixOrder(2 * index + 2);        &#125;    &#125;    &#x2F;&#x2F; 顺序存储二叉树，后序遍历    public void postOrder(int index)&#123;        if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0)&#123;            System.out.println(&quot;二叉树为空，无法进行后序遍历&quot;);        &#125;        &#x2F;&#x2F; 向左递归        if (2 * index + 1 &lt; arr.length)&#123;            postOrder(2 * index + 1);        &#125;        &#x2F;&#x2F; 向右递归        if (2 * index + 2 &lt; arr.length)&#123;            postOrder(2 * index + 2);        &#125;        &#x2F;&#x2F; 输出当前结点        System.out.println(arr[index]);    &#125;&#125;</code></pre></div><h3 id="10-2-3-顺序存储二叉树应用实例"><a href="#10-2-3-顺序存储二叉树应用实例" class="headerlink" title="10.2.3 顺序存储二叉树应用实例"></a>10.2.3 顺序存储二叉树应用实例</h3><p>八大排序算法中的堆排序，就会使用到顺序存储二叉树， 关于堆排序，我们放在&lt;&lt;树结构实际应用&gt;&gt; 章节讲解 </p><h2 id="10-3-线索化二叉树"><a href="#10-3-线索化二叉树" class="headerlink" title="10.3 线索化二叉树"></a>10.3 线索化二叉树</h2><h3 id="10-3-1-先看一个问题"><a href="#10-3-1-先看一个问题" class="headerlink" title="10.3.1 先看一个问题"></a>10.3.1 先看一个问题</h3><p>将数列 {1, 3, 6, 8, 10, 14  } 构建成一颗二叉树.  n+1=7</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211209222324611.png" alt="image-20211209222324611"></p><p>问题分析: </p><ol><li>当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }</li><li>但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.</li><li>如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办?</li><li>解决方案-线索二叉树</li></ol><h3 id="10-3-2-线索二叉树基本介绍"><a href="#10-3-2-线索二叉树基本介绍" class="headerlink" title="10.3.2 线索二叉树基本介绍"></a>10.3.2 线索二叉树基本介绍</h3><ol><li><p>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</p></li><li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</p></li><li><p>一个结点的前一个结点，称为前驱结点</p></li><li><p>一个结点的后一个结点，称为后继结点</p></li></ol><h3 id="10-3-3-线索二叉树应用案例"><a href="#10-3-3-线索二叉树应用案例" class="headerlink" title="10.3.3 线索二叉树应用案例"></a>10.3.3 线索二叉树应用案例</h3><p>应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211209222511722.png" alt="image-20211209222511722"></p><p><strong>思路分析:</strong>  中序遍历的结果：{8, 3, 10, 1, 14, 6}</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211209222552345.png" alt="image-20211209222552345"></p><p>说明: 当线索化二叉树后，Node节点的 属性 left和right，有如下情况:</p><ol><li>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.</li><li>right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.</li></ol><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree.threadedbinarytree;public class ThreadedBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建结点        HeroNode root &#x3D; new HeroNode(1, &quot;tom&quot;);        HeroNode node2 &#x3D; new HeroNode(3, &quot;jack&quot;);        HeroNode node3 &#x3D; new HeroNode(6, &quot;smith&quot;);        HeroNode node4 &#x3D; new HeroNode(8, &quot;milan&quot;);        HeroNode node5 &#x3D; new HeroNode(10, &quot;dim&quot;);        HeroNode node6 &#x3D; new HeroNode(14, &quot;mary&quot;);        &#x2F;&#x2F; 构建二叉树        root.setLeft(node2);        root.setRight(node3);        node2.setLeft(node4);        node2.setRight(node5);        node3.setLeft(node6);        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();        threadedBinaryTree.setRoot(root);        &#x2F;&#x2F; 线索化        threadedBinaryTree.threadedNode();        &#x2F;&#x2F; 以10号结点测试        HeroNode node5Left &#x3D; node5.getLeft();        HeroNode node5Right &#x3D; node5.getRight();        System.out.println(&quot;10 号的前驱结点 &#x3D; &quot; + node5Left);        System.out.println(&quot;10 号的后继节点为 &#x3D;  &quot;+ node5Right);        &#x2F;&#x2F; 测试遍历线索化二叉树        threadedBinaryTree.threadedList();    &#125;&#125;&#x2F;&#x2F; 创建二叉树class ThreadedBinaryTree&#123;    private HeroNode root;    &#x2F;&#x2F; 前驱结点    private HeroNode pre &#x3D; null;    public void setRoot(HeroNode root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 重载threadedNode    public void threadedNode()&#123;        this.threadedNode(root);    &#125;    &#x2F;&#x2F; 线索化二叉树中序遍历    &#x2F;**     *     * @param node 就是当前需要线索化的结点     *&#x2F;    public void threadedNode(HeroNode node)&#123;        &#x2F;&#x2F; 如果当前结点为空，直接返回        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        &#x2F;&#x2F; 先线索化左子树        threadedNode(node.getLeft());        &#x2F;&#x2F; 输出当前结点        &#x2F;&#x2F; 处理前驱结点        if (node.getLeft() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 如果当前结点的左结点为空，则指向前驱结点            node.setLeft(pre);            &#x2F;&#x2F; 设置当前节点的类型,1：前驱结点            node.setLeftType(1);        &#125;        &#x2F;&#x2F; 处理后继节点，node下移一位后再处理后继节点        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 设置后继节点            pre.setRight(node);            &#x2F;&#x2F; 设置类型，后继节点            pre.setRightType(1);        &#125;        &#x2F;&#x2F; !!!每处理一个节点，让当前节点是下一个结点的前驱结点        pre &#x3D; node;        &#x2F;&#x2F; 再线索化右子树        threadedNode(node.getRight());    &#125;&#125;&#x2F;&#x2F; 创建英雄结点class HeroNode&#123;    private int id;    private String name;    private HeroNode left;  &#x2F;&#x2F; 默认为空    private HeroNode right; &#x2F;&#x2F; 默认为空    &#x2F;&#x2F; leftType &#x3D;&#x3D; 0表示是左子树，1表示是前驱结点    private int leftType;    &#x2F;&#x2F; rightType &#x3D;&#x3D; 0表示是右子树，1表示是后继节点    private int rightType;    public int getLeftType() &#123;        return leftType;    &#125;    public void setLeftType(int leftType) &#123;        this.leftType &#x3D; leftType;    &#125;    public int getRightType() &#123;        return rightType;    &#125;    public void setRightType(int rightType) &#123;        this.rightType &#x3D; rightType;    &#125;    public HeroNode(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h3 id="10-3-4-遍历线索化二叉树"><a href="#10-3-4-遍历线索化二叉树" class="headerlink" title="10.3.4 遍历线索化二叉树"></a>10.3.4 遍历线索化二叉树</h3><ol><li>说明：对前面的中序线索化的二叉树， 进行遍历</li><li>分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。</li><li>代码</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree.threadedbinarytree;public class ThreadedBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建结点        HeroNode root &#x3D; new HeroNode(1, &quot;tom&quot;);        HeroNode node2 &#x3D; new HeroNode(3, &quot;jack&quot;);        HeroNode node3 &#x3D; new HeroNode(6, &quot;smith&quot;);        HeroNode node4 &#x3D; new HeroNode(8, &quot;milan&quot;);        HeroNode node5 &#x3D; new HeroNode(10, &quot;dim&quot;);        HeroNode node6 &#x3D; new HeroNode(14, &quot;mary&quot;);        &#x2F;&#x2F; 构建二叉树        root.setLeft(node2);        root.setRight(node3);        node2.setLeft(node4);        node2.setRight(node5);        node3.setLeft(node6);        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();        threadedBinaryTree.setRoot(root);        &#x2F;&#x2F; 线索化        threadedBinaryTree.threadedNode();        &#x2F;&#x2F; 测试中序遍历线索化二叉树        threadedBinaryTree.threadedList();    &#125;&#125;&#x2F;&#x2F; 创建二叉树class ThreadedBinaryTree&#123;    private HeroNode root;    &#x2F;&#x2F; 前驱结点    private HeroNode pre &#x3D; null;    public void setRoot(HeroNode root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 遍历线索化二叉树    public void threadedList()&#123;        &#x2F;&#x2F; 定义一个指针，辅助遍历        HeroNode node &#x3D; root;        &#x2F;&#x2F; 如果当前的node不为空，一直遍历        while (node !&#x3D; null)&#123;            &#x2F;&#x2F; 中序遍历，先左子树            &#x2F;&#x2F; 也就是找到leftType &#x3D;&#x3D; 1(前驱结点)的时候退出循环，将其输出            while (node.getLeftType() &#x3D;&#x3D; 0)&#123;                &#x2F;&#x2F; leftType等于0时，一直找                node &#x3D; node.getLeft();            &#125;            &#x2F;&#x2F; 打印当前结点            System.out.println(node);            &#x2F;&#x2F; 如果当前的结点的指针指的是后继结点，就一直输出            while (node.getRightType() &#x3D;&#x3D; 1)&#123;                node &#x3D; node.getRight();                System.out.println(node);            &#125;            &#x2F;&#x2F; 替换遍历这个结点            node &#x3D; node.getRight();        &#125;    &#125;&#125;&#x2F;&#x2F; 创建英雄结点class HeroNode&#123;    private int id;    private String name;    private HeroNode left;  &#x2F;&#x2F; 默认为空    private HeroNode right; &#x2F;&#x2F; 默认为空    &#x2F;&#x2F; leftType &#x3D;&#x3D; 0表示是左子树，1表示是前驱结点    private int leftType;    &#x2F;&#x2F; rightType &#x3D;&#x3D; 0表示是右子树，1表示是后继节点    private int rightType;    public int getLeftType() &#123;        return leftType;    &#125;    public void setLeftType(int leftType) &#123;        this.leftType &#x3D; leftType;    &#125;    public int getRightType() &#123;        return rightType;    &#125;    public void setRightType(int rightType) &#123;        this.rightType &#x3D; rightType;    &#125;    public HeroNode(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h3 id="10-3-5-线索二叉树应用案例"><a href="#10-3-5-线索二叉树应用案例" class="headerlink" title="10.3.5 线索二叉树应用案例"></a>10.3.5 线索二叉树应用案例</h3><p>课后作业:<br>我这里讲解了中序线索化二叉树，前序线索化二叉树和后序线索化二叉树的分析思路类似，同学们作为课后作业完成.</p><p>后序遍历线索化二叉树不会</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree.threadedbinarytree;public class ThreadedBinaryTreeDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建结点        HeroNode root &#x3D; new HeroNode(1, &quot;tom&quot;);        HeroNode node2 &#x3D; new HeroNode(3, &quot;jack&quot;);        HeroNode node3 &#x3D; new HeroNode(6, &quot;smith&quot;);        HeroNode node4 &#x3D; new HeroNode(8, &quot;milan&quot;);        HeroNode node5 &#x3D; new HeroNode(10, &quot;dim&quot;);        HeroNode node6 &#x3D; new HeroNode(14, &quot;mary&quot;);        &#x2F;&#x2F; 构建二叉树        root.setLeft(node2);        root.setRight(node3);        node2.setLeft(node4);        node2.setRight(node5);        node3.setLeft(node6);        ThreadedBinaryTree threadedBinaryTree &#x3D; new ThreadedBinaryTree();        threadedBinaryTree.setRoot(root);        &#x2F;&#x2F; 中序线索化        &#x2F;&#x2F;threadedBinaryTree.threadedInfixNode();&#x2F;*        &#x2F;&#x2F; 以10号结点测试中序线索化        HeroNode node5Left &#x3D; node5.getLeft();        System.out.println(&quot;10号的中序线索化前驱结点 &#x3D; &quot; + node5Left);*&#x2F;        &#x2F;&#x2F; 测试中序遍历线索化二叉树        &#x2F;&#x2F;threadedBinaryTree.threadedList();        &#x2F;&#x2F; 测试前序线索化二叉树&#x2F;*        threadedBinaryTree.threadedPreNode(root);        HeroNode node5LeftPre &#x3D; node5.getLeft();        System.out.println(&quot;10号前序线索化前驱结点 &#x3D; &quot; + node5LeftPre);        &#x2F;&#x2F; 前序遍历二叉树        threadedBinaryTree.threadedPreList();*&#x2F;        &#x2F;&#x2F; 测试后序线索化二叉树        threadedBinaryTree.threadedPostNode(root);        HeroNode node5RightPost &#x3D; node5.getRight();        System.out.println(&quot;后序线索化10号的后继结点 &#x3D; &quot; + node5RightPost);        &#x2F;&#x2F; 后序遍历线索化二叉树        threadedBinaryTree.threadedPostList();    &#125;&#125;&#x2F;&#x2F; 创建二叉树class ThreadedBinaryTree&#123;    private HeroNode root;    &#x2F;&#x2F; 前驱结点    private HeroNode pre &#x3D; null;    public void setRoot(HeroNode root) &#123;        this.root &#x3D; root;    &#125;    &#x2F;&#x2F; 后序遍历线索化二叉树       &#x2F;&#x2F; 后序线索化二叉树    public void threadedPostNode(HeroNode node)&#123;        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        &#x2F;&#x2F; 先递归线索化左子树        threadedPostNode(node.getLeft());        &#x2F;&#x2F; 右子树        threadedPostNode(node.getRight());        &#x2F;&#x2F; 再处理当前的        &#x2F;&#x2F; 前驱结点        if (node.getLeft() &#x3D;&#x3D; null)&#123;            node.setLeft(pre);            node.setLeftType(1);        &#125;        &#x2F;&#x2F; 后继结点        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null)&#123;            pre.setRight(node);            pre.setRightType(1);        &#125;        pre &#x3D; node;    &#125;    &#x2F;&#x2F; 前序遍历线索化二叉树    public void threadedPreList()&#123;        HeroNode node &#x3D; root;        while (node !&#x3D; null)&#123;            &#x2F;&#x2F; 先输出当前            System.out.println(node);            &#x2F;&#x2F; 处理左子树            while (node.getLeftType() &#x3D;&#x3D; 0)&#123;                node &#x3D; node.getLeft();                System.out.println(node);            &#125;            &#x2F;&#x2F; 处理右子树            while (node.getRightType() &#x3D;&#x3D; 1)&#123;                node &#x3D; node.getRight();                System.out.println(node);            &#125;            node &#x3D; node.getRight();        &#125;    &#125;    &#x2F;**     * 前序线索化二叉树     * @param node 当前要线索化的结点     *&#x2F;    public void threadedPreNode(HeroNode node)&#123;        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        &#x2F;&#x2F; 处理当前的        &#x2F;&#x2F; 前驱结点        if (node.getLeft() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 设置前驱结点            node.setLeft(pre);            &#x2F;&#x2F; 更改结点类型            node.setLeftType(1);        &#125;        &#x2F;&#x2F; 处理后继结点        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 设置后继结点            pre.setRight(node);            &#x2F;&#x2F; 设置类型            pre.setRightType(1);        &#125;        &#x2F;&#x2F; 每处理完一个，就让当前结点是下一个结点的前驱结点        pre &#x3D; node;        &#x2F;&#x2F; 前序递归左子树，先判断是否是左子树再进行递归        if (node.getLeftType() &#x3D;&#x3D; 0)&#123;            threadedPreNode(node.getLeft());        &#125;        &#x2F;&#x2F; 前序递归右子树        if (node.getRightType() &#x3D;&#x3D; 0)&#123;            threadedPreNode(node.getRight());        &#125;    &#125;    &#x2F;&#x2F; 中序遍历线索化二叉树    public void threadedList()&#123;        &#x2F;&#x2F; 定义一个指针，辅助遍历        HeroNode node &#x3D; root;        &#x2F;&#x2F; 如果当前的node不为空，一直遍历        while (node !&#x3D; null)&#123;            &#x2F;&#x2F; 中序遍历，先左子树            &#x2F;&#x2F; 也就是找到leftType &#x3D;&#x3D; 1(前驱结点)的时候退出循环，将其输出            while (node.getLeftType() &#x3D;&#x3D; 0)&#123;                &#x2F;&#x2F; leftType等于0时，一直找                node &#x3D; node.getLeft();            &#125;            &#x2F;&#x2F; 打印当前结点            System.out.println(node);            &#x2F;&#x2F; 如果当前的结点的指针指的是后继结点，就一直输出            while (node.getRightType() &#x3D;&#x3D; 1)&#123;                node &#x3D; node.getRight();                System.out.println(node);            &#125;            &#x2F;&#x2F; 替换遍历这个结点            node &#x3D; node.getRight();        &#125;    &#125;    &#x2F;&#x2F; 重载threadedInfixNode    public void threadedInfixNode()&#123;        this.threadedInfixNode(root);    &#125;    &#x2F;&#x2F; 中序线索二叉树    &#x2F;**     *     * @param node 就是当前需要线索化的结点     *&#x2F;    public void threadedInfixNode(HeroNode node)&#123;        &#x2F;&#x2F; 如果当前结点为空，直接返回        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        &#x2F;&#x2F; 先线索化左子树        threadedInfixNode(node.getLeft());        &#x2F;&#x2F; 输出当前结点        &#x2F;&#x2F; 处理前驱结点        if (node.getLeft() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 如果当前结点的左结点为空，则指向前驱结点            node.setLeft(pre);            &#x2F;&#x2F; 设置当前节点的类型,1：前驱结点            node.setLeftType(1);        &#125;        &#x2F;&#x2F; 处理后继节点，node下移一位后再处理后继节点        if (pre !&#x3D; null &amp;&amp; pre.getRight() &#x3D;&#x3D; null)&#123;            &#x2F;&#x2F; 设置后继节点            pre.setRight(node);            &#x2F;&#x2F; 设置类型，后继节点            pre.setRightType(1);        &#125;        &#x2F;&#x2F; !!!每处理一个节点，让当前节点是下一个结点的前驱结点        pre &#x3D; node;        &#x2F;&#x2F; 再线索化右子树        threadedInfixNode(node.getRight());    &#125;&#125;&#x2F;&#x2F; 创建英雄结点class HeroNode&#123;    private int id;    private String name;    private HeroNode left;  &#x2F;&#x2F; 默认为空    private HeroNode right; &#x2F;&#x2F; 默认为空    &#x2F;&#x2F; leftType &#x3D;&#x3D; 0表示是左子树，1表示是前驱结点    private int leftType;    &#x2F;&#x2F; rightType &#x3D;&#x3D; 0表示是右子树，1表示是后继节点    private int rightType;    public int getLeftType() &#123;        return leftType;    &#125;    public void setLeftType(int leftType) &#123;        this.leftType &#x3D; leftType;    &#125;    public int getRightType() &#123;        return rightType;    &#125;    public void setRightType(int rightType) &#123;        this.rightType &#x3D; rightType;    &#125;    public HeroNode(int id, String name) &#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public HeroNode getLeft() &#123;        return left;    &#125;    public void setLeft(HeroNode left) &#123;        this.left &#x3D; left;    &#125;    public HeroNode getRight() &#123;        return right;    &#125;    public void setRight(HeroNode right) &#123;        this.right &#x3D; right;    &#125;    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;id&#x3D;&quot; + id +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h1 id="第11章-树结构实际应用"><a href="#第11章-树结构实际应用" class="headerlink" title="第11章 树结构实际应用"></a>第11章 树结构实际应用</h1><h2 id="11-1-堆排序"><a href="#11-1-堆排序" class="headerlink" title="11.1 堆排序"></a>11.1 堆排序</h2><h3 id="11-1-1-堆排序基本介绍"><a href="#11-1-1-堆排序基本介绍" class="headerlink" title="11.1.1 堆排序基本介绍"></a>11.1.1 堆排序基本介绍</h3><ol><li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</li><li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</li><li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li><li>大顶堆举例说明</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211210202023265.png" alt="image-20211210202023265"></p><ol start="5"><li> 小顶堆举例说明</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211210202059287.png" alt="image-20211210202059287"></p><ol start="6"><li>一般升序采用大顶堆，降序采用小顶堆 </li></ol><h3 id="11-1-2-堆排序基本思想"><a href="#11-1-2-堆排序基本思想" class="headerlink" title="11.1.2 堆排序基本思想"></a>11.1.2 堆排序基本思想</h3><ol><li>堆排序的基本思想是：<br>将待排序序列构造成一个大顶堆</li><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li><li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li></ol><p>可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p><h3 id="11-1-3-堆排序步骤图解说明"><a href="#11-1-3-堆排序步骤图解说明" class="headerlink" title="11.1.3 堆排序步骤图解说明"></a>11.1.3 堆排序步骤图解说明</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p><p><strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong></p><ol><li>.假设给定无序序列结构如下</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120032217.png" alt="image-20211211120032217"></p><ol start="2"><li>.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120043666.png" alt="image-20211211120043666"></p><ol start="3"><li>.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120051781.png" alt="image-20211211120051781"></p><ol start="4"><li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120136657.png" alt="image-20211211120136657"></p><p>此时，我们就将一个无序序列构造成了一个大顶堆。</p><p><strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></p><ol><li>.将堆顶元素9和末尾元素4进行交换</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120148685.png" alt="image-20211211120148685"></p><ol start="2"><li>.重新调整结构，使其继续满足堆定义</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120158571.png" alt="image-20211211120158571"></p><ol start="3"><li>.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120207009.png" alt="image-20211211120207009"></p><ol start="4"><li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120215701.png" alt="image-20211211120215701"></p><p><strong>再简单总结下堆排序的基本思路：</strong></p><p>​        <strong>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p><p>　　<strong>2).将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p><p>　　<strong>3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><h3 id="11-1-4-堆排序代码实现"><a href="#11-1-4-堆排序代码实现" class="headerlink" title="11.1.4 堆排序代码实现"></a>11.1.4 堆排序代码实现</h3><p>要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。</p><p>代码实现：看老师演示: </p><p>说明：</p><ol><li>堆排序不是很好理解，老师通过Debug 帮助大家理解堆排序</li><li>堆排序的速度非常快，在我的机器上 8百万数据 3 秒左右。O(nlogn) </li><li>代码实现</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class HeapSort &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int[] arr &#x3D; &#123;4,6,8,5,9,-1,195,359,-9000&#125;;        int [] arr &#x3D; new int[8000000];        for (int i &#x3D; 0; i &lt; 8000000; i++)&#123;            arr[i] &#x3D; (int) (Math.random()*80000);       &#x2F;&#x2F; [0,80000)的随机数字        &#125;        Date date1 &#x3D; new Date();        SimpleDateFormat simpleDateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String date1Str &#x3D; simpleDateFormat.format(date1);        System.out.println(&quot;开始排序前时间：&quot;+date1Str);        heapSort(arr);        Date date2 &#x3D; new Date();        String date2Str &#x3D; simpleDateFormat.format(date2);        System.out.println(&quot;开始排序后时间：&quot;+date2Str);    &#x2F;&#x2F; 约2秒*&#x2F;        &#x2F;&#x2F;System.out.println(Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 堆排序    public static void heapSort(int arr[])&#123;        int temp &#x3D; 0;        &#x2F;&#x2F;System.out.println(&quot;堆排序！！&quot;);&#x2F;*        adjustHeap(arr,1,arr.length);        System.out.println(&quot;第一次：&quot; + Arrays.toString(arr));  &#x2F;&#x2F; 4,9,8,5,6        adjustHeap(arr,0,arr.length);        System.out.println(&quot;第二次：&quot; + Arrays.toString(arr));  &#x2F;&#x2F; 9,6,8,5,4*&#x2F;        &#x2F;&#x2F; 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;        for (int i &#x3D; arr.length &#x2F;2 - 1; i &gt;&#x3D; 0; i-- )&#123;            adjustHeap(arr,i,arr.length);        &#125;        &#x2F;&#x2F;System.out.println(&quot;数组：&quot; + Arrays.toString(arr));        &#x2F;&#x2F; 将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;        &#x2F;&#x2F; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。        for (int j &#x3D; arr.length - 1; j &gt;&#x3D; 0; j--)&#123;            temp &#x3D; arr[j];            arr[j] &#x3D; arr[0];            arr[0] &#x3D; temp;            adjustHeap(arr,0,j);        &#125;        &#x2F;&#x2F;System.out.println(Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 构建一个大顶堆    &#x2F;**     *     * @param arr       需要构建大顶堆的数组（二叉树）     * @param i         表示非叶子结点在数组中的索引     * @param length    表示对多少个元素继续调整，length是逐渐减少的     *&#x2F;    public static void adjustHeap(int arr[], int i, int length)&#123;        &#x2F;&#x2F; 先保存当前的元素，临时变量        int temp &#x3D; arr[i];        &#x2F;&#x2F; int k &#x3D; 2 * i + 1 这个就是i结点的左子结点        for (int k &#x3D; 2 * i + 1; k &lt; length; k &#x3D; 2 * k + 1)&#123;            &#x2F;&#x2F; 比较左右结点的值的大小            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k+1])&#123;                &#x2F;&#x2F; 如果右结点的大，让k指向右结点                k++;            &#125;            if (arr[k] &gt; temp)&#123;                &#x2F;&#x2F; 如果arr[k] &gt; 父节点的temp值，则将arr[k]的值放到父节点                arr[i] &#x3D; arr[k];                i &#x3D; k;  &#x2F;&#x2F; 让i指向k            &#125; else &#123;                &#x2F;&#x2F; 如果arr[k] 小于temp，则直接break                break;            &#125;        &#125;        &#x2F;&#x2F; 当for循环结束之后，我们已经将以i为父结点的最大值放在了顶堆上面（局部），        arr[i] &#x3D; temp;  &#x2F;&#x2F; 将temp的值放到调整后的位置    &#125;&#125;</code></pre></div><h3 id="堆排序复盘代码"><a href="#堆排序复盘代码" class="headerlink" title="堆排序复盘代码"></a>堆排序复盘代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.tree.practice;import java.util.Arrays;public class TestHeapSort &#123;    public static void main(String[] args) &#123;        int [] arr &#x3D; &#123;5,4,6,3,9&#125;;        heapSort(arr);        System.out.println(&quot;堆排序后的数组：&quot; + Arrays.toString(arr));    &#125;    &#x2F;&#x2F; 堆排序    public static void heapSort(int arr[])&#123;        int temp &#x3D; 0;        &#x2F;&#x2F; 将无序序列构建成一个堆，按照规则构建成大顶堆或者小顶堆        for (int i &#x3D; arr.length &#x2F; 2 - 1; i &gt;&#x3D; 0; i--)&#123;            adjustHeap(arr,i,arr.length);        &#125;        &#x2F;&#x2F; 将大的数据放在数组最后        for (int j &#x3D; arr.length - 1; j &gt;&#x3D; 0; j--)&#123;            &#x2F;&#x2F; 交换            temp &#x3D; arr[j];            arr[j] &#x3D; arr[0];            arr[0] &#x3D; temp;            &#x2F;&#x2F; 将剩下的数据，继续构建大顶堆，完成排序，i的下标从0开始            adjustHeap(arr,0,j);        &#125;    &#125;    &#x2F;&#x2F; 构建大顶堆    &#x2F;**     *     * @param arr       需要构建大顶堆的数组（二叉树）     * @param i         第一个非叶子结点的索引     * @param length    数组的长度，逐渐减少     *&#x2F;    public static void adjustHeap(int []arr,int i ,int length)&#123;        int temp &#x3D; arr[i];        &#x2F;&#x2F; 先找到i结点左右结点        for (int k &#x3D; 2 * i + 1; k &lt; length; k &#x3D; 2 * k + 1)&#123;            &#x2F;&#x2F; 比较左右结点的大小            if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k+1])&#123;                &#x2F;&#x2F; 将指针定位到较大的右结点                k++;            &#125;            &#x2F;&#x2F; 比较arr[k]与temp的大小            if (arr[k] &gt; temp)&#123;                &#x2F;&#x2F; 将k为索引的值放到父结点上                arr[i] &#x3D; arr[k];                &#x2F;&#x2F; 将i指向k                i &#x3D; k;            &#125; else &#123;                &#x2F;&#x2F; 如果arr[k] &lt; temp，直接break                break;            &#125;        &#125;        &#x2F;&#x2F; 结束for循环后，将temp归位,这时的i已经指向k的位置        arr[i] &#x3D; temp;    &#125;&#125;</code></pre></div><h2 id="11-2-赫夫曼树"><a href="#11-2-赫夫曼树" class="headerlink" title="11.2 赫夫曼树"></a>11.2 赫夫曼树</h2><h3 id="11-2-1-基本介绍"><a href="#11-2-1-基本介绍" class="headerlink" title="11.2.1 基本介绍"></a>11.2.1 基本介绍</h3><ol><li><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。</p></li><li><p>赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p></li></ol><h3 id="11-2-2-赫夫曼树几个重要概念和举例说明"><a href="#11-2-2-赫夫曼树几个重要概念和举例说明" class="headerlink" title="11.2.2 赫夫曼树几个重要概念和举例说明"></a>11.2.2 赫夫曼树几个重要概念和举例说明</h3><ol><li>路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1</li><li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</li><li><strong>树的带权路径长度：</strong>树的带权路径长度规定为所有<strong>叶子结点</strong>的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li><li><strong>WPL</strong>最小的就是赫夫曼树</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120539293.png" alt="image-20211211120539293"></p><h3 id="11-2-3-赫夫曼树创建思路图解"><a href="#11-2-3-赫夫曼树创建思路图解" class="headerlink" title="11.2.3 赫夫曼树创建思路图解"></a>11.2.3 赫夫曼树创建思路图解</h3><p>给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树.</p><p>思路分析(示意图)：</p><p>{13, 7, 8, 3, 29, 6, 1}  </p><p>构成赫夫曼树的步骤：</p><ol><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出根节点权值最小的两颗二叉树 </li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li><li>图解</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211120725316.png" alt="image-20211211120725316"></p><h3 id="11-2-4-赫夫曼树的代码实现"><a href="#11-2-4-赫夫曼树的代码实现" class="headerlink" title="11.2.4 赫夫曼树的代码实现"></a>11.2.4 赫夫曼树的代码实现</h3><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.huffmantree;import com.sun.istack.internal.NotNull;import java.util.ArrayList;import java.util.Collections;public class HuffmanTree &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;13, 7, 8, 3, 29, 6, 1&#125;;        Node root &#x3D; createHuffmanTree(arr);        preOrder(root);    &#125;    &#x2F;&#x2F; 前序遍历    public static void preOrder(Node root)&#123;        if (root !&#x3D; null)&#123;            root.preOrder();        &#125; else &#123;            System.out.println(&quot;树为空，不能遍历&quot;);        &#125;    &#125;    &#x2F;&#x2F; 创建赫夫曼树    public static Node createHuffmanTree(int arr[])&#123;        &#x2F;&#x2F; 为了操作方便，将arr中的每一个元素放到node中，将node放到ArrList集合中        ArrayList&lt;Node&gt; nodes &#x3D; new ArrayList&lt;&gt;();        for (int node : arr) &#123;            nodes.add(new Node(node));        &#125;        while (nodes.size() &gt; 1)&#123;            &#x2F;&#x2F; 排序            Collections.sort(nodes);            &#x2F;&#x2F;System.out.println(nodes);            &#x2F;&#x2F; 将最小的两个值，构建成一颗二叉树            Node leftNode &#x3D; nodes.get(0);            Node rightNode &#x3D; nodes.get(1);            Node parent &#x3D; new Node(leftNode.value + rightNode.value);            parent.left &#x3D; leftNode;            parent.right &#x3D; rightNode;            &#x2F;&#x2F; 将原来在数组的结点删除，并加入父结点            nodes.remove(leftNode);            nodes.remove(rightNode);            nodes.add(parent);            &#x2F;&#x2F;System.out.println(nodes);        &#125;        return nodes.get(0);    &#125;&#125;&#x2F;&#x2F; 创建结点class Node implements Comparable&lt;Node&gt;&#123;    int value;      &#x2F;&#x2F; 权值    Node left;      &#x2F;&#x2F; 左结点    Node right;     &#x2F;&#x2F; 右结点    public Node(int value) &#123;        this.value &#x3D; value;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        System.out.println(this);        if (this.left !&#x3D; null)&#123;            this.left.preOrder();        &#125;        if (this.right !&#x3D; null)&#123;            this.right.preOrder();        &#125;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;value&#x3D;&quot; + value +                &#39;&#125;&#39;;    &#125;    @Override    public int compareTo(Node o) &#123;        &#x2F;&#x2F; 从小到大排序        return this.value - o.value;    &#125;&#125;</code></pre></div><h2 id="11-3赫夫曼编码"><a href="#11-3赫夫曼编码" class="headerlink" title="11.3赫夫曼编码"></a>11.3赫夫曼编码</h2><h3 id="11-3-1-基本介绍"><a href="#11-3-1-基本介绍" class="headerlink" title="11.3.1 基本介绍"></a>11.3.1 基本介绍</h3><ol><li>赫夫曼编码也翻译为    哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</li><li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。</li><li>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</li><li>赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码</li></ol><h3 id="11-3-2-原理剖析"><a href="#11-3-2-原理剖析" class="headerlink" title="11.3.2 原理剖析"></a>11.3.2 原理剖析</h3><ul><li>通信领域中信息的处理方式1-定长编码</li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211162735895.png" alt="image-20211211162735895"></p><ul><li>通信领域中信息的处理方式2-变长编码</li></ul><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211162800442.png" alt="image-20211211162800442"></p><ul><li>通信领域中信息的处理方式3-赫夫曼编码</li></ul><p>传输的 字符串 </p><ol><li><p>i like like like java do you like a java  </p></li><li><p>d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9 // 各个字符对应的个数</p></li><li><p>按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 </p></li></ol><p>步骤：</p><p>构成赫夫曼树的步骤：</p><ol><li><p>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</p></li><li><p>取出根节点权值最小的两颗二叉树 </p></li><li><p>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 </p></li><li><p>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211162911824.png" alt="image-20211211162911824"></p><ol start="4"><li>根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为0 向右的路径为1 ， 编码如下:</li></ol><p>o: 1000  u: 10010 d: 100110 y: 100111 i: 101</p><p>a : 110   k: 1110  e: 1111    j: 0000    v: 0001</p><p>l: 001     : 01</p><ol start="5"><li>按照上面的赫夫曼编码，我们的”i like like like java do you like a java”  字符串对应的编码为 (注意这里我们使用的无损压缩)</li></ol><p>101010010111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110 通过赫夫曼编码处理 长度为 133</p><p>6） 长度为 ： 133 </p><p>说明:</p><p>原来长度是 359 , 压缩了 (359-133) / 359 = 62.9%</p><p>此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性</p><p>赫夫曼编码是无损处理方案</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，<strong>这样对应的赫夫曼编码也不完全一样</strong>，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为:</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211211163053930.png" alt="image-20211211163053930"></p><h3 id="11-3-3-最佳实践-数据压缩-创建赫夫曼树"><a href="#11-3-3-最佳实践-数据压缩-创建赫夫曼树" class="headerlink" title="11.3.3 最佳实践-数据压缩(创建赫夫曼树)"></a>11.3.3 最佳实践-数据压缩(创建赫夫曼树)</h3><p>将给出的一段文本，比如 “i like like like java do you like a java” ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ，形式如 “1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110<br>“ </p><p>步骤1：根据赫夫曼编码压缩数据的原理，需要创建 “i like like like java do you like a java” 对应的赫夫曼树.</p><p>思路：前面已经分析过了，而且我们已然讲过了构建赫夫曼树的具体实现。<br>代码实现：看老师演示:</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建赫夫曼树    private static Node createHuffmanTree(List&lt;Node&gt; nodes)&#123;        while (nodes.size() &gt; 1)&#123;            &#x2F;&#x2F; 将传进来的集合排序，从小到大            Collections.sort(nodes);            &#x2F;&#x2F; 取出最小和次小的两个数组成一颗二叉树            Node leftNode &#x3D; nodes.get(0);            Node rightNode &#x3D; nodes.get(1);            Node parent &#x3D; new Node(null,leftNode.weight + rightNode.weight);            parent.left &#x3D; leftNode;            parent.right &#x3D; rightNode;            &#x2F;&#x2F; 将已经处理好的结点从集合中去掉            nodes.remove(leftNode);            nodes.remove(rightNode);            &#x2F;&#x2F; 将新构成的父结点加入到nodes集合中            nodes.add(parent);        &#125;        &#x2F;&#x2F; 重复上面的步骤，最后将剩下的父结点返回        return nodes.get(0);    &#125;</code></pre></div><h3 id="11-3-4-生成赫夫曼编码和赫夫曼编码后的数据"><a href="#11-3-4-生成赫夫曼编码和赫夫曼编码后的数据" class="headerlink" title="11.3.4 生成赫夫曼编码和赫夫曼编码后的数据"></a>11.3.4 生成赫夫曼编码和赫夫曼编码后的数据</h3><p>我们已经生成了 赫夫曼树, 下面我们继续完成任务<br>生成赫夫曼树对应的赫夫曼编码  , 如下表:=01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000 o=0011<br>使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将”i like like like java do you like a java”   字符串生成对应的编码数据, 形式如下.1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100<br>思路：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。<br>代码实现：看老师演示:</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 编写一个方法，将字符串对应的byte[] 数组，根据赫夫曼编码，返回一个经过赫夫曼编码压缩的一个byte[]   &#x2F;**    *    * @param bytes         字符串数组对应的bytes数组    * @param huffmanCodes   赫夫曼编码    * @return              返回以经过赫夫曼编译压缩的byte数组    *&#x2F;   private static byte[] zip (byte[] bytes, Map&lt;Byte,String&gt; huffmanCodes)&#123;       &#x2F;&#x2F; 传进来的byte[]数组转成赫夫曼编码对应的字符串       StringBuilder stringBuilder &#x3D; new StringBuilder();       for (byte b : bytes) &#123;           stringBuilder.append(huffmanCodes.get(b));       &#125;       &#x2F;&#x2F; 10101000101111111100100010111111110010001011111111001001010....       &#x2F;&#x2F; System.out.println(stringBuilder);       &#x2F;&#x2F; 将赫夫曼编码对应的字符串，分成8位一个，统计分成了多少个len，根据len创建byte[]       int len;       if (stringBuilder.length() % 8 &#x3D;&#x3D; 0)&#123;           len &#x3D; stringBuilder.length() &#x2F; 8;       &#125; else &#123;           len &#x3D; stringBuilder.length() &#x2F; 8 + 1;       &#125;       byte[] huffmanCodesBytes &#x3D; new byte[len];       &#x2F;&#x2F; 遍历生成的字符串数组，将数据加到huffmanCodesBytes中       int index &#x3D; 0;  &#x2F;&#x2F; huffmanCodesBytes数组的下标       for (int i &#x3D; 0; i &lt; stringBuilder.length(); i +&#x3D; 8)&#123;           String strByte;           if (i + 8 &gt; stringBuilder.length())&#123;               &#x2F;&#x2F; 如果超过了StringBuilder的长度，则将后面的字符串直接加入即可               strByte &#x3D; stringBuilder.substring(i);           &#125; else &#123;               &#x2F;&#x2F; 如果没超过，则8位一个加入strByte中               strByte &#x3D; stringBuilder.substring(i, i + 8);           &#125;           &#x2F;&#x2F; 将strByte转成byte放到huffmanCodeBytes中           huffmanCodesBytes[index] &#x3D; (byte) Integer.parseInt(strByte,2);           index++;       &#125;       return huffmanCodesBytes;   &#125;   &#x2F;&#x2F; 生成赫夫曼树对应的赫夫曼编码   &#x2F;&#x2F; 将赫夫曼编码存放在map中   static Map&lt;Byte,String&gt; huffmanCodes &#x3D; new HashMap&lt;&gt;();   &#x2F;&#x2F; 生成的赫夫曼编码表示，需要去拼接路径   static StringBuilder stringBuilder &#x3D; new StringBuilder();   &#x2F;&#x2F; 为了调用方便，重载getCodes，   private static Map&lt;Byte,String&gt; getCodes(Node root)&#123;       if (root &#x3D;&#x3D; null)&#123;           return null;       &#125;       &#x2F;&#x2F; 处理左子树       getCodes(root.left,&quot;0&quot;,stringBuilder);       &#x2F;&#x2F; 处理右子树       getCodes(root.right,&quot;1&quot;,stringBuilder);       return huffmanCodes;   &#125;   &#x2F;**    * 功能，将传入的node结点的所有叶子结点的赫夫曼编码得到，并放在huffmanCodes中    * @param node 传入的结点    * @param code 路径：0表示左子结点，1表示右子结点    * @param stringBuilder 用于拼接路径    *&#x2F;   private static void getCodes(Node node,String code,StringBuilder stringBuilder)&#123;       StringBuilder stringBuilder2 &#x3D; new StringBuilder(stringBuilder);       &#x2F;&#x2F; 将得到的code加入到StringBuilder2中       stringBuilder2.append(code);       if (node !&#x3D; null)&#123;  &#x2F;&#x2F; 如果node &#x3D;&#x3D; null不处理           &#x2F;&#x2F; 判断是否是非叶子结点           if (node.data &#x3D;&#x3D; null)&#123;               &#x2F;&#x2F; 说明不是非叶子结点，               &#x2F;&#x2F; 向左递归               getCodes(node.left, &quot;0&quot;, stringBuilder2);               &#x2F;&#x2F; 向右递归               getCodes(node.right, &quot;1&quot;, stringBuilder2);           &#125; else &#123;               &#x2F;&#x2F; 说明是一个叶子结点               &#x2F;&#x2F; 表示已经找到某个叶子结点的最后               huffmanCodes.put(node.data,stringBuilder2.toString());           &#125;       &#125;   &#125;</code></pre></div><h3 id="11-3-5-使用赫夫曼编码解码"><a href="#11-3-5-使用赫夫曼编码解码" class="headerlink" title="11.3.5 使用赫夫曼编码解码"></a>11.3.5 使用赫夫曼编码解码</h3><p>使用赫夫曼编码来解码数据，具体要求是</p><p>前面我们得到了赫夫曼编码和对应的编码byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</p><p>现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串”i like like like java do you like a java”</p><p>思路：解码过程，就是编码的一个逆向操作。</p><p>代码实现：看老师演示:</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 解码：    * 1.将传进来的已经经过赫夫曼编码表处理过的byte字节数组转成对应的二进制    * 2.把原来的赫夫曼编码表反转，如，原来：a -&gt; 97 反转后：97 -&gt; a    * 3.根据反转后的赫夫曼编码，遍历生成的二进制字符串，进行解码    * @param huffmanCodes 赫夫曼编码表 map    * @param huffmanBytes 经过赫夫曼编码表处理过的字节数组    * @return  返回的是原来字符串对应的数组    *&#x2F;   private static byte[] decode(Map&lt;Byte,String&gt; huffmanCodes, byte[] huffmanBytes)&#123;       &#x2F;&#x2F; 先获得huffmanBytes对应的二进制       StringBuilder stringBuilder &#x3D; new StringBuilder();       &#x2F;&#x2F; 将bytes数组转为二进制字符串       for (int i &#x3D; 0; i &lt; huffmanBytes.length; i++) &#123;           &#x2F;&#x2F; 先拿到huffmanBytes的数据           byte b &#x3D; huffmanBytes[i];           &#x2F;&#x2F; 设置一个flag，是否已经到达数组最后，如果已经是最后一个，设为true           boolean flag &#x3D; (i &#x3D;&#x3D; (huffmanBytes.length - 1));           &#x2F;&#x2F; 将遍历得到的b，转换成对应的二进制，并加入到stringBuilder中           stringBuilder.append(byteToBitString(!flag,b));       &#125;       &#x2F;&#x2F; 10101000101111111100100010111111...        &#x2F;&#x2F; System.out.println(&quot;stringBuilder &#x3D; &quot; + stringBuilder);       &#x2F;&#x2F; 根据赫夫曼编码进行解码       &#x2F;&#x2F; 把赫夫曼编码表反转，a -&gt; 97 , 97 -&gt; a       Map&lt;String, Byte&gt; map &#x3D; new HashMap&lt;&gt;();       for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;           map.put(entry.getValue(),entry.getKey());       &#125;       &#x2F;&#x2F; System.out.println(&quot;map &#x3D; &quot; + map);       &#x2F;&#x2F; 遍历stringBuilder，拿到原来的字符       &#x2F;&#x2F; 创建集合，存放byte       List&lt;Byte&gt; list &#x3D; new ArrayList&lt;&gt;();       for (int i &#x3D; 0; i &lt; stringBuilder.length();) &#123;           int count &#x3D; 1;           &#x2F;&#x2F; 小计数器，截取到哪里           boolean flag &#x3D; true;     &#x2F;&#x2F; 循环结束条件           Byte b &#x3D; null;           &#x2F;&#x2F; 定义一个byte来接收遍历出来 的byte字节           &#x2F;&#x2F; 如果flag &#x3D; true 的时候，还没有找到           while (flag)&#123;               &#x2F;&#x2F; 递增的取出key 如第一次1，第二次10，第三次101...               String key &#x3D; stringBuilder.substring(i, i+count); &#x2F;&#x2F; i 不动，count移动               &#x2F;&#x2F; 从取出的key中，和赫夫曼编码表map对比，看看是否匹配               b &#x3D; map.get(key);               &#x2F;&#x2F; 判断b是否为空，如果为空，则不匹配，继续查找               if (b &#x3D;&#x3D; null)&#123;                   count++;               &#125; else &#123;                   &#x2F;&#x2F; 如果匹配了，直接退出循环                   flag &#x3D; false;               &#125;           &#125;           &#x2F;&#x2F; 将字节b加入到list集合中           list.add(b);           &#x2F;&#x2F; 将i指向新的位置count上           i +&#x3D; count;       &#125;       &#x2F;&#x2F; for循环结束后，已经得到了原来的字符串i like like like java do you like a java 的list集合       &#x2F;&#x2F; 将list集合的数据放到byte[]，并返回       byte[] b &#x3D; new byte[list.size()];       for (int i &#x3D; 0; i &lt; b.length; i++) &#123;           b[i] &#x3D; list.get(i);       &#125;       return b;   &#125;   &#x2F;**    * 将一个byte转成一个二进制字符串    * @param flag 标识是是否需要补高位，如果是true，则需要补高位，否则不用，是针对最后一个    * @param b    传入的byte    * @return     是该 b对应的二进制字符串（注意是反码返回）    *&#x2F;   private static String byteToBitString(boolean flag, byte b)&#123;       &#x2F;&#x2F; 将b转成int类型，方便利用Integer类转成对应的二进制       int temp &#x3D; b;       &#x2F;&#x2F; 如果是正数，还要在高位补位       if (flag)&#123;           &#x2F;&#x2F; 如果为true，则需要补位           temp |&#x3D; 256;    &#x2F;&#x2F; 按位与，只有都为0的时候为0，只要有1出现都为1 ，1 0000 0000 | 0000 00001 &#x3D; 1 0000 0001       &#125;       String str &#x3D; Integer.toBinaryString(temp);  &#x2F;&#x2F; 返回的是对应二进制的补码       &#x2F;&#x2F; 如果高位补位了，截取后面8为返回       if (flag)&#123;           return str.substring(str.length() - 8); &#x2F;&#x2F; 截取后面的8为       &#125; else &#123;           &#x2F;&#x2F; 否则直接返回           return str;       &#125;   &#125;</code></pre></div><h3 id="11-3-6-最佳实践-文件压缩"><a href="#11-3-6-最佳实践-文件压缩" class="headerlink" title="11.3.6 最佳实践-文件压缩"></a>11.3.6 最佳实践-文件压缩</h3><p>我们学习了通过赫夫曼编码对一个字符串进行编码和解码, 下面我们来完成对文件的压缩和解压， 具体要求：给你一个图片文件，要求对其进行无损压缩, 看看压缩效果如何。<br>思路：读取文件-&gt; 得到赫夫曼编码表 -&gt; 完成压缩</p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 编写方法，将以文件进行压缩 * @param srcFile 需要压缩的文件路径 * @param dstFile 压缩后的文件存放路径 *&#x2F;private static void zipFile(String srcFile,String dstFile)&#123;    &#x2F;&#x2F; 创建一个输入流    FileInputStream is &#x3D; null;    &#x2F;&#x2F; 输出流    FileOutputStream os &#x3D; null;    ObjectOutputStream oos &#x3D; null;    try &#123;        &#x2F;&#x2F; 创建输出流        is &#x3D; new FileInputStream(srcFile);        &#x2F;&#x2F; 创建一个和原文件大小一样的byte数组        byte[] b &#x3D; new byte[is.available()];        &#x2F;&#x2F; 读取文件        is.read(b);        &#x2F;&#x2F; 直接对源文件压缩        byte[] huffmanBytes &#x3D; huffmanZip(b);        &#x2F;&#x2F; 创建输出流，存放压缩文件        os &#x3D; new FileOutputStream(dstFile);        &#x2F;&#x2F; 创建ObjectOutputStream，方便后面的解压        oos &#x3D; new ObjectOutputStream(os);        &#x2F;&#x2F; 将压缩好的huffmanBytes放入oos中        oos.writeObject(huffmanBytes);        &#x2F;&#x2F; 顺便把赫夫曼编码表也放进去，否则无法解码        oos.writeObject(huffmanCodes);    &#125; catch (IOException e) &#123;        System.out.println(e.getMessage());    &#125; finally &#123;        try &#123;            os.close();            oos.close();            is.close();        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125;    &#125;&#125;</code></pre></div><h3 id="11-3-7-最佳实践-文件解压-文件恢复"><a href="#11-3-7-最佳实践-文件解压-文件恢复" class="headerlink" title="11.3.7 最佳实践-文件解压(文件恢复)"></a>11.3.7 最佳实践-文件解压(文件恢复)</h3><p>具体要求：将前面压缩的文件，重新恢复成原来的文件。<br>思路：读取压缩文件(数据和赫夫曼编码表)-&gt; 完成解压(文件恢复)</p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**    * 编写一个方法，完成对文件的解压    * @param zipFile 准备解压的文件    * @param dstFile 将文件解压到哪个路径    *&#x2F;   private static void unZip(String zipFile, String dstFile)&#123;       &#x2F;&#x2F; 定义文件输入流       InputStream is &#x3D; null;       &#x2F;&#x2F; 定义一个对象输入流       ObjectInputStream ois &#x3D; null;       OutputStream os &#x3D; null;       try &#123;           &#x2F;&#x2F; 创建文件输入流           is &#x3D; new FileInputStream(zipFile);           &#x2F;&#x2F; 创建一个和is关联的对象输入流           ois &#x3D; new ObjectInputStream(is);           &#x2F;&#x2F; 读取huffmanBytes数组           byte[] huffmanBytes &#x3D; (byte[]) ois.readObject();           &#x2F;&#x2F; 读取赫夫曼编码表           Map&lt;Byte,String&gt; huffmanCodes &#x3D; (Map&lt;Byte, String&gt;) ois.readObject();           &#x2F;&#x2F; 解码           byte[] bytes &#x3D; decode(huffmanCodes, huffmanBytes);           &#x2F;&#x2F; 将bytes数组写入目标文件           os &#x3D; new FileOutputStream(dstFile);           os.write(bytes);       &#125; catch (Exception e) &#123;           System.out.println(e.getMessage());       &#125; finally &#123;           try &#123;               os.close();               ois.close();               is.close();           &#125; catch (IOException e) &#123;               System.out.println(e.getMessage());           &#125;       &#125;   &#125;</code></pre></div><h3 id="11-3-8-完整代码"><a href="#11-3-8-完整代码" class="headerlink" title="11.3.8 完整代码"></a>11.3.8 完整代码</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.huffmancode;import java.io.*;import java.util.*;public class HuffmanCode &#123;    public static void main(String[] args) &#123;       &#x2F;* String srcFile &#x3D; &quot;E:\\11\\src.bmp&quot;;        String dstFile &#x3D; &quot;E:\\11\\dst.zip&quot;;        zipFile(srcFile,dstFile);        System.out.println(&quot;压缩成功~~&quot;);*&#x2F;       unZip(&quot;E:\\11\\dst.zip&quot;,&quot;E:\\11\\src1111.bmp&quot;);        System.out.println(&quot;解压成功~&quot;);        &#x2F;*String content &#x3D; &quot;i like like like java do you like a java&quot;;        byte[] contentBytes &#x3D; content.getBytes();        System.out.println(contentBytes.length);    &#x2F;&#x2F; 40        byte[] huffmanCodeBytes &#x3D; huffmanZip(contentBytes);        System.out.println(&quot;huffmanCodeBytes &#x3D; &quot; + Arrays.toString(huffmanCodeBytes));        String str &#x3D; byteToBitString(false,(byte) 1);        System.out.println(str);        byte[] sourceBytes &#x3D; decode(huffmanCodes, huffmanCodeBytes);        System.out.println(&quot;原来的字符串为：&quot; + new String(sourceBytes));*&#x2F;       &#x2F;* &#x2F;&#x2F; 获取nodes集合        List&lt;Node&gt; nodes &#x3D; getNodes(contentBytes);        System.out.println(nodes);        &#x2F;&#x2F; 测试创建的赫夫曼树        System.out.println(&quot;赫夫曼树&quot;);        Node huffmanTreeRoot &#x3D; createHuffmanTree(nodes);        System.out.println(&quot;前序遍历&quot;);        huffmanTreeRoot.preOrder();        getCodes(huffmanTreeRoot);        System.out.println(&quot;生成的赫夫曼编码 &#x3D; &quot; + huffmanCodes);        byte[] huffmanCodeBytes &#x3D; zip(contentBytes, huffmanCodes);        System.out.println(&quot;huffmanCodeBytes &#x3D; &quot; + Arrays.toString(huffmanCodeBytes));*&#x2F;    &#125;    &#x2F;**     * 编写一个方法，完成对文件的解压     * @param zipFile 准备解压的文件     * @param dstFile 将文件解压到哪个路径     *&#x2F;    private static void unZip(String zipFile, String dstFile)&#123;        &#x2F;&#x2F; 定义文件输入流        InputStream is &#x3D; null;        &#x2F;&#x2F; 定义一个对象输入流        ObjectInputStream ois &#x3D; null;        OutputStream os &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建文件输入流            is &#x3D; new FileInputStream(zipFile);            &#x2F;&#x2F; 创建一个和is关联的对象输入流            ois &#x3D; new ObjectInputStream(is);            &#x2F;&#x2F; 读取huffmanBytes数组            byte[] huffmanBytes &#x3D; (byte[]) ois.readObject();            &#x2F;&#x2F; 读取赫夫曼编码表            Map&lt;Byte,String&gt; huffmanCodes &#x3D; (Map&lt;Byte, String&gt;) ois.readObject();            &#x2F;&#x2F; 解码            byte[] bytes &#x3D; decode(huffmanCodes, huffmanBytes);            &#x2F;&#x2F; 将bytes数组写入目标文件            os &#x3D; new FileOutputStream(dstFile);            os.write(bytes);        &#125; catch (Exception e) &#123;            System.out.println(e.getMessage());        &#125; finally &#123;            try &#123;                os.close();                ois.close();                is.close();            &#125; catch (IOException e) &#123;                System.out.println(e.getMessage());            &#125;        &#125;    &#125;    &#x2F;**     * 编写方法，将以文件进行压缩     * @param srcFile 需要压缩的文件路径     * @param dstFile 压缩后的文件存放路径     *&#x2F;    private static void zipFile(String srcFile,String dstFile)&#123;        &#x2F;&#x2F; 创建一个输入流        FileInputStream is &#x3D; null;        &#x2F;&#x2F; 输出流        FileOutputStream os &#x3D; null;        ObjectOutputStream oos &#x3D; null;        try &#123;            &#x2F;&#x2F; 创建输出流            is &#x3D; new FileInputStream(srcFile);            &#x2F;&#x2F; 创建一个和原文件大小一样的byte数组            byte[] b &#x3D; new byte[is.available()];            &#x2F;&#x2F; 读取文件            is.read(b);            &#x2F;&#x2F; 直接对源文件压缩            byte[] huffmanBytes &#x3D; huffmanZip(b);            &#x2F;&#x2F; 创建输出流，存放压缩文件            os &#x3D; new FileOutputStream(dstFile);            &#x2F;&#x2F; 创建ObjectOutputStream，方便后面的解压            oos &#x3D; new ObjectOutputStream(os);            &#x2F;&#x2F; 将压缩好的huffmanBytes放入oos中            oos.writeObject(huffmanBytes);            &#x2F;&#x2F; 顺便把赫夫曼编码表也放进去，否则无法解码            oos.writeObject(huffmanCodes);        &#125; catch (IOException e) &#123;            System.out.println(e.getMessage());        &#125; finally &#123;            try &#123;                os.close();                oos.close();                is.close();            &#125; catch (IOException e) &#123;                System.out.println(e.getMessage());            &#125;        &#125;    &#125;    &#x2F;**     * 解码：     * 1.将传进来的已经经过赫夫曼编码表处理过的byte字节数组转成对应的二进制     * 2.把原来的赫夫曼编码表反转，如，原来：a -&gt; 97 反转后：97 -&gt; a     * 3.根据反转后的赫夫曼编码，遍历生成的二进制字符串，进行解码     * @param huffmanCodes 赫夫曼编码表 map     * @param huffmanBytes 经过赫夫曼编码表处理过的字节数组     * @return  返回的是原来字符串对应的数组     *&#x2F;    private static byte[] decode(Map&lt;Byte,String&gt; huffmanCodes, byte[] huffmanBytes)&#123;        &#x2F;&#x2F; 先获得huffmanBytes对应的二进制        StringBuilder stringBuilder &#x3D; new StringBuilder();        &#x2F;&#x2F; 将bytes数组转为二进制字符串        for (int i &#x3D; 0; i &lt; huffmanBytes.length; i++) &#123;            &#x2F;&#x2F; 先拿到huffmanBytes的数据            byte b &#x3D; huffmanBytes[i];            &#x2F;&#x2F; 设置一个flag，是否已经到达数组最后，如果已经是最后一个，设为true            boolean flag &#x3D; (i &#x3D;&#x3D; (huffmanBytes.length - 1));            &#x2F;&#x2F; 将遍历得到的b，转换成对应的二进制，并加入到stringBuilder中            stringBuilder.append(byteToBitString(!flag,b));        &#125;        &#x2F;&#x2F; 10101000101111111100100010111111...         &#x2F;&#x2F; System.out.println(&quot;stringBuilder &#x3D; &quot; + stringBuilder);        &#x2F;&#x2F; 根据赫夫曼编码进行解码        &#x2F;&#x2F; 把赫夫曼编码表反转，a -&gt; 97 , 97 -&gt; a        Map&lt;String, Byte&gt; map &#x3D; new HashMap&lt;&gt;();        for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;            map.put(entry.getValue(),entry.getKey());        &#125;        &#x2F;&#x2F; System.out.println(&quot;map &#x3D; &quot; + map);        &#x2F;&#x2F; 遍历stringBuilder，拿到原来的字符        &#x2F;&#x2F; 创建集合，存放byte        List&lt;Byte&gt; list &#x3D; new ArrayList&lt;&gt;();        for (int i &#x3D; 0; i &lt; stringBuilder.length();) &#123;            int count &#x3D; 1;           &#x2F;&#x2F; 小计数器，截取到哪里            boolean flag &#x3D; true;     &#x2F;&#x2F; 循环结束条件            Byte b &#x3D; null;           &#x2F;&#x2F; 定义一个byte来接收遍历出来 的byte字节            &#x2F;&#x2F; 如果flag &#x3D; true 的时候，还没有找到            while (flag)&#123;                &#x2F;&#x2F; 递增的取出key 如第一次1，第二次10，第三次101...                String key &#x3D; stringBuilder.substring(i, i+count); &#x2F;&#x2F; i 不动，count移动                &#x2F;&#x2F; 从取出的key中，和赫夫曼编码表map对比，看看是否匹配                b &#x3D; map.get(key);                &#x2F;&#x2F; 判断b是否为空，如果为空，则不匹配，继续查找                if (b &#x3D;&#x3D; null)&#123;                    count++;                &#125; else &#123;                    &#x2F;&#x2F; 如果匹配了，直接退出循环                    flag &#x3D; false;                &#125;            &#125;            &#x2F;&#x2F; 将字节b加入到list集合中            list.add(b);            &#x2F;&#x2F; 将i指向新的位置count上            i +&#x3D; count;        &#125;        &#x2F;&#x2F; for循环结束后，已经得到了原来的字符串i like like like java do you like a java 的list集合        &#x2F;&#x2F; 将list集合的数据放到byte[]，并返回        byte[] b &#x3D; new byte[list.size()];        for (int i &#x3D; 0; i &lt; b.length; i++) &#123;            b[i] &#x3D; list.get(i);        &#125;        return b;    &#125;    &#x2F;**     * 将一个byte转成一个二进制字符串     * @param flag 标识是是否需要补高位，如果是true，则需要补高位，否则不用，是针对最后一个     * @param b    传入的byte     * @return     是该 b对应的二进制字符串（注意是反码返回）     *&#x2F;    private static String byteToBitString(boolean flag, byte b)&#123;        &#x2F;&#x2F; 将b转成int类型，方便利用Integer类转成对应的二进制        int temp &#x3D; b;        &#x2F;&#x2F; 如果是正数，还要在高位补位        if (flag)&#123;            &#x2F;&#x2F; 如果为true，则需要补位            temp |&#x3D; 256;    &#x2F;&#x2F; 按位与，只有都为0的时候为0，只要有1出现都为1 ，1 0000 0000 | 0000 00001 &#x3D; 1 0000 0001        &#125;        String str &#x3D; Integer.toBinaryString(temp);  &#x2F;&#x2F; 返回的是对应二进制的补码        &#x2F;&#x2F; 如果高位补位了，截取后面8为返回        if (flag)&#123;            return str.substring(str.length() - 8); &#x2F;&#x2F; 截取后面的8为        &#125; else &#123;            &#x2F;&#x2F; 否则直接返回            return str;        &#125;    &#125;    &#x2F;&#x2F; 将前面的步骤封装起来    private static byte[] huffmanZip(byte[] bytes)&#123;        &#x2F;&#x2F; 获取nodes集合        List&lt;Node&gt; nodes &#x3D; getNodes(bytes);        &#x2F;&#x2F; 创建赫夫曼树        Node huffmanTreeRoot &#x3D; createHuffmanTree(nodes);        &#x2F;&#x2F; 对应的赫夫曼编码        Map&lt;Byte, String&gt; huffmanCodes &#x3D; getCodes(huffmanTreeRoot);        &#x2F;&#x2F; 根据赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组        byte[] huffmanCodeBytes &#x3D; zip(bytes, huffmanCodes);        return huffmanCodeBytes;    &#125;    &#x2F;&#x2F; 编写一个方法，将字符串对应的byte[] 数组，根据赫夫曼编码，返回一个经过赫夫曼编码压缩的一个byte[]    &#x2F;**     *     * @param bytes         字符串数组对应的bytes数组     * @param huffmanCodes   赫夫曼编码     * @return              返回以经过赫夫曼编译压缩的byte数组     *&#x2F;    private static byte[] zip (byte[] bytes, Map&lt;Byte,String&gt; huffmanCodes)&#123;        &#x2F;&#x2F; 传进来的byte[]数组转成赫夫曼编码对应的字符串        StringBuilder stringBuilder &#x3D; new StringBuilder();        for (byte b : bytes) &#123;            stringBuilder.append(huffmanCodes.get(b));        &#125;        &#x2F;&#x2F; 10101000101111111100100010111111110010001011111111001001010....        &#x2F;&#x2F; System.out.println(stringBuilder);        &#x2F;&#x2F; 将赫夫曼编码对应的字符串，分成8位一个，统计分成了多少个len，根据len创建byte[]        int len;        if (stringBuilder.length() % 8 &#x3D;&#x3D; 0)&#123;            len &#x3D; stringBuilder.length() &#x2F; 8;        &#125; else &#123;            len &#x3D; stringBuilder.length() &#x2F; 8 + 1;        &#125;        byte[] huffmanCodesBytes &#x3D; new byte[len];        &#x2F;&#x2F; 遍历生成的字符串数组，将数据加到huffmanCodesBytes中        int index &#x3D; 0;  &#x2F;&#x2F; huffmanCodesBytes数组的下标        for (int i &#x3D; 0; i &lt; stringBuilder.length(); i +&#x3D; 8)&#123;            String strByte;            if (i + 8 &gt; stringBuilder.length())&#123;                &#x2F;&#x2F; 如果超过了StringBuilder的长度，则将后面的字符串直接加入即可                strByte &#x3D; stringBuilder.substring(i);            &#125; else &#123;                &#x2F;&#x2F; 如果没超过，则8位一个加入strByte中                strByte &#x3D; stringBuilder.substring(i, i + 8);            &#125;            &#x2F;&#x2F; 将strByte转成byte放到huffmanCodeBytes中            huffmanCodesBytes[index] &#x3D; (byte) Integer.parseInt(strByte,2);            index++;        &#125;        return huffmanCodesBytes;    &#125;    &#x2F;&#x2F; 生成赫夫曼树对应的赫夫曼编码    &#x2F;&#x2F; 将赫夫曼编码存放在map中    static Map&lt;Byte,String&gt; huffmanCodes &#x3D; new HashMap&lt;&gt;();    &#x2F;&#x2F; 生成的赫夫曼编码表示，需要去拼接路径    static StringBuilder stringBuilder &#x3D; new StringBuilder();    &#x2F;&#x2F; 为了调用方便，重载getCodes，    private static Map&lt;Byte,String&gt; getCodes(Node root)&#123;        if (root &#x3D;&#x3D; null)&#123;            return null;        &#125;        &#x2F;&#x2F; 处理左子树        getCodes(root.left,&quot;0&quot;,stringBuilder);        &#x2F;&#x2F; 处理右子树        getCodes(root.right,&quot;1&quot;,stringBuilder);        return huffmanCodes;    &#125;    &#x2F;**     * 功能，将传入的node结点的所有叶子结点的赫夫曼编码得到，并放在huffmanCodes中     * @param node 传入的结点     * @param code 路径：0表示左子结点，1表示右子结点     * @param stringBuilder 用于拼接路径     *&#x2F;    private static void getCodes(Node node,String code,StringBuilder stringBuilder)&#123;        StringBuilder stringBuilder2 &#x3D; new StringBuilder(stringBuilder);        &#x2F;&#x2F; 将得到的code加入到StringBuilder2中        stringBuilder2.append(code);        if (node !&#x3D; null)&#123;  &#x2F;&#x2F; 如果node &#x3D;&#x3D; null不处理            &#x2F;&#x2F; 判断是否是非叶子结点            if (node.data &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 说明不是非叶子结点，                &#x2F;&#x2F; 向左递归                getCodes(node.left, &quot;0&quot;, stringBuilder2);                &#x2F;&#x2F; 向右递归                getCodes(node.right, &quot;1&quot;, stringBuilder2);            &#125; else &#123;                &#x2F;&#x2F; 说明是一个叶子结点                &#x2F;&#x2F; 表示已经找到某个叶子结点的最后                huffmanCodes.put(node.data,stringBuilder2.toString());            &#125;        &#125;    &#125;    &#x2F;&#x2F; 前序遍历    private static void preOrder(Node root)&#123;        if (root !&#x3D; null)&#123;            root.preOrder();        &#125; else &#123;            System.out.println(&quot;树为空，不能遍历~~~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 将数组的每一个数据都放在node中，并将node加入到ArrayList    private static List&lt;Node&gt; getNodes(byte[] bytes)&#123;        &#x2F;&#x2F; 创建ArrayList        ArrayList&lt;Node&gt; nodes &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F; 存储每个byte出现的次数        Map&lt;Byte, Integer&gt; counts &#x3D; new HashMap&lt;&gt;();        &#x2F;&#x2F; 遍历bytes，统计每一个byte出现的次数        for (byte b : bytes) &#123;            Integer count &#x3D; counts.get(b);            &#x2F;&#x2F; 如果次数等于0            if (count &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 则将其加到map中，并设置次数为1                counts.put(b,1);            &#125; else &#123;                &#x2F;&#x2F; 如果已经存在了，则加一                counts.put(b, count + 1);            &#125;        &#125;        &#x2F;&#x2F; 处理完上面这个for循环后，就已经得到了各个字符出现的次数了        &#x2F;&#x2F; 接下来就将node加入到ArrayList集合中        for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;            nodes.add(new Node(entry.getKey(),entry.getValue()));        &#125;        &#x2F;&#x2F; 最后将集合返回        return nodes;    &#125;    &#x2F;&#x2F; 创建赫夫曼树    private static Node createHuffmanTree(List&lt;Node&gt; nodes)&#123;        while (nodes.size() &gt; 1)&#123;            &#x2F;&#x2F; 将传进来的集合排序，从小到大            Collections.sort(nodes);            &#x2F;&#x2F; 取出最小和次小的两个数组成一颗二叉树            Node leftNode &#x3D; nodes.get(0);            Node rightNode &#x3D; nodes.get(1);            Node parent &#x3D; new Node(null,leftNode.weight + rightNode.weight);            parent.left &#x3D; leftNode;            parent.right &#x3D; rightNode;            &#x2F;&#x2F; 将已经处理好的结点从集合中去掉            nodes.remove(leftNode);            nodes.remove(rightNode);            &#x2F;&#x2F; 将新构成的父结点加入到nodes集合中            nodes.add(parent);        &#125;        &#x2F;&#x2F; 重复上面的步骤，最后将剩下的父结点返回        return nodes.get(0);    &#125;&#125;&#x2F;&#x2F; 创建结点Nodeclass Node implements Comparable&lt;Node&gt;&#123;    Byte data;      &#x2F;&#x2F; 存放数据（字符）本身    int weight;     &#x2F;&#x2F; 权值，表示字符出现的次数    Node left;    Node right;    public Node(Byte data, int weight) &#123;        this.data &#x3D; data;        this.weight &#x3D; weight;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;data&#x3D;&quot; + data +                &quot;, weight&#x3D;&quot; + weight +                &#39;&#125;&#39;;    &#125;    &#x2F;&#x2F; 前序遍历    public void preOrder()&#123;        System.out.println(this);        if (this.left !&#x3D; null)&#123;            this.left.preOrder();        &#125;        if (this.right !&#x3D; null)&#123;            this.right.preOrder();        &#125;    &#125;    @Override    public int compareTo(Node o) &#123;        &#x2F;&#x2F; 从小到大排序        return this.weight - o.weight;    &#125;&#125;</code></pre></div><h3 id="11-3-9赫夫曼编码压缩文件注意事项"><a href="#11-3-9赫夫曼编码压缩文件注意事项" class="headerlink" title="11.3.9赫夫曼编码压缩文件注意事项"></a>11.3.9赫夫曼编码压缩文件注意事项</h3><ol><li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件  [举例压一个 .ppt]</li><li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml文件]</li><li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显。</li></ol><h2 id="11-4-二叉排序树"><a href="#11-4-二叉排序树" class="headerlink" title="11.4 二叉排序树"></a>11.4 二叉排序树</h2><h3 id="11-4-1-先看一个需求"><a href="#11-4-1-先看一个需求" class="headerlink" title="11.4.1 先看一个需求"></a>11.4.1 先看一个需求</h3><p>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。</p><h3 id="11-4-2-解决方案分析"><a href="#11-4-2-解决方案分析" class="headerlink" title="11.4.2 解决方案分析"></a>11.4.2 解决方案分析</h3><ol><li>使用数组</li></ol><ul><li>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [示意图]</li><li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[示意图]</li></ul><ol start="2"><li><p>使用链式存储-链表不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。[示意图]</p></li><li><p>使用二叉排序树</p></li></ol><h3 id="11-4-3-二叉排序树介绍"><a href="#11-4-3-二叉排序树介绍" class="headerlink" title="11.4.3 二叉排序树介绍"></a>11.4.3 二叉排序树介绍</h3><p>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点</p><p>的值比当前节点的值大。</p><p>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><p>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211213141237024.png" alt="image-20211213141237024"></p><h3 id="11-4-4-二叉排序树创建和遍历"><a href="#11-4-4-二叉排序树创建和遍历" class="headerlink" title="11.4.4 二叉排序树创建和遍历"></a>11.4.4 二叉排序树创建和遍历</h3><p>一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为 Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 :</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211213141330319.png" alt="image-20211213141330319"></p><h3 id="11-4-5-二叉排序树的删除"><a href="#11-4-5-二叉排序树的删除" class="headerlink" title="11.4.5 二叉排序树的删除"></a>11.4.5 二叉排序树的删除</h3><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p><ol><li>删除叶子节点 (比如：2, 5, 9, 12)</li><li>删除只有一颗子树的节点 (比如：1)</li><li>删除有两颗子树的节点. (比如：7, 3，10 )</li><li>操作的思路分析</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211213141438911.png" alt="image-20211213141438911"></p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">对删除的结点的各种情况思路分析：第一种情况:删除叶子节点 (比如：2, 5, 9, 12)思路(1) 需求先去找到要删除的结点  targetNode(2)  找到targetNode 的 父结点 parent (3)  确定 targetNode 是 parent的左子结点 还是右子结点(4)  根据前面的情况来对应删除左子结点 parent.left &#x3D; null右子结点 parent.right &#x3D; null;第二种情况: 删除只有一颗子树的节点 比如 1思路(1) 需求先去找到要删除的结点  targetNode(2)  找到targetNode 的 父结点 parent (3) 确定targetNode 的子结点是左子结点还是右子结点(4) targetNode 是 parent 的左子结点还是右子结点(5) 如果targetNode 有左子结点5. 1 如果 targetNode 是 parent 的左子结点parent.left &#x3D; targetNode.left;5.2  如果 targetNode 是 parent 的右子结点parent.right &#x3D; targetNode.left;(6) 如果targetNode 有右子结点6.1 如果 targetNode 是 parent 的左子结点parent.left &#x3D; targetNode.right;6.2 如果 targetNode 是 parent 的右子结点parent.right &#x3D; targetNode.right情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 )思路(1) 需求先去找到要删除的结点  targetNode(2)  找到targetNode 的 父结点 parent (3)  从targetNode 的右子树找到最小的结点(4) 用一个临时变量，将 最小结点的值保存 temp &#x3D; 11(5)  删除该最小结点(6)  targetNode.value &#x3D; temp</code></pre></div><h3 id="11-4-6-二叉排序树删除结点的代码实现"><a href="#11-4-6-二叉排序树删除结点的代码实现" class="headerlink" title="11.4.6 二叉排序树删除结点的代码实现"></a>11.4.6 二叉排序树删除结点的代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.binarysorttree;public class BinarySortTreeDemo &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;;        BinarySortTree binarySortTree &#x3D; new BinarySortTree();        &#x2F;&#x2F; 循环添加结点到二叉排序树        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            binarySortTree.add(new Node(arr[i]));        &#125;        System.out.println(&quot;二叉排序树中序遍历&quot;);        binarySortTree.infixOrder();    &#x2F;&#x2F; 1, 3, 5, 7, 9, 10, 12        &#x2F;&#x2F; 测试删除        binarySortTree.delNode(7);        binarySortTree.delNode(3);        binarySortTree.delNode(10);        binarySortTree.delNode(12);        binarySortTree.delNode(5);        binarySortTree.delNode(1);        binarySortTree.delNode(9);        binarySortTree.delNode(2);        System.out.println(&quot;删除后：&quot;);        binarySortTree.infixOrder();    &#125;&#125;&#x2F;&#x2F; 创建树class BinarySortTree&#123;    private Node root;    &#x2F;&#x2F; 添加    public void add(Node node)&#123;        if (root &#x3D;&#x3D; null)&#123;            root &#x3D; node;        &#125; else &#123;            root.add(node);        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (root !&#x3D; null)&#123;            root.infixOrder();        &#125; else &#123;            System.out.println(&quot;树为空，不能遍历~~&quot;);        &#125;    &#125;    &#x2F;&#x2F; 查找要删除的结点    public Node search (int value)&#123;        if (root &#x3D;&#x3D; null)&#123;            return null;        &#125; else &#123;            return root.search(value);        &#125;    &#125;    &#x2F;&#x2F; 查找要删除的结点的父结点    public Node searchParent(int value)&#123;        if (root &#x3D;&#x3D; null)&#123;            return null;        &#125; else &#123;            return root.searchParent(value);        &#125;    &#125;    &#x2F;**     * 1.返回以node为根结点的二叉排序树的最小结点的值     * 2.删除node为根结点的二叉排序树的最小结点     * @param node  传入的node（可以当做是根结点）     * @return 返回node为根结点的二叉排序树的最小值     *&#x2F;    public int delRightTreeMin(Node node)&#123;        Node target &#x3D; node;        &#x2F;&#x2F; 当target的左结点不为空时，继续向左找        while (target.left !&#x3D; null)&#123;            target &#x3D; target.left;        &#125;        &#x2F;&#x2F; 退出循环后，已经找到最小结点        &#x2F;&#x2F; 根据最小结点的值，删除结点        delNode(target.value);        &#x2F;&#x2F; 返回最小值        return target.value;    &#125;    &#x2F;&#x2F; 删除结点    public void delNode(int value)&#123;        &#x2F;&#x2F; 如果根结点为空，直接返回        if (root &#x3D;&#x3D; null)&#123;            return;        &#125; else &#123;            &#x2F;&#x2F; 1.找到需要删除的结点            Node targetNode &#x3D; search(value);            &#x2F;&#x2F; 判断找到的结点是否存在            if (targetNode &#x3D;&#x3D; null)&#123;                return;            &#125;            &#x2F;&#x2F; 判断是否只有根结点            if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 说明只有根结点                root &#x3D; null;                return;            &#125;            &#x2F;&#x2F; 找到父结点            Node parent &#x3D; searchParent(value);            &#x2F;&#x2F; 如果要删除的结点是叶子结点            if (targetNode.left &#x3D;&#x3D; null &amp;&amp; targetNode.right &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 判断是父结点的左右结点                &#x2F;&#x2F; 如果是左结点                if (parent.left !&#x3D; null &amp;&amp; parent.left.value &#x3D;&#x3D; value)&#123;                    parent.left &#x3D; null;                &#125; else if (parent.right !&#x3D; null &amp;&amp; parent.right.value &#x3D;&#x3D; value)&#123;                    &#x2F;&#x2F; 如果是右子结点                    parent.right &#x3D; null;                &#125;            &#125; else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null)&#123;   &#x2F;&#x2F; 如果要删除的结点有两颗子树的结点                &#x2F;&#x2F; 从targetNode的右子树查找最小的值                int minValue &#x3D; delRightTreeMin(targetNode.right);                &#x2F;&#x2F; 将最小的值赋值给当前的targetNode                targetNode.value &#x3D; minValue;            &#125; else &#123;                &#x2F;&#x2F; 如果要删除的结点只有一颗子树                &#x2F;&#x2F; 如果要删除的结点有左结点                if (targetNode.left !&#x3D; null)&#123;                    &#x2F;&#x2F; 如果不判断parent是否为空，当二叉排序树只有根结点和一颗子树的时候会抛出空指针异常                    if (parent !&#x3D; null)&#123;                        &#x2F;&#x2F; 如果targetNode是parent的左结点                        if (parent.left.value &#x3D;&#x3D; value)&#123;                            parent.left &#x3D; targetNode.left;                        &#125; else &#123;                            &#x2F;&#x2F; 如果targetNode是parent的右结点                            parent.right &#x3D; targetNode.left;                        &#125;                    &#125; else &#123;                        &#x2F;&#x2F; 如果parent为空了，直接让targetNode的左子结点指向root即可                        root &#x3D; targetNode.left;                    &#125;                &#125; else &#123;                    if (parent !&#x3D; null)&#123;                        &#x2F;&#x2F; 如果要删除的结点有右结点                        &#x2F;&#x2F; 判断targetNode是parent的左右结点，如果是左                        if (parent.left.value &#x3D;&#x3D; value)&#123;                            parent.left &#x3D; targetNode.right;                        &#125; else &#123;                            &#x2F;&#x2F; 如果targetNode是parent的右结点                            parent.right &#x3D; targetNode.right;                        &#125;                    &#125; else &#123;                        root &#x3D; targetNode.right;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F; 创建结点class Node&#123;    int value;    Node left;    Node right;    public Node(int value) &#123;        this.value &#x3D; value;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;value&#x3D;&quot; + value +                &#39;&#125;&#39;;    &#125;    &#x2F;**     * 查找要删除的结点     * @param value 需要删除的结点的值     * @return 如果找到就返回当前结点，如果没有，则返回null     *&#x2F;    public Node search(int value)&#123;        &#x2F;&#x2F; 如果找到了，直接返回        if (this.value &#x3D;&#x3D; value)&#123;            return this;        &#125; else if (value &lt; this.value)&#123;     &#x2F;&#x2F; 如果要查找的结点小于当前结点的值            &#x2F;&#x2F; 判断左子结点是否为空            if (this.left &#x3D;&#x3D; null)&#123;                return null;            &#125;            &#x2F;&#x2F; 不为空的话，向左递归查找            return this.left.search(value);        &#125; else &#123;            &#x2F;&#x2F; 如果要查找的结点不小于当前的结点的值            if(this.right &#x3D;&#x3D; null)&#123;                return null;            &#125;            &#x2F;&#x2F; 向右递归查找            return this.right.search(value);        &#125;    &#125;    &#x2F;**     * 查找要删除结点的父结点     * @param value 要查找的值     * @return 如果找到就返回父结点，没有就返回null     *&#x2F;    public Node searchParent(int value)&#123;        if ((this.left !&#x3D; null &amp;&amp; this.left.value &#x3D;&#x3D; value) ||                (this.right !&#x3D; null &amp;&amp; this.right.value &#x3D;&#x3D; value))&#123;            &#x2F;&#x2F; 满足上述条件后，当前的结点就是父结点            return this;        &#125; else &#123;            &#x2F;&#x2F; 如果要查找的值小于当前的值，并且左子结点不为空            if (value &lt; this.value &amp;&amp; this.left !&#x3D; null)&#123;                &#x2F;&#x2F; 向左递归查找                return this.left.searchParent(value);            &#125; else if (value &gt;&#x3D; this.value &amp;&amp; this.right !&#x3D; null)&#123;                &#x2F;&#x2F; 向右递归查找                return this.right.searchParent(value);            &#125; else &#123;                return null; &#x2F;&#x2F; 没有父结点            &#125;        &#125;    &#125;    &#x2F;&#x2F; 添加    public void add(Node node)&#123;        &#x2F;&#x2F; 如果结点为空，直接返回        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        if (this.value &gt; node.value)&#123;            &#x2F;&#x2F; 如果插入的值比当前的要小，判断左子结点是否为空            if (this.left &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 如果左子结点为空，直接插入                this.left &#x3D; node;            &#125; else &#123;                &#x2F;&#x2F; 如果左子结点不为空，向左递归添加                this.left.add(node);            &#125;        &#125; else &#123;            &#x2F;&#x2F; 如果要插入的值，大于等于当前的值            &#x2F;&#x2F; 判断右子结点是否为空            if (this.right &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 为空，直接插入                this.right &#x3D; node;            &#125; else &#123;                &#x2F;&#x2F; 不为空，向右递归添加                this.right.add(node);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (this.left !&#x3D; null)&#123;            this.left.infixOrder();        &#125;        System.out.println(this);        if (this.right !&#x3D; null)&#123;            this.right.infixOrder();        &#125;    &#125;&#125;</code></pre></div><h3 id="11-4-7-课后练习"><a href="#11-4-7-课后练习" class="headerlink" title="11.4.7 课后练习"></a>11.4.7 课后练习</h3><p>如果我们从左子树找到最大的结点。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; BinarySortTree 类中添加下面方法&#x2F;**     * 1.查找以node为结点的左子树的最大值     * 2.删除最大值的结点     * @param node 传进来的结点（可以说是根结点）     * @return 返回以node为结点的最大值     *&#x2F;    public int delLeftTreeMax(Node1 node)&#123;        Node1 target &#x3D; node;        &#x2F;&#x2F; 二叉排序树的最大值在右子树        while (target.right !&#x3D; null)&#123;            target &#x3D; target.right;        &#125;        delNode(target.value);        &#x2F;&#x2F; 返回最大值        return target.value;    &#125;</code></pre></div><p>在delNode方法中，修改下列代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">else if (targetNode.left !&#x3D; null &amp;&amp; targetNode.right !&#x3D; null)&#123; &#x2F;&#x2F; 如果要删除的结点有两颗子树                &#x2F;&#x2F; 采用右子树最小值                &#x2F;*int minValue &#x3D; delRightTreeMin(targetNode.right);                targetNode.value &#x3D; minValue;*&#x2F;                &#x2F;&#x2F; 采用左子树最大值                int maxValue &#x3D; delLeftTreeMax(targetNode.left);                targetNode.value &#x3D; maxValue;            &#125;</code></pre></div><h2 id="11-5-平衡二叉树-AVL树"><a href="#11-5-平衡二叉树-AVL树" class="headerlink" title="11.5 平衡二叉树(AVL树)"></a>11.5 平衡二叉树(AVL树)</h2><h3 id="11-5-1-看一个案例-说明二叉排序树可能的问题"><a href="#11-5-1-看一个案例-说明二叉排序树可能的问题" class="headerlink" title="11.5.1 看一个案例(说明二叉排序树可能的问题)"></a>11.5.1 看一个案例(说明二叉排序树可能的问题)</h3><p>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214204537332.png" alt="image-20211214204537332"></p><p>左边BST 存在的问题分析:</p><ol><li>左子树全部为空，从形式上看，更像一个单链表.</li><li>插入速度没有影响</li><li>查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比单链表还慢</li><li>解决方案-平衡二叉树(AVL)</li></ol><h3 id="11-5-2-基本介绍"><a href="#11-5-2-基本介绍" class="headerlink" title="11.5.2 基本介绍"></a>11.5.2 基本介绍</h3><ol><li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</li><li>具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常</li><li>用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</li></ol><p>举例说明, 看看下面哪些AVL树, 为什么?</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214204626492.png" alt="image-20211214204626492"></p><h3 id="11-5-3-应用案例-单旋转-左旋转"><a href="#11-5-3-应用案例-单旋转-左旋转" class="headerlink" title="11.5.3 应用案例-单旋转(左旋转)"></a>11.5.3 应用案例-单旋转(左旋转)</h3><ol><li><p>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}</p></li><li><p>思路分析(示意图)</p></li><li><p>代码实现 </p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 左旋转，    private void leftRotate()&#123;        &#x2F;&#x2F; 1.以根结点的值创建新的结点        Node newNode &#x3D; new Node(value);        &#x2F;&#x2F; 2.新结点的左子结点为当前结点的左子树        newNode.left &#x3D; left;        &#x2F;&#x2F; 3.新结点的右子树为当前结点的右子树的左子树        newNode.right &#x3D; right.left;        &#x2F;&#x2F; 4.将当前结点的值该为当前结点的右子树的值        value &#x3D; right.value;        &#x2F;&#x2F; 5.当前结点的右子树指向当前结点的右子树的右子树        right &#x3D; right.right;        &#x2F;&#x2F; 6.当前结点的左子树指向新的结点        left &#x3D; newNode;    &#125;</code></pre></div><h3 id="11-5-4-应用案例-单旋转-右旋转"><a href="#11-5-4-应用案例-单旋转-右旋转" class="headerlink" title="11.5.4 应用案例-单旋转(右旋转)"></a>11.5.4 应用案例-单旋转(右旋转)</h3><ol><li><p>要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}</p></li><li><p>思路分析(示意图)</p></li><li><p>代码实现 </p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 右旋转    private void rightRotate()&#123;        &#x2F;&#x2F; 1.以当前根结点的值创建新结点的值        Node newNode &#x3D; new Node(value);        &#x2F;&#x2F; 2.新结点的右子树为当前结点的右子结点        newNode.right &#x3D; right;        &#x2F;&#x2F; 3.新结点的左子树为当前结点的左子树的右子树        newNode.left &#x3D; left.right;        &#x2F;&#x2F; 4.将当前结点的值改为当前结点的左子树的值        value &#x3D; left.value;        &#x2F;&#x2F; 5.当前结点的左子树指向当前结点的左子树的左子树        left &#x3D; left.left;        &#x2F;&#x2F; 6.当前结点的右子树指向新的结点        right &#x3D; newNode;    &#125;</code></pre></div><h3 id="11-5-6-应用案例-双旋转"><a href="#11-5-6-应用案例-双旋转" class="headerlink" title="11.5.6 应用案例-双旋转"></a>11.5.6 应用案例-双旋转</h3><p>前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列</p><p>int[] arr = { 10, 11, 7, 6, 8, 9 };  运行原来的代码可以看到，并没有转成 AVL树.</p><p>int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL树</p><p>1)问题分析</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214204920044.png" alt="image-20211214204920044"></p><p>2)解决思路分析</p><ol><li>当符合右旋转时</li><li>如果当前结点的左子结点的右子树高度大于当前结点的左子结点的左子树高度</li><li>先对当前结点的左子结点左旋转</li><li>再对当前结点做右旋转</li></ol><p>如果符合左旋转也是同理，将上述步骤中的左右调换即可！</p><p>3)代码实现(完整代码)</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.avl;public class AVLTreeDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;int[] arr &#x3D; &#123;4,3,6,5,7,8&#125;;        &#x2F;&#x2F;int[] arr &#x3D; &#123;10,12, 8, 9, 7, 6&#125;;        int[] arr &#x3D; &#123;10, 11, 7, 6, 8, 9 &#125;;        AVLTree avlTree &#x3D; new AVLTree();        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            avlTree.add(new Node(arr[i]));        &#125;        System.out.println(&quot;中序遍历&quot;);        avlTree.infixOrder();        System.out.println(&quot;平衡处理后&quot;);        System.out.println(&quot;当前树的高度&quot;+avlTree.getRoot().height());        System.out.println(&quot;当前左子树的高度&quot;+avlTree.getRoot().leftHeight());        System.out.println(&quot;当前右子树的高度&quot;+avlTree.getRoot().rightHeight());    &#125;&#125;&#x2F;&#x2F; 创建AVLTreeclass AVLTree&#123;    private Node root;    public Node getRoot() &#123;        return root;    &#125;    &#x2F;&#x2F; 添加    public void add(Node node)&#123;        if (root &#x3D;&#x3D; null)&#123;            root &#x3D; node;        &#125; else &#123;            root.add(node);        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (root !&#x3D; null)&#123;            root.infixOrder();        &#125; else &#123;            System.out.println(&quot;树为空，不能遍历~~&quot;);        &#125;    &#125;    &#125;&#x2F;&#x2F; 创建结点class Node&#123;    int value;    Node left;    Node right;    public Node(int value) &#123;        this.value &#x3D; value;    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;value&#x3D;&quot; + value +                &#39;&#125;&#39;;    &#125;    &#x2F;&#x2F; 返回左子树的高度    public int leftHeight()&#123;        if (left &#x3D;&#x3D; null)&#123;            return 0;        &#125;        return left.height();    &#125;    &#x2F;&#x2F; 返回右子树的高度    public int rightHeight()&#123;        if (right &#x3D;&#x3D; null)&#123;            return 0;        &#125;        return right.height();    &#125;    &#x2F;**     *     * @return 返回以当前结点为根结点的树的高度     *&#x2F;    public int height()&#123;        return Math.max(left &#x3D;&#x3D; null ? 0 : left.height(),right &#x3D;&#x3D; null ? 0 : right.height()) + 1;    &#125;    &#x2F;&#x2F; 左旋转，    private void leftRotate()&#123;        &#x2F;&#x2F; 1.以根结点的值创建新的结点        Node newNode &#x3D; new Node(value);        &#x2F;&#x2F; 2.新结点的左子结点为当前结点的左子树        newNode.left &#x3D; left;        &#x2F;&#x2F; 3.新结点的右子树为当前结点的右子树的左子树        newNode.right &#x3D; right.left;        &#x2F;&#x2F; 4.将当前结点的值该为当前结点的右子树的值        value &#x3D; right.value;        &#x2F;&#x2F; 5.当前结点的右子树指向当前结点的右子树的右子树        right &#x3D; right.right;        &#x2F;&#x2F; 6.当前结点的左子树指向新的结点        left &#x3D; newNode;    &#125;    &#x2F;&#x2F; 右旋转    private void rightRotate()&#123;        &#x2F;&#x2F; 1.以当前根结点的值创建新结点的值        Node newNode &#x3D; new Node(value);        &#x2F;&#x2F; 2.新结点的右子树为当前结点的右子结点        newNode.right &#x3D; right;        &#x2F;&#x2F; 3.新结点的左子树为当前结点的左子树的右子树        newNode.left &#x3D; left.right;        &#x2F;&#x2F; 4.将当前结点的值改为当前结点的左子树的值        value &#x3D; left.value;        &#x2F;&#x2F; 5.当前结点的左子树指向当前结点的左子树的左子树        left &#x3D; left.left;        &#x2F;&#x2F; 6.当前结点的右子树指向新的结点        right &#x3D; newNode;    &#125;        &#x2F;&#x2F; 添加    public void add(Node node)&#123;        &#x2F;&#x2F; 如果结点为空，直接返回        if (node &#x3D;&#x3D; null)&#123;            return;        &#125;        if (this.value &gt; node.value)&#123;            &#x2F;&#x2F; 如果插入的值比当前的要小，判断左子结点是否为空            if (this.left &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 如果左子结点为空，直接插入                this.left &#x3D; node;            &#125; else &#123;                &#x2F;&#x2F; 如果左子结点不为空，向左递归添加                this.left.add(node);            &#125;        &#125; else &#123;            &#x2F;&#x2F; 如果要插入的值，大于等于当前的值            &#x2F;&#x2F; 判断右子结点是否为空            if (this.right &#x3D;&#x3D; null)&#123;                &#x2F;&#x2F; 为空，直接插入                this.right &#x3D; node;            &#125; else &#123;                &#x2F;&#x2F; 不为空，向右递归添加                this.right.add(node);            &#125;        &#125;        &#x2F;&#x2F; 当添加完一个结点后，如果(右子树的高度 - 左子树的高度) &gt; 1，则左旋转        if (rightHeight() - leftHeight() &gt; 1)&#123;            &#x2F;&#x2F; 如果当前结点的右子结点的左子树高度大于当前结点的右子结点的右子树            if (right !&#x3D; null &amp;&amp; right.leftHeight() &gt; right.rightHeight())&#123;                &#x2F;&#x2F; 先将当前结点的右子结点做右旋转，                right.rightRotate();                &#x2F;&#x2F; 再对当前结点做左旋转                leftRotate();            &#125; else &#123;                &#x2F;&#x2F; 左旋转                leftRotate();            &#125;            &#x2F;&#x2F; 如果处理符合上述条件，处理完后，必须return，否则会出问题            return;        &#125;        &#x2F;&#x2F; 当添加完一个结点后，如果(左子树的高度 - 右子树的高度) &gt; 1 则右旋转        if (leftHeight() - rightHeight() &gt; 1)&#123;            &#x2F;&#x2F; 如果当前结点的左子结点的右子树高度大于当前结点的左子结点的左子树            if (left !&#x3D; null &amp;&amp; left.rightHeight() &gt; left.leftHeight())&#123;                &#x2F;&#x2F; 先将当前结点的左子结点做左旋转                left.leftRotate();                &#x2F;&#x2F; 再对当前结点做右旋转                rightRotate();            &#125; else &#123;                &#x2F;&#x2F; 否则，直接右旋转                rightRotate();            &#125;        &#125;    &#125;    &#x2F;&#x2F; 中序遍历    public void infixOrder()&#123;        if (this.left !&#x3D; null)&#123;            this.left.infixOrder();        &#125;        System.out.println(this);        if (this.right !&#x3D; null)&#123;            this.right.infixOrder();        &#125;    &#125;&#125;</code></pre></div><h1 id="第12章-多路查找树"><a href="#第12章-多路查找树" class="headerlink" title="第12章 多路查找树"></a>第12章 多路查找树</h1><h2 id="12-1-二叉树与B树"><a href="#12-1-二叉树与B树" class="headerlink" title="12.1 二叉树与B树"></a>12.1 二叉树与B树</h2><h3 id="12-1-1-二叉树的问题分析"><a href="#12-1-1-二叉树的问题分析" class="headerlink" title="12.1.1 二叉树的问题分析"></a>12.1.1 二叉树的问题分析</h3><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214232208810.png" alt="image-20211214232208810"></p><ol><li>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:</li><li>问题1：在构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</li><li>问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度.</li></ol><h3 id="12-1-2-多叉树"><a href="#12-1-2-多叉树" class="headerlink" title="12.1.2 多叉树"></a>12.1.2 多叉树</h3><ol><li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以<strong>有更多的数据项和更多的子节点</strong>，就是<strong>多叉树</strong>（multiway tree）</li><li>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，<strong>减少树的高度</strong>，能对<strong>二叉树进行优化</strong>。</li><li>举例说明(下面2-3树就是一颗多叉树)</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214232349970.png" alt="image-20211214232349970"></p><h3 id="12-1-3-B树的基本介绍"><a href="#12-1-3-B树的基本介绍" class="headerlink" title="12.1.3 B树的基本介绍"></a>12.1.3 B树的基本介绍</h3><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214232513376.png" alt="image-20211214232513376"></p><ol><li>如图B树通过重新组织节点， 降低了树的高度.</li><li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次</li><li>I/O就可以完全载入</li><li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中</li></ol><h2 id="12-2-2-3树"><a href="#12-2-2-3树" class="headerlink" title="12.2  2-3树"></a>12.2  2-3树</h2><h3 id="12-2-1-2-3树基本介绍"><a href="#12-2-1-2-3树基本介绍" class="headerlink" title="12.2.1   2-3树基本介绍"></a>12.2.1   2-3树基本介绍</h3><p>2-3树是最简单的B树结构, 具有如下特点:</p><ol><li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.<br>2-3树是由二节点和三节点构成的树。</li></ol><h3 id="12-2-2-2-3树应用案例"><a href="#12-2-2-2-3树应用案例" class="headerlink" title="12.2.2   2-3树应用案例"></a>12.2.2   2-3树应用案例</h3><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3树，并保证数据插入的大小顺序。(演示一下构建2-3树的过程.)</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214232726871.png" alt="image-20211214232726871"></p><p>插入规则:</p><ol><li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。 </li><li>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</li></ol><h3 id="12-2-3-其它说明"><a href="#12-2-3-其它说明" class="headerlink" title="12.2.3 其它说明"></a>12.2.3 其它说明</h3><p>除了23树，还有234树等，概念和23树类似，也是一种B树。 如图:</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214232853510.png" alt="image-20211214232853510"></p><h2 id="12-3-B树、B-树和B-树"><a href="#12-3-B树、B-树和B-树" class="headerlink" title="12.3 B树、B+树和B*树"></a>12.3 B树、B+树和B*树</h2><h3 id="12-3-1-B树的介绍"><a href="#12-3-1-B树的介绍" class="headerlink" title="12.3.1 B树的介绍"></a>12.3.1 B树的介绍</h3><p> B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。</p><p>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图:</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214233007433.png" alt="image-20211214233007433"></p><p>B树的说明:</p><ol><li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li><li>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li><li>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</li><li>搜索有可能在非叶子结点结束</li><li>其搜索性能等价于在关键字全集内做一次二分查找</li></ol><h3 id="12-3-2-B-树的介绍"><a href="#12-3-2-B-树的介绍" class="headerlink" title="12.3.2 B+树的介绍"></a>12.3.2 B+树的介绍</h3><p>B+树是B树的变体，也是一种多路搜索树。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214233134042.png" alt="image-20211214233134042"></p><p>B+树的说明:</p><ol><li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。<br>不可能在非叶子结点命中</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li><li>更适合文件索引系统</li><li>B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li></ol><h3 id="12-3-3-B-树的介绍"><a href="#12-3-3-B-树的介绍" class="headerlink" title="12.3.3 B*树的介绍"></a>12.3.3 B*树的介绍</h3><p>B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211214233257519.png" alt="image-20211214233257519"></p><p>B*树的说明:</p><ol><li>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li><li><em>从第1个特点我们可以看出，B</em>树分配新结点的概率比B+树要低，空间使用率更高</li></ol><h1 id="第13章-图"><a href="#第13章-图" class="headerlink" title="第13章 图"></a>第13章 图</h1><h2 id="13-1-图基本介绍"><a href="#13-1-图基本介绍" class="headerlink" title="13.1  图基本介绍"></a>13.1  图基本介绍</h2><h3 id="13-1-1-为什么要有图"><a href="#13-1-1-为什么要有图" class="headerlink" title="13.1.1 为什么要有图"></a>13.1.1 为什么要有图</h3><ol><li>前面我们学了线性表和树</li><li>线性表局限于一个直接前驱和一个直接后继的关系</li><li>树也只能有一个直接前驱也就是父节点</li><li>当我们需要表示多对多的关系时， 这里我们就用到了图</li></ol><h3 id="13-1-2-图的举例说明"><a href="#13-1-2-图的举例说明" class="headerlink" title="13.1.2 图的举例说明"></a>13.1.2 图的举例说明</h3><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。如图：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215101132184.png" alt="image-20211215101132184"></p><h3 id="13-1-3-图的常用概念"><a href="#13-1-3-图的常用概念" class="headerlink" title="13.1.3 图的常用概念"></a>13.1.3 图的常用概念</h3><ol><li>顶点(vertex)</li><li>边(edge)</li><li>路径</li><li>无向图(右图)</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215101221856.png" alt="image-20211215101221856"></p><ol start="5"><li><p>有向图</p></li><li><p>带权图</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215101250926.png" alt="image-20211215101250926"></p><h2 id="13-2-图的表示方式"><a href="#13-2-图的表示方式" class="headerlink" title="13.2 图的表示方式"></a>13.2 图的表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p><h3 id="13-2-1邻接矩阵"><a href="#13-2-1邻接矩阵" class="headerlink" title="13.2.1邻接矩阵"></a>13.2.1邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215101348176.png" alt="image-20211215101348176"></p><h3 id="13-2-2-邻接表"><a href="#13-2-2-邻接表" class="headerlink" title="13.2.2 邻接表"></a>13.2.2 邻接表</h3><ol><li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</li><li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</li><li>举例说明</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215101435922.png" alt="image-20211215101435922"></p><h2 id="13-3-图的快速入门案例"><a href="#13-3-图的快速入门案例" class="headerlink" title="13.3 图的快速入门案例"></a>13.3 图的快速入门案例</h2><ol><li>要求: 代码实现如下图结构.</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215193623810.png" alt="image-20211215193623810"></p><ol start="2"><li><p>思路分析 (1) 存储顶点String 使用 ArrayList (2) 保存矩阵 int[][] edges </p></li><li><p>代码实现</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 核心代码&#x2F;&#x2F; 插入顶点    public void insertVertex(String vertex)&#123;        vertexList.add(vertex);    &#125;    &#x2F;&#x2F; 添加边    &#x2F;**     *     * @param v1 表示点的下标从第几个开始，A-&gt;0,B-&gt;1...     * @param v2 第二个顶点的下标     * @param weight 有连线，表示1，没有则为0     *&#x2F;    public void insertEdges(int v1, int v2, int weight)&#123;        &#x2F;&#x2F; 无向图        edges[v1][v2] &#x3D; weight;        edges[v2][v1] &#x3D; weight;        numOfEdges++;    &#125;</code></pre></div><h2 id="13-4-图的深度优先遍历介绍"><a href="#13-4-图的深度优先遍历介绍" class="headerlink" title="13.4 图的深度优先遍历介绍"></a>13.4 图的深度优先遍历介绍</h2><h3 id="13-4-1-图遍历介绍"><a href="#13-4-1-图遍历介绍" class="headerlink" title="13.4.1 图遍历介绍"></a>13.4.1 图遍历介绍</h3><p>所谓图的遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略: (1)深度优先遍历 (2)广度优先遍历</p><h3 id="13-4-2-深度优先遍历基本思想"><a href="#13-4-2-深度优先遍历基本思想" class="headerlink" title="13.4.2 深度优先遍历基本思想"></a>13.4.2 深度优先遍历基本思想</h3><p>图的深度优先搜索(Depth First Search) 。</p><ol><li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。</li><li>显然，深度优先搜索是一个递归的过程</li></ol><h3 id="13-4-3-深度优先遍历算法步骤"><a href="#13-4-3-深度优先遍历算法步骤" class="headerlink" title="13.4.3 深度优先遍历算法步骤"></a>13.4.3 深度优先遍历算法步骤</h3><ol><li>访问初始结点v，并标记结点v为已访问。</li><li>查找结点v的第一个邻接结点w。</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤3。</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215194001409.png" alt="image-20211215194001409"></p><h3 id="13-4-4-深度优先算法的代码实现"><a href="#13-4-4-深度优先算法的代码实现" class="headerlink" title="13.4.4 深度优先算法的代码实现"></a>13.4.4 深度优先算法的代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 深度优先遍历    private void dfs(boolean[] isVisited, int i)&#123;        &#x2F;&#x2F; 首先访问初始结点，输出        System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;);        &#x2F;&#x2F; 将结点设置为已经访问        isVisited[i] &#x3D; true;        &#x2F;&#x2F; 获取v的第一个邻接结点w        int w &#x3D; getFirstNeighbor(i);        while ( w !&#x3D; -1)&#123;   &#x2F;&#x2F; 说明w存在            if (!isVisited[w])&#123;                &#x2F;&#x2F; 说明w存在但没被访问过，以w为另外一个v，继续执行深度优先遍历                dfs(isVisited, w);            &#125;            &#x2F;&#x2F; 如果已经被访问过了，则访问w的下一个邻接结点            w &#x3D; getNextNeighbor(i,w);        &#125;    &#125;    &#x2F;&#x2F; 对dfs重载，遍历我们所有的结点，并进行dfs    public void dfs()&#123;        isVisited &#x3D; new boolean[vertexList.size()];        &#x2F;&#x2F; 遍历所有结点，进行dfs[回溯]        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++)&#123;            if (!isVisited[i])&#123;                &#x2F;&#x2F; 如果没有被访问过，进行dfs                dfs(isVisited,i);            &#125;        &#125;    &#125;</code></pre></div><h2 id="13-5-图的广度优先遍历"><a href="#13-5-图的广度优先遍历" class="headerlink" title="13.5 图的广度优先遍历"></a>13.5 图的广度优先遍历</h2><h3 id="13-5-1-广度优先遍历基本思想"><a href="#13-5-1-广度优先遍历基本思想" class="headerlink" title="13.5.1 广度优先遍历基本思想"></a>13.5.1 广度优先遍历基本思想</h3><ol><li>图的广度优先搜索(Broad First Search) 。</li><li>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</li></ol><h3 id="13-5-2-广度优先遍历算法步骤"><a href="#13-5-2-广度优先遍历算法步骤" class="headerlink" title="13.5.2 广度优先遍历算法步骤"></a>13.5.2 广度优先遍历算法步骤</h3><ol><li><p>访问初始结点v并标记结点v为已访问。</p></li><li><p>结点v入队列</p></li><li><p>当队列非空时，继续执行，否则算法结束。</p></li><li><p>出队列，取得队头结点u。</p></li><li><p>查找结点u的第一个邻接结点w。</p></li><li><p>若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：</p><p>6.1 若结点w尚未被访问，则访问结点w并标记为已访问。<br>6.2 结点w入队列<br>6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215194329765.png" alt="image-20211215194329765"></p><h2 id="13-6-广度优先遍历代码实现"><a href="#13-6-广度优先遍历代码实现" class="headerlink" title="13.6 广度优先遍历代码实现"></a>13.6 广度优先遍历代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 广度优先遍历    private void bfs(boolean[] isVisited, int i)&#123;        int u;  &#x2F;&#x2F; 头结点的下标        int w;  &#x2F;&#x2F; u的第一个邻接结点        &#x2F;&#x2F; 队列，保持访问的结点的顺序        LinkedList queue &#x3D; new LinkedList();        &#x2F;&#x2F; 访问当前结点        System.out.print(getValueByIndex(i) + &quot;&#x3D;&gt;&quot;);        &#x2F;&#x2F; 设置为已经访问        isVisited[i] &#x3D; true;        &#x2F;&#x2F; 将i入队列        queue.addLast(i);        &#x2F;&#x2F; 当队列为非空时，继续执行        while (!queue.isEmpty())&#123;            &#x2F;&#x2F; u结点出队列            u &#x3D; (int) queue.removeFirst();            &#x2F;&#x2F; 获取下一个邻接结点            w &#x3D; getFirstNeighbor(i);            &#x2F;&#x2F; 如果w存在            while (w !&#x3D; -1)&#123;                &#x2F;&#x2F; 判断是否被访问过                if (!isVisited[w])&#123;                    &#x2F;&#x2F; 如果没有被访问过，则输出                    System.out.print(getValueByIndex(w) + &quot;&#x3D;&gt;&quot;);                    &#x2F;&#x2F; 设置已经访问                    isVisited[w] &#x3D; true;                    &#x2F;&#x2F; 结点w入队列                    queue.addLast(w);                &#125;                &#x2F;&#x2F; 访问邻接结点后的一个邻接结点                w &#x3D; getNextNeighbor(u,w);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 遍历所有结点，并且bfs    public void bfs()&#123;        isVisited &#x3D; new boolean[vertexList.size()];        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++)&#123;            if (!isVisited[i])&#123;                bfs(isVisited,i);            &#125;        &#125;    &#125;</code></pre></div><h2 id="13-7-图的完整代码"><a href="#13-7-图的完整代码" class="headerlink" title="13.7 图的完整代码"></a>13.7 图的完整代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.graph;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class Graph &#123;    private ArrayList&lt;String&gt; vertexList;   &#x2F;&#x2F; 存储顶点集合    private int[][] edges;                  &#x2F;&#x2F; 存储图的邻接矩阵    private int numOfEdges;                 &#x2F;&#x2F; 边的数目    private boolean[] isVisited;            &#x2F;&#x2F; 标志是否被访问过    public static void main(String[] args) &#123;        int n &#x3D; 8;  &#x2F;&#x2F; 结点个数        String Vertexs[] &#x3D; &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;&#125;;   &#x2F;&#x2F; 创建结点        &#x2F;&#x2F; 创建图        Graph graph &#x3D; new Graph(n);        &#x2F;&#x2F; 添加顶点        for (String vertex : Vertexs) &#123;            graph.insertVertex(vertex);        &#125;        &#x2F;&#x2F; 添加边        &#x2F;&#x2F; A-B,A-C,B-C,B-D,B-E        &#x2F;*graph.insertEdges(0,1,1);        graph.insertEdges(0,2,1);        graph.insertEdges(1,2,1);        graph.insertEdges(1,3,1);        graph.insertEdges(1,4,1);*&#x2F;        graph.insertEdges(0, 1, 1);        graph.insertEdges(0, 2, 1);        graph.insertEdges(1, 3, 1);        graph.insertEdges(1, 4, 1);        graph.insertEdges(3, 7, 1);        graph.insertEdges(4, 7, 1);        graph.insertEdges(2, 5, 1);        graph.insertEdges(2, 6, 1);        graph.insertEdges(5, 6, 1);        &#x2F;&#x2F; 显示图        graph.showGraph();        &#x2F;&#x2F; 测试深度优先遍历        System.out.println(&quot;深度优先遍历&quot;);        graph.dfs();        System.out.println();        System.out.println(&quot;广度优先遍历&quot;);        graph.bfs();    &#125;    &#x2F;&#x2F; 构造器，n为结点个数    public Graph (int n)&#123;        vertexList &#x3D; new ArrayList&lt;&gt;(n);    &#x2F;&#x2F; 初始化顶点        edges &#x3D; new int[n][n];              &#x2F;&#x2F; 初始化图的邻接矩阵        numOfEdges &#x3D; 0;                     &#x2F;&#x2F; 边的数目，默认为0        isVisited &#x3D; new boolean[n];         &#x2F;&#x2F; 表示是否被访问过    &#125;    &#x2F;&#x2F; 获取v的第一个邻接结点的下标w    &#x2F;**     *     * @param index     * @return 如果存在则返回对应的下标，如果不存在，则返回-1     *&#x2F;    public int getFirstNeighbor(int index)&#123;        for (int j &#x3D; 0; j &lt; vertexList.size(); j++)&#123;            &#x2F;&#x2F; 如果edges[index][j] &gt; 0，说明存在，返回下标            if (edges[index][j] &gt; 0)&#123;                return j;            &#125;        &#125;        return -1;    &#125;    &#x2F;&#x2F; 返回v的w邻接结点的下一个结点的下标    &#x2F;&#x2F; 根据前一个邻接结点的下标来获取下一个邻接结点    public int getNextNeighbor(int v1, int v2)&#123;        for (int j &#x3D; v2 + 1; j &lt; vertexList.size(); j++)&#123;            if (edges[v1][j] &gt; 0)&#123;                &#x2F;&#x2F; 说明存在                return j;            &#125;        &#125;        return -1;    &#125;    &#x2F;&#x2F; 深度优先遍历    private void dfs(boolean[] isVisited, int i)&#123;        &#x2F;&#x2F; 首先访问初始结点，输出        System.out.print(getValueByIndex(i) + &quot;-&gt;&quot;);        &#x2F;&#x2F; 将结点设置为已经访问        isVisited[i] &#x3D; true;        &#x2F;&#x2F; 获取v的第一个邻接结点w        int w &#x3D; getFirstNeighbor(i);        while ( w !&#x3D; -1)&#123;   &#x2F;&#x2F; 说明w存在            if (!isVisited[w])&#123;                &#x2F;&#x2F; 说明w存在但没被访问过，以w为另外一个v，继续执行深度优先遍历                dfs(isVisited, w);            &#125;            &#x2F;&#x2F; 如果已经被访问过了，则访问w的下一个邻接结点            w &#x3D; getNextNeighbor(i,w);        &#125;    &#125;    &#x2F;&#x2F; 对dfs重载，遍历我们所有的结点，并进行dfs    public void dfs()&#123;        isVisited &#x3D; new boolean[vertexList.size()];        &#x2F;&#x2F; 遍历所有结点，进行dfs[回溯]        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++)&#123;            if (!isVisited[i])&#123;                &#x2F;&#x2F; 如果没有被访问过，进行dfs                dfs(isVisited,i);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 广度优先遍历    private void bfs(boolean[] isVisited, int i)&#123;        int u;  &#x2F;&#x2F; 头结点的下标        int w;  &#x2F;&#x2F; u的第一个邻接结点        &#x2F;&#x2F; 队列，保持访问的结点的顺序        LinkedList queue &#x3D; new LinkedList();        &#x2F;&#x2F; 访问当前结点        System.out.print(getValueByIndex(i) + &quot;&#x3D;&gt;&quot;);        &#x2F;&#x2F; 设置为已经访问        isVisited[i] &#x3D; true;        &#x2F;&#x2F; 将i入队列        queue.addLast(i);        &#x2F;&#x2F; 当队列为非空时，继续执行        while (!queue.isEmpty())&#123;            &#x2F;&#x2F; u结点出队列            u &#x3D; (int) queue.removeFirst();            &#x2F;&#x2F; 获取下一个邻接结点            w &#x3D; getFirstNeighbor(i);            &#x2F;&#x2F; 如果w存在            while (w !&#x3D; -1)&#123;                &#x2F;&#x2F; 判断是否被访问过                if (!isVisited[w])&#123;                    &#x2F;&#x2F; 如果没有被访问过，则输出                    System.out.print(getValueByIndex(w) + &quot;&#x3D;&gt;&quot;);                    &#x2F;&#x2F; 设置已经访问                    isVisited[w] &#x3D; true;                    &#x2F;&#x2F; 结点w入队列                    queue.addLast(w);                &#125;                &#x2F;&#x2F; 访问邻接结点后的一个邻接结点                w &#x3D; getNextNeighbor(u,w);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 遍历所有结点，并且bfs    public void bfs()&#123;        isVisited &#x3D; new boolean[vertexList.size()];        for (int i &#x3D; 0; i &lt; getNumOfVertex(); i++)&#123;            if (!isVisited[i])&#123;                bfs(isVisited,i);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 图中常用的方法    &#x2F;&#x2F; 返回结点个数    public int getNumOfVertex()&#123;        return vertexList.size();    &#125;    &#x2F;&#x2F; 返回边的数量    public int getNumOfEdges()&#123;        return numOfEdges;    &#125;    &#x2F;&#x2F; 返回结点i对应的数据，如0-&gt;A,1-&gt;B...    public String getValueByIndex(int i)&#123;        return vertexList.get(i);    &#125;    &#x2F;&#x2F; 返回v1和v2对应的权值    public int getWeight(int v1, int v2)&#123;        return edges[v1][v2];    &#125;    &#x2F;&#x2F; 显示图    public void showGraph()&#123;        for (int[] link : edges) &#123;            System.out.println(Arrays.toString(link));        &#125;    &#125;    &#x2F;&#x2F; 插入顶点    public void insertVertex(String vertex)&#123;        vertexList.add(vertex);    &#125;    &#x2F;&#x2F; 添加边    &#x2F;**     *     * @param v1 表示点的下标从第几个开始，A-&gt;0,B-&gt;1...     * @param v2 第二个顶点的下标     * @param weight 有连线，表示1，没有则为0     *&#x2F;    public void insertEdges(int v1, int v2, int weight)&#123;        &#x2F;&#x2F; 无向图        edges[v1][v2] &#x3D; weight;        edges[v2][v1] &#x3D; weight;        numOfEdges++;    &#125;&#125;</code></pre></div><h2 id="13-8-图的深度优先VS-广度优先"><a href="#13-8-图的深度优先VS-广度优先" class="headerlink" title="13.8 图的深度优先VS 广度优先"></a>13.8 图的深度优先VS 广度优先</h2><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211215194659193.png" alt="image-20211215194659193"></p><h1 id="第14章-程序员常用10种算法"><a href="#第14章-程序员常用10种算法" class="headerlink" title="第14章 程序员常用10种算法"></a>第14章 程序员常用10种算法</h1><h2 id="14-1-二分查找算法-非递归"><a href="#14-1-二分查找算法-非递归" class="headerlink" title="14.1 二分查找算法(非递归)"></a>14.1 二分查找算法(非递归)</h2><h3 id="14-1-1-二分查找算法-非递归-介绍"><a href="#14-1-1-二分查找算法-非递归-介绍" class="headerlink" title="14.1.1 二分查找算法(非递归)介绍"></a>14.1.1 二分查找算法(非递归)介绍</h3><ol><li>前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式</li><li>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</li><li>二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7)</li></ol><h3 id="14-1-2-二分查找算法-非递归-代码实现"><a href="#14-1-2-二分查找算法-非递归-代码实现" class="headerlink" title="14.1.2 二分查找算法(非递归)代码实现"></a>14.1.2 二分查找算法(非递归)代码实现</h3><ol><li><p>数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成.</p></li><li><p>思路分析：</p></li><li><p>代码实现：</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.binarysearchnorecuision;public class BinarySearchNoRecursion &#123;    public static void main(String[] args) &#123;        int[] arr &#x3D; &#123;1, 3, 8, 10, 11, 67, 100&#125;;        int index &#x3D; binarySearch(arr, 80);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; 二分查找，非递归    &#x2F;**     *     * @param arr 要查找的数组     * @param target 要查找的值     * @return 找到就返回下标，否则-1     *&#x2F;    public static int binarySearch(int[] arr, int target)&#123;        int left &#x3D; 0;                    &#x2F;&#x2F; 初始化左边        int right &#x3D; arr.length - 1;     &#x2F;&#x2F; 初始化右边        while (left &lt;&#x3D; right)&#123;          &#x2F;&#x2F; 条件成立，一直循环            int mid &#x3D; (left + right) &#x2F; 2;   &#x2F;&#x2F; 初始化mid            &#x2F;&#x2F;判断arr[mid]与target的值            if (arr[mid] &#x3D;&#x3D; target)&#123;                &#x2F;&#x2F; 说明已经找到了                return mid;            &#125; else if (arr[mid] &gt; target)&#123;                &#x2F;&#x2F; 向左边查找                right &#x3D; mid - 1;            &#125; else &#123;                &#x2F;&#x2F; 向右边查找                left &#x3D; mid + 1;            &#125;        &#125;        &#x2F;&#x2F; 如果没有找到，就返回-1        return -1;    &#125;&#125;</code></pre></div><h2 id="14-2-分治算法"><a href="#14-2-分治算法" class="headerlink" title="14.2 分治算法"></a>14.2 分治算法</h2><h3 id="14-2-1-分治算法介绍"><a href="#14-2-1-分治算法介绍" class="headerlink" title="14.2.1 分治算法介绍"></a>14.2.1 分治算法介绍</h3><ol><li>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</li><li>分治算法可以求解的一些经典问题</li></ol><ul><li>二分搜索</li><li>大整数乘法</li><li>棋盘覆盖</li><li>合并排序</li><li>快速排序</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ul><h3 id="14-2-2-分治算法的基本步骤"><a href="#14-2-2-分治算法的基本步骤" class="headerlink" title="14.2.2 分治算法的基本步骤"></a>14.2.2 分治算法的基本步骤</h3><p>分治法在每一层递归上都有三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解。</li></ol><h3 id="14-2-3-分治-Divide-and-Conquer-P-算法设计模式如下："><a href="#14-2-3-分治-Divide-and-Conquer-P-算法设计模式如下：" class="headerlink" title="14.2.3 分治(Divide-and-Conquer(P))算法设计模式如下："></a>14.2.3 分治(Divide-and-Conquer(P))算法设计模式如下：</h3><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">if |P|≤n0   then return(ADHOC(P))&#x2F;&#x2F;将P分解为较小的子问题 P1 ,P2 ,…,Pkfor i←1 to kdo yi ← Divide-and-Conquer(Pi)   递归解决PiT ← MERGE(y1,y2,…,yk)   合并子问题return(T)</code></pre></div><p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p><h3 id="14-2-4-分治算法最佳实践-汉诺塔"><a href="#14-2-4-分治算法最佳实践-汉诺塔" class="headerlink" title="14.2.4 分治算法最佳实践-汉诺塔"></a>14.2.4 分治算法最佳实践-汉诺塔</h3><p>汉诺塔的传说</p><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根<a href="https://baike.baidu.com/item/%E9%87%91%E5%88%9A%E7%9F%B3/80698">金刚石</a>柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p>假如每秒钟一次，共需多长时间呢？移完这些金片需要5845.54亿年以上，太阳系的预期寿命据说也就是数百亿年。真的过了5845.54亿年，地球上的一切生命，连同梵塔、庙宇等，都早已经灰飞烟灭。</p><p>汉诺塔游戏的<strong>演示</strong>和<strong>思路分析</strong>:  </p><p>1)如果是有一个盘， A-&gt;C</p><p>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</p><p>1)先把 最上面的盘 A-&gt;B</p><p>2)把最下边的盘 A-&gt;C</p><p>3)把B塔的所有盘 从 B-&gt;C  </p><p>代码演示：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.dac;public class HanoiTower &#123;    public static void main(String[] args)&#123;        hanoiTower(5 , &#39;A&#39;, &#39;B&#39;, &#39;C&#39;);    &#125;    &#x2F;&#x2F; 汉诺塔的移动方法    &#x2F;&#x2F; 使用分治算法    &#x2F;**     *     * @param num 汉诺塔的数量     * @param a a柱     * @param b b柱     * @param c c柱     *&#x2F;    public static void hanoiTower(int num, char a ,char b, char c)&#123;        &#x2F;&#x2F; 如果只有一个盘        if (num &#x3D;&#x3D; 1)&#123;            System.out.println(&quot;第1个盘从&quot; +a+ &quot;-&gt;&quot; +c);        &#125; else &#123;            &#x2F;&#x2F; 如果有多个盘，可以看成上面到倒数第二块为一个盘，最下面一块为一盘，            &#x2F;&#x2F; 1.将最上面所有的盘 A-&gt;B，中间借助c            hanoiTower(num - 1,a,c,b);            &#x2F;&#x2F; 2.接着将最后一块移动到c，A-&gt;C             System.out.println(&quot;第&quot; +num+ &quot;个盘从&quot; +a+ &quot;-&gt;&quot; +c);            &#x2F;&#x2F; 3,将b柱的所有盘移动到c柱,中间借助a            hanoiTower(num - 1,b,a,c);        &#125;    &#125;&#125;</code></pre></div><h2 id="14-3-动态规划算法"><a href="#14-3-动态规划算法" class="headerlink" title="14.3 动态规划算法"></a>14.3 动态规划算法</h2><h3 id="14-3-1-应用场景-背包问题"><a href="#14-3-1-应用场景-背包问题" class="headerlink" title="14.3.1 应用场景-背包问题"></a>14.3.1 应用场景-背包问题</h3><p>背包问题：有一个背包，容量为4磅 ， 现有如下物品</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211216175909680.png" alt="image-20211216175909680"></p><ol><li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li><li>要求装入的物品不能重复</li></ol><h3 id="14-3-2-动态规划算法介绍"><a href="#14-3-2-动态规划算法介绍" class="headerlink" title="14.3.2 动态规划算法介绍"></a>14.3.2 动态规划算法介绍</h3><ol><li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过填表的方式来逐步推进，得到最优解。</li></ol><h3 id="14-3-3-动态规划算法最佳实践-背包问题"><a href="#14-3-3-动态规划算法最佳实践-背包问题" class="headerlink" title="14.3.3 动态规划算法最佳实践-背包问题"></a>14.3.3 动态规划算法最佳实践-背包问题</h3><ol><li>要求达到的目标为装入的背包的总价值最大，并且重量不超出</li><li>要求装入的物品不能重复</li><li>思路分析和图解</li><li>背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用)</li><li>这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。</li><li>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</li></ol><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">(1)  v[i][0]&#x3D;v[0][j]&#x3D;0; &#x2F;&#x2F;表示 填入表 第一行和第一列是0(2) 当w[i]&gt; j 时：v[i][j]&#x3D;v[i-1][j]   &#x2F;&#x2F; 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略(3) 当j&gt;&#x3D;w[i]时： v[i][j]&#x3D;max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;  &#x2F;&#x2F; 当 准备加入的新增的商品的容量小于等于当前背包的容量,&#x2F;&#x2F; 装入的方式:v[i-1][j]： 就是上一个单元格的装入的最大值v[i] : 表示当前商品的价值 v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值当j&gt;&#x3D;w[i]时： v[i][j]&#x3D;max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; : </code></pre></div><ol start="7"><li>图解</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211216180552767.png" alt="image-20211216180552767"></p><h3 id="14-3-4-动态规划算法最佳实践-背包问题代码实现"><a href="#14-3-4-动态规划算法最佳实践-背包问题代码实现" class="headerlink" title="14.3.4 动态规划算法最佳实践-背包问题代码实现"></a>14.3.4 动态规划算法最佳实践-背包问题代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.dynamic;&#x2F;&#x2F; 动态规划算法解决背包问题public class KnapsackProblem &#123;    public static void main(String[] args) &#123;        int[] w &#x3D; &#123;1,4,3&#125;;              &#x2F;&#x2F; 商品的重量        int[] val &#x3D; &#123;1500,3000,2000&#125;;   &#x2F;&#x2F; 商品的价值        int m &#x3D; 4;                      &#x2F;&#x2F; 背包的容量        int n &#x3D; val.length;             &#x2F;&#x2F; 商品的个数        &#x2F;&#x2F; v[i][j]，这个表示在前i个商品中，能够装入容量为j的背包的最大价值        int[][] v &#x3D; new int[n + 1][m + 1];        &#x2F;&#x2F; 为了记录放入的商品是哪个，这里定义一个二维数组存放路径        int[][] path &#x3D; new int[n + 1][m + 1];        &#x2F;&#x2F; 初始化第一行和第一列        for (int i &#x3D; 0; i &lt; v[0].length; i++)&#123;            v[0][i] &#x3D; 0;    &#x2F;&#x2F; 第一行都为0        &#125;        for (int i &#x3D; 0; i &lt; v.length; i++)&#123;            v[i][0] &#x3D; 0;    &#x2F;&#x2F; 第一列都为0        &#125;        &#x2F;&#x2F; 开始填充        for (int i &#x3D; 1; i &lt; v.length; i++)&#123;            for (int j &#x3D; 1; j &lt; v[0].length; j++)&#123;                &#x2F;&#x2F; 如果商品的重量大于背包的容量                &#x2F;&#x2F; w[i - 1]:i是从1开始的，而商品是要从下标为0开始，所以减一                if (w[i - 1] &gt; j)&#123;                    &#x2F;&#x2F; 直接将上一个单元格的填充策略填入当前的单元格                    v[i][j] &#x3D; v[i - 1][j];                &#125; else &#123;                    &#x2F;&#x2F; 如果j &gt;&#x3D; w[i - 1],这里的val[i - 1]，和上面的w[i - 1]一样，从下标为0的第一商品开始                    &#x2F;&#x2F; v[i][j] &#x3D; Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);                    &#x2F;&#x2F; 为了清楚具体的商品，这里对代码改造，新增一个二维数组记录商品                    if (v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]])&#123;                        v[i][j] &#x3D; val[i - 1] + v[i - 1][j - w[i - 1]];                        &#x2F;&#x2F; 记录最后一个的商品，不是最后一个不用记录                        path[i][j] &#x3D; 1;                    &#125; else &#123;                        v[i][j] &#x3D; v[i - 1][j];                    &#125;                &#125;            &#125;        &#125;        &#x2F;&#x2F; 输出二维数组        for (int i &#x3D; 0; i &lt; v.length; i++) &#123;            for (int j &#x3D; 0; j &lt; v[0].length; j++) &#123;                System.out.print(v[i][j] + &quot; &quot;);            &#125;            System.out.println();        &#125;        &#x2F;&#x2F; 输出商品&#x2F;*        for (int i &#x3D; 0; i &lt; path.length; i++)&#123;            for (int j &#x3D; 0; j &lt; path[0].length; j++)&#123;                &#x2F;&#x2F; 只需要打印最后的商品                if (path[i][j] &#x3D;&#x3D; 1)&#123;                    System.out.printf(&quot;第%d个商品\n&quot;,i);                &#125;            &#125;        &#125;*&#x2F;        &#x2F;&#x2F; 改造输出商品，从最后开始向前遍历        int i &#x3D; path.length - 1;        &#x2F;&#x2F; 行        int j &#x3D; path[0].length - 1;     &#x2F;&#x2F; 列        while (i &gt; 0 &amp;&amp; j &gt; 0)&#123;     &#x2F;&#x2F; 符合这个条件一直循环            if (path[i][j] &#x3D;&#x3D; 1)&#123;                System.out.printf(&quot;第%d个商品\n&quot;,i);                &#x2F;&#x2F; 输出完一个后，j需要减去当前的重量                j -&#x3D; w[i - 1];            &#125;            i--;        &#125;    &#125;&#125;</code></pre></div><h2 id="14-4-KMP算法"><a href="#14-4-KMP算法" class="headerlink" title="14.4 KMP算法"></a>14.4 KMP算法</h2><h3 id="14-4-1-应用场景-字符串匹配问题"><a href="#14-4-1-应用场景-字符串匹配问题" class="headerlink" title="14.4.1 应用场景-字符串匹配问题"></a>14.4.1 应用场景-字符串匹配问题</h3><p>字符串匹配问题：</p><ol><li>有一个字符串 str1= “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2=”尚硅谷你尚硅你”</li><li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li></ol><h3 id="14-4-2-暴力匹配算法"><a href="#14-4-2-暴力匹配算法" class="headerlink" title="14.4.2 暴力匹配算法"></a>14.4.2 暴力匹配算法</h3><p>如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p><ol><li>如果当前字符匹配成功（即**str1[i] == str2[j]），则i++，j++**，继续匹配下一个字符</li><li>如果失配（即**str1[i]! = str2[j]<strong>），令</strong>i = i - (j - 1)**，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)</li><li>暴力匹配算法实现.</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.kmp;public class ViolenceMatch &#123;    public static void main(String[] args) &#123;        String str1 &#x3D; &quot;硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好&quot;;        String str2 &#x3D; &quot;尚硅谷你尚硅你~&quot;;        int index &#x3D; violenceMatch(str1, str2);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; 暴力匹配    public static int violenceMatch(String str1, String str2)&#123;        char[] s1 &#x3D; str1.toCharArray();        char[] s2 &#x3D; str2.toCharArray();        int s1Len &#x3D; s1.length;  &#x2F;&#x2F; s1的长度        int s2Len &#x3D; s2.length;  &#x2F;&#x2F; s2的长度        int i &#x3D; 0;  &#x2F;&#x2F; 指向s1的指针        int j &#x3D; 0;  &#x2F;&#x2F; 指向s2的指针        while (i &lt; s1Len &amp;&amp; j &lt; s2Len)&#123;     &#x2F;&#x2F; 防止越界            &#x2F;&#x2F; 开始比较            if (s1[i] &#x3D;&#x3D; s2[j])&#123;                &#x2F;&#x2F; 说明成功                i++;                j++;            &#125; else &#123;                &#x2F;&#x2F; 如果不成功，i回到第一个匹配成功的后一个，也就是i - (j - 1)个，j置0,(i - j + 1)                i &#x3D; i - (j - 1);                j &#x3D; 0;            &#125;        &#125;        &#x2F;&#x2F; 退出循环的时候判断是否已经找到        if (j &#x3D;&#x3D; s2Len)&#123;    &#x2F;&#x2F; 当j匹配到最后的时候说明已经找到            &#x2F;&#x2F; 返回下标，第一个字符的下标            return i - j;        &#125; else &#123;            &#x2F;&#x2F; 否则返回-1            return -1;        &#125;    &#125;&#125;</code></pre></div><h3 id="14-4-3-KMP算法介绍"><a href="#14-4-3-KMP算法介绍" class="headerlink" title="14.4.3 KMP算法介绍"></a>14.4.3 KMP算法介绍</h3><ol><li>KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</li><li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.</li><li>KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</li><li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a> </li></ol><h3 id="14-4-4-KMP算法最佳应用-字符串匹配问题"><a href="#14-4-4-KMP算法最佳应用-字符串匹配问题" class="headerlink" title="14.4.4 KMP算法最佳应用-字符串匹配问题"></a>14.4.4 KMP算法最佳应用-字符串匹配问题</h3><p>字符串匹配问题：</p><ol><li>有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD”</li><li>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1</li><li>要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法.</li></ol><p>思路分析图解</p><p>举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？</p><p>1.首先，用Str1的第一个字符和Str2的第一个字符去比较，不符合，关键词向后移动一位 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image002.jpg" alt="img"> </p><p>\2.  重复第一步，还是不符合，再后移 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image004.jpg" alt="img"></p><p>\3.  一直重复，直到Str1有一个字符与Str2的第一个字符符合为止</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image006.jpg" alt="img"></p><p>\4.  接着比较字符串和搜索词的下一个字符，还是符合。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image008.jpg" alt="img"></p><p>5.遇到Str1有一个字符与Str2对应的字符不符合。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image010.jpg" alt="img"> </p><p>6.这时候，想到的是继续遍历Str1的下一个字符，重复第1步。(其实是很不明智的，因为此时BCD已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。) </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image012.jpg" alt="img"> </p><p>7.怎么做到把刚刚重复的步骤省略掉？可以对Str2计算出一张《部分匹配表》，这张表的产生在后面介绍 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image014.jpg" alt="img"></p><p>8.已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： </p><p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p><p>因为 6 - 2 等于4，所以将搜索词向后移动 4 位。 </p><p>9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image016.jpg" alt="img"> </p><p>10.因为空格与A不匹配，继续后移一位。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image018.jpg" alt="img"></p><p>11.逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image020.jpg" alt="img"> </p><p>12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image022.jpg" alt="img"> </p><p>13.介绍《部分匹配表》怎么产生的 </p><p>先介绍前缀，后缀是什么 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image024.jpg" alt="img"></p><p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例， </p><p>－”A”的前缀和后缀都为空集，共有元素的长度为0；</p><p>－”AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</p><p>－”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； </p><p>－”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； </p><p>－”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1； </p><p>－”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2； </p><p>－”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</p><p>14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 </p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image026.jpg" alt="img"> </p><p>到此KMP算法思想分析完毕!</p><p><strong>代码实现</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.kmp;import java.util.Arrays;public class KMPAlgorithm &#123;    public static void main(String[] args) &#123;        String str1 &#x3D; &quot;ASFDFABCAcAGDFDAABCAcABGD&quot;;        &#x2F;&#x2F;String dest &#x3D; &quot;ABCAcABG&quot;;        String dest &#x3D; &quot;AGDFDAAB&quot;;        int[] next &#x3D; kmpNext(dest);        System.out.println(&quot;next &#x3D; &quot; + Arrays.toString(next));        int index &#x3D; kmpSearch(next, str1, dest);        System.out.println(&quot;index &#x3D; &quot; + index);    &#125;    &#x2F;&#x2F; KMP 算法    &#x2F;**     *     * @param next 模式串的next数组     * @param str1 源字符串     * @param str2 要匹配的子串     * @return 找到返回下标，否则返回-1     *&#x2F;    public static int kmpSearch(int[] next, String str1, String str2)&#123;        for (int i &#x3D; 0, j &#x3D; 0; i &lt; str1.length(); i++)&#123;            &#x2F;&#x2F; 如果不相等，j &#x3D; next[j - 1]            while (j &gt; 0 &amp;&amp; str1.charAt(i) !&#x3D; str2.charAt(j))&#123;                j &#x3D; next[j - 1];            &#125;            &#x2F;&#x2F; 如果相等            if (str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;                j++;            &#125;            if (j &#x3D;&#x3D; str2.length())&#123;                &#x2F;&#x2F; 如果找到了就返回下标                return i - j + 1;            &#125;        &#125;        return -1;    &#125;    &#x2F;&#x2F; 获取next[]数组    public static int[] kmpNext(String dest)&#123;        int[] next &#x3D; new int[dest.length()];        next[0] &#x3D; 0;    &#x2F;&#x2F; 如果长度为1，则部分匹配值为0        for (int i &#x3D; 1,j &#x3D; 0; i &lt; dest.length(); i++)&#123;            &#x2F;&#x2F; 如果两个字符串不相等,让j移动 next[j - 1]            while (j &gt; 0 &amp;&amp; dest.charAt(j) !&#x3D; dest.charAt(i))&#123;                j &#x3D; next[j - 1];            &#125;            &#x2F;&#x2F; 如果两个字符相等            if (dest.charAt(j) &#x3D;&#x3D; dest.charAt(i))&#123;                j++;            &#125;            &#x2F;&#x2F; 将j的值赋给next[i]            next[i] &#x3D; j;        &#125;        return next;    &#125;&#125;</code></pre></div><h3 id="14-4-5-自己理解的KMP算法"><a href="#14-4-5-自己理解的KMP算法" class="headerlink" title="14.4.5 自己理解的KMP算法"></a>14.4.5 自己理解的KMP算法</h3><h4 id="KMP的next数组分析"><a href="#KMP的next数组分析" class="headerlink" title="KMP的next数组分析"></a>KMP的next数组分析</h4><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/KMP%E7%9A%84next%E6%95%B0%E7%BB%84%E5%88%86%E6%9E%90.png" alt="KMP的next数组分析"></p><h4 id="KMP算法原理分析："><a href="#KMP算法原理分析：" class="headerlink" title="KMP算法原理分析："></a>KMP算法原理分析：</h4><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3-1639733459184.png" alt="KMP算法原理图解"></p><h2 id="14-5-贪心算法"><a href="#14-5-贪心算法" class="headerlink" title="14.5 贪心算法"></a>14.5 贪心算法</h2><h3 id="14-5-1-应用场景-集合覆盖问题"><a href="#14-5-1-应用场景-集合覆盖问题" class="headerlink" title="14.5.1 应用场景-集合覆盖问题"></a>14.5.1 应用场景-集合覆盖问题</h3><p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218135359592.png" alt="image-20211218135359592"></p><h3 id="14-5-2-贪心算法介绍"><a href="#14-5-2-贪心算法介绍" class="headerlink" title="14.5.2 贪心算法介绍"></a>14.5.2 贪心算法介绍</h3><ol><li><p>贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法</p></li><li><p>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</p></li></ol><h3 id="14-5-3-贪心算法最佳应用-集合覆盖"><a href="#14-5-3-贪心算法最佳应用-集合覆盖" class="headerlink" title="14.5.3 贪心算法最佳应用-集合覆盖"></a>14.5.3 贪心算法最佳应用-集合覆盖</h3><ol><li>假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218135500075.png" alt="image-20211218135500075"></p><ol start="2"><li>思路分析: </li></ol><p>如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ -1 个,假设每秒可以计算10个子集， 如图:</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218135538853.png" alt="image-20211218135538853"></p><p>使用贪婪算法，效率高:</p><ol><li>目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合:</li><li>遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） </li><li>将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</li><li>重复第1步直到覆盖了全部的地区</li></ol><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.greedy;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GreedyAlgorithm &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 创建广播HashMap        HashMap&lt;String, HashSet&lt;String&gt;&gt; broadcasts &#x3D; new HashMap&lt;&gt;();        HashSet&lt;String&gt; hashSet1 &#x3D; new HashSet&lt;&gt;();        hashSet1.add(&quot;北京&quot;);        hashSet1.add(&quot;上海&quot;);        hashSet1.add(&quot;天津&quot;);        HashSet&lt;String&gt; hashSet2 &#x3D; new HashSet&lt;&gt;();        hashSet2.add(&quot;广州&quot;);        hashSet2.add(&quot;北京&quot;);        hashSet2.add(&quot;深圳&quot;);        HashSet&lt;String&gt; hashSet3 &#x3D; new HashSet&lt;&gt;();        hashSet3.add(&quot;成都&quot;);        hashSet3.add(&quot;上海&quot;);        hashSet3.add(&quot;杭州&quot;);        HashSet&lt;String&gt; hashSet4 &#x3D; new HashSet&lt;&gt;();        hashSet4.add(&quot;上海&quot;);        hashSet4.add(&quot;天津&quot;);        HashSet&lt;String&gt; hashSet5 &#x3D; new HashSet&lt;&gt;();        hashSet5.add(&quot;杭州&quot;);        hashSet5.add(&quot;大连&quot;);        broadcasts.put(&quot;K1&quot;,hashSet1);        broadcasts.put(&quot;K2&quot;,hashSet2);        broadcasts.put(&quot;K3&quot;,hashSet3);        broadcasts.put(&quot;K4&quot;,hashSet4);        broadcasts.put(&quot;K5&quot;,hashSet5);        &#x2F;&#x2F; 创建一个HashSet表示能覆盖的所有地区        HashSet&lt;String&gt; allAreas &#x3D; new HashSet&lt;&gt;();        allAreas.add(&quot;北京&quot;);        allAreas.add(&quot;上海&quot;);        allAreas.add(&quot;天津&quot;);        allAreas.add(&quot;广州&quot;);        allAreas.add(&quot;深圳&quot;);        allAreas.add(&quot;成都&quot;);        allAreas.add(&quot;杭州&quot;);        allAreas.add(&quot;大连&quot;);        &#x2F;&#x2F; 定义一个ArrayList存放广播台        ArrayList&lt;String&gt; selects &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F; 定义一个临时变量，存放覆盖所有地区allAreas和当前覆盖地区的交集        HashSet&lt;String&gt; tempSet &#x3D; new HashSet&lt;&gt;();        &#x2F;&#x2F; 定义一个maxKey，指向能覆盖最大地区的电台的key        String maxKey &#x3D; null;        &#x2F;&#x2F; 遍历        while (allAreas.size() !&#x3D; 0)&#123;            &#x2F;&#x2F; 每次进行while都要将maxKey置空            maxKey &#x3D; null;            &#x2F;&#x2F; 遍历broadcast.keySet拿到所有的key            for (String key : broadcasts.keySet()) &#123;                &#x2F;&#x2F; 每次进行for都要将tempSet置空                tempSet.clear();                &#x2F;&#x2F; 将key所对应的覆盖地区加入到tempSet中                HashSet&lt;String&gt; areas &#x3D; broadcasts.get(key);                tempSet.addAll(areas);                &#x2F;&#x2F; 求tempSet和allAreas的交集，并赋给tempSet                tempSet.retainAll(allAreas);                &#x2F;&#x2F; 判断当前tempSet指向的key是否是覆盖最多地区的，如果是，将maxKey指向当前的key                &#x2F;&#x2F; tempSet.size() &gt; broadcasts.get(maxKey).size()：当前key指向的电台覆盖地区比maxKey的还要多                if (tempSet.size() &gt; 0  &amp;&amp; (maxKey &#x3D;&#x3D; null || tempSet.size() &gt; broadcasts.get(maxKey).size()))&#123;                    maxKey &#x3D; key;                &#125;            &#125;            &#x2F;&#x2F; 先判断maxKey是否空，不为空，再将maxKey加入selects            if (maxKey !&#x3D; null)&#123;                &#x2F;&#x2F; 将maxKey所指的电台加入selects中                selects.add(maxKey);                &#x2F;&#x2F; 将maxKey所覆盖的地区从allAreas中去掉                allAreas.removeAll(broadcasts.get(maxKey));            &#125;        &#125;        System.out.println(&quot;得到的电台为：&quot; + selects);    &#125;&#125;</code></pre></div><h3 id="14-5-4-贪心算法注意事项和细节"><a href="#14-5-4-贪心算法注意事项和细节" class="headerlink" title="14.5.4 贪心算法注意事项和细节"></a>14.5.4 贪心算法注意事项和细节</h3><ol><li>贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果</li><li>比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区</li><li>但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的.</li></ol><h2 id="14-6-普里姆算法"><a href="#14-6-普里姆算法" class="headerlink" title="14.6 普里姆算法"></a>14.6 普里姆算法</h2><h3 id="14-6-1-应用场景-修路问题"><a href="#14-6-1-应用场景-修路问题" class="headerlink" title="14.6.1 应用场景-修路问题"></a>14.6.1 应用场景-修路问题</h3><p>看一个应用场景和问题：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218193642457.png" alt="image-20211218193642457"></p><ol><li>有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通</li><li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</li></ol><p>思路: 将10条边，连接即可，但是总的里程数不是最小.<br>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. </p><h3 id="14-6-2-最小生成树"><a href="#14-6-2-最小生成树" class="headerlink" title="14.6.2 最小生成树"></a>14.6.2 最小生成树</h3><p>修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。</p><ol><li>给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树<br>N个顶点，一定有N-1条边</li><li>包含全部顶点</li><li>N-1条边都在图中</li><li>举例说明(如图:)</li><li>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218193809266.png" alt="image-20211218193809266"></p><h3 id="14-6-3-普里姆算法介绍"><a href="#14-6-3-普里姆算法介绍" class="headerlink" title="14.6.3 普里姆算法介绍"></a>14.6.3 普里姆算法介绍</h3><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图</p><p>普利姆的算法如下:</p><ol><li>设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </li><li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</li><li>若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</li><li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li><li>提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.</li><li>图解</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218193918120.png" alt="image-20211218193918120"></p><h3 id="14-6-4-普里姆算法最佳实践-修路问题"><a href="#14-6-4-普里姆算法最佳实践-修路问题" class="headerlink" title="14.6.4 普里姆算法最佳实践(修路问题)"></a>14.6.4 普里姆算法最佳实践(修路问题)</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218194017208.png" alt="image-20211218194017208"></p><ol><li>胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通</li><li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li><li>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</li><li>看老师思路分析+代码演示: </li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.prim;import java.util.Arrays;public class PrimAlgorithm &#123;    public static void main(String[] args) &#123;        char[] data &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;        int verxs &#x3D; data.length;        int[][] weight &#x3D; new int[][]&#123;                &#123;10000, 5, 7, 10000, 10000, 10000, 2&#125;,                &#123;5, 10000, 10000, 9, 10000, 10000, 3&#125;,                &#123;7, 10000, 10000, 10000, 8, 10000, 10000&#125;,                &#123;10000, 9, 10000, 10000, 10000, 4, 10000&#125;,                &#123;10000, 10000, 8, 10000, 10000, 5, 4&#125;,                &#123;10000, 10000, 10000, 4, 5, 10000, 6&#125;,                &#123;2, 3, 10000, 10000, 4, 6, 10000&#125;        &#125;;        &#x2F;&#x2F; 创建一个图对象        MGraph graph &#x3D; new MGraph(verxs);        &#x2F;&#x2F; 创建MinTree对象        MinTree minTree &#x3D; new MinTree();        minTree.createGraph(graph,verxs,data,weight);        &#x2F;&#x2F; 显示图        minTree.showGraph(graph);        &#x2F;&#x2F; 测试普里姆算法        minTree.prim(graph,0 );    &#125;&#125;&#x2F;&#x2F; 创建最小生成树class MinTree&#123;    &#x2F;&#x2F; 创建邻接矩阵    &#x2F;**     *     * @param graph 图对象     * @param verxs 图的结点个数     * @param data 图的数据     * @param weight 图的邻接矩阵     *&#x2F;    public void createGraph(MGraph graph, int verxs, char[] data, int[][] weight)&#123;        int i, j;        for (i &#x3D; 0; i &lt; verxs; i++)&#123;        &#x2F;&#x2F; 顶点            graph.data[i] &#x3D; data[i];            for (j &#x3D; 0; j &lt; verxs; j++)&#123;                graph.weight[i][j] &#x3D; weight[i][j];            &#125;        &#125;    &#125;    &#x2F;&#x2F; 显示图的方法    public void showGraph(MGraph graph)&#123;        for (int[] link : graph.weight) &#123;            System.out.println(Arrays.toString(link));        &#125;    &#125;    &#x2F;**     * 普利姆算法     * @param graph 需要生成最小成树的图     * @param v 表示从图的第几个顶点开始     *&#x2F;    public void prim(MGraph graph,int v)&#123;        &#x2F;&#x2F; 表示已经访问过的顶点        int[] visited &#x3D; new int[graph.verxs];        &#x2F;&#x2F; 设置当前v为已经访问        visited[v] &#x3D; 1;        &#x2F;&#x2F; 定义两个辅助变量，记录两个结点的下标        int h1 &#x3D; -1;        int h2 &#x3D; -1;        int minWeight &#x3D; 10000;      &#x2F;&#x2F; 表示两边之间的权值，会被小的替换        &#x2F;&#x2F; 开始遍历边，因为有graph.verxs顶点，普利姆算法结束后，有graph.verxs - 1边        for (int k &#x3D; 1; k &lt; graph.verxs; k++)&#123;            &#x2F;&#x2F; 这个是确定每一次生成的子图，和哪个结点的距离最近            for (int i &#x3D; 0; i &lt; graph.verxs; i++)&#123;      &#x2F;&#x2F; 遍历已经访问过的结点                for (int j &#x3D; 0; j &lt; graph.verxs; j++)&#123;  &#x2F;&#x2F; 遍历还没访问过的结点                    if (visited[i] &#x3D;&#x3D; 1 &amp;&amp; visited[j] &#x3D;&#x3D; 0 &amp;&amp; graph.weight[i][j] &lt; minWeight)&#123;                        &#x2F;&#x2F; 将当前小的边换成minWeight                        minWeight &#x3D; graph.weight[i][j];                        &#x2F;&#x2F; 记录当前两个结点的下标                        h1 &#x3D; i;                        h2 &#x3D; j;                    &#125;                &#125;            &#125;            &#x2F;&#x2F; 退出循环时，已经找到一条边了            System.out.println(&quot;&lt;&quot; + graph.data[h1] + &quot;,&quot; + graph.data[h2] + &quot;&gt; 权值：&quot; + graph.weight[h1][h2]);            &#x2F;&#x2F; 将h2的结点标记为已经访问过            visited[h2] &#x3D; 1;            &#x2F;&#x2F; 将minWeight的值重置为10000，表示不通            minWeight &#x3D; 10000;        &#125;    &#125;&#125;class MGraph&#123;    int verxs;      &#x2F;&#x2F; 表示图的结点个数    char[] data;    &#x2F;&#x2F; 表示图的存放的数据    int[][] weight; &#x2F;&#x2F; 表示图的边，邻接矩阵    public MGraph(int verxs)&#123;        this.verxs &#x3D; verxs;        data &#x3D; new char[verxs];        weight &#x3D; new int[verxs][verxs];    &#125;&#125;</code></pre></div><h2 id="14-7-克鲁斯卡尔算法"><a href="#14-7-克鲁斯卡尔算法" class="headerlink" title="14.7 克鲁斯卡尔算法"></a>14.7 克鲁斯卡尔算法</h2><h3 id="14-7-1-应用场景-公交站问题"><a href="#14-7-1-应用场景-公交站问题" class="headerlink" title="14.7.1 应用场景-公交站问题"></a>14.7.1 应用场景-公交站问题</h3><p>看一个应用场景和问题：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218232807846.png" alt="image-20211218232807846"></p><ol><li>某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通</li><li>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里</li><li>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? </li></ol><h3 id="14-7-2-克鲁斯卡尔算法介绍"><a href="#14-7-2-克鲁斯卡尔算法介绍" class="headerlink" title="14.7.2 克鲁斯卡尔算法介绍"></a>14.7.2 克鲁斯卡尔算法介绍</h3><ol><li>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</li><li>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路</li><li>具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</li></ol><h3 id="14-7-3-克鲁斯卡尔算法图解说明"><a href="#14-7-3-克鲁斯卡尔算法图解说明" class="headerlink" title="14.7.3 克鲁斯卡尔算法图解说明"></a>14.7.3 克鲁斯卡尔算法图解说明</h3><p>以城市公交站问题来图解说明 克鲁斯卡尔算法的原理和步骤：</p><p>在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。<br> <img src="file:///C:\Users\a\AppData\Local\Temp\msohtmlclip1\01\clip_image002.jpg" alt="img"><a href="https://github.com/wangkuiwu/datastructs_and_algorithm/blob/master/pictures/graph/kruskal/01.jpg?raw=true"><img src="file:///C:\Users\a\AppData\Local\Temp\msohtmlclip1\01\clip_image003.gif" alt="说明: IMG_256"></a></p><p>例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。</p><p><img src="file:///C:\Users\a\AppData\Local\Temp\msohtmlclip1\01\clip_image005.jpg" alt="img"></p><h4 id="克鲁斯卡尔算法图解"><a href="#克鲁斯卡尔算法图解" class="headerlink" title="克鲁斯卡尔算法图解"></a><strong>克鲁斯卡尔算法图解</strong></h4><p>以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image007.jpg" alt="说明: 03"></p><p>第1步：将边&lt;E,F&gt;加入R中。<br>   边&lt;E,F&gt;的权值最小，因此将它加入到最小生成树结果R中。<br> 第2步：将边&lt;C,D&gt;加入R中。<br>   上一步操作之后，边&lt;C,D&gt;的权值最小，因此将它加入到最小生成树结果R中。<br> 第3步：将边&lt;D,E&gt;加入R中。<br>   上一步操作之后，边&lt;D,E&gt;的权值最小，因此将它加入到最小生成树结果R中。<br> 第4步：将边&lt;B,F&gt;加入R中。<br>   上一步操作之后，边&lt;C,E&gt;的权值最小，但&lt;C,E&gt;会和已有的边构成回路；因此，跳过边&lt;C,E&gt;。同理，跳过边&lt;C,F&gt;。将边&lt;B,F&gt;加入到最小生成树结果R中。<br> 第5步：将边&lt;E,G&gt;加入R中。<br>   上一步操作之后，边&lt;E,G&gt;的权值最小，因此将它加入到最小生成树结果R中。<br> 第6步：将边&lt;A,B&gt;加入R中。<br>   上一步操作之后，边&lt;F,G&gt;的权值最小，但&lt;F,G&gt;会和已有的边构成回路；因此，跳过边&lt;F,G&gt;。同理，跳过边&lt;B,C&gt;。将边&lt;A,B&gt;加入到最小生成树结果R中。</p><p>此时，最小生成树构造完成！它包括的边依次是：&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</p><h4 id="克鲁斯卡尔算法分析"><a href="#克鲁斯卡尔算法分析" class="headerlink" title="克鲁斯卡尔算法分析"></a><strong>克鲁斯卡尔算法分析</strong></h4><p>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br> <strong>问题一</strong> 对图的所有边按照权值大小进行排序。<br> <strong>问题二</strong> 将边添加到最小生成树中时，怎么样判断是否形成了回路。</p><p>问题一很好解决，采用排序算法进行排序即可。</p><p>问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p><h4 id="如何判断是否构成回路-举例说明-如图"><a href="#如何判断是否构成回路-举例说明-如图" class="headerlink" title="如何判断是否构成回路-举例说明(如图)"></a><strong>如何判断是否构成回路-举例说明(如图)</strong></h4><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image009.jpg" alt="img"></p><p>在将&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt;加入到最小生成树R中之后，这几条边的顶点就都有了终点：</p><p><strong>(01)</strong> C的终点是F。<br> <strong>(02)</strong> D的终点是F。<br> <strong>(03)</strong> E的终点是F。<br> <strong>(04)</strong> F的终点是F。</p><p>关于终点的说明：</p><ol><li><p>就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 </p></li><li><p>因此，接下来，虽然&lt;C,E&gt;是权值最小的边。但是C和E的终点都是F，即它们的终点相同，因此，将&lt;C,E&gt;加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。【后面有代码说明】</p></li></ol><h3 id="14-7-4-克鲁斯卡尔最佳实践-公交站问题"><a href="#14-7-4-克鲁斯卡尔最佳实践-公交站问题" class="headerlink" title="14.7.4 克鲁斯卡尔最佳实践-公交站问题"></a>14.7.4 克鲁斯卡尔最佳实践-公交站问题</h3><p>看一个公交站问题：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211218233333980.png" alt="image-20211218233333980"></p><ol><li>有北京有新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通</li><li>各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里</li><li>问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? </li><li>代码实现</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.kruskal;import java.util.Arrays;public class KruskalCase &#123;    private int edgeNum;    &#x2F;&#x2F; 边的个数    private char[] vertexs; &#x2F;&#x2F; 顶点数组    private int[][] matrix; &#x2F;&#x2F; 邻接矩阵    &#x2F;&#x2F; 定义一个Integer的最大值，表示两点不连通    private static final int INF &#x3D;Integer.MAX_VALUE;    public static void main(String[] args) &#123;        char[] vertexs &#x3D; &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;        int[][] matrix &#x3D; &#123;                &#123;0,12,INF,INF,INF,16,14&#125;,                &#123;12,0,10,INF,INF,7,INF&#125;,                &#123;INF,10,0,3,5,6,INF&#125;,                &#123;INF,INF,3,0,4,INF,INF&#125;,                &#123;INF,INF,5,4,0,2,8&#125;,                &#123;16,7,6,INF,2,0,9&#125;,                &#123;14,INF,INF,INF,8,9,0&#125;        &#125;;        KruskalCase kruskalCase &#x3D; new KruskalCase(vertexs, matrix);        &#x2F;&#x2F; 输出        kruskalCase.printf();        &#x2F;*EData[] edges &#x3D; kruskalCase.getEdges();        System.out.println(&quot;排序前：&quot;);        System.out.println(Arrays.toString(edges));        kruskalCase.sortEdges(edges);        System.out.println(&quot;排序后&quot;);        System.out.println(Arrays.toString(edges));*&#x2F;        kruskalCase.kruskal();    &#125;    &#x2F;&#x2F; 构造器    public KruskalCase(char[] vertexs, int[][] matrix)&#123;        &#x2F;&#x2F; 初始化边和顶点        int vlen &#x3D; vertexs.length;        this.vertexs &#x3D; new char[vlen];        &#x2F;&#x2F; 初始化顶点，复制的方式        for (int i &#x3D; 0; i &lt; vertexs.length; i++)&#123;            this.vertexs[i] &#x3D; vertexs[i];        &#125;        &#x2F;&#x2F; 初始化边        this.matrix &#x3D; new int[vlen][vlen];        for (int i &#x3D; 0; i &lt; matrix.length; i++)&#123;            for (int j &#x3D; 0; j &lt; matrix.length; j++)&#123;                this.matrix[i][j] &#x3D; matrix[i][j];            &#125;        &#125;        &#x2F;&#x2F; 统计边的条数        for (int i &#x3D; 0; i &lt; vlen; i++)&#123;            for (int j &#x3D; i + 1; j &lt; vlen; j++) &#123;                if (this.matrix[i][j] !&#x3D; INF)&#123;                    edgeNum++;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 克鲁斯卡尔算法    public void kruskal()&#123;        int index &#x3D; 0;  &#x2F;&#x2F; 表示最后结果数组的索引        int[] ends &#x3D; new int[edgeNum];  &#x2F;&#x2F; 用于保存“已有最小生成树”中的每一个顶点再最小生成树中的终点        &#x2F;&#x2F; 创建数组，保存最后的最小生成树        EData[] rets &#x3D; new EData[edgeNum];        &#x2F;&#x2F; 获取图中所有的边的集合        EData[] edges &#x3D; getEdges();        System.out.println(&quot;图中的集合&#x3D; &quot; + Arrays.toString(edges) + &quot;共&quot; + edges.length);        &#x2F;&#x2F; 按照边的大小进行排序，从小到大        sortEdges(edges);        &#x2F;&#x2F; 遍历edges数组，将边添加到最小生成树中时，判断是准备加入的边是否形成了回路，如果没有，就加入rets，否则不能加入        for (int i &#x3D; 0; i &lt; edgeNum; i++)&#123;            &#x2F;&#x2F; 获取第i条边的始点            int p1 &#x3D; getPosition(edges[i].start);            &#x2F;&#x2F; 获取第i条边的终点            int p2 &#x3D; getPosition(edges[i].end);            &#x2F;&#x2F; 获取p1的终点            int m &#x3D; getEnd(ends, p1);            &#x2F;&#x2F; 获取p2的终点            int n &#x3D; getEnd(ends, p2);            if (m !&#x3D; n)&#123;                &#x2F;&#x2F; 说明不存在回路                &#x2F;&#x2F; 先将终点的下标放进ends数组中                ends[m] &#x3D; n;                &#x2F;&#x2F; 将新的边加入到rets数组                rets[index++] &#x3D; edges[i];            &#125;        &#125;        System.out.println(&quot;最小生成树为：&quot;);        for (int i &#x3D; 0; i &lt; index; i++)&#123;            System.out.println(rets[i]);        &#125;    &#125;    &#x2F;&#x2F; 打印邻接矩阵    public void printf()&#123;        System.out.println(&quot;邻接矩阵为：&quot;);        for (int i &#x3D; 0; i &lt; vertexs.length; i++)&#123;            for (int j &#x3D; 0; j &lt;vertexs.length; j++)&#123;                System.out.printf(&quot;%12d&quot;,matrix[i][j]);            &#125;            System.out.println();        &#125;    &#125;    &#x2F;&#x2F; 对边进行排序：冒泡排序    private void sortEdges(EData[] eDatas)&#123;        for (int i &#x3D; 0; i &lt; eDatas.length - 1; i++)&#123;            for (int j &#x3D; 0; j &lt; eDatas.length - 1 - i; j++)&#123;                if (eDatas[j].weight &gt; eDatas[j + 1].weight)&#123;                    EData temp &#x3D; eDatas[j];                    eDatas[j] &#x3D; eDatas[j + 1];                    eDatas[j + 1] &#x3D; temp;                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 获取顶点的值对应的下标    &#x2F;**     * 功能：获取顶点的值对应的下标     * @param ch 传进来的值，如&#39;A&#39;,&#39;B&#39;...     * @return 返回对应的下标，否则返回-1     *&#x2F;    private int getPosition(char ch)&#123;        for (int i &#x3D; 0; i &lt;vertexs.length; i++)&#123;            &#x2F;&#x2F; 说明找到了            if (vertexs[i] &#x3D;&#x3D; ch)&#123;                return i;            &#125;        &#125;        return -1;    &#125;    &#x2F;&#x2F; 获取图中的边，放到EData[]数组中，方便后面的遍历    private EData[] getEdges()&#123;        int index &#x3D; 0;        EData[]  eDatas &#x3D; new EData[edgeNum];        for (int i &#x3D; 0; i &lt; vertexs.length; i++)&#123;            for (int j &#x3D; i + 1; j &lt; vertexs.length; j++)&#123;                if (matrix[i][j] !&#x3D; INF)&#123;                    eDatas[index++] &#x3D; new EData(vertexs[i],vertexs[j],matrix[i][j]);                &#125;            &#125;        &#125;        return eDatas;    &#125;    &#x2F;**     * 功能：获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同     * @param ends  数组就是记录各个顶点对应的终点是哪一个     * @param i     表示传入的顶点对应的下标     * @return 返回的就是下标为i的这个顶点对应的终点的下标     *&#x2F;    private int getEnd(int[] ends, int i)&#123;        &#x2F;&#x2F; ends[i] !&#x3D; 0, 表示的是，顶点下标为i的顶点，它有终点，并且终点的下标就是ends[i]的值        &#x2F;&#x2F; ends[i] 数组里面的i表示的是起始顶点的下标，终点的下标为数组的值，即下标为i对应的数组的值        while (ends[i] !&#x3D; 0)&#123;   &#x2F;&#x2F; 说明有终点            &#x2F;&#x2F; 将终点的下标返回给i            i &#x3D; ends[i];        &#125;        return i;    &#125;&#125;&#x2F;&#x2F; 创建一个EData类，他的对象实例表示的就是一条边class EData&#123;    char start;     &#x2F;&#x2F; 边的一个点    char end;       &#x2F;&#x2F; 边的另一个点    int weight;     &#x2F;&#x2F; 边的权值    public EData(char start,char end, int weight)&#123;        this.start &#x3D; start;        this.end &#x3D; end;        this.weight &#x3D; weight;    &#125;    @Override    public String toString() &#123;        return &quot;EData&#123;&quot; +                &quot;&lt;&quot; + start +                &quot;, &quot; + end +                &quot;&gt; &#x3D; &quot; + weight +                &#39;&#125;&#39;;    &#125;&#125;</code></pre></div><h2 id="14-8-迪杰斯特拉算法"><a href="#14-8-迪杰斯特拉算法" class="headerlink" title="14.8 迪杰斯特拉算法"></a>14.8 迪杰斯特拉算法</h2><h3 id="14-8-1-应用场景-最短路径问题"><a href="#14-8-1-应用场景-最短路径问题" class="headerlink" title="14.8.1 应用场景-最短路径问题"></a>14.8.1 应用场景-最短路径问题</h3><p>看一个应用场景和问题：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219191601864.png" alt="image-20211219191601864"></p><ol><li>战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</li><li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li><li>问：如何计算出G村庄到 其它各个村庄的最短距离? </li><li>如果从其它点出发到各个点的最短距离又是多少?</li></ol><h3 id="14-8-2-迪杰斯特拉-Dijkstra-算法介绍"><a href="#14-8-2-迪杰斯特拉-Dijkstra-算法介绍" class="headerlink" title="14.8.2 迪杰斯特拉(Dijkstra)算法介绍"></a>14.8.2 迪杰斯特拉(Dijkstra)算法介绍</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><h3 id="14-8-3-迪杰斯特拉-Dijkstra-算法过程"><a href="#14-8-3-迪杰斯特拉-Dijkstra-算法过程" class="headerlink" title="14.8.3 迪杰斯特拉(Dijkstra)算法过程"></a>14.8.3 迪杰斯特拉(Dijkstra)算法过程</h3><ol><li>设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</li><li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</li><li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</li><li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li></ol><h3 id="14-8-4-迪杰斯特拉-Dijkstra-算法最佳应用-最短路径"><a href="#14-8-4-迪杰斯特拉-Dijkstra-算法最佳应用-最短路径" class="headerlink" title="14.8.4 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径"></a>14.8.4 迪杰斯特拉(Dijkstra)算法最佳应用-最短路径</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219191748909.png" alt="image-20211219191748909"></p><ol><li>战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄</li><li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li><li>问：如何计算出G村庄到 其它各个村庄的最短距离? </li><li>如果从其它点出发到各个点的最短距离又是多少?</li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219191902640.png" alt="image-20211219191902640"></p><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.dijkstra;import java.util.Arrays;public class DijkstraAlgorithm &#123;    public static void main(String[] args) &#123;        char[] vertex &#x3D; &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;        int[][] matrix &#x3D; new int[vertex.length][vertex.length];        final int N &#x3D; 65535;        matrix[0] &#x3D; new int[]&#123;N,5,7,N,N,N,2&#125;;        matrix[1] &#x3D; new int[]&#123;5,N,N,9,N,N,3&#125;;        matrix[2] &#x3D; new int[]&#123;7,N,N,N,8,N,N&#125;;        matrix[3] &#x3D; new int[]&#123;N,9,N,N,N,4,N&#125;;        matrix[4] &#x3D; new int[]&#123;N,N,8,N,N,5,4&#125;;        matrix[5] &#x3D; new int[]&#123;N,N,N,4,5,N,6&#125;;        matrix[6] &#x3D; new int[]&#123;2,3,N,N,4,6,N&#125;;        &#x2F;&#x2F; 创建图        Graph graph &#x3D; new Graph(vertex,matrix);        graph.showGraph();        &#x2F;&#x2F; 测试dsj        graph.dsj(6);        graph.showDijkstra();    &#125;&#125;&#x2F;&#x2F; 创建图类class Graph&#123;    private char[] vertex;  &#x2F;&#x2F; 顶点数组    private int[][] matrix; &#x2F;&#x2F; 邻接矩阵    private VisitedVertex vv;   &#x2F;&#x2F; 表示已经访问过的顶点    public Graph(char[] vertex, int[][] matrix)&#123;        this.vertex &#x3D; vertex;        this.matrix &#x3D; matrix;    &#125;    &#x2F;&#x2F; 显示结果    public void showDijkstra()&#123;        vv.show();    &#125;    &#x2F;&#x2F; 显示图    public void showGraph()&#123;        for (int[] link : matrix)&#123;            System.out.println(Arrays.toString(link));        &#125;    &#125;    &#x2F;&#x2F; 迪杰斯特拉算法    &#x2F;**     *     * @param index 表示出发顶点出发的下标     *&#x2F;    public void dsj(int index)&#123;        vv &#x3D; new VisitedVertex(vertex.length, index);        update(index);  &#x2F;&#x2F; 更新index顶点到周围顶点的距离和前驱结点        for (int j &#x3D; 1; j &lt; vertex.length; j++)&#123;            index &#x3D; vv.updateArr(); &#x2F;&#x2F; 选择并返回新的访问顶点            update(index);          &#x2F;&#x2F; 更新index顶点到周围顶点的距离和前驱顶点        &#125;    &#125;    &#x2F;&#x2F; 更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点    private void update(int index)&#123;        int len &#x3D; 0;        &#x2F;&#x2F; 遍历邻接矩阵的matrix[index]这一行        for (int j &#x3D; 0; j &lt; matrix[index].length; j++)&#123;            &#x2F;&#x2F; len表示从当前顶点到index的距离+index顶点到j顶点的距离            len &#x3D; vv.getDis(index) + matrix[index][j];            &#x2F;&#x2F; 如果j顶点没有被访问过，并且len小于出发顶点到j顶点的距离，就需要更新            if (!vv.in(j) &amp;&amp; len &lt; vv.getDis(j))&#123;                vv.updatePre(j,index);      &#x2F;&#x2F; 更新j顶点的前驱为index顶点                vv.updateDis(j,len);        &#x2F;&#x2F; 更新出发顶点到 j顶点的距离            &#125;        &#125;    &#125;&#125;class VisitedVertex&#123;    &#x2F;&#x2F; 记录各个顶点是否访问过 1表示访问过，0未访问过，会动态更新    public int[] already_arr;    &#x2F;&#x2F; 每个下标对应的值为前一个顶点下标    public int[] pre_visited;    &#x2F;&#x2F; 记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录出G到其他顶点的距离    public int[] dis;    &#x2F;**     *     * @param length 表示顶点的个数     * @param index 出发顶点对应的下标，G为6     *&#x2F;    public VisitedVertex(int length, int index)&#123;        this.already_arr &#x3D; new int[length];        this.pre_visited &#x3D; new int[length];        this.dis &#x3D; new int[length];        &#x2F;&#x2F; 初始化dis        Arrays.fill(dis,65535);        already_arr[index] &#x3D; 1;     &#x2F;&#x2F; 设置出发顶点为已经访问过        dis[index] &#x3D; 0;             &#x2F;&#x2F; 设置出发顶点的访问距离为0    &#125;    &#x2F;**     * 判断顶点是否被访问过     * @param index     * @return 如果访问过就返回true，否则返回false     *&#x2F;    public boolean in(int index)&#123;        return already_arr[index] &#x3D;&#x3D; 1;    &#125;    &#x2F;**     * 更新出发顶点到index的顶点距离     * @param index     * @param len     * @return     *&#x2F;    public void updateDis(int index, int len)&#123;        dis[index] &#x3D; len;    &#125;    &#x2F;**     * 更新pre这个顶点的前驱顶点为index顶点     * @param pre     * @param index     *&#x2F;    public void updatePre(int pre, int index)&#123;        pre_visited[pre] &#x3D; index;    &#125;    &#x2F;&#x2F; 返回出发顶点到index顶点的距离    public int getDis(int index)&#123;        return dis[index];    &#125;    &#x2F;**     * 继续选择并返回新的访问顶点，比如这里的G完后，就是A点作为新的访问顶点（注意不是出发顶点）     * @return     *&#x2F;    public int updateArr()&#123;        int min &#x3D; 65535,index &#x3D; 0;        for (int i &#x3D; 0; i &lt; already_arr.length; i++)&#123;            if (already_arr[i] &#x3D;&#x3D; 0 &amp;&amp; dis[i] &lt; min)&#123;                min &#x3D; dis[i];                index &#x3D; i;            &#125;        &#125;        &#x2F;&#x2F; 更新index顶点被访问过        already_arr[index] &#x3D; 1;        return index;    &#125;    &#x2F;&#x2F; 显示最后的结果    public void show()&#123;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        for (int i : already_arr) &#123;            System.out.print(i + &quot; &quot;);        &#125;        System.out.println();        for (int i : pre_visited) &#123;            System.out.print(i + &quot; &quot;);        &#125;        System.out.println();        for (int i : dis) &#123;            System.out.print(i+ &quot; &quot;);        &#125;        System.out.println();        &#x2F;&#x2F; 为了方便查看，再做处理        char[] vertex &#x3D; &#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;&#125;;        int count &#x3D; 0;        for (int i : dis) &#123;            if (i !&#x3D; 65535)&#123;                System.out.print(vertex[count] + &quot;(&quot;+i+&quot;)&quot;);            &#125; else &#123;                System.out.print(&quot;N&quot;);            &#125;            count++;        &#125;    &#125;&#125;</code></pre></div><h2 id="14-9-弗洛伊德算法"><a href="#14-9-弗洛伊德算法" class="headerlink" title="14.9 弗洛伊德算法"></a>14.9 弗洛伊德算法</h2><h3 id="14-9-1-弗洛伊德-Floyd-算法介绍"><a href="#14-9-1-弗洛伊德-Floyd-算法介绍" class="headerlink" title="14.9.1 弗洛伊德(Floyd)算法介绍"></a>14.9.1 弗洛伊德(Floyd)算法介绍</h3><ol><li>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li><li>弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径</li><li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li><li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li></ol><h3 id="14-9-2-弗洛伊德-Floyd-算法图解分析"><a href="#14-9-2-弗洛伊德-Floyd-算法图解分析" class="headerlink" title="14.9.2 弗洛伊德(Floyd)算法图解分析"></a>14.9.2 弗洛伊德(Floyd)算法图解分析</h3><ol><li>设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</li><li>至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</li><li>弗洛伊德(Floyd)算法图解分析-举例说明</li></ol><h4 id="示例：求最短路径为例说明"><a href="#示例：求最短路径为例说明" class="headerlink" title="示例：求最短路径为例说明"></a>示例：求最短路径为例说明</h4><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image002-1639920735199.jpg" alt="img"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image004-1639920738023.jpg" alt="img"></p><p>第一轮循环中，以A(下标为：0)作为中间顶点，距离表和前驱关系更新为：</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/clip_image006-1639920740217.jpg" alt="img"></p><p>分析如下：</p><ol><li><p>以A顶点作为中间顶点是，B-&gt;A-&gt;C的距离由N-&gt;9，同理C到B；C-&gt;A-&gt;G的距离由N-&gt;12，同理G到C</p></li><li><p>更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束</p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219213400375.png" alt="image-20211219213400375"></p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219213411251.png" alt="image-20211219213411251"></p><h3 id="14-9-3-弗洛伊德-Floyd-算法最佳应用-最短路径"><a href="#14-9-3-弗洛伊德-Floyd-算法最佳应用-最短路径" class="headerlink" title="14.9.3 弗洛伊德(Floyd)算法最佳应用-最短路径"></a>14.9.3 弗洛伊德(Floyd)算法最佳应用-最短路径</h3><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211219213253709.png" alt="image-20211219213253709"></p><ol><li>胜利乡有7个村庄(A, B, C, D, E, F, G)</li><li>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里</li><li>问：如何计算出各村庄到 其它各村庄的最短距离? </li><li>代码实现</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.floyd;import java.util.Arrays;public class FloydAlgorithm &#123;    public static void main(String[] args) &#123;        char[] vertex &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;        &#x2F;&#x2F; 创建邻接矩阵        int[][] matrix &#x3D; new int[vertex.length][vertex.length];        final int N &#x3D; 65535;        matrix[0] &#x3D; new int[]&#123;0, 5, 7, N, N, N, 2&#125;;        matrix[1] &#x3D; new int[]&#123;5, 0, N, 9, N, N, 3&#125;;        matrix[2] &#x3D; new int[]&#123;7, N, 0, N, 8, N, N&#125;;        matrix[3] &#x3D; new int[]&#123;N, 9, N, 0, N, 4, N&#125;;        matrix[4] &#x3D; new int[]&#123;N, N, 8, N, 0, 5, 4&#125;;        matrix[5] &#x3D; new int[]&#123;N, N, N, 4, 5, 0, 6&#125;;        matrix[6] &#x3D; new int[]&#123;2, 3, N, N, 4, 6, 0&#125;;        Graph graph &#x3D; new Graph(vertex.length, matrix, vertex);        graph.floyd();        graph.show();    &#125;&#125;&#x2F;&#x2F; 创建图class Graph&#123;    private char[] vertex;  &#x2F;&#x2F; 存放顶点的数据    private int[][] dis;    &#x2F;&#x2F; 保存各个顶点出发到其他顶点的距离，最后的结果也保存在该数组中    private int[][] pre;    &#x2F;&#x2F; 保存到达目标顶点的前驱顶点    &#x2F;**     *     * @param length 大小     * @param matrix 邻接矩阵     * @param vertex 顶点数组     *&#x2F;    public Graph(int length, int[][] matrix, char[] vertex)&#123;        this.vertex &#x3D; vertex;        this.dis &#x3D; matrix;        this.pre &#x3D; new int[length][length];        &#x2F;&#x2F; 对pre数组初始化，注意存放的是前驱结点        for (int i &#x3D; 0; i &lt; length; i++)&#123;            Arrays.fill(pre[i],i);        &#125;    &#125;    &#x2F;&#x2F; 显示    public void show()&#123;        &#x2F;&#x2F; 为了方便阅读，这里对代码进行改进        char[] vertex &#x3D; &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;&#125;;        for (int k &#x3D; 0; k &lt; vertex.length; k++)&#123;            &#x2F;&#x2F; 输出pre            for (int i &#x3D; 0; i &lt; vertex.length; i++)&#123;                System.out.print(vertex[pre[k][i]] + &quot; &quot;);            &#125;            System.out.println();            &#x2F;&#x2F; 输出dis            for (int i &#x3D; 0; i &lt; vertex.length; i++)&#123;                System.out.print(&quot;(&quot;+vertex[k]+&quot;到&quot;+vertex[i]+&quot;的最短路劲是&quot;+dis[k][i] + &quot;) &quot;);            &#125;            System.out.println();        &#125;    &#125;    &#x2F;&#x2F; 弗洛伊德算法    public void floyd()&#123;        int len &#x3D; 0;    &#x2F;&#x2F; 用于保存距离        &#x2F;&#x2F; 中间顶点[&#39;A&#39;,&#39;B&#39;...]        for (int k &#x3D; 0; k &lt; dis.length; k++)&#123;            &#x2F;&#x2F; 开始顶点            for (int i &#x3D; 0; i &lt; dis.length; i++)&#123;                &#x2F;&#x2F; 结束顶点                for (int j &#x3D; 0; j &lt; dis.length; j++)&#123;                    len &#x3D; dis[i][k] + dis[k][j];    &#x2F;&#x2F; 从i到k的距离，加上从k到i的距离                    if (len &lt; dis[i][j])&#123;                        &#x2F;&#x2F; 更换小的距离                        len &#x3D; dis[i][j];                        &#x2F;&#x2F; 更新前驱顶点                        pre[i][j] &#x3D; pre[k][j];                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="14-10-马踏棋盘算法"><a href="#14-10-马踏棋盘算法" class="headerlink" title="14.10 马踏棋盘算法"></a>14.10 马踏棋盘算法</h2><h3 id="14-10-1-马踏棋盘算法介绍和游戏演示"><a href="#14-10-1-马踏棋盘算法介绍和游戏演示" class="headerlink" title="14.10.1 马踏棋盘算法介绍和游戏演示"></a>14.10.1 马踏棋盘算法介绍和游戏演示</h3><ol><li><p>马踏棋盘算法也被称为骑士周游问题</p></li><li><p>将马随机放在国际象棋的8×8棋盘Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍</p><p>棋盘上全部64个方格</p></li><li><p>游戏演示: <a href="http://www.4399.com/flash/146267_2.htm">http://www.4399.com/flash/146267_2.htm</a> </p></li></ol><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211220011142307.png" alt="image-20211220011142307"></p><h3 id="14-10-2-马踏棋盘游戏代码实现"><a href="#14-10-2-马踏棋盘游戏代码实现" class="headerlink" title="14.10.2 马踏棋盘游戏代码实现"></a>14.10.2 马踏棋盘游戏代码实现</h3><ol><li><p>马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。</p></li><li><p>如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码实现</p></li><li><p>分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.<br>使用前面的游戏来验证算法是否正确。</p></li></ol><p>对第一种实现方式的思路图解</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211220011331019.png" alt="image-20211220011331019"></p><p>分析第一种存在的问题，并使用贪心算法进行优化，解决马踏棋盘问题</p><p><img src="/myBlog/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/image-20211220011417216.png" alt="image-20211220011417216"></p><p>代码实现</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.atguigu.horse;import java.awt.*;import java.util.ArrayList;import java.util.Comparator;public class HorseChessboard &#123;    private static int X;   &#x2F;&#x2F; 表示列    private static int Y;   &#x2F;&#x2F; 表示行    &#x2F;&#x2F; 创建一个数组，标记棋盘的各个位置是否被访问过    private static boolean visited[];    &#x2F;&#x2F; 使用一个属性，标记是否棋盘的所有位置都被访问    private static boolean finished;    public static void main(String[] args) &#123;        System.out.println(&quot;骑士周游算法开始运行~~&quot;);        &#x2F;&#x2F; 测试骑士周游算法是否正确        X &#x3D; 8;        Y &#x3D; 8;        int row &#x3D; 1;    &#x2F;&#x2F; 马儿初始位置的行，从1开始编号        int column &#x3D; 1; &#x2F;&#x2F; 马儿初始位置的列，从1开始编号        int[][] chessboard &#x3D; new int[X][Y];        visited &#x3D; new boolean[X * Y];   &#x2F;&#x2F; 初始化都是false        &#x2F;&#x2F; 测试一下耗时        long start &#x3D; System.currentTimeMillis();        traversalChessboard(chessboard,row - 1,column - 1,1);        long end &#x3D; System.currentTimeMillis();        System.out.println(&quot;共耗时：&quot; + (end - start) + &quot;毫秒&quot;);        &#x2F;&#x2F; 输出棋盘的情况        for (int[] rows : chessboard)&#123;            for (int step : rows)&#123;                System.out.print(step + &quot;\t&quot;);            &#125;            System.out.println();        &#125;    &#125;    &#x2F;**     * 完成马踏棋盘问题的算法     * @param chessboard 棋盘     * @param row 马儿当前的行，从0开始     * @param column 马儿当前的列，从0开始     * @param step 是第几步，初始位置为1     *&#x2F;    public static void traversalChessboard(int[][] chessboard, int row, int column, int step)&#123;        &#x2F;&#x2F; 走第一步        chessboard[row][column] &#x3D; step;        visited[row * X + column] &#x3D; true;   &#x2F;&#x2F; 标记为已经访问过        &#x2F;&#x2F; 获取当前位置的下一个位置的集合        ArrayList&lt;Point&gt; ps &#x3D; next(new Point(column, row));        &#x2F;&#x2F; 对ps排序        sort(ps);        &#x2F;&#x2F; 遍历ps        while (!ps.isEmpty())&#123;            &#x2F;&#x2F; 取出下一个可以走的地方            Point p &#x3D; ps.remove(0);            &#x2F;&#x2F; 判断是否已经被访问过            if (!visited[p.y * X + p.x])&#123;                &#x2F;&#x2F; 说明还没被访问过                traversalChessboard(chessboard, p.y, p.x, step + 1);            &#125;        &#125;        &#x2F;&#x2F; 判断马儿是否完成了任务，使用step和应该走的步数比较        &#x2F;&#x2F; 如果没有达到要求，则表示没有完成任务，将整个棋盘置0        if (step &lt; X * Y &amp;&amp; !finished)&#123;            chessboard[row][column] &#x3D; 0;            visited[row * X + column] &#x3D; false;        &#125; else &#123;            finished &#x3D; true;        &#125;    &#125;    &#x2F;**     * 功能：根据当前位置（Point对象），计算马儿还能走哪些位置（Point），并放入到集合ArrayList中，最多8个     * @param curPoint     * @return     *&#x2F;    public static ArrayList&lt;Point&gt; next(Point curPoint)&#123;        &#x2F;&#x2F; 创建一个ArrayList        ArrayList&lt;Point&gt; ps &#x3D; new ArrayList&lt;&gt;();        &#x2F;&#x2F; 创建一个Point        Point p1 &#x3D; new Point();        &#x2F;&#x2F; 表示马儿可以走5这个位置        if ((p1.x &#x3D; curPoint.x - 2) &gt;&#x3D; 0 &amp;&amp; (p1.y &#x3D; curPoint.y - 1) &gt;&#x3D; 0)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走6这个位置        if ((p1.x &#x3D; curPoint.x - 1) &gt;&#x3D; 0 &amp;&amp; (p1.y &#x3D; curPoint.y - 2) &gt;&#x3D; 0)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走7这个位置        if ((p1.x &#x3D; curPoint.x + 1) &lt; X  &amp;&amp; (p1.y &#x3D; curPoint.y - 2) &gt;&#x3D; 0)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走0这个位置        if ((p1.x &#x3D; curPoint.x + 2) &lt; X  &amp;&amp; (p1.y &#x3D; curPoint.y - 1) &gt;&#x3D; 0)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走1这个位置        if ((p1.x &#x3D; curPoint.x + 2) &lt; X  &amp;&amp; (p1.y &#x3D; curPoint.y + 1) &lt; Y)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走2这个位置        if ((p1.x &#x3D; curPoint.x + 1) &lt; X  &amp;&amp; (p1.y &#x3D; curPoint.y + 2) &lt; Y)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走3这个位置        if ((p1.x &#x3D; curPoint.x - 1) &gt;&#x3D; 0  &amp;&amp; (p1.y &#x3D; curPoint.y + 2) &lt; Y)&#123;            ps.add(new Point(p1));        &#125;        &#x2F;&#x2F; 表示马儿可以走4这个位置        if ((p1.x &#x3D; curPoint.x - 2) &gt;&#x3D; 0  &amp;&amp; (p1.y &#x3D; curPoint.y + 1) &lt; Y)&#123;            ps.add(new Point(p1));        &#125;        return ps;    &#125;    &#x2F;&#x2F; 根据当前这一步的所有的下一步的选择位置，进行非递减排序，减少回溯的次数    public static void sort(ArrayList&lt;Point&gt; ps)&#123;        ps.sort(new Comparator&lt;Point&gt;() &#123;            @Override            public int compare(Point o1, Point o2) &#123;                &#x2F;&#x2F; 获取o1的下一步到所有位置的个数                int count1 &#x3D; next(o1).size();                &#x2F;&#x2F; 获取o2的下一步到所有位置的个数                int count2 &#x3D; next(o2).size();                if (count1 &lt; count2)&#123;                    return -1;                &#125; else if (count1 &#x3D;&#x3D; count2) &#123;                    return 0;                &#125; else &#123;                    return 1;                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>校外如何访问知网</title>
    <link href="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/"/>
    <url>/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="校外如何访问知网"><a href="#校外如何访问知网" class="headerlink" title="校外如何访问知网"></a>校外如何访问知网</h1><span id="more"></span><h1 id="如何引用文献"><a href="#如何引用文献" class="headerlink" title="如何引用文献"></a>如何引用文献</h1><p>打开中国官网<a href="https://www.cnki.net/">https://www.cnki.net/</a></p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215222009413.png" alt="image-20211215222009413"></p><p>如果想更换其他格式，可以点击更多格式</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215222105527.png" alt="image-20211215222105527"></p><p>按照格式复制即可</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215222123559.png" alt="image-20211215222123559"></p><h1 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h1><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215222402410.png" alt="image-20211215222402410"></p><h2 id="在线阅读"><a href="#在线阅读" class="headerlink" title="在线阅读"></a>在线阅读</h2><p>如果没有登录，只可以查看前面几页。登录了之后会发现需要购买。</p><h2 id="HTML阅读"><a href="#HTML阅读" class="headerlink" title="HTML阅读"></a>HTML阅读</h2><p>没有预览，直接购买。</p><h1 id="如何免费上知网"><a href="#如何免费上知网" class="headerlink" title="如何免费上知网"></a>如何免费上知网</h1><p>先了解一下知网可以通过账号登录，也看通过IP地址登录的</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215222907031.png" alt="image-20211215222907031"></p><h2 id="校内访问"><a href="#校内访问" class="headerlink" title="校内访问"></a>校内访问</h2><p>连接校园网，通过IP登录</p><h2 id="校外访问"><a href="#校外访问" class="headerlink" title="校外访问"></a>校外访问</h2><ol><li><p>通过学校的提供的VPN（这个需要学校购买知网数据库才有，我们学校有购买，可能仅限校内，没有VPN，校外无法访问）</p></li><li><p>通过一些有购买知网数据库的图书馆账号登录。这个是具体操作<a href="https://zhuanlan.zhihu.com/p/344063925">https://zhuanlan.zhihu.com/p/344063925</a></p><p>（我还没试过）<strong>推荐用浙江省图书馆的</strong></p></li></ol><p>如果嫌弃上面这个链接太多不想看的话，我直接挑出来给大家。</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215223735256.png" alt="image-20211215223735256"></p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215223746725.png" alt="image-20211215223746725"></p><p>这是浙江省图书馆地址：<a href="https://www.zjlib.cn/">https://www.zjlib.cn/</a></p><p>拖到网站底部，找到中国知网</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215223916863.png" alt="image-20211215223916863"></p><p>登录上去之后该怎么操作就怎么操作，看论文，引文献等等。</p><p><img src="/myBlog/%E6%A0%A1%E5%A4%96%E8%AE%BF%E9%97%AE%E7%9F%A5%E7%BD%91/image-20211215223945938.png" alt="image-20211215223945938"></p><p>如果这个不行就在上面操作的链接中更换其他省的图书馆即可。</p><h1 id="看论文网站"><a href="#看论文网站" class="headerlink" title="看论文网站"></a>看论文网站</h1><p>中国知网：<a href="https://www.cnki.net/">https://www.cnki.net/</a></p><p>维普：<a href="http://www.cqvip.com/">http://www.cqvip.com/</a></p><p>万方：<a href="https://www.wanfangdata.com.cn/index.html">https://www.wanfangdata.com.cn/index.html</a></p><p>上面三个是官方的，下面几个是仿的，不过也可以试着找找，看看有没有找到</p><p>ReadPaper：<a href="https://readpaper.com/">https://readpaper.com/</a></p><p>iData：<a href="https://www.cn-ki.net/">https://www.cn-ki.net/</a></p><p>（据说iData这个每天可以免费下载5篇，不知道真假，不过他的注册需要手机号，且不支持QQ邮箱）</p><p>如果担心隐私泄露，建议选择官方的。</p>]]></content>
    
    
    <categories>
      
      <category>Q&amp;A</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MybatisPlus</title>
    <link href="/myBlog/MybatisPlus/"/>
    <url>/myBlog/MybatisPlus/</url>
    
    <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><p>需要的基础：Mybatis、Spring、SpringMVC</p><p>为什么要学习这个？MybatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成！</p><p>JPA,tk-mapper.MybatisPlusl</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>什么是MybatisPlus？MyBatis-Plus （简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p><p><img src="/myBlog/MybatisPlus/image-20211116093411885.png" alt="image-20211116093411885"></p><p><img src="/myBlog/MybatisPlus/image-20211116093453821.png" alt="image-20211116093453821"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>地址：<a href="https://mp.baomidou.com/guide/quick-start.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E7%A8%8B">https://mp.baomidou.com/guide/quick-start.html#初始化工程</a></p><p>使用第三方组件：</p><ol><li>导入对应的依赖</li><li>研究依赖如何配置</li><li>代码如何编写</li><li>提高扩展技术能力</li></ol><p><strong>步骤</strong>：</p><ol><li>创建数据库</li><li>创建用户表</li></ol><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE mybaits_plus;CREATE TABLE USER(id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,PRIMARY KEY (id));INSERT INTO USER (id, NAME, age, email) VALUES(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);-- 真实开发中，version（乐观锁），deleted（逻辑删除）、gmt_create、gmt_modified</code></pre></div><ol start="3"><li><p>编写项目，初始化项目！使用SringBoot初始化</p></li><li><p>导入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- mysql驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!-- Lombok --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!-- mybatis-plus --&gt;&lt;!-- mybatis-plus 是自己开发的，并非官方 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>说明：我们使用mybatis-plus可以节省我们大量的代码，尽量不要同时导入mybatis和mybatis-plus！版本的差异！</p></li><li><p>连接数据库，这一步和mybatis相同。</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># mysql 5 驱动不同 com.mysql.jdbc.Driver# mysql 8 驱动不同com.mysql.cj.jdbc.Driver 需要增加时区的配置 serverTimezone&#x3D;GMT%2B8spring.datasource.name&#x3D;rootspring.datasource.password&#x3D;rootspring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306?mybatis_plus?useSSL&#x3D;false&amp;useUnicode&#x3D;true&amp;charecterEncoding&#x3D;utf-8&amp;serverTimezone&#x3D;GMT%2B8spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</code></pre></div><p>传统方式pojo-dao(连接mybatis，配置mapper.xml文件)-server-controller</p></li><li><p>使用mybatis-plus之后</p><ul><li><p>pojo</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@NoArgsConstructor@AllArgsConstructorpublic class User&#123;    private Long id;    private String name;    private Integer age;    private String email;&#125;</code></pre></div></li><li><p>mapper接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 在对应的Mapper上面继承基本的接口BaseMapper&#x2F;&#x2F; 代表持久层@Repositorypublic interface UserMapper extends BaseMapper&lt;User&gt; &#123;    &#x2F;&#x2F; 所有的CRUD操作都已经编写完成了    &#125;</code></pre></div><p>注意点：我们需要在启动类上去扫描mapper包下的所有接口。<code>@MapperScan(&quot;com.kuang.mapper&quot;)</code></p></li><li><p>测试类中的测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass MybatisPlusApplicationTests &#123;    &#x2F;&#x2F; 继承了BaseMapper，所有的方法都来继承父类    @Autowired    private UserMapper userMapper;    @Test    void contextLoads() &#123;        &#x2F;&#x2F; 参数是一个Wrapper，条件构造器，这里我们先不用 ，null        &#x2F;&#x2F; 查询全部用户        List&lt;User&gt; userList &#x3D; userMapper.selectList(null);        userList.forEach(System.out::println);    &#125;&#125;</code></pre></div></li><li><p>结果</p><p><img src="/myBlog/MybatisPlus/image-20211116113454027.png" alt="image-20211116113454027"></p></li></ul></li></ol><h1 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h1><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 配置日志输入mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</code></pre></div><p><img src="/myBlog/MybatisPlus/image-20211116151253635.png" alt="image-20211116151253635"></p><h1 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h1><h2 id="insert插入"><a href="#insert插入" class="headerlink" title="insert插入"></a>insert插入</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 测试insert@Testpublic void testInsert()&#123;    User user &#x3D; new User();    user.setName(&quot;狂神说Java&quot;);    user.setAge(3);    user.setEmail(&quot;123456789@qq.com&quot;);    &#x2F;&#x2F; 自动生成id    int result &#x3D; userMapper.insert(user);    System.out.println(result);    System.out.println(user);&#125;</code></pre></div><p><img src="/myBlog/MybatisPlus/image-20211116152120783.png" alt="image-20211116152120783"></p><p>数据库插入的id的默认值为：全局的唯一id</p><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p><strong>默认ID_WORKER全局唯一id</strong></p><p>分布式系统唯一id生成：<a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。具体实现的代码可以参看<a href="https://github.com/twitter/snowflake%E3%80%82%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E6%94%AF%E6%8C%81%E7%9A%84TPS%E5%8F%AF%E4%BB%A5%E8%BE%BE%E5%88%B0419%E4%B8%87%E5%B7%A6%E5%8F%B3%EF%BC%882^22*1000%EF%BC%89%E3%80%82">https://github.com/twitter/snowflake。雪花算法支持的TPS可以达到419万左右（2^22*1000）。</a></p><p><strong>主键自增</strong></p><p>我们需要配置主键自增：</p><ol><li>实体类字段上<code>@TableId(type = IdType.AUTO)</code></li><li>数据库字段一定是自增。</li></ol><p><img src="/myBlog/MybatisPlus/image-20211116153637048.png" alt="image-20211116153637048"></p><p><strong>其他的源码解析</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum IdType &#123;    AUTO(0),&#x2F;&#x2F; 数据库id自增    NONE(1),&#x2F;&#x2F; 未设置主键    INPUT(2),&#x2F;&#x2F; 手动输入    ID_WORKER(3),&#x2F;&#x2F; 默认的全局唯一id    UUID(4),&#x2F;&#x2F; 全局唯一id UUID    ID_WORKER_STR(5);&#x2F;&#x2F; ID_WORKER 字符串表示法&#125;</code></pre></div><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;&#x2F; 测试更新@Testpublic void testUpdate()&#123;    User user &#x3D; new User();    &#x2F;&#x2F; 通过条件自动拼接动态SQL    user.setId(6L);    user.setAge(18);    &#x2F;&#x2F; updateById 参数是对象    int i &#x3D; userMapper.updateById(user);    System.out.println(i);&#125;</code></pre></div><p><img src="/myBlog/MybatisPlus/image-20211116155519891.png" alt="image-20211116155519891"></p><p>所有的SQL都是自动帮你动态配置的！</p><h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><p>创建时间、修改时间！这些操作都是自动化完成的，我们不需要手动更新！</p><p>阿里巴巴开发手册：所有的数据库表：gmt_create、gmt_modified几乎所有的表都要配置上！而且需要自动化。</p><h3 id="方式一：数据库级别（工作中不允许修改数据库）"><a href="#方式一：数据库级别（工作中不允许修改数据库）" class="headerlink" title="方式一：数据库级别（工作中不允许修改数据库）"></a>方式一：数据库级别（工作中不允许修改数据库）</h3><ol><li>在表中新增create_time，update_time</li></ol><p>datatime在mysql5.6之后的版本才支持根据时间戳更新 可以用timestamp</p><p><img src="/myBlog/MybatisPlus/image-20211116161102176.png" alt="image-20211116161102176"></p><ol start="2"><li><p>再次测试插入方法，我们需要先把实体类同步。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Date createTime;private Date updateTime;</code></pre></div></li><li><p>查看结果</p><p><img src="/myBlog/MybatisPlus/image-20211116162826518.png" alt="image-20211116162826518"></p></li></ol><h3 id="方式二：代码级别："><a href="#方式二：代码级别：" class="headerlink" title="方式二：代码级别："></a>方式二：代码级别：</h3><ol><li>删除数据库的默认值、更新操作！</li></ol><p><img src="/myBlog/MybatisPlus/image-20211116163035023.png" alt="image-20211116163035023"></p><ol start="2"><li><p>实体类字段属性上需要增加注解 </p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 字段添加填充内容@TableField(fill &#x3D; FieldFill.INSERT)private Date createTime;@TableField(fill &#x3D; FieldFill.INSERT_UPDATE)private Date updateTime;</code></pre></div></li><li><p>编写处理器来处理这个注解即可</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Slf4j&#x2F;&#x2F; 加入到IOC容器中@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    &#x2F;&#x2F; 插入时的填充策略    @Override    public void insertFill(MetaObject metaObject) &#123;        log.info(&quot;start insert fill...&quot;);        &#x2F;&#x2F; default MetaObjectHandler setFieldValByName(        &#x2F;&#x2F; String fieldName, Object fieldVal, MetaObject metaObject)        this.setFieldValByName(&quot;creatTime&quot;,new Date(),metaObject);        this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);    &#125;    &#x2F;&#x2F; 更新时的填充策略    @Override    public void updateFill(MetaObject metaObject) &#123;        log.info(&quot;start update fill...&quot;);        this.setFieldValByName(&quot;updateTime&quot;,new Date(),metaObject);    &#125;&#125;</code></pre></div></li><li><p>测试插入，创建时间和更新时间都会变化</p><p><img src="/myBlog/MybatisPlus/image-20211116165429457.png" alt="image-20211116165429457"></p></li><li><p>测试更新，只有更新时间发送变化</p><p><img src="/myBlog/MybatisPlus/image-20211116165520617.png" alt="image-20211116165520617"></p></li></ol><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>乐观锁：</strong>顾名思义十分乐观，它总是认为不会出现问题，无论干么都不去上锁！如果出现问题了，再次更新值测试</p><p><strong>悲观锁：</strong>十分悲观，认为什么事情都会出现问题，无论干什么都会上锁，再去操作。</p><p>当要更新一条记录的时候，希望这条记录没有被别人更新<br>乐观锁实现方式：</p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败 </li></ul><h3 id="测试一下MP的乐观锁插件"><a href="#测试一下MP的乐观锁插件" class="headerlink" title="测试一下MP的乐观锁插件"></a>测试一下MP的乐观锁插件</h3><ol><li><p>给数据库中增加version字段</p><p><img src="/myBlog/MybatisPlus/image-20211116192030948.png" alt="image-20211116192030948"></p></li><li><p>实体类加对应的字段</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 乐观锁注解@Versionprivate Integer version;</code></pre></div></li><li><p>注册组件</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 扫描Mapper文件夹@MapperScan(&quot;com.kuang.mapper&quot;)@EnableTransactionManagement@Configurationpublic class MybatisPlusConfig &#123;    &#x2F;&#x2F; 注册乐观锁插件    &#x2F;**     * 旧版     *&#x2F;    @Bean    public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;        return new OptimisticLockerInterceptor();    &#125;    &#x2F;**     * 新版，需要更换较新的MybatisPlus的版本     *&#x2F;&#x2F;*    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor mybatisPlusInterceptor &#x3D; new MybatisPlusInterceptor();        mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());        return mybatisPlusInterceptor;    &#125;*&#x2F;&#125;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 测试乐观锁成功@Testpublic void testOptimisticLocker()&#123;    &#x2F;&#x2F; 1.查询用户信息    User user &#x3D; userMapper.selectById(1L);    &#x2F;&#x2F; 2.修改用户信息    user.setName(&quot;kuangshen&quot;);    user.setEmail(&quot;11111111111@qq.com&quot;);    &#x2F;&#x2F; 3.执行操作    userMapper.updateById(user);&#125;&#x2F;&#x2F; 测试乐观锁失败，多线程下@Testpublic void testOptimisticLocker1()&#123;    &#x2F;&#x2F;  线程1    User user &#x3D; userMapper.selectById(1L);    user.setName(&quot;kuangshen111&quot;);    user.setEmail(&quot;11111111111@qq.com&quot;);    &#x2F;&#x2F; 模拟多线性插队操作    User user1 &#x3D; userMapper.selectById(1L);    user1.setName(&quot;kuangshen222222&quot;);    user1.setEmail(&quot;11111111111@qq.com&quot;);    userMapper.updateById(user1);    &#x2F;&#x2F; 插入失败，因为加了乐观锁，version与查询时不一样。    userMapper.updateById(user);&#125;</code></pre></div></li></ol><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 测试查询@Testpublic void testSelectById()&#123;    User user &#x3D; userMapper.selectById(1L);    System.out.println(user);&#125;&#x2F;&#x2F; 测试批量查询@Testpublic void testSelectByBatchId()&#123;    List&lt;User&gt; userList &#x3D; userMapper.selectBatchIds(Arrays.asList(1, 2, 3));    userList.forEach(System.out::println);&#125;&#x2F;&#x2F; 按条件查询之一 map操作@Testpublic void testSelectByBatchIds()&#123;    HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();    map.put(&quot;name&quot;,&quot;狂神说Java&quot;);    map.put(&quot;age&quot;,3);    userMapper.selectByMap(map);&#125;</code></pre></div><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>分页在网站使用的十分多。</p><ol><li>原始的limit进行分页</li><li>PageHelper第三方插件</li><li>MP其实也内置了分页插件！</li></ol><p><strong>使用</strong></p><ol><li><p>配置拦截器组件</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 旧版@Beanpublic PaginationInterceptor paginationInterceptor() &#123;    &#x2F;*PaginationInterceptor paginationInterceptor &#x3D; new PaginationInterceptor();        &#x2F;&#x2F; 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false        &#x2F;&#x2F; paginationInterceptor.setOverflow(false);        &#x2F;&#x2F; 设置最大单页限制数量，默认 500 条，-1 不受限制        &#x2F;&#x2F; paginationInterceptor.setLimit(500);        &#x2F;&#x2F; 开启 count 的 join 优化,只针对部分 left join        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));        return paginationInterceptor;*&#x2F;    &#x2F;&#x2F; 修改之后    return new PaginationInterceptor();&#125;&#x2F;&#x2F; 最新版&#x2F;* @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor &#x3D; new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.H2));        return interceptor;    &#125;*&#x2F;</code></pre></div></li><li><p>直接使用page对象</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testPage()&#123;    &#x2F;&#x2F; 第一个参数：当前页数    &#x2F;&#x2F; 第二个参数：一页的个数    &#x2F;&#x2F; 使用了分页插件之后，所有的页面操作也变得简单了    Page&lt;User&gt; page &#x3D; new Page&lt;User&gt;(1,5);    userMapper.selectPage(page,null);    page.getRecords().forEach(System.out::println);    &#x2F;&#x2F; getSize：当前页面有多少条数据    System.out.println(&quot;getSize&#x3D;&quot;+page.getSize());    &#x2F;&#x2F; getCurrent：当前是第几页    System.out.println(&quot;getCurrent&#x3D;&quot;+page.getCurrent());    &#x2F;&#x2F; getTotal：一共有多少条数据    System.out.println(&quot;getTotal&#x3D;&quot;+page.getTotal());    &#x2F;&#x2F; getPages：一共有多少页    System.out.println(&quot;getPages&#x3D;&quot;+page.getPages());&#125;</code></pre></div></li></ol><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>基本的删除操作</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 测试删除@Testpublic void testDeleteById()&#123;    userMapper.deleteById(1460507717588463621L);&#125;&#x2F;&#x2F; 通过id批量删除@Testpublic void testDeleteByBatchId()&#123;    userMapper.deleteBatchIds(Arrays.asList(1460507717588463620L,1460507717588463619L));&#125;&#x2F;&#x2F; 通过map删除@Testpublic void testDeleteByMap()&#123;    HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();    map.put(&quot;name&quot;,&quot;狂神说Java&quot;);    userMapper.deleteByMap(map);&#125;</code></pre></div><p>工作当中会遇到的一些问题：逻辑删除！</p><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p><strong>物理删除：</strong>从数据库中直接移除</p><p><strong>逻辑删除：</strong>在数据库中没有移除，而是通过一个变量来让他失效！deleted = 0 =&gt; deteled 1</p><p>管理员可以查看被删除的记录！防止数据的丢失！类似回收站。</p><ol><li><p>在数据库表中增加一个deleted字段</p><p><img src="/myBlog/MybatisPlus/image-20211117092038968.png" alt="image-20211117092038968"></p></li><li><p>在实体类中增加属性</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 逻辑删除@TableLogicprivate Integer deleted;</code></pre></div></li><li><p>配置</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 逻辑删除组件(新版本已经没有了。)@Beanpublic ISqlInjector sqlInjector()&#123;    return new LogicSqlInjector();&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 配置逻辑删除mybatis-plus.global-config.db-config.logic-delete-value&#x3D;1mybatis-plus.global-config.db-config.logic-not-delete-value&#x3D;0</code></pre></div></li><li><p>测试</p><p><img src="/myBlog/MybatisPlus/image-20211117093253788.png" alt="image-20211117093253788"></p><p>记录依旧在数据库，但是值已经变了。</p><p><img src="/myBlog/MybatisPlus/image-20211117093314667.png" alt="image-20211117093314667"></p><p>查询的时候，会自动过滤已经被逻辑删除的字段。</p><p><img src="/myBlog/MybatisPlus/image-20211117093559727.png" alt="image-20211117093559727"></p></li></ol><p>以上所有的CRUD操作以及其扩展操作，我们都必须精通掌握，会大大提升工作和写项目的效率。</p><h2 id="性能分析插件"><a href="#性能分析插件" class="headerlink" title="性能分析插件"></a>性能分析插件</h2><p>我们在平时的开发中，会遇到一些慢sql。测试！druid…</p><p>作用：性能分析烂机器，用于输出每条SQL语句以及其执行时间。</p><p>MP也提供了性能分析插件，如果超过这个时间即就停止运行。</p><ol><li><p>导入插件</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;***sql执行效率*&#x2F;@Bean@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)    &#x2F;&#x2F; 设置dev test 环境开启，保证我们的效率public PerformanceInterceptor performanceInterceptor()&#123;    PerformanceInterceptor performanceInterceptor &#x3D; new PerformanceInterceptor();    &#x2F;&#x2F; ms 设置SQL执行的最大时间，如果超过这个时间就不会执行了。    performanceInterceptor.setMaxTime(100);    performanceInterceptor.setFormat(true);    return performanceInterceptor;&#125;</code></pre></div><p>记得，要在springboot中配置环境为dev或者test环境</p></li><li><p>测试使用</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid contextLoads() &#123;    &#x2F;&#x2F; 参数是一个Wrapper，条件构造器，这里我们先不用 ，null    &#x2F;&#x2F; 查询全部用户    List&lt;User&gt; userList &#x3D; userMapper.selectList(null);    userList.forEach(System.out::println);&#125;</code></pre></div><p>超过了规定时间就会抛出异常。</p><p><img src="/myBlog/MybatisPlus/image-20211117100238696.png" alt="image-20211117100238696"></p></li></ol><p>使用性能分析插件，可以帮助我们提高效率！</p><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>十分重要：Wrapper</p><p>我们写一些复杂的SQL就可以使用它来替代！</p><ol><li><p>测试一</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid contextLoads() &#123;    &#x2F;&#x2F; 查询name不为空的用户，并且邮箱不为控的用户，年龄大于等于12岁    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper        .isNotNull(&quot;name&quot;)        .isNotNull(&quot;email&quot;)        .ge(&quot;age&quot;,12);    userMapper.selectList(wrapper).forEach(System.out::println);&#125;</code></pre></div></li><li><p>测试二</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid test2()&#123;    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    wrapper.eq(&quot;name&quot;,&quot;狂神说111111111111111&quot;);    &#x2F;&#x2F; 查询一个数据，出现多个结果使用list或者map    User user &#x3D; userMapper.selectOne(wrapper);    System.out.println(user);&#125;</code></pre></div></li><li><p>测试三</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid test3()&#123;    &#x2F;&#x2F; 查询年龄在20~30岁之间的用户    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; 区间    wrapper.between(&quot;age&quot;,20,30);    &#x2F;&#x2F; 查询结果数    Integer count &#x3D; userMapper.selectCount(wrapper);    System.out.println(count);&#125;</code></pre></div></li><li><p>测试四</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 模糊查询@Testvoid test4()&#123;    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; 左和右 t%:右    wrapper        .notLike(&quot;name&quot;,&quot;e&quot;)        .likeRight(&quot;email&quot;,&quot;t&quot;);    List&lt;Map&lt;String, Object&gt;&gt; maps &#x3D; userMapper.selectMaps(wrapper);    maps.forEach(System.out::println);&#125;</code></pre></div></li><li><p>测试五</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 模糊查询@Testvoid test5()&#123;    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; id 在子查询中查出来    wrapper.inSql(&quot;id&quot;,&quot;select id from user where id&lt;3&quot;);    List&lt;Object&gt; objects &#x3D; userMapper.selectObjs(wrapper);    objects.forEach(System.out::println);&#125;</code></pre></div></li><li><p>测试六</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testvoid test6()&#123;    QueryWrapper&lt;User&gt; wrapper &#x3D; new QueryWrapper&lt;&gt;();    &#x2F;&#x2F; 通过id降序    wrapper.orderByDesc(&quot;id&quot;);    List&lt;User&gt; userList &#x3D; userMapper.selectList(wrapper);    userList.forEach(System.out::println);&#125;</code></pre></div></li></ol><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>根据实际情况，结合官网修改。</p>]]></content>
    
    
    <categories>
      
      <category>MybatisPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MybatisPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找不到该项目，位置不可</title>
    <link href="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/"/>
    <url>/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="找不到该项目，位置不可"><a href="#找不到该项目，位置不可" class="headerlink" title="找不到该项目，位置不可"></a>找不到该项目，位置不可</h1><p>最近遇到了一个问题，那就是删除文件的时候，文件删不掉，说找不到该项目，位置不可用。</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115113810158.png"></p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115113906078-1636947547530.png"></p><p>我找了很多资料，分别是下面几种。第一个是，写一个.bat的删除文件，第二个是用360的粉碎文件，第三个是进去安全模式，第四个是用U盘启动盘删除。<strong>注意：如果前面三个都试过了，建议直接跳到第四个，亲测有效！！</strong></p><p><strong>第一种：编写.bat文件</strong></p><ol><li> 在电脑桌面，新建一个文本文件，把下面的代码复制进去</li></ol><p>DEL /F /A /Q \?%1<br>RD /S /Q \?%1</p><ol start="2"><li><p>点击另存为，选择所有文件，随便起个名字，把后缀改为.bat，确定保存即可</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115114942178.png"></p></li><li><p>接着把需要删除的文件拖到这个.bat文件上面就可以删除了。</p></li></ol><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115115259240.png"></p><p>但是对于我的这个文件没用。</p><p><strong>第二种：用360粉碎文件</strong></p><ol><li><p>打开360，搜索文件粉碎机</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115115452714.png"></p></li><li><p>把要删除的文件拖进来，点击粉碎文件</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115115555774.png"></p><p>但是这个方法，对我来说，还是不管用。</p></li></ol><p><strong>第三种方法：进去安全模式</strong></p><ol><li><p>win+R，输入MSConfig，回车</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115115819049.png"></p></li><li><p>选择引导，在引导选项中勾上安全引导，点击确定。（也可以在开机的时候按快捷键进去安全模式，不同牌子的电脑有些区别，可自行去了解）</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115115933827.png"></p></li><li><p>确定之后会询问你是否重新启动，确保电脑已经保存所有文件，避免重启时丢失，选择重启启动即可。</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115120140977.png"></p></li><li><p>重启之后电脑会进入一个比较原始的画面，不用管他，直接找到删不掉文件的所在位置，和常规操作一样，右键删除，看看是否成功。</p></li><li><p>如果没有成功，先把所有窗口都关闭回到桌面，把开机自动进去安全模式的功能给关了，win+r，输入MSConfig，引导，把安全引导的勾勾给去掉，确定，重新启动即可。</p></li></ol><p>如果用了上面几个方法都没用，请不要放弃，因为我也试过了，都没生效，下面是第四个方法，亲测有效！！！！。</p><p><strong>第四个方法：U盘启动盘删除</strong></p><p>前提：要有U盘启动盘。</p><p>我这里用的是大白菜，如果没有可以去大白菜官网参考教程制作<a href="http://www.winbaicai.com/">http://www.winbaicai.com/</a></p><p>提示一点：制作U盘启动盘的时候最好用空的U盘，以免重要文件丢失。</p><ol><li><p>有了U盘启动盘之后，在大白菜官网查询如何通过U盘启动系统的快捷键，根据自身电脑选择即可。</p><p><img src="/myBlog/%E6%89%BE%E4%B8%8D%E5%88%B0%E8%AF%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%8F%AF%E7%94%A8/image-20211115121724694.png"></p></li><li><p>准备好工具之后，把电脑关机，插入U盘启动盘，开机的时候，按对应的快捷键（如果怕进入不了，可以多按几次）</p></li><li><p>进入之后，有好几个选项，选择通过USB启动。</p></li><li><p>进去到大白菜的界面之后，观察首页有没有启动pe系统选项，如果没有就选择其他，进入其他里面就有了，选择pe启动，确定即可。</p></li><li><p>进入pe系统之后，这又有两个方法。</p></li><li><p>4.1就是打开我的电脑，找到文件所在位置，点击删除，看看能否成功，如果成功就可以了，不成功的话，接着下面的方法。</p></li><li><p>4.2返回pe系统的桌面，找到分区工具，打开电脑所有的文件都可以在里面找到</p></li><li><p>找到要删除的文件，右键，选择强制删除就可以了（<strong>注意：要确保你要删除的不是系统文件，否则会导致系统文件受损，电脑开不了机！！</strong>）</p></li></ol><p>OK，到这里文件就删除了，我的成功。</p><p>分析一下产生删不掉文件的原因：</p><p>经过测试，我之所以会产生这删不掉的文件，是因为我用的md文件编辑软件的图片存储路径弄错了。正常情况下是<code>./$&#123;filename&#125;</code>这样的，而我手误，把./中的.写成了,才导致的。把他改成正确的路径就没事了。</p>]]></content>
    
    
    <categories>
      
      <category>Q&amp;A</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Q&amp;A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC</title>
    <link href="/myBlog/SpringMVC/"/>
    <url>/myBlog/SpringMVC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>ssm: mybatis + Spring + SpringMVC MVC三层架构</p><p>JavaSE:认真学习, 老师带，入门快<br>JavaWeb:认真学习,老师带,入门快<br>SSM框架:研究官方文档，锻炼自学能力，锻炼笔记能力，锻炼项目能力</p><p>SpringMVC + Vue + SpringBoot + SpringCloud + Linux</p><p>SSM = JavaWeb做项目;</p><p>Spring: IOC和APO</p><p>SpringMVC: SpringMVC的执行流程!</p><p>SpringMVC : SSM框架整合!</p><p>Spring</p><p>MVC:模型(dao, service) 视图 (jsp)控制器 (Servlet)<br>dao<br>service<br>servlet :转发，重定向<br>jsp/html</p><p>前端数据传输实体类</p><p>实体类:用户名，密码，生日，爱好，… 20个</p><p>前端:用户名密码</p><p>pojo: User<br>vo: UserVo<br>dto:</p><p><strong>JSP:本质就是一个Servlet</strong></p><p>假设:你的项目的架构，是设计好的，还是演进的?</p><ul><li>Alibaba PHP</li><li>随着用户大， Java</li><li>王坚去 IOE MySQL</li><li>MySQL : MySQL–&gt; AliSQL. AliRedis</li><li>Allinone –微服务</li></ul><p>MVC :</p><p>MWM: M V VM ViewModel :双向绑定</p><h1 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h1><ul><li>MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。</li><li>是将业务逻辑、数据、显示分离的方法来组织代码。</li><li>MVC主要作用是<strong>降低了视图与业务逻辑间的双向偶合</strong>。</li><li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>。当然不同的MVC存在差异。</li></ul><p><strong>Model（模型）：</strong>数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。</p><p><strong>View（视图）：</strong>负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。</p><p><strong>Controller（控制器）：</strong>接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。</p><p><strong>最典型的MVC就是JSP + servlet + javabean的模式。</strong></p><p><img src="/myBlog/SpringMVC/1905053-20200331221325100-1165356814.png" alt="img"></p><h2 id="1-1、Model1时代"><a href="#1-1、Model1时代" class="headerlink" title="1.1、Model1时代"></a>1.1、Model1时代</h2><ul><li>在web早期的开发中，通常采用的都是Model1。</li><li>Model1中，主要分为两层，视图层和模型层。</li></ul><p><img src="/myBlog/SpringMVC/1905053-20200331221347503-978638377.png" alt="img"></p><p>Model1优点：架构简单，比较适合小型项目开发；</p><p>Model1缺点：JSP职责不单一，职责过重，不便于维护；</p><h2 id="1-2、Model2时代"><a href="#1-2、Model2时代" class="headerlink" title="1.2、Model2时代"></a>1.2、Model2时代</h2><p>Model2把一个项目分成三部分，包括<strong>视图、控制、模型。</strong></p><p><img src="/myBlog/SpringMVC/1905053-20200331221406483-639584230.png" alt="img"></p><p>用户发请求</p><ol><li>Servlet接收请求数据，并调用对应的业务逻辑方法</li><li>业务处理完毕，返回更新后的数据给servlet</li><li>servlet转向到JSP，由JSP来渲染页面</li><li>响应给前端更新后的页面</li></ol><p><strong>职责分析：</strong></p><p><strong>Controller：控制器</strong></p><ol><li>取得表单数据</li><li>调用业务逻辑</li><li>转向指定的页面</li></ol><p><strong>Model：模型</strong></p><ol><li>业务逻辑</li><li>保存数据的状态</li></ol><p><strong>View：视图</strong></p><ol><li>显示页面</li></ol><p>Model2这样不仅提高的代码的复用率与项目的扩展性，且大大降低了项目的维护成本。Model 1模式的实现比较简单，适用于快速开发小规模项目，Model1中JSP页面身兼View和Controller两种角色，将控制逻辑和表现逻辑混杂在一起，从而导致代码的重用性非常低，增加了应用的扩展性和维护的难度。Model2消除了Model1的缺点。</p><h2 id="1-3、回顾Servlet"><a href="#1-3、回顾Servlet" class="headerlink" title="1.3、回顾Servlet"></a>1.3、回顾Servlet</h2><ol><li><p>新建一个Maven工程当做父工程！ pom依赖！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.12&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></li><li><p>建立一个Moudle：springmvc-01-servlet ， 添加Web app的支持！</p></li><li><p>导入servlet 和 jsp 的 jar 依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></li><li><p>编写一个Servlet类，用来处理用户的请求</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.servlet;&#x2F;&#x2F;实现Servlet接口public class HelloServlet extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        &#x2F;&#x2F;取得参数        String method &#x3D; req.getParameter(&quot;method&quot;);        if (method.equals(&quot;add&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);        &#125;        if (method.equals(&quot;delete&quot;))&#123;            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);        &#125;        &#x2F;&#x2F;业务逻辑        &#x2F;&#x2F;视图跳转        req.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp&quot;).forward(req,resp);    &#125;    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        doGet(req,resp);    &#125;&#125;</code></pre></div></li><li><p>编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>在web.xml中注册Servlet</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;com.kuang.servlet.HelloServlet&lt;&#x2F;servlet-class&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;user&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre></div></li><li><p>配置Tomcat，并启动测试</p><ul><li>localhost:8080/user?method=add</li><li>localhost:8080/user?method=delete</li></ul></li><li><p>访问结果</p></li></ol><p><strong>MVC框架要做哪些事情</strong></p><ol><li>将url映射到java类或java类的方法 .</li><li>封装用户提交的数据 .</li><li>处理请求–调用相关的业务处理–封装响应数据 .</li><li>将响应的数据进行渲染 . jsp / html 等表示层数据 .</li></ol><p><strong>说明：</strong></p><p>常见的服务器端MVC框架有：Struts、Spring MVC、ASP.NET MVC、Zend Framework、JSF；常见前端MVC框架：vue、angularjs、react、backbone；由MVC演化出了另外一些模式如：MVP、MVVM 等等….</p><h1 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/myBlog/SpringMVC/1905053-20200331222018441-1850931217.png" alt="img"></p><p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p><p>查看官方文档：<a href="https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web">https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/web.html#spring-web</a></p><p><strong>我们为什么要学习SpringMVC呢?</strong></p><p>Spring MVC的特点：</p><ol><li>轻量级，简单易学</li><li>高效 , 基于请求响应的MVC框架</li><li>与Spring兼容性好，无缝结合</li><li>约定优于配置</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li><li>简洁灵活</li></ol><p>Spring的web框架围绕<strong>DispatcherServlet</strong> [ 调度Servlet ] 设计。</p><p>DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁；</p><p>正因为SpringMVC好 , 简单 , 便捷 , 易学 , 天生和Spring无缝集成(使用SpringIoC和Aop) , 使用约定优于配置 . 能够进行简单的junit测试 . 支持Restful风格 .异常处理 , 本地化 , 国际化 , 数据验证 , 类型转换 , 拦截器 等等……所以我们要学习 .</p><p><strong>最重要的一点还是用的人多 , 使用的公司多 .</strong></p><h3 id="中心控制器"><a href="#中心控制器" class="headerlink" title="中心控制器"></a>中心控制器</h3><p>Spring的web框架围绕DispatcherServlet设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p><p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，**DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)**。</p><p><img src="/myBlog/SpringMVC/1905053-20200331222037711-828417064.png" alt="img"></p><p>SpringMVC的原理如下图所示：</p><p>当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p><p><img src="/myBlog/SpringMVC/1905053-20200331222109176-906298972.png" alt="img"></p><h3 id="SpringMVC执行原理"><a href="#SpringMVC执行原理" class="headerlink" title="SpringMVC执行原理"></a>SpringMVC执行原理</h3><p><img src="/myBlog/SpringMVC/1905053-20200331222126131-219513987.png" alt="img"></p><p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p><p><strong>简要分析执行流程</strong></p><ol><li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。<ul><li>我们假设请求的url为 : <a href="http://localhost/">http://localhost</a>:8080/SpringMVC/hello</li><li><strong>如上url拆分成三部分：</strong></li><li><a href="http://localhost/">http://localhost</a>:8080服务器域名</li><li>SpringMVC部署在服务器上的web站点</li><li>hello表示控制器</li><li>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</li></ul></li><li>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</li><li>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</li><li>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</li><li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</li><li>Handler让具体的Controller执行。</li><li>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</li><li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</li><li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</li><li>视图解析器将解析的逻辑视图名传给DispatcherServlet。</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</li><li>最终视图呈现给用户。</li></ol><p>在这里先听一遍原理，不理解没有关系，我们马上来写一个对应的代码实现大家就明白了，如果不明白，那就写10遍，没有笨人，只有懒人！</p><h1 id="3、HelloSpringMVC-配置版"><a href="#3、HelloSpringMVC-配置版" class="headerlink" title="3、HelloSpringMVC(配置版)"></a>3、HelloSpringMVC(配置版)</h1><ol><li><p>新建一个Moudle ， 添加web的支持！</p></li><li><p>确定导入了SpringMVC 的依赖！</p></li><li><p>配置web.xml ， 注册DispatcherServlet</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;!--1.注册DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;!--启动级别-1--&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;!--&#x2F; 匹配所有的请求；（不包括.jsp）--&gt;    &lt;!--&#x2F;* 匹配所有的请求；（包括.jsp）--&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre></div></li><li><p>编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml说明，这里的名称要求是按照官方来的</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt;</code></pre></div></li><li><p>添加 处理映射器</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&#x2F;&gt;</code></pre></div></li><li><p>添加 处理器适配器</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&#x2F;&gt;</code></pre></div></li><li><p>添加 视图解析器</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;InternalResourceViewResolver&quot;&gt;    &lt;!--前缀--&gt;    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;    &lt;!--后缀--&gt;    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></div></li><li><p>编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图；</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;&#x2F;&#x2F;注意：这里我们先导入Controller接口public class HelloController implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;        &#x2F;&#x2F;ModelAndView 模型和视图        ModelAndView mv &#x3D; new ModelAndView();        &#x2F;&#x2F;封装对象，放在ModelAndView中。Model        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC&quot;);        &#x2F;&#x2F;封装要跳转的视图，放在ModelAndView中        mv.setViewName(&quot;hello&quot;); &#x2F;&#x2F;: &#x2F;WEB-INF&#x2F;jsp&#x2F;hello.jsp        return mv;    &#125;    &#125;</code></pre></div></li><li><p>将自己的类交给SpringIOC容器，注册bean</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--Handler--&gt;&lt;bean id&#x3D;&quot;&#x2F;hello&quot; class&#x3D;&quot;com.kuang.controller.HelloController&quot;&#x2F;&gt;</code></pre></div></li><li><p>写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>配置Tomcat 启动测试！</p></li></ol><h2 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a><strong>可能遇到的问题：</strong></h2><p><strong>访问出现404，排查步骤：</strong></p><ol><li>查看控制台输出，看一下是不是缺少了什么jar包。</li><li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！（与classes同级目录）</li></ol><p><img src="/myBlog/SpringMVC/image-20210731181900414.png" alt="image-20210731181900414"></p><p> 3.重启Tomcat 即可解决！</p><p> 4.没有将Controller类交给SpringIOC容器，注册bean！</p><p> 5.出现500的情况：web.xml中的注册DispatcherServlet中的<inin-param>中的<param-value>的classpath写漏，如下图</param-value></inin-param></p><p><img src="/myBlog/SpringMVC/image-20210731184323992.png" alt="image-20210731184323992"></p><p>小结：看这个估计大部分同学都能理解其中的原理了，但是我们实际开发才不会这么写，不然就疯了，还学这个玩意干嘛！我们来看个注解版实现，这才是SpringMVC的精髓，到底有多么简单，看这个图就知道了。</p><h1 id="4、注解开发"><a href="#4、注解开发" class="headerlink" title="4、注解开发"></a>4、注解开发</h1><p><strong>使用注解开发SpringMVC（注解版）</strong></p><p><strong>第一步:新建一个Moudle , 添加web支持！</strong>建立包结构 com.kuang.controller</p><p><strong>第二步:由于Maven可能存在资源过滤的问题，我们将配置完善</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;        &lt;resource&gt;            &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;            &lt;includes&gt;                &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;            &lt;&#x2F;includes&gt;            &lt;filtering&gt;false&lt;&#x2F;filtering&gt;        &lt;&#x2F;resource&gt;    &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre></div><p><strong>第三步:在pom.xml文件引入相关的依赖</strong>：<br>主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！</p><p><strong>第四步:配置web.xml</strong></p><p>注意点：</p><ul><li>注意web.xml版本问题，要最新版！</li><li>注册DispatcherServlet</li><li>关联SpringMVC的配置文件</li><li>启动级别为1</li><li>映射路径为 / 【不要用/*，会404】</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;!--1.注册servlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;!--所有请求都会被springmvc拦截 --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">&#x2F; 和 &#x2F;* 的区别：&lt; url-pattern &gt; &#x2F; &lt;&#x2F; url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 。&lt; url-pattern &gt; &#x2F;* &lt;&#x2F; url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。</code></pre></div><p><strong>第五步:添加Spring MVC配置文件</strong></p><ul><li>让IOC的注解生效</li><li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li><li>MVC的注解驱动</li><li>配置视图解析器</li></ul><p>在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下：</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;    &lt;!-- 让Spring MVC不处理静态资源 过滤掉一些静态资源，如.css  .js  .html .mp3--&gt;    &lt;mvc:default-servlet-handler &#x2F;&gt;    &lt;!--    支持mvc注解驱动        在spring中一般采用@RequestMapping注解来完成映射关系        要想使@RequestMapping注解生效        必须向上下文中注册DefaultAnnotationHandlerMapping        和一个AnnotationMethodHandlerAdapter实例        这两个实例分别在类级别和方法级别处理。        而annotation-driven配置帮助我们自动完成上述两个实例的注入。     --&gt;    &lt;mvc:annotation-driven &#x2F;&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;        &lt;!-- 后缀 --&gt;        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div><p>在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。</p><p><strong>第六步:创建Controller</strong></p><p>编写一个Java控制类： com.kuang.controller.HelloController , 注意编码规范</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;&#x2F;HelloController&quot;)&#x2F;&#x2F;多添加一级访问public class HelloController &#123;    &#x2F;&#x2F;真实访问地址 : 项目名&#x2F;HelloController&#x2F;hello    @RequestMapping(&quot;&#x2F;hello&quot;)&#x2F;&#x2F;请求路径    public String sayHello(Model model) &#123;        &#x2F;&#x2F;向模型中添加属性msg与值，可以在JSP页面中取出并渲染        model.addAttribute(&quot;msg&quot;, &quot;hello,SpringMVC，我是成博&quot;);        &#x2F;&#x2F;会被视图解析器处理，web-inf&#x2F;jsp&#x2F;hello.jsp        return &quot;hello&quot;;    &#125;&#125;</code></pre></div><ul><li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li><li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello；</li><li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li><li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>hello</strong>.jsp。</li></ul><p><strong>第七步:创建视图层</strong></p><p>在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p><p>可以通过EL表示取出Model中存放的值，或者对象；</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;SpringMVC&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p><strong>第八步:配置Tomcat运行</strong></p><p>配置Tomcat ， 开启服务器 ， 访问 对应的请求路径！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>实现步骤其实非常的简单：  </p><ol><li>新建一个web项目</li><li>导入相关jar包</li><li>编写web.xml , 注册DispatcherServlet</li><li>编写springmvc配置文件</li><li>接下来就是去创建对应的控制类 , controller</li><li>最后完善前端视图和controller之间的对应</li><li>测试运行调试.</li></ol><p>使用springMVC必须配置的三大件：</p><p><strong>处理器映射器、处理器适配器、视图解析器</strong></p><p>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</p><h1 id="5、Controller-及-RestFul风格"><a href="#5、Controller-及-RestFul风格" class="headerlink" title="5、Controller 及 RestFul风格"></a>5、Controller 及 RestFul风格</h1><h3 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h3><ul><li>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</li><li>控制器负责解析用户的请求并将其转换为一个模型。</li><li>在Spring MVC中一个控制器类可以包含多个方法</li><li>在Spring MVC中，对于Controller的配置方式有很多种</li></ul><p>我们来看看有哪些方式可以实现：</p><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;实现该接口的类获得控制器功能public interface Controller &#123;    &#x2F;&#x2F;处理请求且返回一个模型与视图对象    ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125;</code></pre></div><p><strong>测试</strong></p><ol><li><p>新建一个Moudle，springmvc-04-controller 。 将刚才的03 拷贝一份, 我们进行操作！</p><ul><li>删掉HelloController</li><li>mvc的配置文件只留下 视图解析器！</li></ul></li><li><p>编写一个Controller类，ControllerTest1</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;定义控制器&#x2F;&#x2F;注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        &#x2F;&#x2F;返回一个模型视图对象        ModelAndView mv &#x3D; new ModelAndView();        mv.addObject(&quot;msg&quot;,&quot;Test1Controller&quot;);        mv.setViewName(&quot;test&quot;);        return mv;    &#125;&#125;</code></pre></div></li><li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;bean name&#x3D;&quot;&#x2F;t1&quot; class&#x3D;&quot;com.kuang.controller.ControllerTest1&quot;&#x2F;&gt;</code></pre></div></li><li><p>编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    $&#123;msg&#125;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK</p></li></ol><p><strong>说明：</strong></p><ul><li>实现接口Controller定义控制器是较老的办法</li><li>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</li></ul><h3 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a>使用注解@Controller</h3><ul><li>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</li><li>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;</code></pre></div><ul><li>增加一个ControllerTest2类，使用注解实现；</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;@Controller注解的类会自动添加到Spring上下文中&#x2F;&#x2F;代表这个类会被Spring按管&#x2F;&#x2F;被这个注解的类，中的所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析;@Controllerpublic class ControllerTest2&#123;    &#x2F;&#x2F;映射访问路径    @RequestMapping(&quot;&#x2F;t2&quot;)    public String index(Model model)&#123;        &#x2F;&#x2F;Spring MVC会自动实例化一个Model对象用于向视图中传值        model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);        &#x2F;&#x2F;返回视图位置        return &quot;test&quot;;    &#125;&#125;</code></pre></div><ul><li>运行tomcat测试</li></ul><p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p><strong>@RequestMapping</strong></p><ul><li>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</li><li>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</li><li>只注解在方法上面</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class TestController &#123;    @RequestMapping(&quot;&#x2F;h1&quot;)    public String test()&#123;        return &quot;test&quot;;    &#125;&#125;</code></pre></div><p>访问路径：<a href="http://localhost/">http://localhost</a>:8080 / 项目名 / h1</p><ul><li>同时注解类与方法</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller@RequestMapping(&quot;&#x2F;admin&quot;)public class TestController &#123;    @RequestMapping(&quot;&#x2F;h1&quot;)    public String test()&#123;        return &quot;test&quot;;    &#125;&#125;</code></pre></div><p>访问路径：<a href="http://localhost/">http://localhost</a>:8080 / 项目名/ admin /h1 , 需要先指定类的路径再指定方法的路径；</p><h1 id="6、RestFul-风格"><a href="#6、RestFul-风格" class="headerlink" title="6、RestFul 风格"></a>6、RestFul 风格</h1><ul><li>简洁</li><li>高效</li><li>安全</li></ul><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><ul><li>资源：互联网所有的事物都可以被抽象为资源</li><li>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</li><li>分别对应 添加、 删除、修改、查询。</li></ul><p><strong>传统方式操作资源</strong> ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><ul><li><a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</li><li><a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</li><li><a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</li><li><a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</li></ul><p><strong>使用RESTful操作资源</strong> ： 可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><ul><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</li><li><a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</li><li><a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</li></ul><p><strong>学习测试</strong></p><ol><li><p>在新建一个类 RestFulController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class RestFulController &#123;&#125;</code></pre></div></li><li><p>在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class RestFulController &#123;    &#x2F;&#x2F;原来的 :  http:&#x2F;&#x2F;localhost: 8080&#x2F;add?a&#x3D;1&amp;b&#x3D;2    &#x2F;&#x2F;RestFul :  http:&#x2F;&#x2F;localhost : 8080&#x2F;add&#x2F;1&#x2F;2        &#x2F;&#x2F;映射访问路径    @RequestMapping(&quot;&#x2F;commit&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;)    public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;                int result &#x3D; p1+p2;        &#x2F;&#x2F;Spring MVC会自动实例化一个Model对象用于向视图中传值        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);        &#x2F;&#x2F;返回视图位置        return &quot;test&quot;;            &#125;    &#125;</code></pre></div></li><li><p>我们来测试请求查看下</p><p><img src="/myBlog/SpringMVC/1905053-20200331213217087-619232504.png" alt="img"></p></li><li><p>思考：使用路径变量的好处？</p><ul><li><p>使路径变得更加简洁；</p></li><li><p>获得参数更加方便，框架会自动进行类型转换。</p></li><li><p>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</p><p><img src="/myBlog/SpringMVC/1905053-20200401214609681-1237588624.png" alt="img"></p></li></ul></li><li><p>我们来修改下对应的参数类型，再次测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;映射访问路径@RequestMapping(&quot;&#x2F;commit&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;)public String index(@PathVariable int p1, @PathVariable String p2, Model model)&#123;    String result &#x3D; p1+p2;    &#x2F;&#x2F;Spring MVC会自动实例化一个Model对象用于向视图中传值    model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);    &#x2F;&#x2F;返回视图位置    return &quot;test&quot;;&#125;</code></pre></div><p><img src="/myBlog/SpringMVC/1905053-20200401214657561-1298821776.png" alt="img"></p></li></ol><p><strong>使用method属性指定请求类型</strong></p><p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p><p>我们来测试一下：</p><ul><li>增加一个方法</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;映射访问路径,必须是POST请求@RequestMapping(value &#x3D; &quot;&#x2F;hello&quot;,method &#x3D; &#123;RequestMethod.POST&#125;)public String index2(Model model)&#123;    model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);    return &quot;test&quot;;&#125;</code></pre></div><ul><li>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</li></ul><p><img src="/myBlog/SpringMVC/1905053-20200401214714976-802588010.png" alt="img"></p><ul><li>如果将POST修改为GET则正常了；</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;映射访问路径,必须是Get请求@RequestMapping(value &#x3D; &quot;&#x2F;hello&quot;,method &#x3D; &#123;RequestMethod.GET&#125;)public String index2(Model model)&#123;    model.addAttribute(&quot;msg&quot;, &quot;hello!&quot;);    return &quot;test&quot;;&#125;</code></pre></div><p><img src="/myBlog/SpringMVC/1905053-20200401214737681-664600385.png" alt="img"></p><p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p><p>方法级别的注解变体有如下几个： 组合注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping</code></pre></div><p>@GetMapping 是一个组合注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class RestFulController &#123;    &#x2F;&#x2F;原来的 :  http:&#x2F;&#x2F;localhost: 8080&#x2F;add?a&#x3D;1&amp;b&#x3D;2    &#x2F;&#x2F;RestFul :  http:&#x2F;&#x2F;localhost : 8080&#x2F;add&#x2F;1&#x2F;2    &#x2F;&#x2F;映射访问路径    &#x2F;&#x2F;@RequestMapping(value &#x3D; &quot;&#x2F;commit&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;,method &#x3D; RequestMethod.GET)    &#x2F;&#x2F;@GetMapping(&quot;&#x2F;commit&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;)    @GetMapping(path &#x3D; &quot;&#x2F;commit&#x2F;&#123;p1&#125;&#x2F;&#123;p2&#125;&quot;)    public String index(@PathVariable int p1, @PathVariable int p2, Model model)&#123;                int result &#x3D; p1+p2;        &#x2F;&#x2F;Spring MVC会自动实例化一个Model对象用于向视图中传值        model.addAttribute(&quot;msg&quot;, &quot;结果：&quot;+result);        &#x2F;&#x2F;返回视图位置        return &quot;test&quot;;      &#125;    &#125;</code></pre></div><p><img src="/myBlog/SpringMVC/1905053-20200331213251638-969968192.png" alt="img"></p><p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p><p>平时使用的会比较多！</p><h3 id="小黄鸭调试法"><a href="#小黄鸭调试法" class="headerlink" title="小黄鸭调试法"></a>小黄鸭调试法</h3><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p><p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p><p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p><p><img src="/myBlog/SpringMVC/1905053-20200401214504256-745544113.png" alt="img"></p><p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p><h1 id="7、结果跳转三种方式"><a href="#7、结果跳转三种方式" class="headerlink" title="7、结果跳转三种方式"></a>7、结果跳转三种方式</h1><h3 id="7-1、ModelAndView"><a href="#7-1、ModelAndView" class="headerlink" title="7.1、ModelAndView"></a>7.1、ModelAndView</h3><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p><p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 视图解析器 --&gt;&lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;      id&#x3D;&quot;internalResourceViewResolver&quot;&gt;    &lt;!-- 前缀 --&gt;    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;    &lt;!-- 后缀 --&gt;    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></div><p>对应的controller类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ControllerTest1 implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        &#x2F;&#x2F;返回一个模型视图对象        ModelAndView mv &#x3D; new ModelAndView();        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);        mv.setViewName(&quot;test&quot;);        return mv;    &#125;&#125;</code></pre></div><h3 id="7-2、ServletAPI"><a href="#7-2、ServletAPI" class="headerlink" title="7.2、ServletAPI"></a>7.2、ServletAPI</h3><p>通过设置ServletAPI , 不需要视图解析器 .</p><ol><li>通过HttpServletResponse进行输出</li><li>通过HttpServletResponse实现重定向</li><li>通过HttpServletResponse实现转发</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class ResultGo &#123;    @RequestMapping(&quot;&#x2F;result&#x2F;t1&quot;)    public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;        rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;);    &#125;    @RequestMapping(&quot;&#x2F;result&#x2F;t2&quot;)    public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123;        rsp.sendRedirect(&quot;&#x2F;index.jsp&quot;);    &#125;    @RequestMapping(&quot;&#x2F;result&#x2F;t3&quot;)    public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123;        &#x2F;&#x2F;转发        req.setAttribute(&quot;msg&quot;,&quot;&#x2F;result&#x2F;t3&quot;);        req.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;test.jsp&quot;).forward(req,rsp);    &#125;&#125;</code></pre></div><h3 id="7-3、SpringMVC"><a href="#7-3、SpringMVC" class="headerlink" title="7.3、SpringMVC"></a>7.3、SpringMVC</h3><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p><p>测试前，需要将视图解析器注释掉</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class ResultSpringMVC &#123;    @RequestMapping(&quot;&#x2F;rsm&#x2F;t1&quot;)    public String test1()&#123;        &#x2F;&#x2F;转发        return &quot;&#x2F;index.jsp&quot;;    &#125;    @RequestMapping(&quot;&#x2F;rsm&#x2F;t2&quot;)    public String test2()&#123;        &#x2F;&#x2F;转发二        return &quot;forward:&#x2F;index.jsp&quot;;    &#125;    @RequestMapping(&quot;&#x2F;rsm&#x2F;t3&quot;)    public String test3()&#123;        &#x2F;&#x2F;重定向        return &quot;redirect:&#x2F;index.jsp&quot;;    &#125;&#125;</code></pre></div><p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p><p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p><p>可以重定向到另外一个请求实现 .</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class ResultSpringMVC2 &#123;    @RequestMapping(&quot;&#x2F;rsm2&#x2F;t1&quot;)    public String test1()&#123;        &#x2F;&#x2F;转发        return &quot;test&quot;;    &#125;    @RequestMapping(&quot;&#x2F;rsm2&#x2F;t2&quot;)    public String test2()&#123;        &#x2F;&#x2F;重定向        return &quot;redirect:&#x2F;index.jsp&quot;;        &#x2F;&#x2F;return &quot;redirect:hello.do&quot;; &#x2F;&#x2F;hello.do为另一个请求&#x2F;    &#125;&#125;</code></pre></div><p>==<strong>转发需要视图解析器，重定向不需要</strong>==</p><h1 id="8、数据处理"><a href="#8、数据处理" class="headerlink" title="8、数据处理"></a>8、数据处理</h1><h3 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h3><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p><p>提交数据 : <a href="http://localhost/">http://localhost</a>:8080/hello?name=kuangshen</p><p>处理方法 :</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(String name)&#123;    System.out.println(name);    return &quot;hello&quot;;&#125;</code></pre></div><p>后台输出 : kuangshen</p><p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p><p>提交数据 : <a href="http://localhost/">http://localhost</a>:8080/hello?username=kuangshen</p><p>处理方法 :</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;@RequestParam(&quot;username&quot;) : username提交的域的名称 .@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name)&#123;    System.out.println(name);    return &quot;hello&quot;;&#125;</code></pre></div><p>后台输出：</p><p><strong>3、提交的是一个对象</strong></p><p>要求提交的表单域和对象的属性名一致 , 参数使用对象即可</p><ol><li>实体类</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User &#123;    private int id;    private String name;    private int age;    &#x2F;&#x2F;构造    &#x2F;&#x2F;get&#x2F;set    &#x2F;&#x2F;tostring()&#125;</code></pre></div><p>  2.提交数据 : <a href="http://localhost:8080/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/user?name=kuangshen&amp;id=1&amp;age=15</a></p><p>  3.处理方法 :</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;user&quot;)public String user(User user)&#123;    System.out.println(user);    return &quot;hello&quot;;&#125;</code></pre></div><p>后台输出 : User { id=1, name=’kuangshen’, age=15 }</p><p><strong>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</strong></p><h3 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h3><p><strong>第一种 : 通过ModelAndView</strong></p><p>我们前面一直都是如此 . 就不过多解释</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ControllerTest1 implements Controller &#123;    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123;        &#x2F;&#x2F;返回一个模型视图对象        ModelAndView mv &#x3D; new ModelAndView();        mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;);        mv.setViewName(&quot;test&quot;);        return mv;    &#125;&#125;</code></pre></div><p><strong>第二种 : 通过ModelMap</strong></p><p>ModelMap</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123;    &#x2F;&#x2F;封装要显示到视图中的数据    &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name);    model.addAttribute(&quot;name&quot;,name);    System.out.println(name);    return &quot;hello&quot;;&#125;</code></pre></div><p><strong>第三种 : 通过Model</strong></p><p>Model</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;ct2&#x2F;hello&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123;    &#x2F;&#x2F;封装要显示到视图中的数据    &#x2F;&#x2F;相当于req.setAttribute(&quot;name&quot;,name);    model.addAttribute(&quot;msg&quot;,name);    System.out.println(name);    return &quot;test&quot;;&#125;</code></pre></div><p><strong>对比</strong></p><p>就对于新手而言简单来说使用区别就是：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</code></pre></div><p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p><p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p><h1 id="9、数据处理（乱码问题）"><a href="#9、数据处理（乱码问题）" class="headerlink" title="9、数据处理（乱码问题）"></a>9、数据处理（乱码问题）</h1><p>测试步骤：</p><ol><li><p>我们可以在首页编写一个提交的表单</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;form action&#x3D;&quot;&#x2F;e&#x2F;t&quot; method&#x3D;&quot;post&quot;&gt;  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;  &lt;input type&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt;</code></pre></div></li><li><p>后台编写对应的处理类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class Encoding &#123;    @RequestMapping(&quot;&#x2F;e&#x2F;t&quot;)    public String test(Model model,String name)&#123;        model.addAttribute(&quot;msg&quot;,name); &#x2F;&#x2F;获取表单提交的值        return &quot;test&quot;; &#x2F;&#x2F;跳转到test页面显示输入的值    &#125;&#125;</code></pre></div></li><li><p>输入中文测试，发现乱码</p></li></ol><p><img src="/myBlog/SpringMVC/1905053-20200402193540997-1854631524.png" alt="img"></p><p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p><p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p><p>修改了xml文件需要重启服务器！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--2.配置SpringMVC的乱码过滤--&gt;&lt;filter&gt;    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;    &lt;init-param&gt;        &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;        &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;    &lt;&#x2F;init-param&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;&lt;&#x2F;filter-mapping&gt;</code></pre></div><p>有些极端情况下.这个过滤器对get的支持不好 .</p><p>处理方法 :</p><ol><li><p>修改tomcat配置文件 ： 设置编码！(conf–&gt;server.xml)</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;Connector URIEncoding&#x3D;&quot;utf-8&quot; port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;           connectionTimeout&#x3D;&quot;20000&quot;           redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt;</code></pre></div></li><li><p>自定义过滤器</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;&#x2F;** * 解决get和post请求 全部乱码的过滤器 *&#x2F;public class GenericEncodingFilter implements Filter &#123;    @Override    public void destroy() &#123;    &#125;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;        &#x2F;&#x2F;处理response的字符编码        HttpServletResponse myResponse&#x3D;(HttpServletResponse) response;        myResponse.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);        &#x2F;&#x2F; 转型为与协议相关对象        HttpServletRequest httpServletRequest &#x3D; (HttpServletRequest) request;        &#x2F;&#x2F; 对request包装增强        HttpServletRequest myrequest &#x3D; new MyRequest(httpServletRequest);        chain.doFilter(myrequest, response);    &#125;    @Override    public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;&#125;&#x2F;&#x2F;自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123;    private HttpServletRequest request;    &#x2F;&#x2F;是否编码的标记    private boolean hasEncode;    &#x2F;&#x2F;定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰    public MyRequest(HttpServletRequest request) &#123;        super(request);&#x2F;&#x2F; super必须写        this.request &#x3D; request;    &#125;    &#x2F;&#x2F; 对需要增强方法 进行覆盖    @Override    public Map getParameterMap() &#123;        &#x2F;&#x2F; 先获得请求方式        String method &#x3D; request.getMethod();        if (method.equalsIgnoreCase(&quot;post&quot;)) &#123;            &#x2F;&#x2F; post请求            try &#123;                &#x2F;&#x2F; 处理post乱码                request.setCharacterEncoding(&quot;utf-8&quot;);                return request.getParameterMap();            &#125; catch (UnsupportedEncodingException e) &#123;                e.printStackTrace();            &#125;        &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123;            &#x2F;&#x2F; get请求            Map&lt;String, String[]&gt; parameterMap &#x3D; request.getParameterMap();            if (!hasEncode) &#123; &#x2F;&#x2F; 确保get手动编码逻辑只运行一次                for (String parameterName : parameterMap.keySet()) &#123;                    String[] values &#x3D; parameterMap.get(parameterName);                    if (values !&#x3D; null) &#123;                        for (int i &#x3D; 0; i &lt; values.length; i++) &#123;                            try &#123;                                &#x2F;&#x2F; 处理get乱码                                values[i] &#x3D; new String(values[i]                                        .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);                            &#125; catch (UnsupportedEncodingException e) &#123;                                e.printStackTrace();                            &#125;                        &#125;                    &#125;                &#125;                hasEncode &#x3D; true;            &#125;            return parameterMap;        &#125;        return super.getParameterMap();    &#125;    &#x2F;&#x2F;取一个值    @Override    public String getParameter(String name) &#123;        Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();        String[] values &#x3D; parameterMap.get(name);        if (values &#x3D;&#x3D; null) &#123;            return null;        &#125;        return values[0]; &#x2F;&#x2F; 取回参数的第一个值    &#125;    &#x2F;&#x2F;取所有值    @Override    public String[] getParameterValues(String name) &#123;        Map&lt;String, String[]&gt; parameterMap &#x3D; getParameterMap();        String[] values &#x3D; parameterMap.get(name);        return values;    &#125;&#125;</code></pre></div><p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p><p><strong>然后在web.xml中配置这个过滤器即可！</strong></p><p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p></li></ol><h1 id="10、整合SSM"><a href="#10、整合SSM" class="headerlink" title="10、整合SSM"></a>10、整合SSM</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>环境：</p><ul><li>IDEA</li><li>MySQL 5.7.19</li><li>Tomcat 9</li><li>Maven 3.6</li></ul><p> 要求：</p><ul><li>需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；</li></ul><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><p>创建一个存放书籍数据的数据库表</p><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE &#96;ssmbuild&#96;;USE &#96;ssmbuild&#96;;DROP TABLE IF EXISTS &#96;books&#96;;CREATE TABLE &#96;books&#96; (&#96;bookID&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;书id&#39;,&#96;bookName&#96; VARCHAR(100) NOT NULL COMMENT &#39;书名&#39;,&#96;bookCounts&#96; INT(11) NOT NULL COMMENT &#39;数量&#39;,&#96;detail&#96; VARCHAR(200) NOT NULL COMMENT &#39;描述&#39;,KEY &#96;bookID&#96; (&#96;bookID&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT  INTO &#96;books&#96;(&#96;bookID&#96;,&#96;bookName&#96;,&#96;bookCounts&#96;,&#96;detail&#96;)VALUES(1,&#39;Java&#39;,1,&#39;从入门到放弃&#39;),(2,&#39;MySQL&#39;,10,&#39;从删库到跑路&#39;),(3,&#39;Linux&#39;,5,&#39;从进门到进牢&#39;);</code></pre></div><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><ol><li><p>新建一Maven项目！ssmbuild ， 添加web的支持</p></li><li><p>导入相关的pom依赖！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;   &lt;!--Junit--&gt;   &lt;dependency&gt;       &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;       &lt;version&gt;4.12&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--数据库驱动--&gt;   &lt;dependency&gt;       &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;       &lt;version&gt;5.1.47&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!-- 数据库连接池 --&gt;   &lt;dependency&gt;       &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;       &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--Servlet - JSP --&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;       &lt;version&gt;2.5&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;       &lt;version&gt;2.2&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;       &lt;version&gt;1.2&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--Mybatis--&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;       &lt;version&gt;3.5.2&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;       &lt;version&gt;2.0.2&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;!--Spring--&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;       &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;   &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></li><li><p>Maven资源过滤设置</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;build&gt;   &lt;resources&gt;       &lt;resource&gt;           &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;           &lt;includes&gt;               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;           &lt;&#x2F;includes&gt;           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;       &lt;&#x2F;resource&gt;       &lt;resource&gt;           &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;           &lt;includes&gt;               &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;               &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;           &lt;&#x2F;includes&gt;           &lt;filtering&gt;false&lt;&#x2F;filtering&gt;       &lt;&#x2F;resource&gt;   &lt;&#x2F;resources&gt;&lt;&#x2F;build&gt;</code></pre></div></li><li><p>建立基本结构和配置框架！</p></li></ol><ul><li><p>com.kuang.pojo</p></li><li><p>com.kuang.dao</p></li><li><p>com.kuang.service</p></li><li><p>com.kuang.controller</p></li><li><p>mybatis-config.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;&#x2F;configuration&gt;applicationContext.xml</code></pre></div></li><li><p>applicationContext.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;&lt;&#x2F;beans&gt;</code></pre></div></li></ul><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><ol><li><p>数据库配置文件 <strong>database.properties</strong></p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">jdbc.driver&#x3D;com.mysql.jdbc.Driverjdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8jdbc.username&#x3D;rootjdbc.password&#x3D;123456</code></pre></div></li><li><p>IDEA关联数据库</p></li><li><p>编写MyBatis的核心配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;      &lt;typeAliases&gt;       &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;   &lt;&#x2F;typeAliases&gt;   &lt;mappers&gt;       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;BookMapper.xml&quot;&#x2F;&gt;   &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre></div></li><li><p>编写数据库对应的实体类 com.kuang.pojo.Books</p><p>使用lombok插件！</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123;      private int bookID;   private String bookName;   private int bookCounts;   private String detail;   &#125;</code></pre></div></li><li><p>编写Dao层的 Mapper接口！</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.dao;import com.kuang.pojo.Books;import java.util.List;public interface BookMapper &#123;   &#x2F;&#x2F;增加一个Book   int addBook(Books book);   &#x2F;&#x2F;根据id删除一个Book   int deleteBookById(int id);   &#x2F;&#x2F;更新Book   int updateBook(Books books);   &#x2F;&#x2F;根据id查询,返回一个Book   Books queryBookById(int id);   &#x2F;&#x2F;查询全部Book,返回list集合   List&lt;Books&gt; queryAllBook();&#125;</code></pre></div></li><li><p>编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.dao.BookMapper&quot;&gt;   &lt;!--增加一个Book--&gt;   &lt;insert id&#x3D;&quot;addBook&quot; parameterType&#x3D;&quot;Books&quot;&gt;      insert into ssmbuild.books(bookName,bookCounts,detail)      values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)   &lt;&#x2F;insert&gt;   &lt;!--根据id删除一个Book--&gt;   &lt;delete id&#x3D;&quot;deleteBookById&quot; parameterType&#x3D;&quot;int&quot;&gt;      delete from ssmbuild.books where bookID&#x3D;#&#123;bookID&#125;   &lt;&#x2F;delete&gt;   &lt;!--更新Book--&gt;   &lt;update id&#x3D;&quot;updateBook&quot; parameterType&#x3D;&quot;Books&quot;&gt;      update ssmbuild.books      set bookName &#x3D; #&#123;bookName&#125;,bookCounts &#x3D; #&#123;bookCounts&#125;,detail &#x3D; #&#123;detail&#125;      where bookID &#x3D; #&#123;bookID&#125;   &lt;&#x2F;update&gt;   &lt;!--根据id查询,返回一个Book--&gt;   &lt;select id&#x3D;&quot;queryBookById&quot; resultType&#x3D;&quot;Books&quot;&gt;      select * from ssmbuild.books      where bookID &#x3D; #&#123;bookID&#125;   &lt;&#x2F;select&gt;   &lt;!--查询全部Book--&gt;   &lt;select id&#x3D;&quot;queryAllBook&quot; resultType&#x3D;&quot;Books&quot;&gt;      SELECT * from ssmbuild.books   &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre></div></li><li><p>编写Service层的接口和实现类</p><p>接口：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.service;import com.kuang.pojo.Books;import java.util.List;&#x2F;&#x2F;BookService:底下需要去实现,调用dao层public interface BookService &#123;   &#x2F;&#x2F;增加一个Book   int addBook(Books book);   &#x2F;&#x2F;根据id删除一个Book   int deleteBookById(int id);   &#x2F;&#x2F;更新Book   int updateBook(Books books);   &#x2F;&#x2F;根据id查询,返回一个Book   Books queryBookById(int id);   &#x2F;&#x2F;查询全部Book,返回list集合   List&lt;Books&gt; queryAllBook();&#125;</code></pre></div><p>实现类：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.service;import com.kuang.dao.BookMapper;import com.kuang.pojo.Books;import java.util.List;public class BookServiceImpl implements BookService &#123;   &#x2F;&#x2F;调用dao层的操作，设置一个set接口，方便Spring管理   private BookMapper bookMapper;   public void setBookMapper(BookMapper bookMapper) &#123;       this.bookMapper &#x3D; bookMapper;  &#125;      public int addBook(Books book) &#123;       return bookMapper.addBook(book);  &#125;      public int deleteBookById(int id) &#123;       return bookMapper.deleteBookById(id);  &#125;      public int updateBook(Books books) &#123;       return bookMapper.updateBook(books);  &#125;      public Books queryBookById(int id) &#123;       return bookMapper.queryBookById(id);  &#125;      public List&lt;Books&gt; queryAllBook() &#123;       return bookMapper.queryAllBook();  &#125;&#125;</code></pre></div><p><strong>OK，到此，底层需求操作编写完毕！</strong></p></li></ol><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><ol><li><p>配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p></li><li><p>我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context       https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;   &lt;!-- 配置整合mybatis --&gt;   &lt;!-- 1.关联数据库文件 --&gt;   &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt;   &lt;!-- 2.数据库连接池 --&gt;   &lt;!--数据库连接池       dbcp 半自动化操作 不能自动连接       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）   --&gt;   &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;       &lt;!-- 配置连接池属性 --&gt;       &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;       &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;       &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;       &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;       &lt;!-- c3p0连接池的私有属性 --&gt;       &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;       &lt;property name&#x3D;&quot;minPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;       &lt;!-- 关闭连接后不自动commit --&gt;       &lt;property name&#x3D;&quot;autoCommitOnClose&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;       &lt;!-- 获取连接超时时间 --&gt;       &lt;property name&#x3D;&quot;checkoutTimeout&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;       &lt;!-- 当获取连接失败重试次数 --&gt;       &lt;property name&#x3D;&quot;acquireRetryAttempts&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;   &lt;!-- 3.配置SqlSessionFactory对象 --&gt;   &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;       &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;       &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;   &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;   &lt;!--解释 ：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;jpfss&#x2F;p&#x2F;7799806.html--&gt;   &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;       &lt;!-- 注入sqlSessionFactory --&gt;       &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;       &lt;!-- 给出需要扫描Dao接口包 --&gt;       &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;com.kuang.dao&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div></li><li><p><strong>Spring整合service层</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;   &lt;!-- 扫描service相关的bean --&gt;   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.service&quot; &#x2F;&gt;   &lt;!--BookServiceImpl注入到IOC容器中--&gt;   &lt;bean id&#x3D;&quot;BookServiceImpl&quot; class&#x3D;&quot;com.kuang.service.BookServiceImpl&quot;&gt;       &lt;property name&#x3D;&quot;bookMapper&quot; ref&#x3D;&quot;bookMapper&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;   &lt;!-- 配置事务管理器 --&gt;   &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;       &lt;!-- 注入数据库连接池 --&gt;       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;   &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div><p>Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！</p></li></ol><h2 id="SpringMVC层"><a href="#SpringMVC层" class="headerlink" title="SpringMVC层"></a>SpringMVC层</h2><p><strong>web.xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;        xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;        version&#x3D;&quot;4.0&quot;&gt;   &lt;!--DispatcherServlet--&gt;   &lt;servlet&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;       &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;           &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;             &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;       &lt;&#x2F;init-param&gt;       &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;   &lt;&#x2F;servlet&gt;   &lt;servlet-mapping&gt;       &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;       &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;   &lt;&#x2F;servlet-mapping&gt;   &lt;!--encodingFilter--&gt;   &lt;filter&gt;       &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;       &lt;filter-class&gt;          org.springframework.web.filter.CharacterEncodingFilter       &lt;&#x2F;filter-class&gt;       &lt;init-param&gt;           &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;           &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;       &lt;&#x2F;init-param&gt;   &lt;&#x2F;filter&gt;   &lt;filter-mapping&gt;       &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;       &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;   &lt;&#x2F;filter-mapping&gt;      &lt;!--Session过期时间--&gt;   &lt;session-config&gt;       &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;   &lt;&#x2F;session-config&gt;   &lt;&#x2F;web-app&gt;</code></pre></div><p><strong>spring-mvc.xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;      xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd   http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc   https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;   &lt;!-- 配置SpringMVC --&gt;   &lt;!-- 1.开启SpringMVC注解驱动 --&gt;   &lt;mvc:annotation-driven &#x2F;&gt;   &lt;!-- 2.静态资源默认servlet配置--&gt;   &lt;mvc:default-servlet-handler&#x2F;&gt;   &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;   &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;       &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot; &#x2F;&gt;       &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;       &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;   &lt;&#x2F;bean&gt;   &lt;!-- 4.扫描web相关的bean --&gt;   &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot; &#x2F;&gt;&lt;&#x2F;beans&gt;</code></pre></div><p><strong>Spring配置整合文件，applicationContext.xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;      xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;   &lt;import resource&#x3D;&quot;spring-dao.xml&quot;&#x2F;&gt;   &lt;import resource&#x3D;&quot;spring-service.xml&quot;&#x2F;&gt;   &lt;import resource&#x3D;&quot;spring-mvc.xml&quot;&#x2F;&gt;   &lt;&#x2F;beans&gt;</code></pre></div><h2 id="配置文件，暂时结束！Controller-和-视图层编写"><a href="#配置文件，暂时结束！Controller-和-视图层编写" class="headerlink" title="配置文件，暂时结束！Controller 和 视图层编写"></a><strong>配置文件，暂时结束！Controller 和 视图层编写</strong></h2><ol><li><p>BookController 类编写 ， 方法一：查询全部书籍</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller@RequestMapping(&quot;&#x2F;book&quot;)public class BookController &#123;   @Autowired   @Qualifier(&quot;BookServiceImpl&quot;)   private BookService bookService;   @RequestMapping(&quot;&#x2F;allBook&quot;)   public String list(Model model) &#123;       List&lt;Books&gt; list &#x3D; bookService.queryAllBook();       model.addAttribute(&quot;list&quot;, list);       return &quot;allBook&quot;;  &#125;&#125;</code></pre></div></li><li><p>编写首页 <strong>index.jsp</strong></p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; pageEncoding&#x3D;&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;首页&lt;&#x2F;title&gt;   &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;       a &#123;           text-decoration: none;           color: black;           font-size: 18px;      &#125;       h3 &#123;           width: 180px;           height: 38px;           margin: 100px auto;           text-align: center;           line-height: 38px;           background: deepskyblue;           border-radius: 4px;      &#125;   &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h3&gt;   &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;allBook&quot;&gt;点击进入列表页&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>书籍列表页面 <strong>allbook.jsp</strong></p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;书籍列表&lt;&#x2F;title&gt;   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;   &lt;!-- 引入 Bootstrap --&gt;   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt;   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;           &lt;div class&#x3D;&quot;page-header&quot;&gt;               &lt;h1&gt;                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;&#x2F;small&gt;               &lt;&#x2F;h1&gt;           &lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt;   &lt;div class&#x3D;&quot;row&quot;&gt;       &lt;div class&#x3D;&quot;col-md-4 column&quot;&gt;           &lt;a class&#x3D;&quot;btn btn-primary&quot; href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toAddBook&quot;&gt;新增&lt;&#x2F;a&gt;       &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt;   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;           &lt;table class&#x3D;&quot;table table-hover table-striped&quot;&gt;               &lt;thead&gt;               &lt;tr&gt;                   &lt;th&gt;书籍编号&lt;&#x2F;th&gt;                   &lt;th&gt;书籍名字&lt;&#x2F;th&gt;                   &lt;th&gt;书籍数量&lt;&#x2F;th&gt;                   &lt;th&gt;书籍详情&lt;&#x2F;th&gt;                   &lt;th&gt;操作&lt;&#x2F;th&gt;               &lt;&#x2F;tr&gt;               &lt;&#x2F;thead&gt;               &lt;tbody&gt;               &lt;c:forEach var&#x3D;&quot;book&quot; items&#x3D;&quot;$&#123;requestScope.get(&#39;list&#39;)&#125;&quot;&gt;                   &lt;tr&gt;                       &lt;td&gt;$&#123;book.getBookID()&#125;&lt;&#x2F;td&gt;                       &lt;td&gt;$&#123;book.getBookName()&#125;&lt;&#x2F;td&gt;                       &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;&#x2F;td&gt;                       &lt;td&gt;$&#123;book.getDetail()&#125;&lt;&#x2F;td&gt;                       &lt;td&gt;                           &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;toUpdateBook?id&#x3D;$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;&#x2F;a&gt; |                           &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;del&#x2F;$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;&#x2F;a&gt;                       &lt;&#x2F;td&gt;                   &lt;&#x2F;tr&gt;               &lt;&#x2F;c:forEach&gt;               &lt;&#x2F;tbody&gt;           &lt;&#x2F;table&gt;       &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</code></pre></div></li><li><p>BookController 类编写 ， 方法二：添加书籍</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;toAddBook&quot;)public String toAddPaper() &#123;   return &quot;addBook&quot;;&#125;@RequestMapping(&quot;&#x2F;addBook&quot;)public String addPaper(Books books) &#123;   System.out.println(books);   bookService.addBook(books);   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;&#125;</code></pre></div></li><li><p>添加书籍页面：<strong>addBook.jsp</strong></p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;新增书籍&lt;&#x2F;title&gt;   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;   &lt;!-- 引入 Bootstrap --&gt;   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt;   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;           &lt;div class&#x3D;&quot;page-header&quot;&gt;               &lt;h1&gt;                   &lt;small&gt;新增书籍&lt;&#x2F;small&gt;               &lt;&#x2F;h1&gt;           &lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt;   &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;addBook&quot; method&#x3D;&quot;post&quot;&gt;      书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;      书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;      书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;       &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;添加&quot;&gt;   &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;</code></pre></div></li><li><p>BookController 类编写 ， 方法三：修改书籍</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;toUpdateBook&quot;)public String toUpdateBook(Model model, int id) &#123;   Books books &#x3D; bookService.queryBookById(id);   System.out.println(books);   model.addAttribute(&quot;book&quot;,books );   return &quot;updateBook&quot;;&#125;@RequestMapping(&quot;&#x2F;updateBook&quot;)public String updateBook(Model model, Books book) &#123;   System.out.println(book);   bookService.updateBook(book);   Books books &#x3D; bookService.queryBookById(book.getBookID());   model.addAttribute(&quot;books&quot;, books);   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;&#125;</code></pre></div></li><li><p>修改书籍页面  <strong>updateBook.jsp</strong></p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;   &lt;title&gt;修改信息&lt;&#x2F;title&gt;   &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;   &lt;!-- 引入 Bootstrap --&gt;   &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bootstrap&#x2F;3.3.7&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;container&quot;&gt;   &lt;div class&#x3D;&quot;row clearfix&quot;&gt;       &lt;div class&#x3D;&quot;col-md-12 column&quot;&gt;           &lt;div class&#x3D;&quot;page-header&quot;&gt;               &lt;h1&gt;                   &lt;small&gt;修改信息&lt;&#x2F;small&gt;               &lt;&#x2F;h1&gt;           &lt;&#x2F;div&gt;       &lt;&#x2F;div&gt;   &lt;&#x2F;div&gt;   &lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;book&#x2F;updateBook&quot; method&#x3D;&quot;post&quot;&gt;       &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;bookID&quot; value&#x3D;&quot;$&#123;book.getBookID()&#125;&quot;&#x2F;&gt;      书籍名称：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookName&quot; value&#x3D;&quot;$&#123;book.getBookName()&#125;&quot;&#x2F;&gt;      书籍数量：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;bookCounts&quot; value&#x3D;&quot;$&#123;book.getBookCounts()&#125;&quot;&#x2F;&gt;      书籍详情：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;detail&quot; value&#x3D;&quot;$&#123;book.getDetail() &#125;&quot;&#x2F;&gt;       &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;   &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;</code></pre></div></li><li><p>BookController 类编写 ， 方法四：删除书籍</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;del&#x2F;&#123;bookId&#125;&quot;)public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123;   bookService.deleteBookById(id);   return &quot;redirect:&#x2F;book&#x2F;allBook&quot;;&#125;</code></pre></div></li></ol><p><strong>配置Tomcat，进行运行！</strong></p><p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！</p><p><strong>项目结构图</strong> </p><p><img src="/myBlog/SpringMVC/1.png" alt="1"></p><p><img src="/myBlog/SpringMVC/2.png" alt="2"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>启动Tomcat不成功的原因，可能是没有导lib包</li></ul><p><img src="/myBlog/SpringMVC/image-20210811192257482.png" alt="image-20210811192257482"></p><ul><li>返回值类型写错</li></ul><p><img src="/myBlog/SpringMVC/image-20210811192336918.png" alt="image-20210811192336918"></p><ul><li><p>找不到bean</p><p><img src="/myBlog/SpringMVC/image-20210811192627057.png" alt="image-20210811192627057"></p></li><li><p>排错思路</p><p><img src="/myBlog/SpringMVC/image-20210811192652810.png" alt="image-20210811192652810"></p></li></ul><ul><li>出现这个错误，可能是返回值类型写错</li></ul><p><img src="/myBlog/SpringMVC/image-20210811192746763.png" alt="image-20210811192746763"></p><p><img src="/myBlog/SpringMVC/image-20210811192802314.png" alt="image-20210811192802314"></p><ul><li><p>用了中文逗号</p><p><img src="/myBlog/SpringMVC/image-20210811192859967.png" alt="image-20210811192859967"></p></li></ul><h2 id="小结及展望"><a href="#小结及展望" class="headerlink" title="小结及展望"></a>小结及展望</h2><p>这个是同学们的第一个SSM整合案例，一定要烂熟于心！</p><p>SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的底线。</p><p>或许很多人，工作就做这些事情，但是对于个人的提高来说，还远远不够！</p><p>我们后面还要学习一些 SpringMVC 的知识！</p><ul><li>Ajax  和  Json</li><li>文件上传和下载</li><li>拦截器</li></ul><p>前路漫漫，认真坚持最重要！</p><h1 id="11、JSON交互处理"><a href="#11、JSON交互处理" class="headerlink" title="11、JSON交互处理"></a>11、JSON交互处理</h1><h2 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h2><ul><li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li><li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li><li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li></ul><p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p><ul><li><p>对象表示为键值对，数据由逗号分隔</p></li><li><p>花括号保存对象</p></li><li><p>方括号保存数组</p></li></ul><p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;&#123;&quot;age&quot;: &quot;3&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125;</code></pre></div><p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p><ul><li>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</li></ul><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">var obj &#x3D; &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;; &#x2F;&#x2F;这是一个对象，注意键名也是可以使用引号包裹的var json &#x3D; &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;; &#x2F;&#x2F;这是一个 JSON 字符串，本质是一个字符串</code></pre></div><p><strong>JSON 和 JavaScript 对象互转</strong></p><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">var obj &#x3D; JSON.parse(&#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;); &#x2F;&#x2F;结果是 &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;</code></pre></div><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">var json &#x3D; JSON.stringify(&#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;);&#x2F;&#x2F;结果是 &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;</code></pre></div><p><strong>代码测试</strong></p><ol><li><p>新建一个module ，springmvc-05-json ， 添加web的支持</p></li><li><p>在web目录下新建一个 json-1.html ， 编写测试内容</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;JSON_秦疆&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&#x2F;&#x2F;编写一个js的对象var user &#x3D; &#123; name:&quot;成博&quot;, age:3, sex:&quot;男&quot;&#125;;&#x2F;&#x2F;将js对象转换成json字符串var str &#x3D; JSON.stringify(user);console.log(str);&#x2F;&#x2F;将json字符串转换为js对象var user2 &#x3D; JSON.parse(str);console.log(user2.age,user2.name,user2.sex);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>在IDEA中使用浏览器打开，查看控制台输出！</p></li></ol><p><img src="/myBlog/SpringMVC/1905053-20200331213612113-1624858159.png" alt="img"></p><h2 id="Controller返回JSON数据"><a href="#Controller返回JSON数据" class="headerlink" title="Controller返回JSON数据"></a>Controller返回JSON数据</h2><h2 id="1-jackson"><a href="#1-jackson" class="headerlink" title="1.jackson"></a>1.jackson</h2><ul><li><p>Jackson应该是目前比较好的json解析工具了</p></li><li><p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p></li><li><p>我们这里使用Jackson，使用它需要导入它的jar包；</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.fasterxml.jackson.core&#x2F;jackson-core --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.10.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></li><li><p>配置SpringMVC需要的配置<br><strong>web.xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;!--1.注册servlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;!--所有请求都会被springmvc拦截 --&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;SpringMVC&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;    &lt;filter&gt;        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;    &lt;&#x2F;filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encoding&lt;&#x2F;filter-name&gt;        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;filter-mapping&gt;&lt;&#x2F;web-app&gt;</code></pre></div><p><strong>springmvc-servlet.xml</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;        &lt;!-- 后缀 --&gt;        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div><ul><li>我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;&#x2F;&#x2F;需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String name;    private int age;    private String sex;    &#125;</code></pre></div><ul><li>这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法</li></ul></li></ul><p>编写一个Controller；</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class UserController &#123;    @RequestMapping(&quot;&#x2F;json1&quot;)    @ResponseBody    public String json1() throws JsonProcessingException &#123;        &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper &#x3D; new ObjectMapper();        &#x2F;&#x2F;创建一个对象        User user &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);        &#x2F;&#x2F;将我们的对象解析成为json格式        String str &#x3D; mapper.writeValueAsString(user);        &#x2F;&#x2F;由于@ResponseBody注解，这里会将str转成json格式返回；十分方便        return str;    &#125;&#125;</code></pre></div><ul><li>配置Tomcat ， 启动测试一下！</li></ul><p><img src="/myBlog/SpringMVC/1905053-20200331213642133-500236017.png" alt="img"></p><ul><li><p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p></li><li><p>通过@RequestMaping的produces属性来实现，修改下代码</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;produces:指定响应体返回类型和编码@RequestMapping(value &#x3D; &quot;&#x2F;json1&quot;,produces &#x3D; &quot;application&#x2F;json;charset&#x3D;utf-8&quot;)</code></pre></div></li><li><p>再次测试， <a href="http://localhost/">http://localhost</a>:8080/json1 ， 乱码问题OK！</p></li></ul><p>【注意：使用json记得处理乱码问题】</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p><strong>乱码统一解决</strong></p><p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p><p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> &lt;!--JSON乱码问题配置--&gt;&lt;mvc:annotation-driven&gt;    &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;        &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;            &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;        &lt;&#x2F;bean&gt;        &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;            &lt;property name&#x3D;&quot;objectMapper&quot;&gt;                &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                    &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;                &lt;&#x2F;bean&gt;            &lt;&#x2F;property&gt;        &lt;&#x2F;bean&gt;    &lt;&#x2F;mvc:message-converters&gt;&lt;&#x2F;mvc:annotation-driven&gt;</code></pre></div><p><strong>返回json字符串统一解决</strong></p><p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerpublic class UserController &#123;    &#x2F;&#x2F;produces:指定响应体返回类型和编码    @RequestMapping(value &#x3D; &quot;&#x2F;json1&quot;)    public String json1() throws JsonProcessingException &#123;        &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据        ObjectMapper mapper &#x3D; new ObjectMapper();        &#x2F;&#x2F;创建一个对象        User user &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);        &#x2F;&#x2F;将我们的对象解析成为json格式        String str &#x3D; mapper.writeValueAsString(user);        &#x2F;&#x2F;由于@ResponseBody注解，这里会将str转成json格式返回；十分方便        return str;    &#125;&#125;</code></pre></div><p>启动tomcat测试，结果都正常输出！</p><h3 id="测试集合输出"><a href="#测试集合输出" class="headerlink" title="测试集合输出"></a>测试集合输出</h3><p>增加一个新的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json2&quot;)@ResponseBodypublic String json2() throws JsonProcessingException &#123;    &#x2F;&#x2F;创建一个jackson的对象映射器，用来解析数据    ObjectMapper mapper &#x3D; new ObjectMapper();    &#x2F;&#x2F;创建一个对象    User user1 &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);    User user2 &#x3D; new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);    User user3 &#x3D; new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);    User user4 &#x3D; new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);    List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();    list.add(user1);    list.add(user2);    list.add(user3);    list.add(user4);    &#x2F;&#x2F;将我们的对象解析成为json格式    String str &#x3D; mapper.writeValueAsString(list);    return str;&#125;</code></pre></div><p>运行结果 : 十分完美，没有任何问题！</p><h3 id="输出时间对象"><a href="#输出时间对象" class="headerlink" title="输出时间对象"></a>输出时间对象</h3><p>增加一个新的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json3&quot;)public String json3() throws JsonProcessingException &#123;    ObjectMapper mapper &#x3D; new ObjectMapper();    &#x2F;&#x2F;创建时间一个对象，java.util.Date    Date date &#x3D; new Date();    &#x2F;&#x2F;将我们的对象解析成为json格式    String str &#x3D; mapper.writeValueAsString(date);    return str;&#125;</code></pre></div><p>运行结果 :</p><ul><li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li><li>Jackson 默认是会把时间转成timestamps形式</li></ul><p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json4&quot;)public String json4() throws JsonProcessingException &#123;    ObjectMapper mapper &#x3D; new ObjectMapper();    &#x2F;&#x2F;不使用时间戳的方式    mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);    &#x2F;&#x2F;自定义日期格式对象    SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    &#x2F;&#x2F;指定日期格式    mapper.setDateFormat(sdf);    Date date &#x3D; new Date();    String str &#x3D; mapper.writeValueAsString(date);    return str;&#125;</code></pre></div><p>运行结果 : 成功的输出了时间！</p><p><strong>时间戳格式化，老手艺不能丢</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json6&quot;)@ResponseBodypublic String json6() throws JsonProcessingException &#123;    ObjectMapper mapper &#x3D; new ObjectMapper();    Date date &#x3D; new Date();    &#x2F;&#x2F;自定义日期的格式    SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    &#x2F;&#x2F; objectMapper,时间解析后的默认格式为: Timestamp, 时间裁    return mapper.writeValueAsString(sdf.format(date));&#125;</code></pre></div><h3 id="抽取为工具类"><a href="#抽取为工具类" class="headerlink" title="抽取为工具类"></a>抽取为工具类</h3><p><strong>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123;        public static String getJson(Object object) &#123;        return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;);    &#125;    public static String getJson(Object object,String dateFormat) &#123;        ObjectMapper mapper &#x3D; new ObjectMapper();        &#x2F;&#x2F;不使用时间差的方式        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        &#x2F;&#x2F;自定义日期格式对象        SimpleDateFormat sdf &#x3D; new SimpleDateFormat(dateFormat);        &#x2F;&#x2F;指定日期格式        mapper.setDateFormat(sdf);        try &#123;            return mapper.writeValueAsString(object);        &#125; catch (JsonProcessingException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;</code></pre></div><p>我们使用工具类，代码就更加简洁了！</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json5&quot;)public String json5() throws JsonProcessingException &#123;    Date date &#x3D; new Date();    String json &#x3D; JsonUtils.getJson(date);    return json;&#125;</code></pre></div><p>大工告成！完美！</p><h2 id="2-FastJson"><a href="#2-FastJson" class="headerlink" title="2.FastJson"></a>2.FastJson</h2><p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p><p>fastjson 的 pom依赖！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.2.60&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>fastjson 三个主要的类：</p><ul><li>【JSONObject 代表 json 对象 】<ul><li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li><li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li></ul></li><li>【JSONArray 代表 json 对象数组】<ul><li>内部是有List接口中的方法来完成操作的。</li></ul></li><li>【JSON 代表 JSONObject和JSONArray的转化】<ul><li>JSON类源码分析与使用</li><li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li></ul></li></ul><p><strong>代码测试，我们新建一个FastJsonDemo 类</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.kuang.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个对象        User user1 &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);        User user2 &#x3D; new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);        User user3 &#x3D; new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);        User user4 &#x3D; new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);        List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();        list.add(user1);        list.add(user2);        list.add(user3);        list.add(user4);        System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;);        String str1 &#x3D; JSON.toJSONString(list);        System.out.println(&quot;JSON.toJSONString(list)&#x3D;&#x3D;&gt;&quot;+str1);        String str2 &#x3D; JSON.toJSONString(user1);        System.out.println(&quot;JSON.toJSONString(user1)&#x3D;&#x3D;&gt;&quot;+str2);        System.out.println(&quot;\n****** JSON字符串 转 Java对象*******&quot;);        User jp_user1&#x3D;JSON.parseObject(str2,User.class);        System.out.println(&quot;JSON.parseObject(str2,User.class)&#x3D;&#x3D;&gt;&quot;+jp_user1);        System.out.println(&quot;\n****** Java对象 转 JSON对象 ******&quot;);        JSONObject jsonObject1 &#x3D; (JSONObject) JSON.toJSON(user2);        System.out.println(&quot;(JSONObject) JSON.toJSON(user2)&#x3D;&#x3D;&gt;&quot;+jsonObject1.getString(&quot;name&quot;));        System.out.println(&quot;\n****** JSON对象 转 Java对象 ******&quot;);        User to_java_user &#x3D; JSON.toJavaObject(jsonObject1, User.class);        System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)&#x3D;&#x3D;&gt;&quot;+to_java_user);    &#125;&#125;</code></pre></div><p>例题：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;json8&quot;)    @ResponseBody    public String json8() throws JsonProcessingException &#123;        &#x2F;&#x2F;创建一个对象        User user1 &#x3D; new User(&quot;秦疆1号&quot;, 3, &quot;男&quot;);        User user2 &#x3D; new User(&quot;秦疆2号&quot;, 3, &quot;男&quot;);        User user3 &#x3D; new User(&quot;秦疆3号&quot;, 3, &quot;男&quot;);        User user4 &#x3D; new User(&quot;秦疆4号&quot;, 3, &quot;男&quot;);        List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();        list.add(user1);        list.add(user2);        list.add(user3);        list.add(user4);        &#x2F;&#x2F;将我们的对象解析成为json格式        String str1 &#x3D; JSON.toJSONString(list);        return str1;    &#125;</code></pre></div><p>测试：</p><p><img src="/myBlog/SpringMVC/1905053-20200331213729633-854108693.png" alt="img"></p><h1 id="12、Ajax技术"><a href="#12、Ajax技术" class="headerlink" title="12、Ajax技术"></a>12、Ajax技术</h1><h2 id="12-1、AJAX初体验"><a href="#12-1、AJAX初体验" class="headerlink" title="12.1、AJAX初体验"></a>12.1、AJAX初体验</h2><p>异步可理解为局部刷新，同步指需要按部就班地完成一整套流程</p><ul><li><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></li><li>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</li><li><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></li><li>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</li><li>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</li><li>就和国内百度的搜索框一样：</li><li>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</li><li>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</li><li>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</li></ul><h3 id="伪造Ajax"><a href="#伪造Ajax" class="headerlink" title="伪造Ajax"></a>伪造Ajax</h3><p>我们可以使用前端的一个标签来伪造一个ajax的样子。 iframe标签</p><ol><li><p>新建一个module ： sspringmvc-06-ajax ， 导入web支持！</p></li><li><p>编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang&#x3D;&quot;en&quot;&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;window.onload &#x3D; function()&#123; var myDate &#x3D; new Date(); document.getElementById(&#39;currentTime&#39;).innerText &#x3D; myDate.getTime();&#125;;function LoadPage()&#123; var targetUrl &#x3D;  document.getElementById(&#39;url&#39;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src &#x3D; targetUrl;&#125;&lt;&#x2F;script&gt;&lt;div&gt;&lt;p&gt;请输入要加载的地址：&lt;span id&#x3D;&quot;currentTime&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;p&gt; &lt;input id&#x3D;&quot;url&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;LoadPage()&quot;&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;h3&gt;加载页面位置：&lt;&#x2F;h3&gt;&lt;iframe id&#x3D;&quot;iframePosition&quot; style&#x3D;&quot;width: 100%;height: 500px;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>使用IDEA开浏览器测试一下</p></li></ol><p><strong>利用AJAX可以做：</strong></p><ul><li>注册时，输入用户名自动检测用户是否已经存在。</li><li>登陆时，提示用户名密码错误</li><li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li><li>….等等</li></ul><h3 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery.ajax"></a>jQuery.ajax</h3><ul><li>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</li><li>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</li><li>jQuery 提供多个与 AJAX 有关的方法。</li><li>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</li><li>jQuery 不是生产者，而是大自然搬运工。</li><li>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</li></ul><div class="code-wrapper"><pre class="line-numbers language-js" data-language="js"><code class="language-js">jQuery.ajax(...)       部分参数：              url：请求地址             type：请求方式，GET、POST（1.9.0之后用method）          headers：请求头             data：要发送的数据      contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)            async：是否异步          timeout：设置请求超时时间（毫秒）       beforeSend：发送请求前执行的函数(全局)         complete：完成之后执行的回调函数(全局)          success：成功之后执行的回调函数(全局)            error：失败之后执行的回调函数(全局)          accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型         dataType：将服务器端返回的数据转换成指定类型            &quot;xml&quot;: 将服务器端返回的内容转换成xml格式           &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式           &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。         &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式           &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象          &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</code></pre></div><p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p><ol><li><p>配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;    &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;    &lt;mvc:default-servlet-handler &#x2F;&gt;    &lt;mvc:annotation-driven &#x2F;&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;        &lt;!-- 后缀 --&gt;        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div></li><li><p>编写一个AjaxController</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controllerpublic class AjaxController &#123;    @RequestMapping(&quot;&#x2F;a1&quot;)    public void ajax1(String name , HttpServletResponse response) throws IOException &#123;        if (&quot;admin&quot;.equals(name))&#123;            response.getWriter().print(&quot;true&quot;);        &#125;else&#123;            response.getWriter().print(&quot;false&quot;);        &#125;    &#125;&#125;</code></pre></div></li><li><p>导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></div></li><li><p>编写index.jsp测试</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;&#x2F;title&gt;    &lt;%--&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;--%&gt;    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        function a1()&#123;            $.post(&#123;                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a1&quot;,                data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;,                success:function (data,status) &#123;                    alert(data);                    alert(status);                &#125;            &#125;);        &#125;    &lt;&#x2F;script&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;  &lt;%--onblur：失去焦点触发事件--%&gt;  用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txtName&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>启动tomcat测试！ 打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p></li></ol><h2 id="12-2、AJAX异步加载数据"><a href="#12-2、AJAX异步加载数据" class="headerlink" title="12.2、AJAX异步加载数据"></a>12.2、AJAX异步加载数据</h2><h3 id="Springmvc实现"><a href="#Springmvc实现" class="headerlink" title="Springmvc实现"></a>Springmvc实现</h3><p>实体类user</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123;    private String name;    private int age;    private String sex;&#125;</code></pre></div><p>我们来获取一个集合对象，展示到前端页面</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;a2&quot;)public List&lt;User&gt; ajax2()&#123;    List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;();    list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;));    list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;));    list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;));    return list; &#x2F;&#x2F;由于@RestController注解，将list转成json格式返回&#125;</code></pre></div><p>前端页面</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;获取数据&quot;&#x2F;&gt;&lt;table width&#x3D;&quot;80%&quot; align&#x3D;&quot;center&quot;&gt;    &lt;tr&gt;        &lt;td&gt;姓名&lt;&#x2F;td&gt;        &lt;td&gt;年龄&lt;&#x2F;td&gt;        &lt;td&gt;性别&lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;    &lt;tbody id&#x3D;&quot;content&quot;&gt;    &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    $(function () &#123;        $(&quot;#btn&quot;).click(function () &#123;            $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123;                console.log(data)                var html&#x3D;&quot;&quot;;                for (var i &#x3D; 0; i &lt;data.length ; i++) &#123;                    html+&#x3D; &quot;&lt;tr&gt;&quot; +                        &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;&#x2F;td&gt;&quot; +                        &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;&#x2F;td&gt;&quot; +                        &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;&#x2F;td&gt;&quot; +                        &quot;&lt;&#x2F;tr&gt;&quot;                &#125;                $(&quot;#content&quot;).html(html);            &#125;);        &#125;)    &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p><h2 id="12-3、AJAX验证用户名体验"><a href="#12-3、AJAX验证用户名体验" class="headerlink" title="12.3、AJAX验证用户名体验"></a>12.3、AJAX验证用户名体验</h2><h3 id="注册提示效果"><a href="#注册提示效果" class="headerlink" title="注册提示效果"></a>注册提示效果</h3><p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p><p>我们写一个Controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;a3&quot;)public String ajax3(String name,String pwd)&#123;    String msg &#x3D; &quot;&quot;;    &#x2F;&#x2F;模拟数据库中存在数据    if (name!&#x3D;null)&#123;        if (&quot;admin&quot;.equals(name))&#123;            msg &#x3D; &quot;OK&quot;;        &#125;else &#123;            msg &#x3D; &quot;用户名输入错误&quot;;        &#125;    &#125;    if (pwd!&#x3D;null)&#123;        if (&quot;123456&quot;.equals(pwd))&#123;            msg &#x3D; &quot;OK&quot;;        &#125;else &#123;            msg &#x3D; &quot;密码输入有误&quot;;        &#125;    &#125;    return msg; &#x2F;&#x2F;由于@RestController注解，将msg转成json格式返回&#125;</code></pre></div><p>前端页面 login.jsp</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;ajax&lt;&#x2F;title&gt;    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;        function a1()&#123;            $.post(&#123;                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,                data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;,                success:function (data) &#123;                    if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123;                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                    &#125;else &#123;                        $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                    &#125;                    $(&quot;#userInfo&quot;).html(data);                &#125;            &#125;);        &#125;        function a2()&#123;            $.post(&#123;                url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;,                data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;,                success:function (data) &#123;                    if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123;                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;);                    &#125;else &#123;                        $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;);                    &#125;                    $(&quot;#pwdInfo&quot;).html(data);                &#125;            &#125;);        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt;    用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt;    &lt;span id&#x3D;&quot;userInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;p&gt;    密码:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&#x2F;&gt;    &lt;span id&#x3D;&quot;pwdInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>【记得处理json乱码问题】</p><p>测试一下效果，动态请求响应，局部刷新，就是如此！</p><h2 id="12-4、补充，自己看看"><a href="#12-4、补充，自己看看" class="headerlink" title="12.4、补充，自己看看"></a>12.4、补充，自己看看</h2><h3 id="获取baidu接口Demo"><a href="#获取baidu接口Demo" class="headerlink" title="获取baidu接口Demo"></a>获取baidu接口Demo</h3><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;    &lt;title&gt;JSONP百度搜索&lt;&#x2F;title&gt;    &lt;style&gt;        #q&#123;            width: 500px;            height: 30px;            border:1px solid #ddd;            line-height: 30px;            display: block;            margin: 0 auto;            padding: 0 10px;            font-size: 14px;        &#125;        #ul&#123;            width: 520px;            list-style: none;            margin: 0 auto;            padding: 0;            border:1px solid #ddd;            margin-top: -1px;            display: none;        &#125;        #ul li&#123;            line-height: 30px;            padding: 0 10px;        &#125;        #ul li:hover&#123;            background-color: #f60;            color: #fff;        &#125;    &lt;&#x2F;style&gt;    &lt;script&gt;        &#x2F;&#x2F; 2.步骤二        &#x2F;&#x2F; 定义demo函数 (分析接口、数据)        function demo(data)&#123;            var Ul &#x3D; document.getElementById(&#39;ul&#39;);            var html &#x3D; &#39;&#39;;            &#x2F;&#x2F; 如果搜索数据存在 把内容添加进去            if (data.s.length) &#123;                &#x2F;&#x2F; 隐藏掉的ul显示出来                Ul.style.display &#x3D; &#39;block&#39;;                &#x2F;&#x2F; 搜索到的数据循环追加到li里                for(var i &#x3D; 0;i&lt;data.s.length;i++)&#123;                    html +&#x3D; &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;&#x2F;li&gt;&#39;;                &#125;                &#x2F;&#x2F; 循环的li写入ul                Ul.innerHTML &#x3D; html;            &#125;        &#125;        &#x2F;&#x2F; 1.步骤一        window.onload &#x3D; function()&#123;            &#x2F;&#x2F; 获取输入框和ul            var Q &#x3D; document.getElementById(&#39;q&#39;);            var Ul &#x3D; document.getElementById(&#39;ul&#39;);            &#x2F;&#x2F; 事件鼠标抬起时候            Q.onkeyup &#x3D; function()&#123;                &#x2F;&#x2F; 如果输入框不等于空                if (this.value !&#x3D; &#39;&#39;) &#123;                    &#x2F;&#x2F; ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆                    &#x2F;&#x2F; 创建标签                    var script &#x3D; document.createElement(&#39;script&#39;);                    &#x2F;&#x2F;给定要跨域的地址 赋值给src                    &#x2F;&#x2F;这里是要请求的跨域的地址 我写的是百度搜索的跨域地址                    script.src &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;&#39;+this.value+&#39;&amp;cb&#x3D;demo&#39;;                    &#x2F;&#x2F; 将组合好的带src的script标签追加到body里                    document.body.appendChild(script);                &#125;            &#125;        &#125;    &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;q&quot; &#x2F;&gt;&lt;ul id&#x3D;&quot;ul&quot;&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h2 id="12-5、问题"><a href="#12-5、问题" class="headerlink" title="12.5、问题"></a>12.5、问题</h2><ul><li>没有在pom导入Jackson依赖</li></ul><p><img src="/myBlog/SpringMVC/image-20210811204452782.png" alt="image-20210811204452782"></p><ul><li>输出数据没有在table标签内，且没对齐</li></ul><p><img src="/myBlog/SpringMVC/image-20210811204532578.png" alt="image-20210811204532578">+</p><ul><li>这是正确的</li></ul><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;tbody id&#x3D;&quot;content&quot;&gt;&lt;%--数据 ：后台--%&gt;&lt;&#x2F;tbody&gt;</code></pre></div><ul><li>这是发生错误的</li></ul><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;tboby id&#x3D;&quot;content&quot;&gt;&lt;&#x2F;tboby&gt;</code></pre></div><h1 id="13、拦截器"><a href="#13、拦截器" class="headerlink" title="13、拦截器"></a>13、拦截器</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p><p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p><p><strong>过滤器</strong></p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li></ul><p><strong>拦截器</strong></p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li></ul><h3 id="13-1、自定义拦截器"><a href="#13-1、自定义拦截器" class="headerlink" title="13.1、自定义拦截器"></a>13.1、自定义拦截器</h3><p>那如何实现拦截器呢？</p><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p><ol><li><p>新建一个Moudule ， springmvc-07-Interceptor ， 添加web支持</p></li><li><p>配置web.xml 和 springmvc-servlet.xml 文件</p></li><li><p>编写一个拦截器</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123;    &#x2F;&#x2F;在请求处理的方法之前执行    &#x2F;&#x2F;如果返回true执行下一个拦截器    &#x2F;&#x2F;如果返回false就不执行下一个拦截器    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123;        System.out.println(&quot;------------处理前------------&quot;);        return true;    &#125;    &#x2F;&#x2F;在请求处理方法执行之后执行    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;        System.out.println(&quot;------------处理后------------&quot;);    &#125;    &#x2F;&#x2F;在dispatcherServlet处理后执行,做清理工作.    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;        System.out.println(&quot;------------清理------------&quot;);    &#125;&#125;</code></pre></div></li><li><p>在springmvc的配置文件中配置拦截器</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--&#x2F;** 包括路径及其子路径--&gt;        &lt;!--&#x2F;admin&#x2F;* 拦截的是&#x2F;admin&#x2F;add等等这种 , &#x2F;admin&#x2F;add&#x2F;user不会被拦截--&gt;        &lt;!--&#x2F;admin&#x2F;** 拦截的是&#x2F;admin&#x2F;下的所有--&gt;        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;        &lt;!--bean配置的就是拦截器--&gt;        &lt;bean class&#x3D;&quot;com.kuang.interceptor.MyInterceptor&quot;&#x2F;&gt;    &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;</code></pre></div></li><li><p>编写一个Controller，接收请求</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;&#x2F;&#x2F;测试拦截器的控制器@Controllerpublic class InterceptorController &#123;    @RequestMapping(&quot;&#x2F;interceptor&quot;)    @ResponseBody    public String testFunction() &#123;        System.out.println(&quot;控制器中的方法执行了&quot;);        return &quot;hello&quot;;    &#125;&#125;</code></pre></div></li><li><p>前端 index.jsp</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;interceptor&quot;&gt;拦截器测试&lt;&#x2F;a&gt;</code></pre></div></li><li><p>启动tomcat 测试一下</p></li></ol><h3 id="13-2、验证用户是否登录-认证用户"><a href="#13-2、验证用户是否登录-认证用户" class="headerlink" title="13.2、验证用户是否登录 (认证用户)"></a>13.2、验证用户是否登录 (认证用户)</h3><p><strong>实现思路</strong></p><ol><li>有一个登陆页面，需要写一个controller访问页面。</li><li>登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></li><li>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</li></ol><p><strong>代码编写</strong></p><ol><li><p>编写一个登陆页面 login.jsp</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;h1&gt;登录页面&lt;&#x2F;h1&gt;&lt;hr&gt;&lt;body&gt;&lt;form action&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;login&quot;&gt;    用户名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&gt; &lt;br&gt;    密码： &lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;pwd&quot;&gt; &lt;br&gt;    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>编写一个Controller处理请求</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller@RequestMapping(&quot;&#x2F;user&quot;)public class UserController &#123;    &#x2F;&#x2F;跳转到登陆页面    @RequestMapping(&quot;&#x2F;jumplogin&quot;)    public String jumpLogin() throws Exception &#123;        return &quot;login&quot;;    &#125;    &#x2F;&#x2F;跳转到成功页面    @RequestMapping(&quot;&#x2F;jumpSuccess&quot;)    public String jumpSuccess() throws Exception &#123;        return &quot;success&quot;;    &#125;    &#x2F;&#x2F;登陆提交    @RequestMapping(&quot;&#x2F;login&quot;)    public String login(HttpSession session, String username, String pwd) throws Exception &#123;        &#x2F;&#x2F; 向session记录用户身份信息        System.out.println(&quot;接收前端&#x3D;&#x3D;&#x3D;&quot;+username);        session.setAttribute(&quot;user&quot;, username);        return &quot;success&quot;;    &#125;    &#x2F;&#x2F;退出登陆    @RequestMapping(&quot;logout&quot;)    public String logout(HttpSession session) throws Exception &#123;        &#x2F;&#x2F; session 过期        session.invalidate();        return &quot;login&quot;;    &#125;&#125;</code></pre></div></li><li><p>编写一个登陆成功的页面 success.jsp</p><div class="code-wrapper"><pre class="line-numbers language-jsp" data-language="jsp"><code class="language-jsp">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;登录成功页面&lt;&#x2F;h1&gt;&lt;hr&gt;$&#123;user&#125;&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;logout&quot;&gt;注销&lt;&#x2F;a&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;  &lt;h1&gt;首页&lt;&#x2F;h1&gt;  &lt;hr&gt;  &lt;%--登录--%&gt;  &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;jumplogin&quot;&gt;登录&lt;&#x2F;a&gt;  &lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;user&#x2F;jumpSuccess&quot;&gt;成功页面&lt;&#x2F;a&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div></li><li><p>编写用户登录拦截器</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;public class LoginInterceptor implements HandlerInterceptor &#123;    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123;        &#x2F;&#x2F; 如果是登陆页面则放行        System.out.println(&quot;uri: &quot; + request.getRequestURI());        if (request.getRequestURI().contains(&quot;login&quot;)) &#123;            return true;        &#125;        HttpSession session &#x3D; request.getSession();        &#x2F;&#x2F; 如果用户已登陆也放行        if(session.getAttribute(&quot;user&quot;) !&#x3D; null) &#123;            return true;        &#125;        &#x2F;&#x2F; 用户没有登陆跳转到登陆页面        request.getRequestDispatcher(&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;login.jsp&quot;).forward(request, response);        return false;    &#125;    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123;    &#125;        public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123;    &#125;&#125;</code></pre></div></li><li><p>在Springmvc的配置文件中注册拦截器</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;        &lt;bean id&#x3D;&quot;loginInterceptor&quot; class&#x3D;&quot;com.kuang.interceptor.LoginInterceptor&quot;&#x2F;&gt;    &lt;&#x2F;mvc:interceptor&gt;&lt;&#x2F;mvc:interceptors&gt;</code></pre></div></li><li><p>再次重启Tomcat测试！</p></li></ol><p><strong>OK，测试登录拦截功能无误</strong></p><h1 id="14、文件上传和下载"><a href="#14、文件上传和下载" class="headerlink" title="14、文件上传和下载"></a>14、文件上传和下载</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p><p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p><p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li><li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li></ul><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;form action&#x3D;&quot;&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;    &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;    &lt;input type&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt;</code></pre></div><p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p><ul><li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li><li>而Spring MVC则提供了更简单的封装。</li><li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li><li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件</li></ul><h3 id="14-1、文件上传"><a href="#14-1、文件上传" class="headerlink" title="14.1、文件上传"></a>14.1、文件上传</h3><p>一、导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--文件上传--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-fileupload&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;commons-fileupload&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.3.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;4.0.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><p>二、配置bean：multipartResolver<br>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--文件上传配置--&gt;&lt;bean id&#x3D;&quot;multipartResolver&quot;  class&#x3D;&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;    &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;    &lt;property name&#x3D;&quot;defaultEncoding&quot; value&#x3D;&quot;utf-8&quot;&#x2F;&gt;    &lt;!-- 上传文件大小上限，单位为字节（10485760&#x3D;10M） --&gt;    &lt;property name&#x3D;&quot;maxUploadSize&quot; value&#x3D;&quot;10485760&quot;&#x2F;&gt;    &lt;property name&#x3D;&quot;maxInMemorySize&quot; value&#x3D;&quot;40960&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></div><p>CommonsMultipartFile 的 常用方法：</p><ul><li><strong>String getOriginalFilename()：获取上传文件的原名</strong></li><li><strong>InputStream getInputStream()：获取文件流</strong></li><li><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></li></ul><p>我们去实际测试一下</p><p>三、编写前端页面</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;form action&#x3D;&quot;&#x2F;upload&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; method&#x3D;&quot;post&quot;&gt;  &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;upload&quot;&gt;&lt;&#x2F;form&gt;</code></pre></div><p>四、<strong>Controller</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@Controllerpublic class FileController &#123;    &#x2F;&#x2F;@RequestParam(&quot;file&quot;) 将name&#x3D;file控件得到的文件封装成CommonsMultipartFile 对象    &#x2F;&#x2F;批量上传CommonsMultipartFile则为数组即可    @RequestMapping(&quot;&#x2F;upload&quot;)    public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123;        &#x2F;&#x2F;获取文件名 : file.getOriginalFilename();        String uploadFileName &#x3D; file.getOriginalFilename();        &#x2F;&#x2F;如果文件名为空，直接回到首页！        if (&quot;&quot;.equals(uploadFileName))&#123;            return &quot;redirect:&#x2F;index.jsp&quot;;        &#125;        System.out.println(&quot;上传文件名 : &quot;+uploadFileName);        &#x2F;&#x2F;上传路径保存设置        String path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);        &#x2F;&#x2F;如果路径不存在，创建一个        File realPath &#x3D; new File(path);        if (!realPath.exists())&#123;            realPath.mkdir();        &#125;        System.out.println(&quot;上传文件保存地址：&quot;+realPath);        InputStream is &#x3D; file.getInputStream(); &#x2F;&#x2F;文件输入流        OutputStream os &#x3D; new FileOutputStream(new File(realPath,uploadFileName)); &#x2F;&#x2F;文件输出流        &#x2F;&#x2F;读取写出        int len&#x3D;0;        byte[] buffer &#x3D; new byte[1024];        while ((len&#x3D;is.read(buffer))!&#x3D;-1)&#123;            os.write(buffer,0,len);            os.flush();        &#125;        os.close();        is.close();        return &quot;redirect:&#x2F;index.jsp&quot;;    &#125;&#125;</code></pre></div><p>五、测试上传文件，OK！</p><p><strong>采用file.Transto 来保存上传的文件</strong></p><ol><li><p>编写Controller</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;* * 采用file.Transto 来保存上传的文件 *&#x2F;@RequestMapping(&quot;&#x2F;upload2&quot;)public String  fileUpload2(@RequestParam(&quot;file&quot;) CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123;    &#x2F;&#x2F;上传路径保存设置    String path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);    File realPath &#x3D; new File(path);    if (!realPath.exists())&#123;        realPath.mkdir();    &#125;    &#x2F;&#x2F;上传文件地址    System.out.println(&quot;上传文件保存地址：&quot;+realPath);    &#x2F;&#x2F;通过CommonsMultipartFile的方法直接写文件（注意这个时候）    file.transferTo(new File(realPath +&quot;&#x2F;&quot;+ file.getOriginalFilename()));    return &quot;redirect:&#x2F;index.jsp&quot;;&#125;</code></pre></div></li><li><p>前端表单提交地址修改</p></li><li><p>访问提交测试，OK！</p></li></ol><h3 id="14-2、文件下载"><a href="#14-2、文件下载" class="headerlink" title="14.2、文件下载"></a>14.2、文件下载</h3><p>文件下载步骤：</p><ol><li>设置 response 响应头</li><li>读取文件 – InputStream</li><li>写出文件 – OutputStream</li><li>执行操作</li><li>关闭流 （先开后关）</li></ol><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(value&#x3D;&quot;&#x2F;download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123;    &#x2F;&#x2F;要下载的图片地址    String  path &#x3D; request.getServletContext().getRealPath(&quot;&#x2F;upload&quot;);    String  fileName &#x3D; &quot;基础语法.jpg&quot;;    &#x2F;&#x2F;1、设置response 响应头    response.reset(); &#x2F;&#x2F;设置页面不缓存,清空buffer    response.setCharacterEncoding(&quot;UTF-8&quot;); &#x2F;&#x2F;字符编码    response.setContentType(&quot;multipart&#x2F;form-data&quot;); &#x2F;&#x2F;二进制传输数据    &#x2F;&#x2F;设置响应头    response.setHeader(&quot;Content-Disposition&quot;,            &quot;attachment;fileName&#x3D;&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;));    File file &#x3D; new File(path,fileName);    &#x2F;&#x2F;2、 读取文件--输入流    InputStream input&#x3D;new FileInputStream(file);    &#x2F;&#x2F;3、 写出文件--输出流    OutputStream out &#x3D; response.getOutputStream();    byte[] buff &#x3D;new byte[1024];    int index&#x3D;0;    &#x2F;&#x2F;4、执行 写出操作    while((index&#x3D; input.read(buff))!&#x3D; -1)&#123;        out.write(buff, 0, index);        out.flush();    &#125;    out.close();    input.close();    return null;&#125;</code></pre></div><p>前端</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;a href&#x3D;&quot;&#x2F;download&quot;&gt;点击下载&lt;&#x2F;a&gt;</code></pre></div><h1 id="15、通用"><a href="#15、通用" class="headerlink" title="15、通用"></a>15、通用</h1><h3 id="1-web-xml"><a href="#1-web-xml" class="headerlink" title="1.web.xml"></a>1.web.xml</h3><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee http:&#x2F;&#x2F;xmlns.jcp.org&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_4_0.xsd&quot;         version&#x3D;&quot;4.0&quot;&gt;    &lt;!--DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;            &lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;    &lt;&#x2F;servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;&#x2F;servlet-name&gt;        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;servlet-mapping&gt;    &lt;!--encodingFilter--&gt;    &lt;filter&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;filter-class&gt;            org.springframework.web.filter.CharacterEncodingFilter        &lt;&#x2F;filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;            &lt;param-value&gt;utf-8&lt;&#x2F;param-value&gt;        &lt;&#x2F;init-param&gt;    &lt;&#x2F;filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;encodingFilter&lt;&#x2F;filter-name&gt;        &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;    &lt;&#x2F;filter-mapping&gt;    &lt;!--Session过期时间--&gt;    &lt;session-config&gt;        &lt;session-timeout&gt;15&lt;&#x2F;session-timeout&gt;    &lt;&#x2F;session-config&gt;&lt;&#x2F;web-app&gt;</code></pre></div><h3 id="2-springmvc-servlet-xml"><a href="#2-springmvc-servlet-xml" class="headerlink" title="2.springmvc-servlet.xml"></a>2.springmvc-servlet.xml</h3><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;    &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt;    &lt;mvc:default-servlet-handler &#x2F;&gt;    &lt;!--JSON乱码问题配置--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters register-defaults&#x3D;&quot;true&quot;&gt;            &lt;bean class&#x3D;&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;                &lt;constructor-arg value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;            &lt;&#x2F;bean&gt;            &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;                &lt;property name&#x3D;&quot;objectMapper&quot;&gt;                    &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;                        &lt;property name&#x3D;&quot;failOnEmptyBeans&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;                    &lt;&#x2F;bean&gt;                &lt;&#x2F;property&gt;            &lt;&#x2F;bean&gt;        &lt;&#x2F;mvc:message-converters&gt;    &lt;&#x2F;mvc:annotation-driven&gt;    &lt;!-- 视图解析器 --&gt;    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;          id&#x3D;&quot;internalResourceViewResolver&quot;&gt;        &lt;!-- 前缀 --&gt;        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt;        &lt;!-- 后缀 --&gt;        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre></div><h3 id="3、使用到的注解"><a href="#3、使用到的注解" class="headerlink" title="3、使用到的注解"></a>3、使用到的注解</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Controller注解类型用于声明Spring类的实例是一个控制器@RequestMapping(&quot;&#x2F;HelloController&quot;)@PathVariable int p1 组合注解  @GetMapping          @PostMapping          @PutMapping          @DeleteMapping          @PatchMapping@RequestParam(&quot;username&quot;) String name @ResponseBody    组合注解   @RestController</code></pre></div><h3 id="4、使用到的jar包"><a href="#4、使用到的jar包" class="headerlink" title="4、使用到的jar包"></a>4、使用到的jar包</h3><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.12&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;        &lt;version&gt;5.1.9.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;dependency&gt;        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.fasterxml.jackson.core&#x2F;jackson-core --&gt;&lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.10.0&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;         &lt;!-- fastjson --&gt;   &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.2.60&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;         &lt;dependency&gt;       &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;       &lt;version&gt;1.18.10&lt;&#x2F;version&gt;       &lt;scope&gt;compile&lt;&#x2F;scope&gt;     &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><p><img src="/myBlog/SpringMVC/1905053-20200331213841543-745577399.png" alt="img"></p><h1 id="16、SpringMVC的执行流程"><a href="#16、SpringMVC的执行流程" class="headerlink" title="16、SpringMVC的执行流程"></a>16、SpringMVC的执行流程</h1><p><img src="/myBlog/SpringMVC/1370903-20180827201021158-682489195.png" alt="img"></p><p><strong>1、一个请求匹配前端控制器 DispatcherServlet 的请求映射路径(在 web.xml中指定), WEB 容器将该请求转交给 DispatcherServlet 处理</strong></p><p><strong>2、DispatcherServlet 接收到请求后, 将根据 请求信息 交给 处理器映射器 （HandlerMapping）</strong></p><p><strong>3、HandlerMapping 根据用户的url请求 查找匹配该url的 Handler，并返回一个执行链</strong></p><p><strong>4、DispatcherServlet 再请求 处理器适配器(HandlerAdapter) 调用相应的 Handler 进行处理并返回 ModelAndView 给 DispatcherServlet</strong></p><p><strong>5、DispatcherServlet 将 ModelAndView 请求 ViewReslover（视图解析器）解析，返回具体 View</strong></p><p><strong>6、DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）</strong></p><p><strong>7、DispatcherServlet 将页面响应给用户</strong></p>]]></content>
    
    
    <categories>
      
      <category>framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/myBlog/Redis/"/>
    <url>/myBlog/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis笔记"><a href="#Redis笔记" class="headerlink" title="Redis笔记"></a>Redis笔记</h1><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。</p><span id="more"></span><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p><h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><h2 id="为什么用Nosql"><a href="#为什么用Nosql" class="headerlink" title="为什么用Nosql"></a>为什么用Nosql</h2><ol><li><p>单击MySQL的年代</p><ul><li><p>数据量如果太大，一个机器内存放不了</p></li><li><p>数据的索引（B+Tree），一个机器内存也放不下</p></li><li><p>访问量（读写混合），一个服务器承受不来</p></li></ul><p><img src="/myBlog/Redis/image-20211105143145272-1636731322211.png" alt="image-20211105143145272"></p></li><li><p>memcached（缓存）+MySQL+垂直拆分（读写分离）</p><ul><li>发展过程：优化数据结构和索引–&gt;文件缓存（IO）–&gt; Memcached（当时最热门的技术）</li></ul><p><img src="/myBlog/Redis/image-20211105143507833-1636731322212.png" alt="image-20211105143507833"></p></li><li><p>分库分表+水平拆分+mysql集群</p><ul><li>==本质：数据库（读、写）==</li></ul><p><img src="/myBlog/Redis/image-20211105144556574-1636731322212.png" alt="image-20211105144556574"></p></li><li><p>如今</p><p><img src="/myBlog/Redis/image-20211105151219429-1636731322212.png" alt="image-20211105151219429"></p></li><li><p>为什么用Nosql</p><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式的增长</p></li></ol><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><p>NoSQL = Not Only SQL</p><p>泛指非关系型数据库，传统的关系型数据库难以对付web2.0时代！，NoSQL在当今大数据时代环境下迅速发展，Redis。</p><p>关系型数据库：表格，行，列</p><h2 id="NoSQL特点"><a href="#NoSQL特点" class="headerlink" title="NoSQL特点"></a>NoSQL特点</h2><ol><li><p>方便扩展（数据之间没有关系，很好扩展）</p></li><li><p>大数据量高性能（Redis一秒抄写8万次，读取11万，Nosql的缓存记录集，是一种细粒度的缓存，性能较高）</p></li><li><p>数据类型，多样性 </p></li><li><p>传统的RDBMS和Nosql</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">传统的RDBMS- 结构化组织- SQL- 数据和关系都存在单独的表中- 操作，数据定义语言- 严格的一致性- 基础的事务</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">Nosql- 不仅仅是数据- 没有固定的查询语言- 键值对存储，列存储，文档存储，图形数据库（社交关系）- 最终一致性- CAP定理和BASE(异地多活)- 高性能，高可用，高并发</code></pre></div></li></ol><p>了解：3v+3高</p><p><strong>3v：</strong></p><ol><li>海量volume</li><li>多样variety</li><li>实时velocity</li></ol><p><strong>3高：</strong></p><ol><li>高并发</li><li>高可用(或者高可扩，随时水平拆分，机器不够了，可用扩展机器)</li><li>高性能</li></ol><h2 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h2><p><strong>KV键值对：</strong></p><ul><li>redis</li></ul><p><strong>文档类型数据库(bson格式和json一样)：</strong></p><ul><li>MongoDB（一般必须掌握）<ul><li>MongoDB是一个基于分布式文件存储的数据库，主要用来处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据中间的产品 ，MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的</li></ul></li></ul><p><strong>列存储数据库</strong></p><ul><li>HBase</li><li>分布式文件系统</li></ul><p><strong>图关系数据库</strong></p><ul><li>存关系，比如朋友圈社交网络，广告推荐</li><li>Neo4j， InfoGrid</li></ul><h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis （Remote Dictionnary Server）,即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h2 id="Redis能干嘛"><a href="#Redis能干嘛" class="headerlink" title="Redis能干嘛"></a>Redis能干嘛</h2><ol><li>内存存储、持久化，内存中是断点即失，所以说持久化很重要（rdb，aof）</li><li>效率高，可以用于高速缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器（浏览量） </li><li>….</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li><li>…</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>wsl（Windows下的Linux子系统）</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a><strong>Windows安装</strong></h3><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a><strong>Linux安装</strong></h3><ol><li><p>下载安装包</p></li><li><p>解压到/opt目录下</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost opt]# ls redis-6.2.6  redis-6.2.6.tar.gz[root@localhost opt]# </code></pre></div></li><li><p>进到redis目录下，下载yum</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install gcc-c++</code></pre></div><p>结果报了以下错误</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost redis-6.2.6]# yum install gcc-c++Loaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileCould not retrieve mirrorlist http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;7&amp;arch&#x3D;x86_64&amp;repo&#x3D;os&amp;infra&#x3D;stock error was14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; Unknown error&quot; One of the configured repositories failed (Unknown), and yum doesn&#39;t have enough cached data to continue. At this point the only safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:     1. Contact the upstream for the repository and get them to fix the problem.     2. Reconfigure the baseurl&#x2F;etc. for the repository, to point to a working        upstream. This is most often useful if you are using a newer        distribution release than is supported by the repository (and the        packages for the previous distribution release still work).     3. Run the command with the repository temporarily disabled            yum --disablerepo&#x3D;&lt;repoid&gt; ...     4. Disable the repository permanently, so yum won&#39;t use it by default. Yum        will then just ignore the repository until you permanently enable it        again or use --enablerepo for temporary usage:            yum-config-manager --disable &lt;repoid&gt;        or            subscription-manager repos --disable&#x3D;&lt;repoid&gt;     5. Configure the failing repository to be skipped, if it is unavailable.        Note that yum will try to contact the repo. when it runs most commands,        so will have to try and fail each time (and thus. yum will be be much        slower). If it is a very temporary problem though, this is often a nice        compromise:            yum-config-manager --save --setopt&#x3D;&lt;repoid&gt;.skip_if_unavailable&#x3D;trueCannot find a valid baseurl for repo: base&#x2F;7&#x2F;x86_64</code></pre></div><p>解决方案：</p><ul><li>检查网络，发现ping不通，网络有问题</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[admin@localhost ~]$ ping baidu.comping: baidu.com: Name or service not known[admin@localhost ~]$ </code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">BOOTPROTO&#x3D;staticDEFROUTE&#x3D;yesIPADDR&#x3D;192.168.242.3NETMSAK&#x3D;255.255.255.0GATEWAY&#x3D;192.168.242.2ONBOOT&#x3D;yesDNS1&#x3D;192.168.242.2# 原来是之前配置网络的时候，这一行忘记配置了</code></pre></div><ul><li>配置好，重启服务器，即可</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">service network restart</code></pre></div><ul><li><p>重新执行安装yum的命令。建议使用</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y gcc-c++# -y表示出现的询问都同意</code></pre></div></li></ul><p>检查是否安装成功</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -v</code></pre></div></li><li><p>在redis的目录下执行以下命令</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">makemake install</code></pre></div></li><li><p>redis安装默认路径<code>/usr/local/bin</code></p></li><li><p>拷贝/opt下面的redis的中的conf文件到/usr/local/bin/myredisconfig文件夹下面</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp &#x2F;opt&#x2F;redis-6.2.6&#x2F;redis.conf .&#x2F;myredisconfig</code></pre></div></li><li><p>redis默认不是后台运行，键daemonize处的no改为yes</p><p><img src="/myBlog/Redis/image-20211105214415132-1636731341803.png" alt="image-20211105214415132"></p></li><li><p>设置密码，找到# requirepass foobared，另起一行（除了设置这些之外，还可以设置redis开机自启等等，具体可以网上搜索）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">requirepass xxx# xxx是你的密码</code></pre></div></li><li><p>启动redis，但是没有信息出来，所以使用 <code>ps -ef |gref redis</code>查看6379端口号是否在使用，接着启动客户端</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost bin]# pwd&#x2F;usr&#x2F;local&#x2F;bin[root@localhost bin]# .&#x2F;redis-server myredisconfig&#x2F;redis.conf [root@localhost bin]# ps -ef |grep redisroot      10525      1  0 21:53 ?        00:00:00 .&#x2F;redis-server 127.0.0.1:6379root      10539   3057  0 21:54 pts&#x2F;0    00:00:00 grep --color&#x3D;auto redis[root@localhost bin]# </code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost bin]# .&#x2F;redis-cli -p 6379127.0.0.1:6379&gt; </code></pre></div></li><li><p>测试，发现值存不进去</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set name Ten(error) NOAUTH Authentication required.</code></pre></div><p>经过查找，原来是上一步我们设置了密码，需要认证，输入密码就可以了<code>auth &quot;xxx&quot;</code>，xxx是你的密码</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; auth xxxOK127.0.0.1:6379&gt;</code></pre></div></li><li><p>关闭redis服务<code>shutdown</code>，再次使用ps -ef |grep redis 查看，redis进程已经被关闭</p></li></ol><h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong>：是一个官方自带的压力测试工具！</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 测试：100个并发连接 100000请求redis-benchmark -h localhost -p 6379 -c 100 -n 100000 </code></pre></div><p>如果redis设置了密码认证，可以先去redis.conf将密码暂时去掉</p><p>来自菜鸟教程的表格</p><table><thead><tr><th align="left"></th><th align="left"></th><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">序号</td><td align="left">选项</td><td align="left">描述</td><td align="left">默认值</td></tr><tr><td align="left">1</td><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left">2</td><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left">3</td><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left">5</td><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left">6</td><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">2</td></tr><tr><td align="left">7</td><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left">8</td><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 <numreq> 请求</numreq></td><td align="left">1</td></tr><tr><td align="left">10</td><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis。仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">***-l*（L 的小写字母）**</td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表。</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">***-I*（i 的大写字母）**</td><td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td><td align="left"></td></tr></tbody></table><p><img src="/myBlog/Redis/image-20211106002032827-1636731341803.png" alt="image-20211106002032827"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>redis默认有16个数据库</p><p><img src="/myBlog/Redis/image-20211106150331202-1636731341803.png" alt="image-20211106150331202"></p><p>默认使用第0个</p><p>可以使用<code>select 2</code>切换第2个数据库</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">select 2# 切换到2号数据库dbsize# 查看当前数据库的大小keys *# 查询所有的keyflushdb# 清除当前的数据库flushall# 清空所有的数据库</code></pre></div><p><strong>redis是单线程</strong>（redis6.0之后是多线程）</p><p><strong>redis为什么单线程还这么快？</strong></p><p>误区1：高性能的服务器一定是多线程的？</p><p>误区2：多线程（CPU上下文会切换）一定比单线程效率高</p><p>核心：redis是将所有的数据全部放在内存中的，所以说使用单线程去操作效率是最高的，多线程（CPU上下文会切换：耗时的操作），对于内存系统来说，如果没有上下文切换效率就是最高的。多次读写都是在一个CPU上的，在内存情况下，这个就是最佳方案！</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><h2 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exists name# 判断是否存在namemove name 1# 移动当前的数据库的name到1号数据库del name# 删除nameexpire name 10  # 设置name 10秒后过期 ttl name# 查看剩余时间type name# 查看当前的name的类型 </code></pre></div><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">append key1 &quot;hello&quot;# 在key1后面追加“hello”，如果当前key1不存在，则新建strlen key1# 获取当前key1的字符长度</code></pre></div><p><strong>incr自增，计数器</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set views 0# 设置一个值为0的viewsOK127.0.0.1:6379&gt; get views&quot;0&quot;127.0.0.1:6379&gt; INCR views# 将views的值加一(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>decr自减</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; get views&quot;2&quot;127.0.0.1:6379&gt; DECR views# 将views减一(integer) 1127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>INCRBY views 10</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; get views&quot;1&quot;127.0.0.1:6379&gt; INCRBY views 10# 一次性加10(integer) 11127.0.0.1:6379&gt; </code></pre></div><p><strong>DECRBY views 5</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; INCRBY views 10(integer) 11127.0.0.1:6379&gt; DECRBY views 5# 一次性减5(integer) 6127.0.0.1:6379&gt; </code></pre></div><p><strong>getrange</strong>:取一个字符串范围，取全部为0 -1</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set key1 &quot;hello,Ten&quot;OK127.0.0.1:6379&gt; GETRANGE key1 1 3&quot;ell&quot;127.0.0.1:6379&gt; GETRANGE key1 0 3&quot;hell&quot;127.0.0.1:6379&gt; GETRANGE key1 0 -1&quot;hello,Ten&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>setrange</strong>:替换某范围的字符串 </p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set key2 abcdefgOK127.0.0.1:6379&gt; get key2&quot;abcdefg&quot;127.0.0.1:6379&gt; SETRANGE key2 1 xx(integer) 7127.0.0.1:6379&gt; get key2&quot;axxdefg&quot;127.0.0.1:6379&gt; </code></pre></div><p>**setex:**设置过期时间</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setex key3 30 &quot;hello&quot;OK127.0.0.1:6379&gt; ttl key3(integer) 21</code></pre></div><p><strong>setnx</strong>：不存在再设置，如果存在则不设置（在分布式锁中会常用到）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setnx mykey &quot;redis&quot;(integer) 1127.0.0.1:6379&gt; get mykey&quot;redis&quot;127.0.0.1:6379&gt; setnx mykey &quot;Mongodb&quot;(integer) 0127.0.0.1:6379&gt; get mykey&quot;redis&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>mset，mget，批量存值和取值</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k3&quot;3) &quot;k1&quot;127.0.0.1:6379&gt; mget k1 k2 k31) &quot;v1&quot;2) &quot;v2&quot;3) &quot;v3&quot;127.0.0.1:6379&gt; keys *1) &quot;k2&quot;2) &quot;k3&quot;3) &quot;k1&quot;127.0.0.1:6379&gt; msetnx k1 v1 k4 v4# msetnx是原子性操作，要不成功，要不失败(integer) 0127.0.0.1:6379&gt; </code></pre></div><p><strong>key的巧妙设置</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># set user:1 &#123;name:zhangsan,age:2&#125;# 设置一个user:1 对象，值为json字符来保存一个对象# 这里的key是以巧妙的设计： user:&#123;id&#125;:&#123;filed&#125;127.0.0.1:6379&gt; mset user:1:name zhangsan user:1:age 2OK127.0.0.1:6379&gt; mget user:1:name user:1:age1) &quot;zhangsan&quot;2) &quot;2&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>getset</strong>，先get，再set，如果不存在值，则返回null，再设置新的值进入。如果存在先取出，再设置进去。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; getset db redis(nil)127.0.0.1:6379&gt; get db&quot;redis&quot;127.0.0.1:6379&gt; getset db mongodb&quot;redis&quot;127.0.0.1:6379&gt; get db&quot;mongodb&quot;127.0.0.1:6379&gt; </code></pre></div><p>String类似的使用场景：value除了我们的字符串还可以是数字。</p><ul><li>计数器</li><li>统计多单位的数量</li><li>粉丝数</li><li>对象缓存存储</li></ul><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><p>在redis里面，我们可以把list玩成，栈、队列、阻塞队列。</p><p><strong>lpush list one</strong>：往list中存入一个one的值（头部）</p><p><strong>lrange list 0 -1</strong>：取出list中所有的值</p><p> <strong>RPUSH list right</strong>：在右边加入right的值（尾部）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; lpush list one(integer) 1127.0.0.1:6379&gt; lpush list two(integer) 2127.0.0.1:6379&gt; keys *1) &quot;list&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;127.0.0.1:6379&gt; RPUSH list right(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;right&quot;127.0.0.1:6379&gt; </code></pre></div><p><img src="/myBlog/Redis/image-20211107113912628-1636731341803.png" alt="image-20211107113912628"></p><p><strong>lpop</strong>：从左边移除</p><p><strong>rpop</strong>：从右边移除</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;two&quot;2) &quot;one&quot;3) &quot;right&quot;127.0.0.1:6379&gt; LPOP list&quot;two&quot;127.0.0.1:6379&gt; RPOP list&quot;right&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;one&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>lindex list 0</strong> ：获取list索引为0的元素</p><p><strong>llen list</strong> ：查看当前list的长度 </p><p><strong>lrem list 2 one</strong>：移除list中的两个one（list中的值可以重复，如果超过最大数量，只移除存在的最大数量）</p><p><strong>ltrim mylist 1 2</strong>：截取mylist中的索引为1 和2的值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; LTRIM list 0 1OK127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>rpoplpush list otherlist</strong>：移除list中最后一个元素，并加到otherlist中</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; rpoplpush list otherlist&quot;3&quot;127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; LRANGE otherlist 0 -11) &quot;3&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>lset list 0 item：</strong>将list中索引为0的值改成item（前提是，list中相对应的索引存在）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; lpush list 0# 插入元素(integer) 1127.0.0.1:6379&gt; LRANGE list 0 0# 查看是否存在相对应的元素1) &quot;0&quot;127.0.0.1:6379&gt; lset list 0 itemOK127.0.0.1:6379&gt; LRANGE list 0 01) &quot;item&quot;127.0.0.1:6379&gt; lset list 1 other# 索引为1的元素不存在，所以报错(error) ERR index out of range127.0.0.1:6379&gt; </code></pre></div><p>**linsert list before|after “world” “my”**：在list中的world之前（之后）加上my</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; rpush list &quot;hello&quot;(integer) 1127.0.0.1:6379&gt; rpush list &quot;world&quot;(integer) 2127.0.0.1:6379&gt; LINSERT list before &quot;world&quot; &quot;my&quot;# 在list中的world之前插入my(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) &quot;hello&quot;2) &quot;my&quot;3) &quot;world&quot;127.0.0.1:6379&gt; </code></pre></div><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>set中的值是不可以重复的，无序的</p><p>**sadd myset “hello”**：往myset中添加一个字符串hello</p><p><strong>smembers myset：</strong>取出myset中的值</p><p><strong>sismembers myset hello：</strong>判断myset里面是否有这个hello，如果有返回1，没有返回0</p><p><strong>scard myset</strong>：获取myset中的个数</p><p><strong>srem myset hello：</strong>移除myset中的hello元素</p><p><strong>srandmember myset 2：</strong>在myset中随机抽取两个数字，不要数字就是默认取一个</p><p><strong>spop myset：</strong>随机弹出myset中的一个元素</p><p><strong>smove myset myset2 holle：</strong>将myset中的hello元素移动到myset2中</p><p><strong>sdiff key1 key2：</strong>key1集合减去key2集合（==差集==）</p><p><strong>sinter key1 key2:</strong> key1和key2的==交集==</p><p><strong>sunion key1 key2</strong>：key1和key2的==并集==</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; sadd key1 1(integer) 1127.0.0.1:6379&gt; sadd key1 2(integer) 1127.0.0.1:6379&gt; sadd key1 3(integer) 1127.0.0.1:6379&gt; sadd key2 3(integer) 1127.0.0.1:6379&gt; sadd key2 4(integer) 1127.0.0.1:6379&gt; sadd key2 5(integer) 1127.0.0.1:6379&gt; SDIFF key1 key2# 差集1) &quot;1&quot;2) &quot;2&quot;127.0.0.1:6379&gt; SINTER key1 key2# 交集（共同好友）1) &quot;3&quot;127.0.0.1:6379&gt; SUNION key1 key2# 并集1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;5) &quot;5&quot;127.0.0.1:6379&gt; </code></pre></div><p>微博，A用户将所有关注的人放在一个set集合中，将它的粉丝也放在一个集合中</p><p>共同关注，共同爱好，推荐好友</p><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Map集合，key-Map集合，key-<key-value></key-value></p><p>hset myhash field1 hello:</p><p>hget</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hset myhash field1 hello(integer) 1127.0.0.1:6379&gt; hget myhash field1&quot;hello&quot;127.0.0.1:6379&gt;</code></pre></div><p><strong>hmset</strong>:一次存多个值，如果重复会自动覆盖（redis4.0后已被官方弃用，建议使用hset）</p><p><strong>hmget</strong>:一次取多个值</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hmset myhash field1 hello field2 worldOK127.0.0.1:6379&gt; hmget myhash field1 field21) &quot;hello&quot;2) &quot;world&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>hgetall</strong>：获取hash中所有的键值对 </p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hgetall myhash1) &quot;field1&quot;2) &quot;hello&quot;3) &quot;field2&quot;4) &quot;world&quot;</code></pre></div><p><strong>hdel myhash field1</strong>：删除myhash 中的field1，即删除hash中指定的key，对应的value值也被删除</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hdel myhash field1(integer) 1127.0.0.1:6379&gt; HGETALL myhash1) &quot;field2&quot;2) &quot;world&quot;127.0.0.1:6379&gt;</code></pre></div><p><strong>hlen myhash：</strong>查看myhash中key的个数</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hgetall myhash1) &quot;field2&quot;2) &quot;world&quot;3) &quot;field1&quot;4) &quot;hello&quot;127.0.0.1:6379&gt; hlen myhash(integer) 2127.0.0.1:6379&gt; </code></pre></div><p><strong>hexists</strong>：判断hash中的某一个字段是否存在</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hexists myhash field1(integer) 1127.0.0.1:6379&gt; hexists myhash field3(integer) 0127.0.0.1:6379&gt; </code></pre></div><p><strong>hkeys myhash：</strong>获取myhash中所有的key</p><p><strong>hvals myhash：</strong>获取myhash中所有的value</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hkeys myhash1) &quot;field2&quot;2) &quot;field1&quot;127.0.0.1:6379&gt; hvals myhash1) &quot;world&quot;2) &quot;hello&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>hincrby：</strong>自增</p><p><strong>hsetnx：</strong>判断是否存在，如果存在则不创建，不存在则新建</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; hset myhash field3 5(integer) 1127.0.0.1:6379&gt; hincrby myhash field3 1# 自增1(integer) 6127.0.0.1:6379&gt; hincrby myhash field3 -1(integer) 5127.0.0.1:6379&gt; hsetnx myhash field4 hello# field4不存在，新建(integer) 1127.0.0.1:6379&gt; HGETALL myhash1) &quot;field2&quot;2) &quot;world&quot;3) &quot;field1&quot;4) &quot;hello&quot;5) &quot;field3&quot;6) &quot;5&quot;7) &quot;field4&quot;8) &quot;hello&quot;127.0.0.1:6379&gt; hsetnx myhash field4 hello# field4已经存在，创建失败(integer) 0127.0.0.1:6379&gt; </code></pre></div><p>hash变更的数据 user name age ，尤其是用户信息之类的，经常变动的信息。hash更适合对象的存储，String更加适合字符串。 </p><h2 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h2><p>在set的基础上，增加了一个值，set k1 v1 ，zset k1 score1 v1</p><p><strong>zadd</strong>:添加</p><p><strong>zrange</strong>:查看</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; zadd zset 1 one(integer) 1127.0.0.1:6379&gt; zadd zset 2 two(integer) 1127.0.0.1:6379&gt; zadd zset 3 three(integer) 1127.0.0.1:6379&gt; ZRANGE zset 0 -11) &quot;one&quot;2) &quot;two&quot;3) &quot;three&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>zrangebyscore：</strong>通过score排序</p><p><strong>zrevrange</strong>:降序</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; zadd salary 2500 xiaohong(integer) 1127.0.0.1:6379&gt; zadd salary 5000 zhangsan(integer) 1127.0.0.1:6379&gt; zadd salary 200 Ten(integer) 1127.0.0.1:6379&gt; zrangebyscore salary -inf +inf# 显示所有用户，从小到大排序，不带score排序1) &quot;Ten&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores# 带有score排序1) &quot;Ten&quot;2) &quot;200&quot;3) &quot;xiaohong&quot;4) &quot;2500&quot;5) &quot;zhangsan&quot;6) &quot;5000&quot;127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;Ten&quot;2) &quot;zhangsan&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1# 降序，从高到底1) &quot;zhangsan&quot;2) &quot;Ten&quot;127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores1) &quot;zhangsan&quot;2) &quot;5000&quot;3) &quot;Ten&quot;4) &quot;200&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>zrem：</strong>移除元素</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;Ten&quot;2) &quot;xiaohong&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; zrem salary xiaohong(integer) 1127.0.0.1:6379&gt; ZRANGE salary 0 -11) &quot;Ten&quot;2) &quot;zhangsan&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>zcard</strong>:获取有序集合中的个数</p><p><strong>zcount</strong>：获取指范围之间的个数</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; zadd myzset 1 hello 2 world 3 Ten(integer) 3127.0.0.1:6379&gt; zcount myzset 1 3(integer) 3127.0.0.1:6379&gt; zcount myzset 1 2(integer) 2127.0.0.1:6379&gt; zcount myzset 0 1(integer) 1127.0.0.1:6379&gt; zcount myzset 0 2(integer) 2127.0.0.1:6379&gt; </code></pre></div><p>案例思路：set 排序，存储班级成绩表，工资表排序</p><p>普通消息 1 ，重要消息 2 ，带权重进行判断！</p><p>排行榜应用实现，取Top N测试。</p><h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="geospatail-地理位置"><a href="#geospatail-地理位置" class="headerlink" title="geospatail 地理位置"></a>geospatail 地理位置</h2><p>朋友的定位，附近的人，打车的距离计算</p><p>redis的geo在redis3.2版本就推出了。这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人。</p><p><strong>geoadd</strong>：添加地址位置</p><p>规则：两极无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入</p><p>有效的经度从-180度到180度</p><p>有效的纬度从-85.05112878到85.05112878度</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing(integer) 1127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai(integer) 1127.0.0.1:6379&gt; geoadd china:city 106.20 29.53 chongqin 114.05 22.52 shengzhen(integer) 2127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian(integer) 2127.0.0.1:6379&gt; </code></pre></div><p><strong>geopos</strong>：获取位置信息</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; geopos china:city beijing1) 1) &quot;116.39999896287918091&quot;   2) &quot;39.90000009167092543&quot;127.0.0.1:6379&gt; geopos china:city chongqin1) 1) &quot;106.19999796152114868&quot;   2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>geodist</strong>：</p><p>两人之间的距离</p><p>单位：</p><ul><li><strong>m</strong>表示单位为米</li><li><strong>km</strong>表示单位为千米</li><li><strong>mi</strong>表示单位为英里</li><li><strong>ft</strong>表示单位为英尺</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai&quot;1067378.7564&quot;127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km&quot;1067.3788&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>georedius</strong>：以给定的经纬度为中心，找出某一半径的元素</p><p>附近的人？（获得所有附近的地址，定位！）通过半径来查询。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">27.0.0.1:6379&gt; GEORADIUS china:city 110 30 100000 km # 以110，30 这个经纬度为中心，寻找方圆1000km内的城市1) &quot;chongqin&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing127.0.0.1:6379&gt; GEORADIUS china:city 110 30 1000 km1) &quot;chongqin&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist# 带有直线距离1) 1) &quot;chongqin&quot;   2) &quot;370.5852&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withcoord# 带有经纬度1) 1) &quot;chongqin&quot;   2) 1) &quot;106.19999796152114868&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; </code></pre></div><p>获得指定的个数</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 11) 1) &quot;chongqin&quot;   2) &quot;370.5852&quot;   3) 1) &quot;106.19999796152114868&quot;      2) &quot;29.52999957900659211&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 21) 1) &quot;chongqin&quot;   2) &quot;370.5852&quot;   3) 1) &quot;106.19999796152114868&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;   3) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; GEORADIUS china:city 110 30 500 km withdist withcoord count 31) 1) &quot;chongqin&quot;   2) &quot;370.5852&quot;   3) 1) &quot;106.19999796152114868&quot;      2) &quot;29.52999957900659211&quot;2) 1) &quot;xian&quot;   2) &quot;483.8340&quot;   3) 1) &quot;108.96000176668167114&quot;      2) &quot;34.25999964418929977&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>georediusbymember</strong>：以某个城市为中心，搜索方圆1000km的地方</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km1) &quot;beijing&quot;2) &quot;xian&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>geohash</strong>：返回一个或多个位置元素的geohash字符串,将二维的经纬度转换为一维的字符串</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; geohash china:city beijing chongqin1) &quot;wx4fbxxfke0&quot;2) &quot;wm5xbxu2xq0&quot;127.0.0.1:6379&gt; </code></pre></div><p><strong>geo 底层的实现原是Zset ，我们可以使用Zset命名来操作</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;chongqin&quot;2) &quot;xian&quot;3) &quot;shengzhen&quot;4) &quot;hangzhou&quot;5) &quot;shanghai&quot;6) &quot;beijing&quot;127.0.0.1:6379&gt; zrem china:city chongqin(integer) 1127.0.0.1:6379&gt; zrange china:city 0 -11) &quot;xian&quot;2) &quot;shengzhen&quot;3) &quot;hangzhou&quot;4) &quot;shanghai&quot;5) &quot;beijing&quot;127.0.0.1:6379&gt; </code></pre></div><h2 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h2><p><strong>什么是基数？</strong>一个集合中的元素不重复元素的数量</p><p>A{1,3,5,7,8,7}</p><p>B{1,3,5,7,8}</p><p>基数（不重复的元素） = 5个 ，可以接收误差！</p><p><strong>简介</strong></p><p>redis 2.8.9版本就更新了Hyperloglog 数据结构！</p><p>Redis Hyperloglog 基数统计的算法！</p><p>优点：占用的内存是固定的，2^64不同的元素的技术，只需要12kb内存！如果要从内存角度来比较的话Hyperloglog首选</p><p><strong>网页的UV（一个人访问一个网站多次，但是还是算作一个人）</strong></p><p>传统的方式，set保存用户的id，然后就可以统计set中的元素数量作为标准判断！</p><p>这个方式如果保存大量的用户id，就会比较麻烦，我们的目的是为计数，而不是保存用户id。</p><p><strong>pfadd</strong>：添加</p><p><strong>pfcount：</strong>统计个数</p><p><strong>pfmerge</strong>：将两个集合合并，去除重复的</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; pfadd mykey a b c d e f g h i j(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey(integer) 10127.0.0.1:6379&gt; pfadd mykey2 i j z x c v b n m(integer) 1127.0.0.1:6379&gt; PFCOUNT mykey2(integer) 9127.0.0.1:6379&gt; PFMERGE mykey3 mykey mykey2OK127.0.0.1:6379&gt; PFCOUNT mykey3(integer) 15127.0.0.1:6379&gt; </code></pre></div><p>如果允许容错，那么一定可以使用Hyperloglog。</p><p>如果不允许容错，就使用set或者自己的数据类型即可。</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p><strong>位存储</strong></p><p>统计用户信息，活跃，不活跃！登录、未登录！打卡，两个状态的，都可以使用Bitmap！</p><p>Bitmap位图，数据结构！都是操作二进制位来进行记录，就是只有0和1两个状态！</p><p><strong>setbit</strong>：存</p><p><strong>getbit</strong>：取</p><p><strong>bitcount</strong>:统计打卡天数</p><p>记录一周是否打卡，0未打卡，1已打卡</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; setbit sign 0 1(integer) 0127.0.0.1:6379&gt; setbit sign 1 0(integer) 0127.0.0.1:6379&gt; setbit sign 2 0(integer) 0127.0.0.1:6379&gt; setbit sign 3 1(integer) 0127.0.0.1:6379&gt; setbit sign 4 1(integer) 0127.0.0.1:6379&gt; setbit sign 5 1(integer) 0127.0.0.1:6379&gt; setbit sign 6 0(integer) 0127.0.0.1:6379&gt; getbit sign 4(integer) 1127.0.0.1:6379&gt; getbit sign 6(integer) 0127.0.0.1:6379&gt; BITCOUNT sign (integer) 4127.0.0.1:6379&gt; </code></pre></div><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>redis事务本质：一组命令的集合！一个事务中所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><p>一次性、顺序性、排他性！执行一些列的命令。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">---- 队列 set set set set 执行 ----</code></pre></div><p>==redis事务没有隔离级别的概念==</p><p>所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行！Exec</p><p>==redis单条命名是保证原子性的，但是事务不保证原子性==</p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（…）</li><li>执行事务（exec）</li></ul><p><strong>正常执行事务：</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; multi# 开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1# 命令QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; exec# 执行事务1) OK2) OK3) &quot;v2&quot;4) OK127.0.0.1:6379&gt;</code></pre></div><p><strong>放弃事务：</strong>discard</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; DISCARD# 放弃事务OK127.0.0.1:6379&gt; get k4# 事务没有被执行到，所以找不到(nil)127.0.0.1:6379&gt; </code></pre></div><p><strong>编译型异常</strong>（代码有问题！命令有错），事务中所有的命令都不会被执行</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; set k1 v1QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; getset k3(error) ERR wrong number of arguments for &#39;getset&#39; command127.0.0.1:6379(TX)&gt; set k4 v4QUEUED127.0.0.1:6379(TX)&gt; exec(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k4(nil)127.0.0.1:6379&gt; </code></pre></div><p><strong>运行时异常</strong>（1/0），如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; incr k1# 让字符串加一，语法没问题，但是实际结果会报错QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; get k3QUEUED127.0.0.1:6379(TX)&gt; exec1) (error) ERR value is not an integer or out of range2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; </code></pre></div><h1 id="监控-Watch（面试常问）"><a href="#监控-Watch（面试常问）" class="headerlink" title="监控 Watch（面试常问）"></a>监控 Watch（面试常问）</h1><p><strong>悲观锁</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁。</li></ul><p><strong>乐观锁</strong>：</p><ul><li>很乐观，认为什么时候都不会出问题，所以不上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p><strong>redis监视测试</strong></p><p>正常执行成功</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money# 监视moneyOK127.0.0.1:6379&gt; multi# 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功OK127.0.0.1:6379(TX)&gt; DECRBY money 20QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 20QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 802) (integer) 20127.0.0.1:6379&gt; </code></pre></div><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作！</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; watch money# 监视 moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; DECRBY money 10QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10# 执行到这一行的时候，突然下面的线程二将money的值改变了QUEUED127.0.0.1:6379(TX)&gt; exec# 执行失败，因为money加了watch乐观锁(nil)127.0.0.1:6379&gt; </code></pre></div><p>线程二：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; get money&quot;80&quot;127.0.0.1:6379&gt; set money 1000OK127.0.0.1:6379&gt; </code></pre></div><p>如何解决？</p><p>先解锁，再去做其他的操作（事务执行结束之后，redis会自动解锁）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; unwatch# 解锁OK127.0.0.1:6379&gt; watch money# 获取最新的值，再次加监视OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; DECRBY money 1QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 1QUEUED127.0.0.1:6379(TX)&gt; exec# 对比监视的值是否发生了变化，如果没有，则执行成功1) (integer) 992) (integer) 1</code></pre></div><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用java来操作redis</p><p>什么是Jedis？ 是redis官方推荐的java连接开发工具！使用java操作redis的<strong>中间件</strong>！如果你要使用java操作redis，那么一定要对Jedis十分熟悉。</p><p><strong>常用的API</strong></p><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><p>所有的API命令，就是我们对应的上面学习的命令，一个都没有变化！</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;redis.clients&#x2F;jedis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.0.0-beta2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;fastjson --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.2.78&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestTX &#123;    public static void main(String[] args) &#123;        Jedis jedis &#x3D; new Jedis(&quot;192.168.242.3&quot;, 6379);        jedis.auth(&quot;123456&quot;);        JSONObject jsonObject &#x3D; new JSONObject();        jsonObject.put(&quot;hello&quot;,&quot;world&quot;);        jsonObject.put(&quot;name&quot;,&quot;Ten&quot;);        &#x2F;&#x2F; 开启事务        Transaction multi &#x3D; jedis.multi();        String result &#x3D; jsonObject.toJSONString();        try &#123;            multi.set(&quot;user1&quot;,result);            multi.set(&quot;user2&quot;,result);            multi.exec();        &#125; catch (Exception e) &#123;            &#x2F;&#x2F; 放弃事务            multi.discard();            e.printStackTrace();            System.out.println(jedis.get(&quot;user1&quot;));            System.out.println(jedis.get(&quot;user2&quot;));        &#125; finally &#123;            jedis.close();        &#125;    &#125;&#125;</code></pre></div><h1 id="SpringBoot-整合"><a href="#SpringBoot-整合" class="headerlink" title="SpringBoot 整合"></a>SpringBoot 整合</h1><p>SpringBoot操作数据：spring-data ,jpa,jdbc,mongodb,redis!</p><p>SpringData 也就是和SpringBoot齐名的项目</p><p>说明：在SpringBoot2.x之后，原来使用的jedis被替换为了lettuce。</p><p>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool 连接池！BIO</p><p>lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据了。更像NIO模式</p><p>源码分析：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Bean @ConditionalOnMissingBean(&#x2F;&#x2F; 我们可以自己定义一个redisTemplate来替换这个默认的     name &#x3D; &#123;&quot;redisTemplate&quot;&#125; ) @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;     &#x2F;&#x2F; 默认的RedisTemplate没有过多的设置，redis对象都是需要序列化     &#x2F;&#x2F; 两个泛型都是Object, Object 的类型，我们后面使用需要强制转换&lt;String , Object&gt;     RedisTemplate&lt;Object, Object&gt; template &#x3D; new RedisTemplate();     template.setConnectionFactory(redisConnectionFactory);     return template; &#125; @Bean @ConditionalOnMissingBean &#x2F;&#x2F; 由于String是redis中最常用的使用类型，所以也单独提出来了一个bean @ConditionalOnSingleCandidate(RedisConnectionFactory.class) public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;     StringRedisTemplate template &#x3D; new StringRedisTemplate();     template.setConnectionFactory(redisConnectionFactory);     return template; &#125;</code></pre></div><ol><li><p>导入依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.5.6&lt;&#x2F;version&gt;        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;    &lt;&#x2F;parent&gt;    &lt;groupId&gt;com.ten&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;02-redis-springboot&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;name&gt;02-redis-springboot&lt;&#x2F;name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;    &lt;&#x2F;properties&gt;    &lt;dependencies&gt;        &lt;!-- redis整合SpringBoot --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;            &lt;optional&gt;true&lt;&#x2F;optional&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;            &lt;optional&gt;true&lt;&#x2F;optional&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;            &lt;optional&gt;true&lt;&#x2F;optional&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;                            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;                        &lt;&#x2F;exclude&gt;                    &lt;&#x2F;excludes&gt;                &lt;&#x2F;configuration&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;&lt;&#x2F;project&gt;</code></pre></div></li><li><p>配置</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 配置redisspring.redis.host&#x3D;192.168.242.3spring.redis.port&#x3D;6379spring.redis.password&#x3D;123456# redis设置了密码的需加这一行配置</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass ApplicationTests &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    void contextLoads() &#123;        &#x2F;&#x2F; opsForValue 操作字符串 类似String        &#x2F;&#x2F; opsForList 操作list 类似list        &#x2F;&#x2F; redisTemplate.opsForList();        &#x2F;&#x2F; 除了基本的操作，我们常用的方法都可以直接通过RedisTemplate操作，比如事务，和基本的CRUD        &#x2F;&#x2F; 获取redis的连接对象        &#x2F;&#x2F; RedisConnection connection &#x3D; redisTemplate.getConnectionFactory().getConnection();        &#x2F;&#x2F; connection.flushDb();        redisTemplate.opsForValue().set(&quot;mykey&quot;,&quot;hello,world&quot;);        System.out.println(redisTemplate.opsForValue().get(&quot;mykey&quot;));    &#125;&#125;</code></pre></div><p>关于数据的保存</p></li></ol><p><img src="/myBlog/Redis/image-20211109161652248-1636731414340.png" alt="image-20211109161652248"></p><p>编写自己序列化配置类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfig &#123;    &#x2F;&#x2F; 编写我们自己的配置类    @Bean    @SuppressWarnings(&quot;all&quot;)    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        &#x2F;&#x2F; 我们为了自己开发方便，一般直接使用&lt;String, Object&gt;        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;String, Object&gt; ();        template.setConnectionFactory(redisConnectionFactory);        &#x2F;&#x2F; json序列化配置        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper om &#x3D; new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        &#x2F;&#x2F; String序列化        StringRedisSerializer stringRedisSerializer &#x3D; new StringRedisSerializer();        &#x2F;&#x2F; key采用string的序列化方式        template.setKeySerializer(stringRedisSerializer);        &#x2F;&#x2F; hash的key也采用String的序列化方式        template.setHashKeySerializer(stringRedisSerializer);        &#x2F;&#x2F; value序列化方式采用Jackson        template.setValueSerializer(jackson2JsonRedisSerializer);        &#x2F;&#x2F; hash的value序列化方式采用jackson        template.setHashKeySerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;&#125;</code></pre></div><p>实际开发，为了方便，可以将这些方法抽取成工具类。（网上搜索RedisUtils有很多，具体结合实际项目）</p><p>思路：</p><ol><li>导入依赖</li><li>编写配置文件</li><li>测试</li><li>根据实际要求，编写自己需要的序列化配置文件</li><li>将redis中的方法抽取出来，做成工具类，以便后期开发使用。</li></ol><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><ol><li><p>配置文件unit单位对大小写不敏感。</p><p><img src="/myBlog/Redis/image-20211109193951137-1636731414341.png" alt="image-20211109193951137"></p></li><li><p>包含，就好比我们学习Spring、import，include</p><p><img src="/myBlog/Redis/image-20211109194709896-1636731414341.png" alt="image-20211109194709896"></p></li><li><p>网络</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bind 127.0.0.1 -::1# 绑定的ipprotected-mode yes# 保护模式port 6379# 端口设置</code></pre></div></li><li><p>通用GENERAL</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">daemonize yes# 以守护进程的方式运行（后台运行），默认是no，需要修改为yespidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid# 如果以后台的方式运行，我们就需要指定一个pid文件# 日志# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for development&#x2F;testing)# verbose (many rarely useful info, but not a mess like the debug level)# notice (moderately verbose, what you want in production probably)生产环境# warning (only very important &#x2F; critical messages are logged)loglevel noticelogfile &quot;&quot;# 日志生成的文件位置名，如果为空，则为默认的位置输出databases 16# 默认数据库数量为16个always-show-logo no# 是否总是显示logo（开启服务时，数据库的logo）</code></pre></div></li><li><p>快照</p><p>持久化，在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb .aof</p><p>redis是内存数据库，如果没有持久化，那么数据断点就会丢失！</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save 3600 1# 如果900秒内，至少有1个key进行了修改，我们就进行持久化操作save 300 100# 如果300秒内，至少有100个key进行了修改，我们就进行持久化操作save 60 10000# 如果60秒内，至少有10000个key进行了修改，我们就进行持久化操作# 我们后面学习持久化，会自己定义这个测试stop-writes-on-bgsave-error yes# 当bgsave快照操作出错时停止写数据到磁盘rdbcompression yes# 是否压缩rdb文件，需要消耗一些cpu资源rdbchecksum yes# 保存rdb文件的时候，进行错误的检查校验dir .&#x2F;# rdb持久化保存文件的目录</code></pre></div></li><li><p>REPLICATION 复制，我们后面讲解主从复制的时候再讲解</p></li><li><p>SECURITY 安全</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">config set requirepass &quot;123456&quot;# 设置redis密码config get requirepass# 获得密码auth 123456# 使用密码登录认证</code></pre></div></li><li><p>限制CLIENTS</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">maxclients 10000# 设置能连接上redis的客户端的最大数量maxmemory &lt;bytes&gt;# redis 配置最大的内存容量maxmemory-policy noeviction# 内存到达上限之后的处理策略1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key   3、volatile-random：随机删除即将过期key   4、allkeys-random：随机删除   5、volatile-ttl ： 删除即将过期的   6、noeviction ： 永不过期，返回错误</code></pre></div></li><li><p>APPEND ONLY 模式 aof配置</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no# 默认是不开启aof模式的，默认使用rdb方式持久化的，在大部分情况下，rdb够用了appendfilename &quot;appendonly.aof&quot; # 持久化文件的名字# appendfsync always# 每次修改都会sync。消耗性能appendfsync everysec# 每秒执行一次 sync ，可能会丢失这1s的数据！# appendfsync no# 不执行sync，这个时候操作系统自己同步数据，速度最快</code></pre></div></li></ol><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>面试和工作，持久化都是重点！</p><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能！</p><h2 id="RDB（RedisDataBase）"><a href="#RDB（RedisDataBase）" class="headerlink" title="RDB（RedisDataBase）"></a>RDB（RedisDataBase）</h2><p>什么是RDB？ </p><p><img src="/myBlog/Redis/image-20211110111343837-1636731446157.png" alt="image-20211110111343837"></p><p>在指定的时间间隔内将内存中的数据极快写入磁盘，也就是行话说Snapshot快照，他恢复时是将快照文件直接读到内存里。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常灵敏，那RDB方法要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能会丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p><p>==rdb保存的文件是dump.rdb==,都是在配置文件中的快照选项中配置的。</p><p><img src="/myBlog/Redis/image-20211110115128561-1636731446157.png" alt="image-20211110115128561"></p><p><strong>触发机制</strong></p><ol><li>save的规则满足的情况下，会自动触发rdb规则</li><li>执行flushall命令，也会触发我们的rdb规则</li><li>退出redis，也会产生rdb文件 </li></ol><p>备份完就自动生成一个dump.rdb</p><p><strong>如何恢复rdb文件</strong></p><ol><li><p>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据。</p></li><li><p>查看需要存放的位置</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;&#x2F;usr&#x2F;local&#x2F;bin&quot;# 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据。127.0.0.1:6379&gt; </code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly no# 默认是不开启aof模式的，默认使用rdb方式持久化的，在大部分情况下，rdb够用了appendfilename &quot;appendonly.aof&quot; # 持久化文件的名字# appendfsync always# 每次修改都会sync。消耗性能appendfsync everysec# 每秒执行一次 sync ，可能会丢失这1s的数据！# appendfsync no# 不执行sync，这个时候操作系统自己同步数据，速度最快</code></pre></div></li></ol><p><strong>重写规则说明</strong></p><p>aof默认的是无限追加，文件会越来远大。</p><p><img src="/myBlog/Redis/image-20211110125255401-1636731446158.png" alt="image-20211110125255401"></p><p><img src="/myBlog/Redis/image-20211110125322034-1636731446158.png" alt="image-20211110125322034"></p><p>如果aof文件大于64m，将fork一个新的进程来将我们的文件进行重写。</p><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复！dump.rdb</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作。如果redis意外宕机了，这个最后的一次修改数据就没了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍。</p><p>以日志形式来记录每个写操作，将redis执行过的执行记录下来（读操作不记录），只 许追加文件不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p>aof保存的是appendonly.aof 文件</p><p><strong>append</strong></p><p><img src="/myBlog/Redis/image-20211110122837901-1636731446158.png" alt="image-20211110122837901"></p><p>默认是不开启的，我们需要手动进行配置。我们只需要将appendonly改为yes就可以开启aof了</p><p>重启，redis就可以生效了。</p><p><img src="/myBlog/Redis/image-20211110123055770-1636731446158.png" alt="image-20211110123055770"></p><p>如果这个aof文件有错误，这时候redis是启动不起来的，我们需要修复这个aof文件，redis给我们提供了这样一个工具<code>redis-check-aof</code> （删掉错误的代码）</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># redis-check-aof --fix appendonly.aof[root@localhost bin]# .&#x2F;redis-check-aof --fix appendonly.aof 0x              87: Expected \r\n, got: 6661AOF analyzed: size&#x3D;153, ok_up_to&#x3D;110, ok_up_to_line&#x3D;33, diff&#x3D;43This will shrink the AOF from 153 bytes, with 43 bytes, to 110 bytesContinue? [y&#x2F;N]: ySuccessfully truncated AOF[root@localhost bin]# </code></pre></div><p>如果文件正常了，启动redis就可以恢复了。</p><p>优点：</p><ol><li>每次修改都会同步，文件的完整会更加好！</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高。</li></ol><p>缺点：</p><ol><li>相对于数据文件来说，aof远远大于rdb，修复的速度也被rdb慢。</li><li>aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化！</li></ol><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis发布订阅（pub/sub)是一种==消息通信模式==：发送者(pub)发送消息，订阅者(sub)接收消息。微信、微博、关注系统。</p><p>Redis客户端可以订阅任意数量的频道</p><p>订阅/发布消息图：</p><p>第一个：消息发送者，第二个：频道，第三个：消息订阅者</p><p><img src="/myBlog/Redis/image-20211110141642042-1636731446158.png" alt="image-20211110141642042"></p><p>下图展示了频道channel1，以及订阅这个频道的三个客户端——client2、client5、client1之间的关系：</p><p><img src="/myBlog/Redis/image-20211110142031866-1636731446158.png" alt="image-20211110142031866"></p><p>当有新消息通过publish命令发送到频道channel1时，这个消息会被发送给订阅他的三个客户端：</p><p><img src="/myBlog/Redis/image-20211110142125541-1636731446169.png" alt="image-20211110142125541"></p><p><strong>命令</strong></p><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室（chatroom)和实时广播、实时提醒等。</p><p><img src="/myBlog/Redis/image-20211110142435094-1636731446169.png" alt="image-20211110142435094"></p><p><strong>测试</strong></p><p>先订阅一个频道Ten</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; SUBSCRIBE TenReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;Ten&quot;3) (integer) 1</code></pre></div><p>再开一个进程，发布消息</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; PUBLISH Ten &quot;hello Ten&quot;(integer) 1127.0.0.1:6379&gt; </code></pre></div><p>最后频道这么就会自动更新内容</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; SUBSCRIBE TenReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;Ten&quot;3) (integer) 11) &quot;message&quot;2) &quot;Ten&quot;3) &quot;hello Ten&quot;</code></pre></div><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>主从复制,是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；==数据的复制是单向的，只能由主节点到从节点==。Master以写为主 ，Slave以读为主。</p><p>==默认情况下，每台Redis服务器都是主节点==；且一个主节点可以有多个从节点(或没有从节点) ，但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li><p>数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。</p></li><li><p>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</p></li><li><p>负载均衡：在主从复制的基础，上配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接</p><p>主节点，读Redis数据时应用连接从节点) ， 分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大</p><p>大提高Redis服务器的并发量。</p></li><li><p>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p></li></ol><p>一般来说,要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G ，也不能将所有内存用作Redis存储内存，一般来说，==单台Redis最大使用内存不应该超过20G==。</li></ol><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p><p>对于这种场景我们可以使如下这种架构 ：</p><p><img src="/myBlog/Redis/image-20211110160627503-1636731465018.png" alt="image-20211110160627503"></p><p>主从复制，读写分离！80%的情况下都是在进行读操作！减缓服务器的压力。架构中经常使用。一主二从。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>只配置从库，不用配置主库。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; info replication# 查看当前库的信息# Replicationrole:master# 角色masterconnected_slaves:0# 没有从机master_failover_state:no-failovermaster_replid:c24b4990216f9f43edd239880dd084fb611f24d6master_replid2:0000000000000000000000000000000000000000master_repl_offset:0second_repl_offset:-1repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0127.0.0.1:6379&gt; </code></pre></div><p>复制三个文件，修改对应的信息</p><ol><li>端口</li><li>pid名字</li><li>log文件名字</li><li>dump.rdb名字</li></ol><p><img src="/myBlog/Redis/image-20211110164938440-1636731465018.png" alt="image-20211110164938440"></p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p>==默认情况下，每台Redis服务器都是主节点==；我们一般情况下只用配置从机就好了</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">slaveof 127.0.0.1 6379# 找主机</code></pre></div><p>主机有密码的，在从机的配置文件conf里加上：masterpass 密码</p><p>主机</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;56,lag&#x3D;1slave1:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;56,lag&#x3D;0master_failover_state:no-failovermaster_replid:9a9b9c66882dedab9eeacbc42faaea7da17252c5master_replid2:0000000000000000000000000000000000000000master_repl_offset:56second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:56127.0.0.1:6379&gt; </code></pre></div><p>从机</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6380&gt; info replication# Replicationrole:slavemaster_host:127.0.0.1master_port:6379master_link_status:upmaster_last_io_seconds_ago:10master_sync_in_progress:0slave_read_repl_offset:28slave_repl_offset:28slave_priority:100slave_read_only:1replica_announced:1connected_slaves:0master_failover_state:no-failovermaster_replid:9a9b9c66882dedab9eeacbc42faaea7da17252c5master_replid2:0000000000000000000000000000000000000000master_repl_offset:28second_repl_offset:-1repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:1repl_backlog_histlen:28127.0.0.1:6380&gt; </code></pre></div><p><strong>细节</strong></p><p>主机可以写，从机不可以写，只能读！主机中的所有信息和数据，都会自动被从机保存。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; </code></pre></div><p>从机只读</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6380&gt; keys *1) &quot;k1&quot;127.0.0.1:6380&gt; get k1&quot;v1&quot;127.0.0.1:6380&gt; set k2 v2(error) READONLY You can&#39;t write against a read only replica.127.0.0.1:6380&gt;</code></pre></div><p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作了，这个时候，主机如果回来了依旧可以获取到主机写的信息！</p><p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变成主机！只要变为从机，立马就会从主机中获取值！</p><p><strong>复制原理</strong></p><p>Slave启动成功连接到master后会发送一个sync命令</p><p>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步==。</p><p>==全量复制==：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p>==增量复制==：Master继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行。</p><p><strong>层层链路</strong></p><p>上一个M链接下一个S,也可以完成主从复制。</p><p><img src="/myBlog/Redis/image-20211110193759690-1636731465019.png" alt="image-20211110193759690"></p><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>手动变成主机。其他节点就可以手动连接到这个最新的主机 </p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>（自动选举主机的模式）</p><p><strong>概述</strong></p><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是推荐的方式，更多的时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵）架构来解决这个问题。</p><p>自动版，能够后台监控主机是否故障，如果故障了根据投票数==自动将从库转换为主库==。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p><img src="/myBlog/Redis/image-20211110200036007-1636731465018.png" alt="image-20211110200036007"></p><p>这里的哨兵的两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵检测到了master宕机，会自动将slave切换成master，然后通过==发布订阅模式==通知其他的从服务器，修改配置文件，让它们切换主机</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还回进行监控，这样就行程了多哨兵的模式。</p><p><img src="/myBlog/Redis/image-20211110202645563-1636731465019.png" alt="image-20211110202645563"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover（故障转移）操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><p><strong>测试</strong></p><ol><li><p>配置哨兵配置文件sentinel.config</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sentinel monitor 被监视的名称 host port 1sentinel monitor myredis 127.0.0.1 6379 1</code></pre></div><p>后面的1，代表主机挂了之后，slave投票看让谁接替成为主机。</p></li><li><p>启动</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost bin]# .&#x2F;redis-sentinel .&#x2F;myredisconf&#x2F;sentinel.conf# 启动</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost bin]# .&#x2F;redis-sentinel .&#x2F;myredisconf&#x2F;sentinel.conf 8463:X 10 Nov 2021 20:38:26.820 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo8463:X 10 Nov 2021 20:38:26.820 # Redis version&#x3D;6.2.6, bits&#x3D;64, commit&#x3D;00000000, modified&#x3D;0, pid&#x3D;8463, just started8463:X 10 Nov 2021 20:38:26.820 # Configuration loaded8463:X 10 Nov 2021 20:38:26.821 * Increased maximum number of open files to 10032 (it was originally set to 1024).8463:X 10 Nov 2021 20:38:26.821 * monotonic clock: POSIX clock_gettime                _._                                                             _.-&#96;&#96;__ &#39;&#39;-._                                                   _.-&#96;&#96;    &#96;.  &#96;_.  &#39;&#39;-._           Redis 6.2.6 (00000000&#x2F;0) 64 bit  .-&#96;&#96; .-&#96;&#96;&#96;.  &#96;&#96;&#96;\&#x2F;    _.,_ &#39;&#39;-._                                   (    &#39;      ,       .-&#96;  | &#96;,    )     Running in sentinel mode |&#96;-._&#96;-...-&#96; __...-.&#96;&#96;-._|&#39;&#96; _.-&#39;|     Port: 26379 |    &#96;-._   &#96;._    &#x2F;     _.-&#39;    |     PID: 8463  &#96;-._    &#96;-._  &#96;-.&#x2F;  _.-&#39;    _.-&#39;                                    |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                   |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |           https:&#x2F;&#x2F;redis.io         &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                    |&#96;-._&#96;-._    &#96;-.__.-&#39;    _.-&#39;_.-&#39;|                                   |    &#96;-._&#96;-._        _.-&#39;_.-&#39;    |                                    &#96;-._    &#96;-._&#96;-.__.-&#39;_.-&#39;    _.-&#39;                                         &#96;-._    &#96;-.__.-&#39;    _.-&#39;                                                 &#96;-._        _.-&#39;                                                         &#96;-.__.-&#39;                                               8463:X 10 Nov 2021 20:38:26.822 # WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.8463:X 10 Nov 2021 20:38:26.837 # Sentinel ID is bd3c3a2017d9d9c4ee03c810ae071661cd4be1d78463:X 10 Nov 2021 20:38:26.837 # +monitor master myredis 127.0.0.1 6379 quorum 18463:X 10 Nov 2021 20:38:26.838 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 63798463:X 10 Nov 2021 20:39:37.137 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379</code></pre></div><p>如果主机挂了，哨兵会自动投票选举出新的主机。</p><p>哨兵日志</p><p><img src="/myBlog/Redis/image-20211110204544847-1636731465019.png" alt="image-20211110204544847"></p></li></ol><p>如果主机再次恢复过来，也只能是归并到新的主机下，当做从机，这就是哨兵模式的规则。</p><p><strong>哨兵模式</strong></p><p>优点：</p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，他全有。</li><li>主从可以切换，故障可以转移，系统的可用性就会更好。</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮。</li></ol><p>缺点：</p><ol><li>Redis不好在线扩容，集群容量一旦到达上限，在线扩容级十分麻烦。</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择。</li></ol><p><strong>哨兵模式的全部配置</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Example sentinel.conf    # 哨兵sentinel实例运行的端口 默认26379  port 26379    # 哨兵sentinel的工作目录  dir &#x2F;tmp    # 哨兵sentinel监控的redis主节点的 ip port   # master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。  # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了  # sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;    sentinel monitor mymaster 127.0.0.1 6379 2    # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码  # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码  # sentinel auth-pass &lt;master-name&gt; &lt;password&gt;  sentinel auth-pass mymaster MySUPER--secret-0123passw0rd      # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒  # sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;  sentinel down-after-milliseconds mymaster 30000    # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，  这个数字越小，完成failover所需的时间就越长，  但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。  可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。  # sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;  sentinel parallel-syncs mymaster 1        # 故障转移的超时时间 failover-timeout 可以用在以下这些方面：   #1. 同一个sentinel对同一个master两次failover之间的间隔时间。  #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。  #3.当想要取消一个正在进行的failover所需要的时间。    #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了  # 默认三分钟  # sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;  sentinel failover-timeout mymaster 180000    # SCRIPTS EXECUTION    #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。  #对于脚本的运行结果有以下规则：  #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10  #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。  #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。  #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。    #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，  这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，  一个是事件的类型，  一个是事件的描述。  如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。  #通知脚本  # sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;    sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh    # 客户端重新配置主节点参数脚本  # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。  # 以下参数将会在调用脚本时传给脚本:  # &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;  # 目前&lt;state&gt;总是“failover”,  # &lt;role&gt;是“leader”或者“observer”中的一个。   # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的  # 这个脚本应该是通用的，能被多次调用，不是针对性的。  # sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;   sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh</code></pre></div><h1 id="Redis缓存穿透、击穿和雪崩"><a href="#Redis缓存穿透、击穿和雪崩" class="headerlink" title="Redis缓存穿透、击穿和雪崩"></a>Redis缓存穿透、击穿和雪崩</h1><p>面试高频，工作常用。服务的高可用问题。</p><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，他也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目录，业界也都有比较流行的解决方案。</p><p><img src="/myBlog/Redis/image-20211110212837552-1636731483147.png" alt="image-20211110212837552"></p><h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><p><strong>概念</strong></p><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库中没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，本次查询失败。当用户很多的时候，缓存都没有命中（秒杀），都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于缓存穿透。</p><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p><p><img src="/myBlog/Redis/image-20211110214237579-1636731483147.png" alt="image-20211110214237579"></p><p><strong>缓存空对象</strong></p><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><p><img src="/myBlog/Redis/image-20211110214533317-1636731483148.png" alt="image-20211110214533317"></p><p>但是这种方法会存在两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓冲层和存储层的数据会有一段时间窗口的不一致，这对于需要保存一致性的业务会有影响。</li></ol><h2 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h2><p><strong>概述</strong></p><p>这里需要注意和缓存穿透的区别，缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发级穿透缓存，直接请求数据库，就像在一个屏幕上凿开了一个洞。</p><p>当某个key在过期瞬间，有大量的请求并发访问，这类数据一般都是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。</p><p><strong>解决方案</strong></p><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到分布式锁，因此对分布式锁的考验很大。</p><p><img src="/myBlog/Redis/image-20211110220805289-1636731483148.png" alt="image-20211110220805289"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>概念</strong></p><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis宕机！</p><p>产生雪崩的原因之一，比如双十一零点抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到凌晨一点的时候，这批商品的缓存就过期了。而这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用会暴增，造成存储层也会挂掉的情况。</p><p><img src="/myBlog/Redis/image-20211110221746510-1636731483148.png" alt="image-20211110221746510"></p><p>其实集中过期倒不是非常致命，比较致命的缓存雪崩是缓存服务器某个节点宕机或者断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p><strong>解决方案</strong></p><p><strong>redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我就多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群（异地多活）。</p><p><strong>限流降级</strong></p><p>这个解决方案的思想就是在缓存失效后，通过加锁或者队列来控制读数据库缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据预热的含义就是在正式部署之前，先把可能的数据预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/myBlog/Linux/"/>
    <url>/myBlog/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux笔记"><a href="#Linux笔记" class="headerlink" title="Linux笔记"></a>Linux笔记</h1><p>Linux操作系统是基于UNIX操作系统发展而来的一种克隆系统。</p><span id="more"></span><h1 id="目录结构："><a href="#目录结构：" class="headerlink" title="目录结构："></a>目录结构：</h1><p><img src="/myBlog/Linux/image-20211102201829355.png" alt="image-20211102201829355"></p><ul><li><p>/：根目录，所有目录最顶层的目录</p></li><li><p>**~**：当前用户的主目录，如果是root用户就是/root/目录，如果是其他用户就是/home/下用户名的用户，如/home/admin</p></li><li><p>==<strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。==</p></li><li><p><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p></li><li><p>==<strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。==</p></li><li><p><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p></li><li><p><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</p></li><li><p><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p>==<strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。==</p></li><li><p><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</p></li><li><p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p></li><li><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p></li><li><p>==<strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。==</p></li><li><p><strong>/usr/bin：</strong> 系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong> 内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</p></li></ul><h1 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h1><p>sudo -i用不了</p><p>进入vim /etc/sudoers，按照root账户形式，在下面添加一行</p><p>admin ALL =(ALL) ALL</p><h2 id="关机命令："><a href="#关机命令：" class="headerlink" title="关机命令："></a>关机命令：</h2><ul><li><p>sync：将数据保存到硬盘中</p></li><li><p>shutdown -r now：马上重启</p></li><li><p>shutdown -h now：马上关机</p></li><li><p>shutdown：关机</p></li><li><p>init 0：关机</p></li><li><p>reboot：重启 </p></li><li><p>halt：关闭系统，等同于shutdown - h now 和poweroff</p></li></ul><h2 id="目录管理："><a href="#目录管理：" class="headerlink" title="目录管理："></a>目录管理：</h2><ul><li>cd：切换目录</li><li>./：当前目录</li><li>cd.. ：返回上一级目录</li></ul><h3 id="ls：列出目录"><a href="#ls：列出目录" class="headerlink" title="ls：列出目录"></a>ls：列出目录</h3><ul><li>ls -a：all，查看全部的文件，包含隐藏文件</li><li>ls -l： 列出所有的文件，包含文件的属性和权限，没有隐藏文件</li></ul><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>cd ../usr：相对路径进入usr文件</p><p>cd /home/admin: 绝对路径进去admin文件夹</p><p>cd ~：回到当前用户目录下</p><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><ul><li>显示当前用户所在的目录</li></ul><h3 id="mkdir创建目录"><a href="#mkdir创建目录" class="headerlink" title="mkdir创建目录"></a>mkdir创建目录</h3><ul><li><p>mkdir test：创建目录</p></li><li><p>mkdir -p test/test1/test2/test3：递归创建多级目录</p></li></ul><h3 id="rmdir-删除目录"><a href="#rmdir-删除目录" class="headerlink" title="rmdir 删除目录"></a>rmdir 删除目录</h3><ul><li><p>rmdir test3：删除一个空的目录</p></li><li><p>rmdir -p test/test1/test2: 递归删除多个目录</p></li></ul><h3 id="cp-复制文件或者目录"><a href="#cp-复制文件或者目录" class="headerlink" title="cp:复制文件或者目录"></a>cp:复制文件或者目录</h3><ul><li><p>cp 原来的地方 新的地方：cp 1.txt test</p></li><li><p>如果当前还有其他目录，需要用到-r进行递归，如：cp -r 1.txt test</p></li></ul><h3 id="rm：异常文件或者目录"><a href="#rm：异常文件或者目录" class="headerlink" title="rm：异常文件或者目录"></a>rm：异常文件或者目录</h3><ul><li><p>rm -f：忽略不存在的文件，不会出现警告，强制删除</p></li><li><p>rm -r：递归删除目录，需要确定是否删除</p></li><li><p>rm -i :互动，询问是否删除</p></li><li><p>rm -rf /*：直接删除系统中所有文件，没有警告，非常危险！！！不建议执行！！！！否则你将会这样</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 此处省略N行。。。rm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;mem’: Permission deniedrm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;cwd’: Permission deniedrm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;root’: Permission deniedrm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;exe’: Permission deniedrm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;mounts’: Permission deniedrm: cannot remove ‘&#x2F;proc&#x2F;697&#x2F;task&#x2F;713&#x2F;mountinfo’^C[root@localhost test]# rm: cannot remove ‘test2’: Is a directory-bash: &#x2F;usr&#x2F;libexec&#x2F;pk-command-not-found: &#x2F;lib64&#x2F;ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory[root@localhost test]# rm: cannot remove ‘test2’: Is a directory-bash: &#x2F;usr&#x2F;libexec&#x2F;pk-command-not-found: &#x2F;lib64&#x2F;ld-linux-x86-64.so.2: bad ELF interpreter: No such file or directory[root@localhost test]# ls-bash: &#x2F;bin&#x2F;ls: No such file or directory[root@localhost test]# cd ..&#x2F;cd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory[root@localhost ]# pwd&#x2F;home&#x2F;admin&#x2F;test&#x2F;..&#x2F;[root@localhost ]# cd &#x2F;home[root@localhost home]# ls-bash: &#x2F;bin&#x2F;ls: No such file or directory[root@localhost home]# cd ~[root@localhost ~]# ls-bash: &#x2F;bin&#x2F;ls: No such file or directory[root@localhost ~]# ls -al-bash: &#x2F;bin&#x2F;ls: No such file or directory[root@localhost ~]# dir-bash: &#x2F;bin&#x2F;dir: No such file or directory[root@localhost ~]# </code></pre></div><p><img src="/myBlog/Linux/image-20211102165244390.png" alt="image-20211102165244390"></p><h3 id="mv：移动文件或者目录，重命名"><a href="#mv：移动文件或者目录，重命名" class="headerlink" title="mv：移动文件或者目录，重命名"></a>mv：移动文件或者目录，重命名</h3><ul><li>mv -f：强制移动</li><li>mv -u：只替换已经更新过的文件</li><li>mv test test2：将test改名为test2</li><li>mv：移动文件，如将a.txt文件移动到b文件夹下，mv a.txt b</li></ul><ul><li>zxvf：解压文件</li></ul><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p><img src="/myBlog/Linux/image-20211102203952548.png" alt="image-20211102203952548"></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为【rwx】 的三个参数的组合。</p><ul><li>[ r ]代表可读(read)</li><li>[ w ]代表可写(write)</li><li>[ x ]代表可执行(execute)</li></ul><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p><img src="/myBlog/Linux/image-20211102204306150.png" alt="image-20211102204306150"></p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>1、4、7：读</p><p>2、5、8：写</p><p>3、6、9：操作</p><p><img src="/myBlog/Linux/image-20211102204619828.png" alt="image-20211102204619828"></p><h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="chgrp：更改文件的属组"><a href="#chgrp：更改文件的属组" class="headerlink" title="chgrp：更改文件的属组"></a>chgrp：更改文件的属组</h3><ul><li>chgrp -R 属组 文件名：如chgrp -R root test，test原本所属组为admin，现在改为root</li><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost Ten]# ls -ltotal 0drwxrwxr-x. 2 admin admin 6 Nov  2 20:09 testdrwxrwxr-x. 2 admin admin 6 Nov  2 20:11 test2[root@localhost Ten]# chgrp -R root test[root@localhost Ten]# ls -ltotal 0drwxrwxr-x. 2 admin root  6 Nov  2 20:09 testdrwxrwxr-x. 2 admin admin 6 Nov  2 20:11 test2[root@localhost Ten]# </code></pre></div><p><img src="/myBlog/Linux/image-20211102205944102.png" alt="image-20211102205944102"></p><h3 id="chown：更改文件的属主"><a href="#chown：更改文件的属主" class="headerlink" title="chown：更改文件的属主"></a>chown：更改文件的属主</h3><ul><li>chown -R 属主名 文件名：如chown -R root test，将test的属主改为root</li><li>chown -R 属主名:属组名 文件名：如chown -R admin:admin test，将test的所属主名和属组名都改名admin</li></ul><h3 id="chmod：更改文件9个属性"><a href="#chmod：更改文件9个属性" class="headerlink" title="chmod：更改文件9个属性"></a>chmod：更改文件9个属性</h3><ul><li>chmod -R xyz 文件或者目录：如，chmod -R 777 test，将test文件的三个权限都更改rwx。</li></ul><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">r:4     w:2         x:1</code></pre></div><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><ul><li><p>ifconfig：查看网络配置</p></li><li><p>==cat：由第一行开始显示文件内容==</p></li><li><p>tac：从最后一行开始显示文件内容，cat和tac是倒过来写的</p></li><li><p>==nl：显示文章行号==</p></li></ul><p><img src="/myBlog/Linux/image-20211102231332124.png" alt="image-20211102231332124"></p><ul><li>==more：一页一页的显示文件内容，空格翻页，enter代表向下一行，:f 查看当前行号，按B可以往上翻==</li><li>==less：与more类似，可以往前翻页，空格翻页，上下键代表翻动页面，q表示退出，查询字符串/要查询的字符串（向下查询），向上查询使用?要查询的字符串，如果还想继续查询可以用n向上查询，N向下==</li><li>head：只看头几行，如head -n 20 csh.login ，查看csh.login文件的前20行</li><li>tail：之后尾几行，如tail -n 20 csh.login，查看csh.login文件的后20行</li></ul><h2 id="拓展：Linux链接的概念（了解即可）"><a href="#拓展：Linux链接的概念（了解即可）" class="headerlink" title="拓展：Linux链接的概念（了解即可）"></a>拓展：Linux链接的概念（了解即可）</h2><p>Linux的链接分为两种：硬链接、软链接</p><p><strong>硬链接：</strong>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能，如，B是A的硬链接，当A被删除时，B依旧可以访问，反之亦然。只有当所有的硬链接都删除后，才可以彻底删除文件。</p><p><strong>软链接：</strong>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。比如，给A创建一个软链接B，当A被删除时，B就无法访问了。也可以理解为A为源文件，B为快捷键，源文件被删除了，该文件的快捷键当然也是访问不了的。</p><ul><li>touch：创建文件，如touch f1，创建f1文件</li><li>echo：输入字符串，也可以输入到文件中，如echo “Hello” &gt;&gt; f1，往f1中添加”Hello“</li><li>ln：创建一个硬链接，如ln f1 f2，创建一个硬链接，从f1指向f2</li><li>ln -s ：创建一个软链接，如ln -s f1 f3，创建一个软链接，从f1指向f3</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[admin@localhost Ten]$ touch f1# 创建f1[admin@localhost Ten]$ lsf1  test  test2[admin@localhost Ten]$ ln f1 f2# 创建从f1指向f2的硬链接[admin@localhost Ten]$ lsf1  f2  test  test2[admin@localhost Ten]$ ln -s f1 f3# 创建从f1指向f3的软链接（符号链接）[admin@localhost Ten]$ lsf1  f2  f3  test  test2[admin@localhost Ten]$ ls -ltotal 0-rw-rw-r--. 2 admin admin 0 Nov  3 11:37 f1-rw-rw-r--. 2 admin admin 0 Nov  3 11:37 f2lrwxrwxrwx. 1 admin admin 2 Nov  3 11:37 f3 -&gt; f1drwxrwxr-x. 2 admin admin 6 Nov  2 20:09 testdrwxrwxr-x. 2 admin admin 6 Nov  2 20:11 test2[admin@localhost Ten]$ [admin@localhost Ten]$ echo &quot;Hello&quot; &gt;&gt; &quot;f1&quot;# 往f1中写入内容[admin@localhost Ten]$ cat f1# f1正常读Hello[admin@localhost Ten]$ cat f2# f2正常读Hello[admin@localhost Ten]$ cat f3# f3正常读Hello[admin@localhost Ten]$ </code></pre></div><p>删除</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[admin@localhost Ten]$ lsf1  f2  f3  test  test2[admin@localhost Ten]$ rm -rf f1# 删除f1[admin@localhost Ten]$ ls f2  f3  test  test2[admin@localhost Ten]$ cat f2# f2是硬链接，没有影响，依旧可以访问I am Ten[admin@localhost Ten]$ cat f3# f3是软链接，已经失效cat: f3: No such file or directory[admin@localhost Ten]$ ^C</code></pre></div><ul><li>ls -li：显示索引节点号（Inode Index）</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[admin@localhost Ten]$ ls -litotal 8 5194981 -rw-rw-r--. 2 admin admin 6 Nov  3 11:38 f1 5194981 -rw-rw-r--. 2 admin admin 6 Nov  3 11:38 f2 5195004 lrwxrwxrwx. 1 admin admin 2 Nov  3 11:37 f3 -&gt; f113209000 drwxrwxr-x. 2 admin admin 6 Nov  2 20:09 test   77723 drwxrwxr-x. 2 admin admin 6 Nov  2 20:11 test2[admin@localhost Ten]$ </code></pre></div><h2 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h2><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><ul><li>Vim Study：创建或编辑一个Study的文件，如果存入Study就编辑，如果不存在就会新建</li></ul><p><strong>命令模式：</strong></p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p><strong>输入模式：</strong></p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式</strong></p><ul><li>:q，退出程序</li><li>:w，保存文件</li></ul><p><img src="/myBlog/Linux/image-20211103165822413.png" alt="image-20211103165822413"></p><p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">==n&lt; space&gt;==</td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td></tr><tr><td align="left">n&lt; Enter&gt;</td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">==/word==</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">==n==</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">==N==</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table><table><thead><tr><th align="left">删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr></tbody></table><p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">==i, I==</td><td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">==:wq==</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">==:set nu==</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><p><strong>添加用户，useradd命令</strong></p><ul><li><p>useradd -m  用户名：自动创建这个用户的目录/home/Test，如useradd -m Test,创建一个名为Test的用户</p></li><li><p>cat /etc/passwd，就可以看到刚刚被创建的用户</p></li><li><p>useradd -G 用户名：分配组</p></li></ul><p><strong>删除用户 userdel</strong></p><ul><li>userdel - r Test，将刚刚创建的Test用户的目录一并删掉</li></ul><p><strong>修改用户</strong> usermod</p><ul><li>usermod 对应修改的内容 修改的用户，如usermod  -d /home/233 Test，将Test用户的主目录修改为233，修改完查看配置文件即可</li></ul><p><strong>切换用户</strong></p><ul><li>su 用户名，如su Test，或者su - root</li><li>#：超级管理员，$：普通用户</li></ul><p><img src="/myBlog/Linux/image-20211103174249440.png" alt="image-20211103174249440"></p><ul><li>hostname 名字:修改主机名，如hostname Test，将主机名改为Test，改完之后重新连接。</li></ul><p><strong>修改用户的密码</strong></p><p>root下：</p><ul><li>passwd 用户名，如passwd Test，修改</li></ul><p>用户下：</p><ul><li>直接passwd就可以输入了</li></ul><p><strong>锁定用户</strong></p><ul><li>passwd -l 用户名，如passwd -l Test，锁定Test用户，用户就不能登录了</li><li>passwd -d 用户名，没有密码也不能登录</li><li>passwd -u 用户名， 将锁定的用户解锁</li></ul><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p>属主、属组</p><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><strong>groupadd：创建一个用户组</strong></p><ul><li>groupadd Test：创建一个Test的用户组</li><li>groupadd -g 111 Test1，创建一个端口号为111的Test1组，如果不设置用户组id，他会自增。</li><li>cat /etc/group：查看用户组的情况</li></ul><p><strong>groupdel：删除用户组</strong></p><ul><li>groupdel Test：删除Test的用户组</li></ul><p><strong>groupmod：修改</strong></p><ul><li>groupmod -g 666 -n newTest Test：将Test的用户组的用户组id改为666，并将名字改为newTest</li></ul><p><strong>切换用户组</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 登录当前用户 Test$ newgrp root</code></pre></div><p><strong>拓展：文件的查看</strong>（了解）</p><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><ul><li>/etc/passwd:</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5:...ntp:x:38:38::&#x2F;etc&#x2F;ntp:&#x2F;sbin&#x2F;nologintcpdump:x:72:72::&#x2F;:&#x2F;sbin&#x2F;nologinadmin:x:1000:1000:admin:&#x2F;home&#x2F;admin:&#x2F;bin&#x2F;bashTest:x:1001:666::&#x2F;home&#x2F;Test:&#x2F;bin&#x2F;bash</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">用户名:口令（登录密码，不可见）:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></pre></div><ul><li>/etc/shadow</li></ul><p>登录口令：把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><ul><li>/etc/group</li></ul><p>用户组的所有信息都存放在/etc/group文件中。</p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>df（列出文件系统整体的磁盘使用）  du（检查磁盘空间使用量）</p><ul><li>df -h:列出多少M</li><li>du -a:查看所有文件使用情况，可以看到子文件</li><li>du -sm /* :检查根目录下，每个目录所占用的容量</li></ul><p><strong>Mac或者想要Linux挂载我们的一些本地磁盘或者文件</strong></p><p>挂载</p><ul><li>mount /dev/Test /mnt/Test：将外部设备Test的U盘挂载到模mnt下面</li></ul><p>卸载：umount -f 挂载位置 ：强制卸载</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>==Linux中一切皆文件（文件：读写执行（查看、创建、删除、移动、复制、编辑 ），权限（用户、用户组）。系统：（磁盘、进程））==</p><p><strong>基本概念</strong></p><ol><li>在Linux中，每一个程序都有自己的一个进程，每一个进程都有一个id号</li><li>每一个进程，都有一个父进程！ </li><li>进程可以有两种存在方式：前台！后台运行！</li><li>一般的话服务都是后天运行的，基本的程序都是前天运行</li></ol><p><strong>命令</strong></p><ul><li>ps：查看当前系统中正在执行的各种进程的信息</li><li>ps -a:显示当前终端运行的所有的进程信息</li><li>ps -u:以用户的信息显示信息</li><li>ps -x:显示后台运行进程的参数</li><li>ps -aux:查看所有的进程</li></ul><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -aux | grep mysql# 过滤出与mysql相关的进程# | 在Linux中这个叫做管道符A|B，将A的输出结果作为B的输出条件# grep 查找文件中符合条件的字符串！</code></pre></div><p><strong>ps -ef:可以查看到父进程的信息</strong></p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps -ef | grep mysql# 看父进程一般通过目录树结构来查看pstree -pupstree -p# 显示父idpstree -u# 显示当前用户组</code></pre></div><p><img src="/myBlog/Linux/image-20211103222647990.png" alt="image-20211103222647990"></p><p>结束进程：杀掉进程，等价于window结束任务</p><ul><li>kill -9 进程的id：强制结束该进程</li></ul><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="JDK安装-rpm"><a href="#JDK安装-rpm" class="headerlink" title="JDK安装(rpm)"></a>JDK安装(rpm)</h2><p>rpm安装jdk不用配置环境变量</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 检查当前系统是否存在java环境java -version# 如果存在就卸载# rpm -qa|grep jdk# 检测JDK版本信息# rpm -e --nodeps jdk_# 强制卸载 # 卸载完后再重新安装# rpm -ivh rpm包# 配置环境变量</code></pre></div><p>配置环境变量：/etc/profile</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_121export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATHexport JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;binexport PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;java1.8...export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$&#123;CLASSPATH&#125;export PATH&#x3D;$PAHT:$&#123;JAVA_HOME&#125;&#x2F;bin:$&#123;JRE_HOME&#125;&#x2F;bin</code></pre></div><p>让这个配置文件生效：source /etc/profi</p><p>查看端口：</p><p>firewall-cmd –list-ports</p><p>开启防火墙端口：</p><p>firewall-cmd –zone=pulic –add-port=9000/tcp –p ermanent</p><p>重启防火墙：</p><p>systemctl restart firewalld.service</p><p>检查当前的网卡文件：</p><p>ip addr</p><h2 id="Tomcat安装（tar-gz）"><a href="#Tomcat安装（tar-gz）" class="headerlink" title="Tomcat安装（tar.gz）"></a>Tomcat安装（tar.gz）</h2><ol><li>解压</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unzip 文件名 # 如果是压缩包是zip格式的，使用tar -zvxf 包名</code></pre></div><ol start="2"><li>启动Tomcat测试，./xxx.sh脚本即可运行</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 执行 .&#x2F;startup.sh# 停止 .&#x2F;shutdown.sh</code></pre></div><ol start="3"><li>查看防火墙，并开启8080端口</li></ol><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all    # 查看全部信息firewall-cmd --list-ports  # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port&#x3D;80&#x2F;tcp  #添加端口，格式为：端口&#x2F;通讯协议--permanent   #永久生效，没有此参数重启后失效</code></pre></div><ol start="4"><li>测试。访问192.168.242.3:8080。出现页面，表示安装成功。</li></ol><h2 id="安装Docker（yum）"><a href="#安装Docker（yum）" class="headerlink" title="安装Docker（yum）"></a>安装Docker（yum）</h2><ol><li><p>查看系统版本信息</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[root@localhost bin]# cat &#x2F;etc&#x2F;redhat-release CentOS Linux release 7.8.2003 (Core)</code></pre></div></li><li><p>安装我们的准备环境</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install 包名# yum install 安装命令 -y所有的提示都为yyum -y install gccyum -y install gcc-c++</code></pre></div></li><li><p>或者用宝塔面板安装 </p></li></ol><h1 id="VMare使用"><a href="#VMare使用" class="headerlink" title="VMare使用"></a>VMare使用</h1><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>保留当前系统的信息为快照，随时可以恢复，以防未来系统被损坏，就好比游戏中的归档</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="使用xftp上传文件时，状态显示错误"><a href="#使用xftp上传文件时，状态显示错误" class="headerlink" title="使用xftp上传文件时，状态显示错误"></a>使用xftp上传文件时，状态显示错误</h2><p><img src="/myBlog/Linux/image-20211104114435498.png" alt="image-20211104114435498"></p><p>原因可能是：内存不够、权限不够（切换root）、或者是目录权限不够，如果是目录权限不够可以用以下命令设置权限</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 777 目录名</code></pre></div><p>使用tar.gz包</p><p>安装到/home/admin/java</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf jdk包名</code></pre></div><p>配置环境变量</p><p>vim /etc/profile</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export JAVA_HOME&#x3D;&#x2F;home&#x2F;admin&#x2F;java&#x2F;jdk1.8.0_121export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jreexport CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;libexport PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</code></pre></div><p>刷新配置文件：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;etc&#x2F;profile</code></pre></div><p>最后java -version检查是否配置成功</p><p>这个笔记是在学习狂神说Linux做的笔记，如需原版，请前往b站。地址：<a href="https://www.bilibili.com/video/BV187411y7hF?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV187411y7hF?spm_id_from=333.999.0.0</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis</title>
    <link href="/myBlog/mybatis/"/>
    <url>/myBlog/mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>环境：</p><ul><li>jdk 8 +</li><li>MySQL 5.7.19</li><li>maven-3.6.1</li><li>IDEA</li></ul><p>回顾：</p><ul><li>JDBC</li><li>MySQL</li><li>Java 基础</li><li>Maven</li><li>Junit</li></ul><p>SSM框架：配置文件的。最好的方式：看官网文档；</p><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-1什么是MyBatis"><a href="#1-1什么是MyBatis" class="headerlink" title="1.1什么是MyBatis"></a>1.1什么是MyBatis</h2><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong></li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程</li><li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 实体类 【Plain Old Java Objects,普通的 Java对象】映射成数据库中的记录。</li><li>MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 。</li><li>2013年11月迁移到<strong>Github</strong> .</li></ul><p>如何获得Mybatis？</p><ul><li>maven仓库：</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;    &lt;version&gt;3.5.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div><ul><li>Mybatis官方文档 : <a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></li><li>GitHub : <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></li></ul><h2 id="1-2、持久层"><a href="#1-2、持久层" class="headerlink" title="1.2、持久层"></a>1.2、持久层</h2><p><strong>数据持久化</strong></p><ul><li>持久化是将程序数据在持久状态和瞬时状态间转换的机制。</li><li>即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。</li><li>JDBC就是一种持久化机制。文件IO也是一种持久化机制。</li><li>在生活中 : 将鲜肉冷藏，吃的时候再解冻的方法也是。将水果做成罐头的方法也是。</li></ul><p><strong>为什么需要持久化服务呢？那是由于内存本身的缺陷引起的</strong></p><ul><li><p>内存断电后数据会丢失，但有一些对象是无论如何都不能丢失的，比如银行账号等，遗憾的是，人们还无法保证内存永不掉电。</p></li><li><p>内存过于昂贵，与硬盘、光盘等外存相比，内存的价格要高2~3个数量级，而且维持成本也高，至少需要一直供电吧。所以即使对象不需要永久保存，也会因为内存的容量限制不能一直呆在内存中，需要持久化来缓存到外存。</p></li></ul><h2 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h2><p><strong>什么是持久层？</strong></p><ul><li>完成持久化工作的代码块 .  —-&gt;  dao层 【DAO (Data Access Object)  数据访问对象】</li><li>大多数情况下特别是企业级应用，数据持久化往往也就意味着将内存中的数据保存到磁盘上加以固化，而持久化的实现过程则大多通过各种<strong>关系数据库</strong>来完成。</li><li>不过这里有一个字需要特别强调，也就是所谓的“层”。对于应用系统而言，数据持久功能大多是必不可少的组成部分。也就是说，我们的系统中，已经天然的具备了“持久层”概念？也许是，但也许实际情况并非如此。之所以要独立出一个“持久层”的概念,而不是“持久模块”，“持久单元”，也就意味着，我们的系统架构中，应该有一个相对独立的逻辑层面，专注于数据持久化逻辑的实现.</li><li>与系统其他部分相对而言，这个层面应该具有一个较为清晰和严格的逻辑边界。【说白了就是用来操作数据库存在的！】</li></ul><h2 id="1-4、为什么需要Mybatis"><a href="#1-4、为什么需要Mybatis" class="headerlink" title="1.4、为什么需要Mybatis"></a>1.4、为什么需要Mybatis</h2><ul><li><p>Mybatis就是帮助程序猿将数据存入数据库中 , 和从数据库中取数据 </p></li><li><p>传统的jdbc操作 , 有很多重复代码块 .比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 .</p></li><li><p>MyBatis 是一个半自动化的<strong>ORM框架 (Object Relationship Mapping) –&gt;对象关系映射</strong></p></li><li><p>所有的事情，不用Mybatis依旧可以做到，只是用了它，所有实现会更加简单！<strong>技术没有高低之分，只有使用这个技术的人有高低之别</strong></p></li><li><p>MyBatis的优点</p></li><li><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供xml标签，支持编写动态sql。</li><li>…….</li></ul></li><li><p><strong>最重要的一点，使用的人多！公司需要！</strong></p></li></ul><h1 id="2、第一Mybatis程序"><a href="#2、第一Mybatis程序" class="headerlink" title="2、第一Mybatis程序"></a>2、第一Mybatis程序</h1><p>思路：搭建环境 –&gt; 导入Mybatis –&gt; 编写代码 –&gt; 测试！</p><h2 id="2-1、搭建实验数据库"><a href="#2-1、搭建实验数据库" class="headerlink" title="2.1、搭建实验数据库"></a>2.1、搭建实验数据库</h2><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE DATABASE &#96;mybatis&#96;;USE &#96;mybatis&#96;;DROP TABLE IF EXISTS &#96;user&#96;;CREATE TABLE &#96;user&#96; (    &#96;id&#96; int(20) NOT NULL,    &#96;name&#96; varchar(30) DEFAULT NULL,    &#96;pwd&#96; varchar(30) DEFAULT NULL,    PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;insert  into &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) values (1,&#39;狂神&#39;,&#39;123456&#39;),(2,&#39;张三&#39;,&#39;abcdef&#39;),(3,&#39;李四&#39;,&#39;987654&#39;);</code></pre></div><p>新建项目</p><ol><li><p>新建一个普通的maven项目</p></li><li><p>删除src目录</p></li><li><p>导入maven依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--导入依赖--&gt;&lt;dependencies&gt;    &lt;!--mysql驱动--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;        &lt;version&gt;5.1.46&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--mybatis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;        &lt;version&gt;3.5.2&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--Junit--&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;        &lt;version&gt;4.12&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre></div></li></ol><h2 id="2-2、创建一个模块"><a href="#2-2、创建一个模块" class="headerlink" title="2.2、创建一个模块"></a>2.2、创建一个模块</h2><ul><li><p>编写MyBatis核心配置文件</p></li><li><p>查看帮助文档</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;   &lt;environments default&#x3D;&quot;development&quot;&gt;       &lt;environment id&#x3D;&quot;development&quot;&gt;           &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;           &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;               &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123456&quot;&#x2F;&gt;           &lt;&#x2F;dataSource&gt;       &lt;&#x2F;environment&gt;   &lt;&#x2F;environments&gt;   &lt;mappers&gt;       &lt;mapper resource&#x3D;&quot;com&#x2F;kuang&#x2F;dao&#x2F;userMapper.xml&quot;&#x2F;&gt;   &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre></div><ul><li><p>编写MyBatis工具类</p></li><li><p>查看帮助文档</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;   private static SqlSessionFactory sqlSessionFactory;   static &#123;       try &#123;           String resource &#x3D; &quot;mybatis-config.xml&quot;;           InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);           sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream);      &#125; catch (IOException e) &#123;           e.printStackTrace();      &#125;  &#125;   &#x2F;&#x2F;获取SqlSession连接   public static SqlSession getSession()&#123;       return sqlSessionFactory.openSession();  &#125;&#125;</code></pre></div><h2 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h2><ul><li>实体类</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User &#123;      private int id;  &#x2F;&#x2F;id   private String name;   &#x2F;&#x2F;姓名   private String pwd;   &#x2F;&#x2F;密码      &#x2F;&#x2F;构造,有参,无参   &#x2F;&#x2F;set&#x2F;get   &#x2F;&#x2F;toString()   &#125;</code></pre></div><ul><li><p>编写Mapper接口类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.kuang.pojo.User;import java.util.List;public interface UserMapper &#123;   List&lt;User&gt; selectUser();&#125;</code></pre></div></li><li><p>编写Mapper.xml配置文件</p></li><li><p>namespace 十分重要，不能写错！</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.dao.UserMapper&quot;&gt; &lt;select id&#x3D;&quot;selectUser&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;  select * from user &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre></div><ul><li><p>编写测试类</p></li><li><p>Junit 包测试</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyTest &#123;   @Test   public void selectUser() &#123;       SqlSession session &#x3D; MybatisUtils.getSession();       &#x2F;&#x2F;方法一:       &#x2F;&#x2F;List&lt;User&gt; users &#x3D; session.selectList(&quot;com.kuang.mapper.UserMapper.selectUser&quot;);       &#x2F;&#x2F;方法二:       UserMapper mapper &#x3D; session.getMapper(UserMapper.class);       List&lt;User&gt; users &#x3D; mapper.selectUser();       for (User user: users)&#123;           System.out.println(user);      &#125;       session.close();  &#125;&#125;</code></pre></div><h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p><strong>可能出现问题说明：Maven静态资源过滤问题</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;resources&gt;   &lt;resource&gt;       &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;       &lt;includes&gt;           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;       &lt;&#x2F;includes&gt;       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;   &lt;&#x2F;resource&gt;   &lt;resource&gt;       &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;       &lt;includes&gt;           &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;           &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;       &lt;&#x2F;includes&gt;       &lt;filtering&gt;false&lt;&#x2F;filtering&gt;   &lt;&#x2F;resource&gt;&lt;&#x2F;resources&gt;</code></pre></div><h1 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h1><h2 id="3-1、namespace"><a href="#3-1、namespace" class="headerlink" title="3.1、namespace"></a>3.1、namespace</h2><ol><li>将上面案例中的UserMapper接口改名为 UserDao；</li><li>将UserMapper.xml中的namespace改为为UserDao的路径 .</li><li>再次测试</li></ol><p><strong>结论：</strong></p><p>配置文件中namespace中的名称为对应Mapper接口或者Dao接口的完整包名,必须一致！</p><h2 id="3-2、select"><a href="#3-2、select" class="headerlink" title="3.2、select"></a>3.2、select</h2><ul><li><p>select标签是mybatis中最常用的标签之一</p></li><li><p>select语句有很多属性可以详细配置每一条SQL语句</p></li><li><ul><li>SQL语句返回值类型。【完整的类名或者别名】</li><li>传入SQL语句的参数类型 。【万能的Map，可以多尝试使用】</li><li>命名空间中唯一的标识符</li><li>接口中的方法名与映射文件中的SQL语句ID 一一对应</li><li>id：就是对应的namespace中的方法名</li><li>parameterType：参数类型！</li><li>resultType：Sql语句执行的返回值！</li></ul></li></ul><p><strong>需求：根据id查询用户</strong></p><ol><li><p>在UserMapper中添加对应方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface UserMapper &#123;   &#x2F;&#x2F;查询全部用户   List&lt;User&gt; selectUser();   &#x2F;&#x2F;根据id查询用户   User selectUserById(int id);&#125;</code></pre></div></li><li><p>在UserMapper.xml中添加Select语句</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;select * from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试类中测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void tsetSelectUserById() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();  &#x2F;&#x2F;获取SqlSession连接   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.selectUserById(1);   System.out.println(user);   session.close();&#125;</code></pre></div><p><strong>课堂练习</strong>：根据 密码 和 名字 查询用户</p><p>思路一：直接在方法中传递参数</p><ol><li>在接口方法的参数前加 @Param属性</li><li>Sql语句编写的时候，直接取@Param中设置的值即可，不需要单独设置参数类型</li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;通过密码和名字查询用户User selectUserByNP(@Param(&quot;username&quot;) String username,@Param(&quot;pwd&quot;) String pwd);&#x2F;*   &lt;select id&#x3D;&quot;selectUserByNP&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;     select * from user where name &#x3D; #&#123;username&#125; and pwd &#x3D; #&#123;pwd&#125;   &lt;&#x2F;select&gt;*&#x2F;</code></pre></div><p>思路二：使用万能的Map</p><ol><li><p>在接口方法中，参数直接传递Map；</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">User selectUserByNP2(Map&lt;String,Object&gt; map);</code></pre></div></li><li><p>编写sql语句的时候，需要传递参数类型，参数类型为map</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserByNP2&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;select * from user where name &#x3D; #&#123;username&#125; and pwd &#x3D; #&#123;pwd&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>在使用方法的时候，Map的 key 为 sql中取的值即可，没有顺序要求！</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();map.put(&quot;username&quot;,&quot;小明&quot;);map.put(&quot;pwd&quot;,&quot;123456&quot;);User user &#x3D; mapper.selectUserByNP2(map);</code></pre></div><p>总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可</p><h2 id="3-3、insert"><a href="#3-3、insert" class="headerlink" title="3.3、insert"></a>3.3、insert</h2><p>我们一般使用insert标签进行插入操作，它的配置和select标签差不多！</p><p><strong>需求：给数据库增加一个用户</strong></p><ol><li><p>在UserMapper接口中添加对应的方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;添加一个用户int addUser(User user);</code></pre></div></li><li><p>在UserMapper.xml中添加insert语句</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;insert id&#x3D;&quot;addUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;    insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&lt;&#x2F;insert&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testAddUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; new User(5,&quot;王五&quot;,&quot;zxcvbn&quot;);   int i &#x3D; mapper.addUser(user);   System.out.println(i);   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库   session.close();&#125;</code></pre></div><p><strong>注意点：增、删、改操作需要提交事务！</strong></p><h2 id="3-4、update"><a href="#3-4、update" class="headerlink" title="3.4、update"></a>3.4、update</h2><p>我们一般使用update标签进行更新操作，它的配置和select标签差不多！</p><p><strong>需求：修改用户的信息</strong></p><ol><li><p>同理，编写接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;修改一个用户int updateUser(User user);</code></pre></div></li><li><p>编写对应的配置文件SQL</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;com.kuang.pojo.User&quot;&gt;  update user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id &#x3D; #&#123;id&#125;&lt;&#x2F;update&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testUpdateUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.selectUserById(1);   user.setPwd(&quot;asdfgh&quot;);   int i &#x3D; mapper.updateUser(user);   System.out.println(i);   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库   session.close();&#125;</code></pre></div><h2 id="3-5、delete"><a href="#3-5、delete" class="headerlink" title="3.5、delete"></a>3.5、delete</h2><p>我们一般使用delete标签进行删除操作，它的配置和select标签差不多！</p><p><strong>需求：根据id删除一个用户</strong></p><ol><li><p>同理，编写接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据id删除用户int deleteUser(int id);</code></pre></div></li><li><p>编写对应的配置文件SQL</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;delete id&#x3D;&quot;deleteUser&quot; parameterType&#x3D;&quot;int&quot;&gt;  delete from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;delete&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDeleteUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   int i &#x3D; mapper.deleteUser(5);   System.out.println(i);   session.commit(); &#x2F;&#x2F;提交事务,重点!不写的话不会提交到数据库   session.close();&#125;</code></pre></div><p><strong>小结：</strong></p><ul><li>所有的增删改操作都需要提交事务！</li><li>接口所有的普通参数，尽量都写上@Param参数，尤其是多个参数时，必须写上！</li><li>有时候根据业务的需求，可以考虑使用map传递参数！</li><li>为了规范操作，在SQL的配置文件中，我们尽量将Parameter参数和resultType都写上！</li></ul><h2 id="3-6、思考题"><a href="#3-6、思考题" class="headerlink" title="3.6、思考题"></a>3.6、思考题</h2><p><strong>模糊查询like语句该怎么写?</strong></p><ol><li><p>在Java代码中添加sql通配符。</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">string wildcardname &#x3D; “%smi%”;list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname);&lt;select id&#x3D;”selectlike”&gt;select * from foo where bar like #&#123;value&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>在sql语句中拼接通配符，会引起sql注入</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">string wildcardname &#x3D; “smi”;list&lt;name&gt; names &#x3D; mapper.selectlike(wildcardname);&lt;select id&#x3D;”selectlike”&gt;    select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;&#x2F;select&gt;</code></pre></div><h1 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h1><h2 id="4-1、核心配置文件"><a href="#4-1、核心配置文件" class="headerlink" title="4.1、核心配置文件"></a>4.1、核心配置文件</h2><ul><li>mybatis-config.xml 系统核心配置文件</li><li>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。</li><li>能配置的内容如下：</li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器）&lt;!-- 注意元素节点的顺序！顺序不对会报错 --&gt;</code></pre></div><p>我们可以阅读 mybatis-config.xml 上面的dtd的头文件！</p><h2 id="4-2、environments元素"><a href="#4-2、environments元素" class="headerlink" title="4.2、environments元素"></a>4.2、environments元素</h2><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt;   &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;     &lt;property name&#x3D;&quot;...&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;   &lt;&#x2F;transactionManager&gt;   &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;     &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;     &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;     &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;     &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;   &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt;&lt;&#x2F;environments&gt;</code></pre></div><ul><li><p>配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定）</p></li><li><p>子元素节点：<strong>environment</strong></p></li><li><ul><li><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p></li><li><p>数据源是必须配置的。</p></li><li><p>有三种内建的数据源类型</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">type&#x3D;&quot;[UNPOOLED|POOLED|JNDI]&quot;）</code></pre></div></li><li><p>unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。</p></li><li><p><strong>pooled</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</p></li><li><p>jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</p></li><li><p>数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等….</p></li><li><p>详情：点击查看官方文档</p></li><li><p>这两种事务管理器类型都不需要设置任何属性。</p></li><li><p>具体的一套环境，通过设置id进行区别，id保证唯一！</p></li><li><p>子元素节点：transactionManager - [ 事务管理器 ]</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 语法 --&gt;&lt;transactionManager type&#x3D;&quot;[ JDBC | MANAGED ]&quot;&#x2F;&gt;</code></pre></div></li></ul></li></ul><h2 id="4-3、mappers元素"><a href="#4-3、mappers元素" class="headerlink" title="4.3、mappers元素"></a>4.3、mappers元素</h2><p><strong>mappers</strong></p><ul><li>映射器 : 定义映射SQL语句文件</li><li>既然 MyBatis 的行为其他元素已经配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 <code>file:///</code> 的 URL），或类名和包名等。映射器是MyBatis中最核心的组件之一，在MyBatis 3之前，只支持xml映射器，即：所有的SQL语句都必须在xml文件中配置。而从MyBatis 3开始，还支持接口映射器，这种映射器方式允许以Java代码的方式注解定义SQL语句，非常简洁。</li></ul><p><strong>引入资源方式</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;builder&#x2F;PostMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- 使用完全限定资源定位符（URL） --&gt;&lt;mappers&gt; &lt;mapper url&#x3D;&quot;file:&#x2F;&#x2F;&#x2F;var&#x2F;mappers&#x2F;AuthorMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--使用映射器接口实现类的完全限定类名需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;mapper class&#x3D;&quot;org.mybatis.builder.AuthorMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--将包内的映射器接口实现全部注册为映射器但是需要配置文件名称和接口名称一致，并且位于同一目录下--&gt;&lt;mappers&gt; &lt;package name&#x3D;&quot;org.mybatis.builder&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div><p><strong>Mapper文件</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.UserMapper&quot;&gt;   &lt;&#x2F;mapper&gt;</code></pre></div><ul><li><p>namespace中文意思：命名空间，作用如下：</p></li><li><ul><li>namespace的命名必须跟某个接口同名</li><li>接口中的方法与映射文件中sql语句id应该一一对应</li></ul></li><li><ol><li>namespace和子元素的id联合保证唯一  , 区别不同的mapper</li><li>绑定DAO接口</li><li>namespace命名规则 : 包名+类名</li></ol></li></ul><p>MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。</p><h2 id="4-4、Properties优化"><a href="#4-4、Properties优化" class="headerlink" title="4.4、Properties优化"></a>4.4、Properties优化</h2><p>数据库这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。具体的官方文档</p><p>我们来优化我们的配置文件</p><ol><li><p>在资源目录下新建一个db.properties</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">driver&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8username&#x3D;rootpassword&#x3D;123456</code></pre></div></li><li><p>将文件导入properties 配置文件</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;configuration&gt;   &lt;!--导入properties文件--&gt;   &lt;properties resource&#x3D;&quot;db.properties&quot;&#x2F;&gt;   &lt;environments default&#x3D;&quot;development&quot;&gt;       &lt;environment id&#x3D;&quot;development&quot;&gt;           &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;           &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;               &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;               &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;           &lt;&#x2F;dataSource&gt;       &lt;&#x2F;environment&gt;   &lt;&#x2F;environments&gt;   &lt;mappers&gt;       &lt;mapper resource&#x3D;&quot;mapper&#x2F;UserMapper.xml&quot;&#x2F;&gt;   &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt;</code></pre></div><p>更多操作，可以查看官方文档！【演示带领学习】</p><ul><li>配置文件优先级问题</li><li>新特性：使用占位符</li></ul><h2 id="4-5、typeAliases优化"><a href="#4-5、typeAliases优化" class="headerlink" title="4.5、typeAliases优化"></a>4.5、typeAliases优化</h2><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--配置别名,注意顺序--&gt;&lt;typeAliases&gt;   &lt;typeAlias type&#x3D;&quot;com.kuang.pojo.User&quot; alias&#x3D;&quot;User&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;</code></pre></div><p>当这样配置时，<code>User</code>可以用在任何使用<code>com.kuang.pojo.User</code>的地方。</p><p>也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如:</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;typeAliases&gt;   &lt;package name&#x3D;&quot;com.kuang.pojo&quot;&#x2F;&gt;&lt;&#x2F;typeAliases&gt;</code></pre></div><p>每一个在包 <code>com.kuang.pojo</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。</p><p>若有注解，则别名为其注解值。见下面的例子：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Alias(&quot;user&quot;)public class User &#123;  ...&#125;</code></pre></div><p>去官网查看一下Mybatis默认的一些类型别名！</p><h2 id="4-6、其他配置浏览"><a href="#4-6、其他配置浏览" class="headerlink" title="4.6、其他配置浏览"></a>4.6、其他配置浏览</h2><p><strong>设置</strong></p><ul><li><p>设置（settings）相关 =&gt; 查看帮助文档</p></li><li><ul><li>懒加载</li><li>日志实现</li><li>缓存开启关闭</li></ul></li><li><p>一个配置完整的 settings 元素的示例如下：</p></li></ul><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt; &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;multipleResultSetsEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;autoMappingBehavior&quot; value&#x3D;&quot;PARTIAL&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;autoMappingUnknownColumnBehavior&quot; value&#x3D;&quot;WARNING&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;defaultExecutorType&quot; value&#x3D;&quot;SIMPLE&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;defaultStatementTimeout&quot; value&#x3D;&quot;25&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;defaultFetchSize&quot; value&#x3D;&quot;100&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;safeRowBoundsEnabled&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;false&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;localCacheScope&quot; value&#x3D;&quot;SESSION&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;jdbcTypeForNull&quot; value&#x3D;&quot;OTHER&quot;&#x2F;&gt; &lt;setting name&#x3D;&quot;lazyLoadTriggerMethods&quot; value&#x3D;&quot;equals,clone,hashCode,toString&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre></div><p><strong>类型处理器</strong></p><ul><li>无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。</li><li>你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。【了解即可】</li></ul><p><strong>对象工厂</strong></p><ul><li>MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。</li><li>默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过有参构造方法来实例化。</li><li>如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。【了解即可】</li></ul><h2 id="4-7、生命周期和作用域"><a href="#4-7、生命周期和作用域" class="headerlink" title="4.7、生命周期和作用域"></a>4.7、生命周期和作用域</h2><p><strong>作用域（Scope）和生命周期</strong></p><p>理解我们目前已经讨论过的不同作用域和生命周期类是至关重要的，因为错误的使用会导致非常严重的并发问题。</p><p>我们可以先画一个流程图，分析一下Mybatis的执行过程！</p><p><img src="/myBlog/mybatis/image-20210621140626109.png" alt="image-20210621140626109"></p><p><strong>作用域理解</strong></p><ul><li>SqlSessionFactoryBuilder 的作用在于创建 SqlSessionFactory，创建成功后，SqlSessionFactoryBuilder 就失去了作用，所以它只能存在于创建 SqlSessionFactory 的方法中，而不要让其长期存在。因此 <strong>SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域</strong>（也就是局部方法变量）。</li><li>SqlSessionFactory 可以被认为是一个数据库连接池，它的作用是创建 SqlSession 接口对象。因为 MyBatis 的本质就是 Java 对数据库的操作，所以 SqlSessionFactory 的生命周期存在于整个 MyBatis 的应用之中，所以一旦创建了 SqlSessionFactory，就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期。</li><li>由于 SqlSessionFactory 是一个对数据库的连接池，所以它占据着数据库的连接资源。如果创建多个 SqlSessionFactory，那么就存在多个数据库连接池，这样不利于对数据库资源的控制，也会导致数据库连接资源被消耗光，出现系统宕机等情况，所以尽量避免发生这样的情况。</li><li>因此在一般的应用中我们往往希望 SqlSessionFactory 作为一个单例，让它在应用中被共享。所以说 <strong>SqlSessionFactory 的最佳作用域是应用作用域。</strong></li><li>如果说 SqlSessionFactory 相当于数据库连接池，那么 SqlSession 就相当于一个数据库连接（Connection 对象），你可以在一个事务里面执行多条 SQL，然后通过它的 commit、rollback 等方法，提交或者回滚事务。所以它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory，否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用 try…catch…finally… 语句来保证其正确关闭。</li><li><strong>所以 SqlSession 的最佳的作用域是请求或方法作用域。</strong></li></ul><p><img src="/myBlog/mybatis/image-20210621140705877.png" alt="image-20210621140705877"></p><p>学会了Crud，和基本的配置及原理，后面就可以学习些业务开发</p><h1 id="5、ResultMap"><a href="#5、ResultMap" class="headerlink" title="5、ResultMap"></a>5、ResultMap</h1><h2 id="5-1、查询为null问题"><a href="#5-1、查询为null问题" class="headerlink" title="5.1、查询为null问题"></a>5.1、查询为null问题</h2><p><strong>要解决的问题：属性名和字段名不一致</strong></p><p>环境：新建一个项目，将之前的项目拷贝过来</p><ol><li><p>查看之前的数据库的字段名</p><p><img src="/myBlog/mybatis/image-20210621141030263.png" alt="image-20210621141030263"></p></li><li><p>Java中的实体类设计</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class User &#123;   private int id;  &#x2F;&#x2F;id   private String name;   &#x2F;&#x2F;姓名   private String password;   &#x2F;&#x2F;密码和数据库不一样！      &#x2F;&#x2F;构造   &#x2F;&#x2F;set&#x2F;get   &#x2F;&#x2F;toString()&#125;</code></pre></div></li><li><p>接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据id查询用户User selectUserById(int id);</code></pre></div></li><li><p>mapper映射文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;user&quot;&gt;  select * from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testSelectUserById() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();  &#x2F;&#x2F;获取SqlSession连接   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.selectUserById(1);   System.out.println(user);   session.close();&#125;</code></pre></div><p><strong>结果:</strong></p><ul><li>User{id=1, name=’狂神’, password=’null’}</li><li>查询出来发现 password 为空 . 说明出现了问题！</li></ul><p><strong>分析：</strong></p><ul><li><p>select * from user where id = #{id} 可以看做</p><p>select  id,name,pwd  from user where id = #{id}</p></li><li><p>mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】</p></li></ul><p><strong>解决方案</strong></p><p>方案一：为列名指定别名 , 别名和java实体类的属性名一致 </p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;User&quot;&gt;  select id , name , pwd as password from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div><p><strong>方案二：使用结果集映射-&gt;ResultMap</strong> 【推荐】</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;resultMap id&#x3D;&quot;UserMap&quot; type&#x3D;&quot;User&quot;&gt;   &lt;!-- id为主键 --&gt;   &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;   &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;   &lt;result column&#x3D;&quot;pwd&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;&lt;select id&#x3D;&quot;selectUserById&quot; resultMap&#x3D;&quot;UserMap&quot;&gt;  select id , name , pwd from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div><h2 id="5-2、ResultMap"><a href="#5-2、ResultMap" class="headerlink" title="5.2、ResultMap"></a>5.2、ResultMap</h2><p><strong>自动映射</strong></p><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来。</li><li>实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的长达数千行的代码。</li><li>ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。</li></ul><p>你已经见过简单映射语句的示例了，但并没有显式指定 <code>resultMap</code>。比如：</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserById&quot; resultType&#x3D;&quot;map&quot;&gt;select id , name , pwd  from user  where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div><p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 不是一个很好的模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为模型。</p><p><code>ResultMap</code> 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。</p><p><strong>手动映射</strong></p><ol><li><p>返回值类型为resultMap</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUserById&quot; resultMap&#x3D;&quot;UserMap&quot;&gt;  select id , name , pwd from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>编写resultMap，实现手动映射！</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;resultMap id&#x3D;&quot;UserMap&quot; type&#x3D;&quot;User&quot;&gt;   &lt;!-- id为主键 --&gt;   &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;   &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt;   &lt;result column&#x3D;&quot;name&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;   &lt;result column&#x3D;&quot;pwd&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;</code></pre></div><p>如果世界总是这么简单就好了。但是肯定不是的，数据库中，存在一对多，多对一的情况，我们之后会使用到一些高级的结果集映射，association，collection这些，我们将在之后讲解，今天你们需要把这些知识都消化掉才是最重要的！理解结果集映射的这个概念！</p><h1 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h1><h2 id="6-1日志工厂"><a href="#6-1日志工厂" class="headerlink" title="6.1日志工厂"></a>6.1日志工厂</h2><p>思考：我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？</p><p>如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题。</p><p>对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具。</p><p>Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j</li><li>JDK logging</li></ul><p>具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p><p><strong>标准日志实现</strong></p><p>指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt;       &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre></div><p>测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug</p><h2 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h2><p><strong>简介：</strong></p><ul><li>Log4j是Apache的一个开源项目</li><li>通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件….</li><li>我们也可以控制每一条日志的输出格式；</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</li></ul><ol><li><p><strong>使用步骤：</strong></p><ol><li><p>导入log4j的包</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;   &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;   &lt;version&gt;1.2.17&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></li><li><p>配置文件编写</p><div class="code-wrapper"><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger&#x3D;DEBUG,console,file#控制台输出的相关设置log4j.appender.console &#x3D; org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target &#x3D; System.outlog4j.appender.console.Threshold&#x3D;DEBUGlog4j.appender.console.layout &#x3D; org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern&#x3D;[%c]-%m%n#文件输出的相关设置log4j.appender.file &#x3D; org.apache.log4j.RollingFileAppenderlog4j.appender.file.File&#x3D;.&#x2F;log&#x2F;kuang.loglog4j.appender.file.MaxFileSize&#x3D;10mblog4j.appender.file.Threshold&#x3D;DEBUGlog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern&#x3D;[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis&#x3D;DEBUGlog4j.logger.java.sql&#x3D;DEBUGlog4j.logger.java.sql.Statement&#x3D;DEBUGlog4j.logger.java.sql.ResultSet&#x3D;DEBUGlog4j.logger.java.sql.PreparedStatement&#x3D;DEBUG</code></pre></div></li><li><p>setting设置日志实现</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt;   &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;</code></pre></div></li><li><p>在程序中使用Log4j进行输出！</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;注意导包：org.apache.log4j.Loggerstatic Logger logger &#x3D; Logger.getLogger(MyTest.class);@Testpublic void selectUser() &#123;   logger.info(&quot;info：进入selectUser方法&quot;);   logger.debug(&quot;debug：进入selectUser方法&quot;);   logger.error(&quot;error: 进入selectUser方法&quot;);   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   List&lt;User&gt; users &#x3D; mapper.selectUser();   for (User user: users)&#123;       System.out.println(user);  &#125;   session.close();&#125;</code></pre></div></li><li><p>测试，看控制台输出！</p></li></ol><ul><li>使用Log4j 输出日志</li><li>可以看到还生成了一个日志的文件 【需要修改file的日志级别】</li></ul></li></ol><h1 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h1><h2 id="7-1、limit实现分页"><a href="#7-1、limit实现分页" class="headerlink" title="7.1、limit实现分页"></a>7.1、limit实现分页</h2><p><strong>思考：为什么需要分页？</strong></p><p>在学习mybatis等持久层框架的时候，会经常对数据进行增删改查操作，使用最多的是对数据库进行查询操作，如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内。</p><p><strong>使用Limit实现分页</strong></p><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#语法SELECT * FROM table LIMIT stratIndex，pageSizeSELECT * FROM table LIMIT 5,10; &#x2F;&#x2F; 检索记录行 6-15  #为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   SELECT * FROM table LIMIT 95,-1; &#x2F;&#x2F; 检索记录行 96-last.  #如果只给定一个参数，它表示返回最大的记录行数目：   SELECT * FROM table LIMIT 5; &#x2F;&#x2F;检索前 5 个记录行  #换句话说，LIMIT n 等价于 LIMIT 0,n。 </code></pre></div><p><strong>步骤：</strong></p><ol><li><p>修改Mapper文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;selectUser&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;user&quot;&gt;  select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>Mapper接口，参数为map</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;选择全部用户实现分页List&lt;User&gt; selectUser(Map&lt;String,Integer&gt; map);</code></pre></div></li><li><p>在测试类中传入参数测试</p><ul><li>  推断：起始位置 =  （当前页面 - 1 ） * 页面大小</li></ul></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;分页查询 , 两个参数startIndex , pageSize@Testpublic void testSelectUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   int currentPage &#x3D; 1;  &#x2F;&#x2F;第几页   int pageSize &#x3D; 2;  &#x2F;&#x2F;每页显示几个   Map&lt;String,Integer&gt; map &#x3D; new HashMap&lt;String,Integer&gt;();   map.put(&quot;startIndex&quot;,(currentPage-1)*pageSize);   map.put(&quot;pageSize&quot;,pageSize);   List&lt;User&gt; users &#x3D; mapper.selectUser(map);   for (User user: users)&#123;       System.out.println(user);  &#125;   session.close();&#125;</code></pre></div><h2 id="7-2、RowBounds分页"><a href="#7-2、RowBounds分页" class="headerlink" title="7.2、RowBounds分页"></a>7.2、RowBounds分页</h2><p>我们除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可。我们来看下如何实现的！</p><p><strong>步骤：</strong></p><ol><li><p>mapper接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;选择全部用户RowBounds实现分页List&lt;User&gt; getUserByRowBounds();</code></pre></div></li><li><p>mapper文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;getUserByRowBounds&quot; resultType&#x3D;&quot;user&quot;&gt;select * from user&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试类</p></li></ol><p>在这里，我们需要使用RowBounds类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testUserByRowBounds() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   int currentPage &#x3D; 2;  &#x2F;&#x2F;第几页   int pageSize &#x3D; 2;  &#x2F;&#x2F;每页显示几个   RowBounds rowBounds &#x3D; new RowBounds((currentPage-1)*pageSize,pageSize);   &#x2F;&#x2F;通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了]   List&lt;User&gt; users &#x3D; session.selectList(&quot;com.kuang.mapper.UserMapper.getUserByRowBounds&quot;, null, rowBounds);   for (User user: users)&#123;       System.out.println(user);  &#125;   session.close();&#125;</code></pre></div><h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><h2 id="8-1、面向接口编程"><a href="#8-1、面向接口编程" class="headerlink" title="8.1、面向接口编程"></a>8.1、面向接口编程</h2><ul><li>大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程</li><li><strong>根本原因 :  解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好</strong></li><li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；</li><li>而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li></ul><p><strong>关于接口的理解</strong></p><ul><li><p>接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。</p></li><li><p>接口的本身反映了系统设计人员对系统的抽象理解。</p></li><li><p>接口应有两类：</p></li><li><ul><li>第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；</li><li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；</li></ul></li><li><p>一个体有可能有多个抽象面。抽象体与抽象面是有区别的。</p></li></ul><p><strong>三个面向区别</strong></p><ul><li><p>面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .</p></li><li><p>面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .</p></li><li><p>接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构</p></li></ul><h2 id="8-2、利用注解开发"><a href="#8-2、利用注解开发" class="headerlink" title="8.2、利用注解开发"></a>8.2、利用注解开发</h2><ul><li><p><strong>mybatis最初配置信息是基于 XML ,映射语句(SQL)也是定义在 XML 中的。而到MyBatis 3提供了新的基于注解的配置。不幸的是，Java 注解的的表达力和灵活性十分有限。最强大的 MyBatis 映射并不能用注解来构建</strong></p></li><li><p>sql 类型主要分成 :</p></li><li><ul><li>@select ()</li><li>@update ()</li><li>@Insert ()</li><li>@delete ()</li></ul></li></ul><p><strong>注意：</strong>利用注解开发就不需要mapper.xml映射文件了 .</p><ol><li><p>我们在我们的接口中添加注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;查询全部用户@Select(&quot;select id,name,pwd password from user&quot;)public List&lt;User&gt; getAllUser();</code></pre></div></li><li><p>在mybatis的核心配置文件中注入</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--使用class绑定接口--&gt;&lt;mappers&gt;   &lt;mapper class&#x3D;&quot;com.kuang.mapper.UserMapper&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div></li><li><p>我们去进行测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testGetAllUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   &#x2F;&#x2F;本质上利用了jvm的动态代理机制   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   List&lt;User&gt; users &#x3D; mapper.getAllUser();   for (User user : users)&#123;       System.out.println(user);  &#125;   session.close();&#125;</code></pre></div><p>  4.利用Debug查看本质</p><p><img src="/myBlog/mybatis/image-20210621161958604.png" alt="image-20210621161958604"></p><p>5.本质上利用了jvm的动态代理机制</p><p><img src="/myBlog/mybatis/image-20210621162015063.png" alt="image-20210621162015063"></p><p>6.Mybatis详细的执行流程</p><p><img src="/myBlog/mybatis/image-20210621162031523.png" alt="image-20210621162031523"></p><h2 id="8-3、注解增删改"><a href="#8-3、注解增删改" class="headerlink" title="8.3、注解增删改"></a>8.3、注解增删改</h2><p>改造MybatisUtils工具类的getSession( ) 方法，重载实现。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取SqlSession连接public static SqlSession getSession()&#123;    return getSession(true); &#x2F;&#x2F;事务自动提交&#125;public static SqlSession getSession(boolean flag)&#123;    return sqlSessionFactory.openSession(flag);&#125;</code></pre></div><p>【注意】确保实体类和数据库字段对应</p><p><strong>查询：</strong></p><ol><li><p>编写接口方法注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据id查询用户@Select(&quot;select * from user where id &#x3D; #&#123;id&#125;&quot;)User selectUserById(@Param(&quot;id&quot;) int id);</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testSelectUserById() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.selectUserById(1);   System.out.println(user);   session.close();&#125;</code></pre></div></li></ol><p><strong>新增：</strong></p><ol><li><p>编写接口方法注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;添加一个用户@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;)int addUser(User user);</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testAddUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; new User(6, &quot;秦疆&quot;, &quot;123456&quot;);   mapper.addUser(user);   session.close();&#125;</code></pre></div><p><strong>修改：</strong></p><ol><li><p>编写接口方法注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;修改一个用户@Update(&quot;update user set name&#x3D;#&#123;name&#125;,pwd&#x3D;#&#123;pwd&#125; where id &#x3D; #&#123;id&#125;&quot;)int updateUser(User user);</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testUpdateUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; new User(6, &quot;秦疆&quot;, &quot;zxcvbn&quot;);   mapper.updateUser(user);   session.close();&#125;</code></pre></div><p><strong>删除：</strong></p><ol><li><p>编写接口方法注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据id删除用@Delete(&quot;delete from user where id &#x3D; #&#123;id&#125;&quot;)int deleteUser(@Param(&quot;id&quot;)int id);</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testDeleteUser() &#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   mapper.deleteUser(6);      session.close();&#125;</code></pre></div><p>【注意点：增删改一定记得对事务的处理】</p><h2 id="8-4、关于-Param"><a href="#8-4、关于-Param" class="headerlink" title="8.4、关于@Param"></a>8.4、关于@Param</h2><p>@Param注解用于给方法参数起一个名字。以下是总结的使用原则：</p><ul><li>在方法只接受一个参数的情况下，可以不使用@Param。</li><li>在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名。</li><li>如果参数是 JavaBean ， 则不能使用@Param。</li><li>不使用@Param注解时，参数只能有一个，并且是Javabean。</li></ul><h2 id="8-5、-与-的区别"><a href="#8-5、-与-的区别" class="headerlink" title="8.5、#与$的区别"></a>8.5、#与$的区别</h2><ul><li><p>#{} 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">INSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?);</code></pre></div></li><li><p>${} 的作用是直接进行字符串替换</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">INSERT INTO user (name) VALUES (&#39;$&#123;name&#125;&#39;);INSERT INTO user (name) VALUES (&#39;kuangshen&#39;);</code></pre></div><p><strong>使用注解和配置文件协同开发，才是MyBatis的最佳实践！</strong></p><p>使用注解开发可以提高我们的开发效率，可以合理使用哦！</p></li></ul><h1 id="9、Lombok"><a href="#9、Lombok" class="headerlink" title="9、Lombok"></a>9、Lombok</h1><p>使用步骤：</p><ol><li><p>在IDEA安装Lombok插件！</p></li><li><p>在项目中导入Lombok的jar包</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.18.20&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></div></li><li><p>在实体类上加注解即可！</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows@val@varexperimental @var@UtilityClass@ExtensionMethod (Experimental, activate manually in plugin settings)</code></pre></div><p>说明：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Date：无参构造，get、set、tostring、hashcode、equals@NoArgsConstructor  &#x2F;&#x2F;无参构造@AllArgsConstructor  &#x2F;&#x2F;有参构造</code></pre></div><h1 id="10、多对一处理"><a href="#10、多对一处理" class="headerlink" title="10、多对一处理"></a>10、多对一处理</h1><h2 id="10-1、测试环境搭建"><a href="#10-1、测试环境搭建" class="headerlink" title="10.1、测试环境搭建"></a>10.1、测试环境搭建</h2><ol><li>导入Lombok</li><li>新建实体类Teacher，Student</li><li>建立Mapper接口</li><li>建立Mapper.XML文件</li><li>在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】</li><li>测试查询是否能够成功！</li></ol><p><strong>多对一的处理</strong></p><p>多对一的理解：</p><ul><li>多个学生对应一个老师</li><li>如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！</li></ul><p><strong>数据库设计</strong></p><p><img src="/myBlog/mybatis/image-20210622005224017.png" alt="image-20210622005224017"></p><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE &#96;teacher&#96; (&#96;id&#96; INT(10) NOT NULL,&#96;name&#96; VARCHAR(30) DEFAULT NULL,PRIMARY KEY (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INTO teacher(&#96;id&#96;, &#96;name&#96;) VALUES (1, &#39;秦老师&#39;);CREATE TABLE &#96;student&#96; (&#96;id&#96; INT(10) NOT NULL,&#96;name&#96; VARCHAR(30) DEFAULT NULL,&#96;tid&#96; INT(10) DEFAULT NULL,PRIMARY KEY (&#96;id&#96;),KEY &#96;fktid&#96; (&#96;tid&#96;),CONSTRAINT &#96;fktid&#96; FOREIGN KEY (&#96;tid&#96;) REFERENCES &#96;teacher&#96; (&#96;id&#96;)) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;1&#39;, &#39;小明&#39;, &#39;1&#39;);INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;2&#39;, &#39;小红&#39;, &#39;1&#39;);INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;3&#39;, &#39;小张&#39;, &#39;1&#39;);INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;4&#39;, &#39;小李&#39;, &#39;1&#39;);INSERT INTO &#96;student&#96; (&#96;id&#96;, &#96;name&#96;, &#96;tid&#96;) VALUES (&#39;5&#39;, &#39;小王&#39;, &#39;1&#39;);</code></pre></div><p><strong>搭建测试环境</strong></p><ol><li><p>IDEA安装Lombok插件</p></li><li><p>引入Maven依赖</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.projectlombok&#x2F;lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt; &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt; &lt;version&gt;1.16.10&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;s</code></pre></div></li><li><p>在代码中增加注解</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data &#x2F;&#x2F;GET,SET,ToString，有参，无参构造public class Teacher &#123;   private int id;   private String name;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Student &#123;   private int id;   private String name;   &#x2F;&#x2F;多个学生可以是同一个老师，即多对一   private Teacher teacher;&#125;</code></pre></div></li><li><p>编写实体类对应的Mapper接口 【两个】</p><p><strong>无论有没有需求，都应该写上，以备后来之需！</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface StudentMapper &#123;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface TeacherMapper &#123;&#125;</code></pre></div></li><li><p>编写Mapper接口对应的 mapper.xml配置文件 【两个】</p><p><strong>无论有没有需求，都应该写上，以备后来之需！</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper           PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;           &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.StudentMapper&quot;&gt;&lt;&#x2F;mapper&gt;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper           PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;           &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.TeacherMapper&quot;&gt;&lt;&#x2F;mapper&gt;</code></pre></div></li></ol><h2 id="10-2、按查询嵌套处理"><a href="#10-2、按查询嵌套处理" class="headerlink" title="10.2、按查询嵌套处理"></a>10.2、按查询嵌套处理</h2><ol><li><p>给StudentMapper接口增加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取所有学生及对应老师的信息public List&lt;Student&gt; getStudents();</code></pre></div></li><li><p>编写对应的Mapper文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.StudentMapper&quot;&gt;   &lt;!--   需求：获取所有学生及对应老师的信息   思路：       1. 获取所有学生的信息       2. 根据获取的学生信息的老师ID-&gt;获取该老师的信息       3. 思考问题，这样学生的结果集中应该包含老师，该如何处理呢，数据库中我们一般使用关联查询？           1. 做一个结果集映射：StudentTeacher           2. StudentTeacher结果集的类型为 Student           3. 学生中老师的属性为teacher，对应数据库中为tid。              多个 [1,...）学生关联一个老师&#x3D;&gt; 一对一，一对多           4. 查看官网找到：association – 一个复杂类型的关联；使用它来处理关联查询   --&gt;   &lt;select id&#x3D;&quot;getStudents&quot; resultMap&#x3D;&quot;StudentTeacher&quot;&gt;    select * from student   &lt;&#x2F;select&gt;   &lt;resultMap id&#x3D;&quot;StudentTeacher&quot; type&#x3D;&quot;Student&quot;&gt;       &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;       &lt;association property&#x3D;&quot;teacher&quot;  column&#x3D;&quot;tid&quot; javaType&#x3D;&quot;Teacher&quot; select&#x3D;&quot;getTeacher&quot;&#x2F;&gt;   &lt;&#x2F;resultMap&gt;   &lt;!--   这里传递过来的id，只有一个属性的时候，下面可以写任何值   association中column多参数配置：       column&#x3D;&quot;&#123;key&#x3D;value,key&#x3D;value&#125;&quot;       其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。   --&gt;   &lt;select id&#x3D;&quot;getTeacher&quot; resultType&#x3D;&quot;teacher&quot;&gt;      select * from teacher where id &#x3D; #&#123;id&#125;   &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt;</code></pre></div></li><li><p>编写完毕去Mybatis配置文件中，注册Mapper！</p></li><li><p>注意点说明：</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;resultMap id&#x3D;&quot;StudentTeacher&quot; type&#x3D;&quot;Student&quot;&gt;   &lt;!--association关联属性 property属性名 javaType属性类型 column在多的一方的表中的列名--&gt;   &lt;association property&#x3D;&quot;teacher&quot;  column&#x3D;&quot;&#123;id&#x3D;tid,name&#x3D;tid&#125;&quot; javaType&#x3D;&quot;Teacher&quot; select&#x3D;&quot;getTeacher&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;&lt;!--这里传递过来的id，只有一个属性的时候，下面可以写任何值association中column多参数配置：   column&#x3D;&quot;&#123;key&#x3D;value,key&#x3D;value&#125;&quot;   其实就是键值对的形式，key是传给下个sql的取值名称，value是片段一中sql查询的字段名。--&gt;&lt;select id&#x3D;&quot;getTeacher&quot; resultType&#x3D;&quot;teacher&quot;&gt;  select * from teacher where id &#x3D; #&#123;id&#125; and name &#x3D; #&#123;name&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testGetStudents()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   StudentMapper mapper &#x3D; session.getMapper(StudentMapper.class);   List&lt;Student&gt; students &#x3D; mapper.getStudents();   for (Student student : students)&#123;       System.out.println(               &quot;学生名:&quot;+ student.getName()                       +&quot;\t老师:&quot;+student.getTeacher().getName());  &#125;&#125;</code></pre></div><h2 id="10-3、按结果嵌套处理"><a href="#10-3、按结果嵌套处理" class="headerlink" title="10.3、按结果嵌套处理"></a>10.3、按结果嵌套处理</h2><p>除了上面这种方式，还有其他思路吗？</p><p>我们还可以按照结果进行嵌套处理；</p><ol><li><p>接口方法编写</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Student&gt; getStudents2();</code></pre></div></li><li><p>编写对应的mapper文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--按查询结果嵌套处理思路：   1. 直接查询出结果，进行结果集的映射--&gt;&lt;select id&#x3D;&quot;getStudents2&quot; resultMap&#x3D;&quot;StudentTeacher2&quot; &gt;  select s.id sid, s.name sname , t.name tname  from student s,teacher t  where s.tid &#x3D; t.id&lt;&#x2F;select&gt;&lt;resultMap id&#x3D;&quot;StudentTeacher2&quot; type&#x3D;&quot;Student&quot;&gt;   &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;sid&quot;&#x2F;&gt;   &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;sname&quot;&#x2F;&gt;   &lt;!--关联对象property 关联对象在Student实体类中的属性--&gt;   &lt;association property&#x3D;&quot;teacher&quot; javaType&#x3D;&quot;Teacher&quot;&gt;       &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;tname&quot;&#x2F;&gt;   &lt;&#x2F;association&gt;&lt;&#x2F;resultMap&gt;</code></pre></div></li><li><p>去mybatis-config文件中注入【此处应该处理过了】</p></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testGetStudents2()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   StudentMapper mapper &#x3D; session.getMapper(StudentMapper.class);   List&lt;Student&gt; students &#x3D; mapper.getStudents2();   for (Student student : students)&#123;       System.out.println(               &quot;学生名:&quot;+ student.getName()                       +&quot;\t老师:&quot;+student.getTeacher().getName());  &#125;&#125;</code></pre></div></li></ol><p><strong>小结</strong></p><p>按照查询进行嵌套处理就像SQL中的子查询</p><p>按照结果进行嵌套处理就像SQL中的联表查询</p><h1 id="11、一对多处理"><a href="#11、一对多处理" class="headerlink" title="11、一对多处理"></a>11、一对多处理</h1><p>一对多的理解：</p><ul><li>一个老师拥有多个学生</li><li>如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！</li></ul><p><strong>实体类编写</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Student &#123;   private int id;   private String name;   private int tid;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Teacher &#123;   private int id;   private String name;   &#x2F;&#x2F;一个老师多个学生   private List&lt;Student&gt; students;&#125;</code></pre></div><p>….. 和之前一样，搭建测试的环境！</p><h2 id="11-1、按结果嵌套处理"><a href="#11-1、按结果嵌套处理" class="headerlink" title="11.1、按结果嵌套处理"></a>11.1、按结果嵌套处理</h2><ol><li><p>TeacherMapper接口编写方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;获取指定老师，及老师下的所有学生public Teacher getTeacher(int id);</code></pre></div></li><li><p>编写接口对应的Mapper配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.TeacherMapper&quot;&gt;   &lt;!--   思路:       1. 从学生表和老师表中查出学生id，学生姓名，老师姓名       2. 对查询出来的操作做结果集映射           1. 集合的话，使用collection！               JavaType和ofType都是用来指定对象类型的               JavaType是用来指定pojo中属性的类型               ofType指定的是映射到list集合属性中pojo的类型。   --&gt;   &lt;select id&#x3D;&quot;getTeacher&quot; resultMap&#x3D;&quot;TeacherStudent&quot;&gt;      select s.id sid, s.name sname , t.name tname, t.id tid      from student s,teacher t      where s.tid &#x3D; t.id and t.id&#x3D;#&#123;id&#125;   &lt;&#x2F;select&gt;   &lt;resultMap id&#x3D;&quot;TeacherStudent&quot; type&#x3D;&quot;Teacher&quot;&gt;       &lt;result  property&#x3D;&quot;name&quot; column&#x3D;&quot;tname&quot;&#x2F;&gt;       &lt;collection property&#x3D;&quot;students&quot; ofType&#x3D;&quot;Student&quot;&gt;           &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;sid&quot; &#x2F;&gt;           &lt;result property&#x3D;&quot;name&quot; column&#x3D;&quot;sname&quot; &#x2F;&gt;           &lt;result property&#x3D;&quot;tid&quot; column&#x3D;&quot;tid&quot; &#x2F;&gt;       &lt;&#x2F;collection&gt;   &lt;&#x2F;resultMap&gt;&lt;&#x2F;mapper&gt;</code></pre></div></li><li><p>将Mapper文件注册到MyBatis-config文件中</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;mappers&gt;   &lt;mapper resource&#x3D;&quot;mapper&#x2F;TeacherMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div></li><li><p>测试</p></li></ol><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testGetTeacher()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   TeacherMapper mapper &#x3D; session.getMapper(TeacherMapper.class);   Teacher teacher &#x3D; mapper.getTeacher(1);   System.out.println(teacher.getName());   System.out.println(teacher.getStudents());&#125;</code></pre></div><h2 id="11-2、按查询嵌套处理"><a href="#11-2、按查询嵌套处理" class="headerlink" title="11.2、按查询嵌套处理"></a>11.2、按查询嵌套处理</h2><ol><li><p>TeacherMapper接口编写方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Teacher getTeacher2(int id);</code></pre></div></li><li><p>编写接口对应的Mapper配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;getTeacher2&quot; resultMap&#x3D;&quot;TeacherStudent2&quot;&gt;select * from teacher where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;&lt;resultMap id&#x3D;&quot;TeacherStudent2&quot; type&#x3D;&quot;Teacher&quot;&gt;   &lt;!--column是一对多的外键 , 写的是一的主键的列名--&gt;   &lt;collection property&#x3D;&quot;students&quot; javaType&#x3D;&quot;ArrayList&quot; ofType&#x3D;&quot;Student&quot; column&#x3D;&quot;id&quot; select&#x3D;&quot;getStudentByTeacherId&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt;&lt;select id&#x3D;&quot;getStudentByTeacherId&quot; resultType&#x3D;&quot;Student&quot;&gt;  select * from student where tid &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>将Mapper文件注册到MyBatis-config文件中</p></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testGetTeacher2()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   TeacherMapper mapper &#x3D; session.getMapper(TeacherMapper.class);   Teacher teacher &#x3D; mapper.getTeacher2(1);   System.out.println(teacher.getName());   System.out.println(teacher.getStudents());&#125;</code></pre></div></li></ol><p><strong>小结</strong></p><ol><li>关联-association</li><li>集合-collection</li><li>所以association是用于一对一和多对一，而collection是用于一对多的关系</li><li>JavaType和ofType都是用来指定对象类型的<ul><li>JavaType是用来指定pojo中属性的类型</li><li>ofType指定的是映射到list集合属性中pojo的类型。</li></ul></li></ol><p><strong>注意说明：</strong></p><ol><li>保证SQL的可读性，尽量通俗易懂</li><li>根据实际要求，尽量编写性能更高的SQL语句</li><li>注意属性名和字段不一致的问题</li><li>注意一对多和多对一 中：字段和属性对应的问题</li><li>尽量使用Log4j，通过日志来查看自己的错误</li></ol><p>一对多和多对一对于很多人来说是难点，一定要大量的做练习理解</p><h1 id="12、动态SQL"><a href="#12、动态SQL" class="headerlink" title="12、动态SQL"></a>12、动态SQL</h1><h2 id="12-1、介绍"><a href="#12-1、介绍" class="headerlink" title="12.1、介绍"></a>12.1、介绍</h2><p>什么是动态SQL：<strong>动态SQL指的是根据不同的查询条件 , 生成不同的Sql语句.</strong></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">官网描述：MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。  -------------------------------  - if  - choose (when, otherwise)  - trim (where, set)  - foreach  -------------------------------</code></pre></div><p>我们之前写的 SQL 语句都比较简单，如果有比较复杂的业务，我们需要写复杂的 SQL 语句，往往需要拼接，而拼接 SQL ，稍微不注意，由于引号，空格等缺失可能都会导致错误。</p><p>那么怎么去解决这个问题呢？这就要使用 mybatis 动态SQL，通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句，从而在提高 SQL 语句的准确性的同时，也大大提高了开发人员的效率。</p><h2 id="12-2、搭建环境"><a href="#12-2、搭建环境" class="headerlink" title="12.2、搭建环境"></a>12.2、搭建环境</h2><p><strong>新建一个数据库表：blog</strong></p><p>字段：id，title，author，create_time，views</p><div class="code-wrapper"><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE &#96;blog&#96; (&#96;id&#96; varchar(50) NOT NULL COMMENT &#39;博客id&#39;,&#96;title&#96; varchar(100) NOT NULL COMMENT &#39;博客标题&#39;,&#96;author&#96; varchar(30) NOT NULL COMMENT &#39;博客作者&#39;,&#96;create_time&#96; datetime NOT NULL COMMENT &#39;创建时间&#39;,&#96;views&#96; int(30) NOT NULL COMMENT &#39;浏览量&#39;) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</code></pre></div><ol><li><p>创建Mybatis基础工程</p></li><li><p>IDutil工具类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IDUtil &#123;   public static String genId()&#123;       return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);  &#125;&#125;</code></pre></div></li><li><p>实体类编写  【注意set方法作用】</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Date;public class Blog &#123;   private String id;   private String title;   private String author;   private Date createTime;   private int views;   &#x2F;&#x2F;set，get....&#125;</code></pre></div></li><li><p>编写Mapper接口及xml文件</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface BlogMapper &#123;&#125;</code></pre></div><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper       PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;       &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.kuang.mapper.BlogMapper&quot;&gt;&lt;&#x2F;mapper&gt;</code></pre></div></li><li><p>插入初始数据</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;settings&gt;   &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;   &lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;STDOUT_LOGGING&quot;&#x2F;&gt;&lt;&#x2F;settings&gt;&lt;!--注册Mapper.xml--&gt;&lt;mappers&gt; &lt;mapper resource&#x3D;&quot;mapper&#x2F;BlogMapper.xml&quot;&#x2F;&gt;&lt;&#x2F;mappers&gt;</code></pre></div></li><li><p>插入初始数据</p></li></ol><p>编写接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;新增一个博客int addBlog(Blog blog);</code></pre></div><p>sql配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;insert id&#x3D;&quot;addBlog&quot; parameterType&#x3D;&quot;blog&quot;&gt;  insert into blog (id, title, author, create_time, views)  values (#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;);&lt;&#x2F;insert&gt;</code></pre></div><p>初始化博客方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void addInitBlog()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);   Blog blog &#x3D; new Blog();   blog.setId(IDUtil.genId());   blog.setTitle(&quot;Mybatis如此简单&quot;);   blog.setAuthor(&quot;狂神说&quot;);   blog.setCreateTime(new Date());   blog.setViews(9999);   mapper.addBlog(blog);   blog.setId(IDUtil.genId());   blog.setTitle(&quot;Java如此简单&quot;);   mapper.addBlog(blog);   blog.setId(IDUtil.genId());   blog.setTitle(&quot;Spring如此简单&quot;);   mapper.addBlog(blog);   blog.setId(IDUtil.genId());   blog.setTitle(&quot;微服务如此简单&quot;);   mapper.addBlog(blog);   session.close();&#125;</code></pre></div><p>初始化数据完毕！</p><h2 id="12-3、if-语句"><a href="#12-3、if-语句" class="headerlink" title="12.3、if 语句"></a>12.3、if 语句</h2><p><strong>需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询</strong></p><ol><li><p>编写接口类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;需求1List&lt;Blog&gt; queryBlogIf(Map map);</code></pre></div></li><li><p>编写SQL语句</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--需求1：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询select * from blog where title &#x3D; #&#123;title&#125; and author &#x3D; #&#123;author&#125;--&gt;&lt;select id&#x3D;&quot;queryBlogIf&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;  select * from blog where   &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;      title &#x3D; #&#123;title&#125;   &lt;&#x2F;if&gt;   &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;      and author &#x3D; #&#123;author&#125;   &lt;&#x2F;if&gt;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryBlogIf()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);   HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();   map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;);   map.put(&quot;author&quot;,&quot;狂神说&quot;);   List&lt;Blog&gt; blogs &#x3D; mapper.queryBlogIf(map);   System.out.println(blogs);   session.close();&#125;</code></pre></div></li></ol><p>这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句！</p><h2 id="12-4、Where"><a href="#12-4、Where" class="headerlink" title="12.4、Where"></a>12.4、Where</h2><p>修改上面的SQL语句；</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;queryBlogIf&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;          title &#x3D; #&#123;title&#125;       &lt;&#x2F;if&gt;       &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;          and author &#x3D; #&#123;author&#125;       &lt;&#x2F;if&gt;   &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre></div><p>这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。</p><h2 id="12-5、Set"><a href="#12-5、Set" class="headerlink" title="12.5、Set"></a>12.5、Set</h2><p>同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？</p><ol><li><p>编写接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">int updateBlog(Map map);</code></pre></div></li><li><p>sql配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!--注意set是用的逗号隔开--&gt;&lt;update id&#x3D;&quot;updateBlog&quot; parameterType&#x3D;&quot;map&quot;&gt;  update blog     &lt;set&gt;         &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;            title &#x3D; #&#123;title&#125;,         &lt;&#x2F;if&gt;         &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;            author &#x3D; #&#123;author&#125;         &lt;&#x2F;if&gt;     &lt;&#x2F;set&gt;  where id &#x3D; #&#123;id&#125;;&lt;&#x2F;update&gt;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testUpdateBlog()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);   HashMap&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();   map.put(&quot;title&quot;,&quot;动态SQL&quot;);   map.put(&quot;author&quot;,&quot;秦疆&quot;);   map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;);   mapper.updateBlog(map);   session.close();&#125;</code></pre></div><h2 id="11-6、choose语句"><a href="#11-6、choose语句" class="headerlink" title="11.6、choose语句"></a>11.6、choose语句</h2></li></ol><p>有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句</p><ol><li><p>编写接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Blog&gt; queryBlogChoose(Map map);</code></pre></div></li><li><p>sql配置文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;queryBlogChoose&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;choose&gt;           &lt;when test&#x3D;&quot;title !&#x3D; null&quot;&gt;                title &#x3D; #&#123;title&#125;           &lt;&#x2F;when&gt;           &lt;when test&#x3D;&quot;author !&#x3D; null&quot;&gt;              and author &#x3D; #&#123;author&#125;           &lt;&#x2F;when&gt;           &lt;otherwise&gt;              and views &#x3D; #&#123;views&#125;           &lt;&#x2F;otherwise&gt;       &lt;&#x2F;choose&gt;   &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试类</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryBlogChoose()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);   HashMap&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();   map.put(&quot;title&quot;,&quot;Java如此简单&quot;);   map.put(&quot;author&quot;,&quot;狂神说&quot;);   map.put(&quot;views&quot;,9999);   List&lt;Blog&gt; blogs &#x3D; mapper.queryBlogChoose(map);   System.out.println(blogs);   session.close();&#125;</code></pre></div></li></ol><h2 id="12-6、SQL片段"><a href="#12-6、SQL片段" class="headerlink" title="12.6、SQL片段"></a>12.6、SQL片段</h2><p>有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。</p><p><strong>提取SQL片段：</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;sql id&#x3D;&quot;if-title-author&quot;&gt;   &lt;if test&#x3D;&quot;title !&#x3D; null&quot;&gt;      title &#x3D; #&#123;title&#125;   &lt;&#x2F;if&gt;   &lt;if test&#x3D;&quot;author !&#x3D; null&quot;&gt;      and author &#x3D; #&#123;author&#125;   &lt;&#x2F;if&gt;&lt;&#x2F;sql&gt;</code></pre></div><p><strong>引用SQL片段：</strong></p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;queryBlogIf&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt;       &lt;include refid&#x3D;&quot;if-title-author&quot;&gt;&lt;&#x2F;include&gt;       &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt;   &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre></div><p>注意：</p><p>①、最好基于 单表来定义 sql 片段，提高片段的可重用性</p><p>②、在 sql 片段中不要包括 where</p><h2 id="12-7、Foreach"><a href="#12-7、Foreach" class="headerlink" title="12.7、Foreach"></a>12.7、Foreach</h2><p>将数据库中前三个数据的id修改为1,2,3；</p><p>需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息</p><ol><li><p>编写接口</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;Blog&gt; queryBlogForeach(Map map);</code></pre></div></li><li><p>编写SQL语句</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;queryBlogForeach&quot; parameterType&#x3D;&quot;map&quot; resultType&#x3D;&quot;blog&quot;&gt;  select * from blog   &lt;where&gt;       &lt;!--       collection:指定输入对象中的集合属性       item:每次遍历生成的对象       open:开始遍历时的拼接字符串       close:结束时拼接的字符串       separator:遍历对象之间需要拼接的字符串       select * from blog where 1&#x3D;1 and (id&#x3D;1 or id&#x3D;2 or id&#x3D;3)     --&gt;       &lt;foreach collection&#x3D;&quot;ids&quot;  item&#x3D;&quot;id&quot; open&#x3D;&quot;and (&quot; close&#x3D;&quot;)&quot; separator&#x3D;&quot;or&quot;&gt;          id&#x3D;#&#123;id&#125;       &lt;&#x2F;foreach&gt;   &lt;&#x2F;where&gt;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryBlogForeach()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);   HashMap map &#x3D; new HashMap();   List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;Integer&gt;();   ids.add(1);   ids.add(2);   ids.add(3);   map.put(&quot;ids&quot;,ids);   List&lt;Blog&gt; blogs &#x3D; mapper.queryBlogForeach(map);   System.out.println(blogs);   session.close();&#125;</code></pre></div><p>小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。s</p></li></ol><h1 id="13、缓存"><a href="#13、缓存" class="headerlink" title="13、缓存"></a>13、缓存</h1><h2 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h2><p>1、什么是缓存 [ Cache ]？</p><ul><li>存在内存中的临时数据。</li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li></ul><p>2、为什么使用缓存？</p><ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率。</li></ul><p>3、什么样的数据能使用缓存？</p><ul><li>经常查询并且不经常改变的数据。</li></ul><h2 id="13-2、Mybatis缓存"><a href="#13-2、Mybatis缓存" class="headerlink" title="13.2、Mybatis缓存"></a>13.2、Mybatis缓存</h2><ul><li><p>MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。</p></li><li><p>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p></li><li><ul><li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）</li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li></ul></li></ul><h2 id="13-3、一级缓存"><a href="#13-3、一级缓存" class="headerlink" title="13.3、一级缓存"></a>13.3、一级缓存</h2><p>一级缓存也叫本地缓存：</p><ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中。</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库；</li></ul><p><strong>测试</strong></p><ol><li><p>在mybatis中加入日志，方便测试结果</p></li><li><p>编写接口方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;根据id查询用户User queryUserById(@Param(&quot;id&quot;) int id);</code></pre></div></li><li><p>接口对应的Mapper文件</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;select id&#x3D;&quot;queryUserById&quot; resultType&#x3D;&quot;user&quot;&gt;  select * from user where id &#x3D; #&#123;id&#125;&lt;&#x2F;select&gt;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   User user2 &#x3D; mapper.queryUserById(1);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session.close();&#125;</code></pre></div><p>5.结果分析</p></li></ol><p><img src="/myBlog/mybatis/image-20210622140854609.png" alt="image-20210622140854609"></p><p><strong>一级缓存失效的四种情况</strong></p><p>一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它；</p><p>一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！</p><ol><li><p>sqlSession不同</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   SqlSession session2 &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   UserMapper mapper2 &#x3D; session2.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   User user2 &#x3D; mapper2.queryUserById(1);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session.close();   session2.close();&#125;</code></pre></div><p>观察结果：发现发送了两条SQL语句！</p><p>结论：<strong>每个sqlSession中的缓存相互独立</strong></p></li><li><p>sqlSession相同，查询条件不同</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   UserMapper mapper2 &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   User user2 &#x3D; mapper2.queryUserById(2);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session.close();&#125;</code></pre></div><p>观察结果：发现发送了两条SQL语句！很正常的理解</p><p>结论：<strong>当前缓存中，不存在这个数据</strong></p></li><li><p>sqlSession相同，两次查询之间执行了增删改操作</p><p>增加方法</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;修改用户int updateUser(Map map);</code></pre></div><p>编写SQL</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;update id&#x3D;&quot;updateUser&quot; parameterType&#x3D;&quot;map&quot;&gt;  update user set name &#x3D; #&#123;name&#125; where id &#x3D; #&#123;id&#125;&lt;&#x2F;update&gt;</code></pre></div><p>测试</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   HashMap map &#x3D; new HashMap();   map.put(&quot;name&quot;,&quot;kuangshen&quot;);   map.put(&quot;id&quot;,4);   mapper.updateUser(map);   User user2 &#x3D; mapper.queryUserById(1);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session.close();&#125;</code></pre></div><p>观察结果：查询在中间执行了增删改操作后，重新执行了</p><p>结论：<strong>因为增删改操作可能会对当前数据产生影响</strong></p></li><li><p>sqlSession相同，手动清除一级缓存</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   session.clearCache();&#x2F;&#x2F;手动清除缓存   User user2 &#x3D; mapper.queryUserById(1);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session.close();&#125;</code></pre></div></li></ol><p>一级缓存就是一个map</p><h2 id="13-4、二级缓存"><a href="#13-4、二级缓存" class="headerlink" title="13.4、二级缓存"></a>13.4、二级缓存</h2><ul><li><p>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</p></li><li><p>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；</p></li><li><p>工作机制</p></li><li><ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中；</li><li>新的会话查询信息，就可以从二级缓存中获取内容；</li><li>不同的mapper查出的数据会放在自己对应的缓存（map）中；</li></ul></li></ul><p><strong>使用步骤</strong></p><ol><li><p>开启全局缓存 【mybatis-config.xml】</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</code></pre></div></li><li><p>去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;cache&#x2F;&gt;官方示例&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;查看官方文档&lt;cache eviction&#x3D;&quot;FIFO&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&#x2F;&gt;这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</code></pre></div></li><li><p>代码测试</p><ul><li>所有的实体类先实现序列化接口</li><li>测试代码</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Testpublic void testQueryUserById()&#123;   SqlSession session &#x3D; MybatisUtils.getSession();   SqlSession session2 &#x3D; MybatisUtils.getSession();   UserMapper mapper &#x3D; session.getMapper(UserMapper.class);   UserMapper mapper2 &#x3D; session2.getMapper(UserMapper.class);   User user &#x3D; mapper.queryUserById(1);   System.out.println(user);   session.close();   User user2 &#x3D; mapper2.queryUserById(1);   System.out.println(user2);   System.out.println(user&#x3D;&#x3D;user2);   session2.close();&#125;</code></pre></div></li></ol><p><strong>结论</strong></p><ul><li>只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据</li><li>查出的数据都会被默认先放在一级缓存中</li><li>只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中</li></ul><h2 id="13-5、缓存原理图"><a href="#13-5、缓存原理图" class="headerlink" title="13.5、缓存原理图"></a>13.5、缓存原理图</h2><p><img src="/myBlog/mybatis/image-20210622141444604.png" alt="image-20210622141444604"></p><h2 id="13-6、EhCache"><a href="#13-6、EhCache" class="headerlink" title="13.6、EhCache"></a>13.6、EhCache</h2><p>第三方缓存实现–EhCache: 查看百度百科</p><p>Ehcache是一种广泛使用的java分布式缓存，用于通用缓存；</p><p>要在应用程序中使用Ehcache，需要引入依赖的jar包</p><div class="code-wrapper"><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis.caches&#x2F;mybatis-ehcache --&gt;&lt;dependency&gt;   &lt;groupId&gt;org.mybatis.caches&lt;&#x2F;groupId&gt;   &lt;artifactId&gt;mybatis-ehcache&lt;&#x2F;artifactId&gt;   &lt;version&gt;1.1.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;在mapper.xml中使用对应的缓存即可&lt;mapper namespace &#x3D; “org.acme.FooMapper” &gt;   &lt;cache type &#x3D; “org.mybatis.caches.ehcache.EhcacheCache” &#x2F;&gt;&lt;&#x2F;mapper&gt;编写ehcache.xml文件，如果在加载时未找到&#x2F;ehcache.xml资源或出现问题，则将使用默认配置。&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;        xsi:noNamespaceSchemaLocation&#x3D;&quot;http:&#x2F;&#x2F;ehcache.org&#x2F;ehcache.xsd&quot;        updateCheck&#x3D;&quot;false&quot;&gt;   &lt;!--      diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：      user.home – 用户主目录      user.dir – 用户当前工作目录      java.io.tmpdir – 默认临时文件路径    --&gt;   &lt;diskStore path&#x3D;&quot;.&#x2F;tmpdir&#x2F;Tmp_EhCache&quot;&#x2F;&gt;      &lt;defaultCache           eternal&#x3D;&quot;false&quot;           maxElementsInMemory&#x3D;&quot;10000&quot;           overflowToDisk&#x3D;&quot;false&quot;           diskPersistent&#x3D;&quot;false&quot;           timeToIdleSeconds&#x3D;&quot;1800&quot;           timeToLiveSeconds&#x3D;&quot;259200&quot;           memoryStoreEvictionPolicy&#x3D;&quot;LRU&quot;&#x2F;&gt;   &lt;cache           name&#x3D;&quot;cloud_user&quot;           eternal&#x3D;&quot;false&quot;           maxElementsInMemory&#x3D;&quot;5000&quot;           overflowToDisk&#x3D;&quot;false&quot;           diskPersistent&#x3D;&quot;false&quot;           timeToIdleSeconds&#x3D;&quot;1800&quot;           timeToLiveSeconds&#x3D;&quot;1800&quot;           memoryStoreEvictionPolicy&#x3D;&quot;LRU&quot;&#x2F;&gt;   &lt;!--      defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。    --&gt;   &lt;!--     name:缓存名称。     maxElementsInMemory:缓存最大数目     maxElementsOnDisk：硬盘最大缓存个数。     eternal:对象是否永久有效，一但设置了，timeout将不起作用。     overflowToDisk:是否保存到磁盘，当系统当机时     timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal&#x3D;false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。     timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal&#x3D;false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。     diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.     diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。     diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。     memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     clearOnFlush：内存数量最大时是否清除。     memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。     FIFO，first in first out，这个是大家最熟的，先进先出。     LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。     LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。  --&gt;&lt;&#x2F;ehcache&gt;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
