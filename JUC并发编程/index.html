

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/myBlog/img/fluid.png">
  <link rel="icon" href="/myBlog/img/browserTitle.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Ten">
  <meta name="keywords" content="">
  
    <meta name="description" content="JUC并发编程JUC 概述简介在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。 进程和线程的概念进程（Process） 计算机中的程序关">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC并发编程">
<meta property="og:url" content="https://no-ten.github.io/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="TBlog">
<meta property="og:description" content="JUC并发编程JUC 概述简介在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。 进程和线程的概念进程（Process） 计算机中的程序关">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304115504390.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304150459745.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304170030914.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304202147809.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132103446.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132643455.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305134836146.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305164446445.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305171806962.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191058548.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191838834.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305192917090.png">
<meta property="og:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305193328989.png">
<meta property="article:published_time" content="2022-03-05T12:48:17.000Z">
<meta property="article:modified_time" content="2022-03-06T08:08:06.124Z">
<meta property="article:author" content="Ten">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://no-ten.github.io/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304115504390.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>JUC并发编程 - TBlog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/myBlog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/myBlog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/myBlog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"no-ten.github.io","root":"/myBlog/","version":"1.9.0","typing":{"enable":true,"typeSpeed":230,"cursorChar":"_","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/myBlog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/myBlog/js/utils.js" ></script>
  <script  src="/myBlog/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/myBlog/atom.xml" title="TBlog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/myBlog/">
      <strong>TBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/myBlog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/myBlog/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JUC并发编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Ten
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-05 20:48" pubdate>
          2022年3月5日晚上8点48分 
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JUC并发编程</h1>
            
            <div class="markdown-body">
              
              <h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h1 id="JUC-概述"><a href="#JUC-概述" class="headerlink" title="JUC 概述"></a>JUC 概述</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p>
<h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a>进程（Process）</h3><ul>
<li>计算机中的程序关于某数据集合上的一次运行活动</li>
<li>进程是线程的容器</li>
<li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li>
<li>系统进行资源分配和调度的基本单位，是操作系统结构的基础</li>
</ul>
<h3 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h3><ul>
<li>操作系统能够进行运算调度的最小单位</li>
<li>被包含在进程之中，是进程中的实际运作单位</li>
<li>一条线程指的是进程中一个单一顺序的控制流</li>
</ul>
<p>简单来说就是，进程是一个应用程序而线程就是一个应用程序里面的其他操作，一个应用程序可以包含多个线程。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程有5个状态，分别是NEW（新建）、RUNNABLE（准备就绪）、BLOCKED（阻塞）、WAITING（不见不散，一定得等到，不然不做其他的）、TIME-WAITING（过时不候：超过了时间就过去了）、TERMINATED（终结）。</p>
<h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><ol>
<li>sleep是Thead的静态方法，wait是Object里面的方法，wait可以被任意实例后的对象调用。</li>
<li>sleep不会释放锁，它也不需要占用锁，但是调用他的前提是当前线程占有锁（即需要再synchronize中）</li>
<li>他们都可以被interrupted中断。</li>
</ol>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发就是指在很短的一个时间段发生的事情，如到点抢票。</p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行就是指在同一时刻发生的事情。</p>
<h3 id="管程Monitor"><a href="#管程Monitor" class="headerlink" title="管程Monitor"></a>管程Monitor</h3><p>管程Monitor，<strong>监视器</strong>，也就是我们所说的<strong>锁</strong>，它是一种同步机制，保证同一个时间只有一个线程访问被保护数据或者代码，jvm同步基于进入和退出，使用管程对象实现的。</p>
<h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>自定义线程都是用户线程，主线程结束了，用户线程还在，jvm存活。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>系统特定的线程，比如垃圾回收，没有用户线程了，都是守护线程，jvm结束。</p>
<p><strong>测试用户进程和守护进程的代码</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DaemonAndUserProcess &#123;
    public static void main(String[] args) &#123;
        Thread aa &#x3D; new Thread(() -&gt; &#123;
            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + Thread.currentThread().isDaemon());
            while (true) &#123;

            &#125;
        &#125;, &quot;aa&quot;);
        &#x2F;&#x2F; 设置线程为守护线程
        aa.setDaemon(true);
        aa.start();     &#x2F;&#x2F; 开启线程
        System.out.println(Thread.currentThread().getName() + &quot; over&quot;);
    &#125;
&#125;</code></pre></div>



<h1 id="LOCK接口"><a href="#LOCK接口" class="headerlink" title="LOCK接口"></a>LOCK接口</h1><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>它是java中的关键字，是一种同步锁，它可以修饰以下几种：</p>
<ol>
<li>修改代码块，被修饰的代码块称为同步代码块，其作用范围就是大括号{}括起来的代码，作用对象就是调用这个代码的对象。</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用范围就是整个方法，作用的对象是调用这个方法的对象。</li>
<li>修饰静态方法</li>
<li>修饰一个类。</li>
</ol>
<h3 id="多线程编程步骤（上）"><a href="#多线程编程步骤（上）" class="headerlink" title="多线程编程步骤（上）"></a>多线程编程步骤（上）</h3><ol>
<li>创建资源类，编程属性和操作方法</li>
<li>创建多线程，调用资源类的方法</li>
</ol>
<h3 id="售票例子"><a href="#售票例子" class="headerlink" title="售票例子"></a>售票例子</h3><p>三个售票员，卖30张票</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.sync;

&#x2F;&#x2F; 第一步：创建资源类，编写属性和操作方法
class Ticket&#123;
    &#x2F;&#x2F; 定义票的数量
    private int number &#x3D; 30;
    &#x2F;&#x2F; 定义操作方法：卖票，得加锁synchronized
    public synchronized void sale()&#123;
        &#x2F;&#x2F; 判断是否有剩余的票
        if (number &gt; 0)&#123;
            System.out.println(Thread.currentThread().getName() + &quot; : 卖出了：&quot; + (number--) + &quot; 剩余：&quot; + number);
        &#125;
    &#125;
&#125;
public class SaleTicket &#123;
    &#x2F;&#x2F; 第二部：编写多线程，调用操作资源
    public static void main(String[] args) &#123;
        Ticket ticket &#x3D; new Ticket();
        &#x2F;&#x2F; 创建三个线程，利用匿名内部类
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                &#x2F;&#x2F; 编写操作
                for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                    ticket.sale();
                &#125;
            &#125;
        &#125;,&quot;AA&quot;).start();

        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                &#x2F;&#x2F; 编写操作
                for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                    ticket.sale();
                &#125;
            &#125;
        &#125;,&quot;BB&quot;).start();

        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                &#x2F;&#x2F; 编写操作
                for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                    ticket.sale();
                &#125;
            &#125;
        &#125;,&quot;CC&quot;).start();

    &#125;
&#125;</code></pre></div>

<h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><h3 id="什么是LOCK"><a href="#什么是LOCK" class="headerlink" title="什么是LOCK"></a>什么是LOCK</h3><p>LOCK锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。LOCK是一个类，可以通过这个类实现同步访问。</p>
<p><strong>LOCK和synchronized的不同</strong></p>
<ol>
<li>LOCK不是java内置的，synchronized是java语言的关键字。</li>
<li>LOCK需要用户手动去上锁和释放锁，synchronized不用，它会自动帮我们完成。</li>
<li>LOCK可以让等待的线程响应中断，而synchronized不能，使用synchronized的时候，需要一直等待下去，不能够响应中断</li>
<li>通过lock可以知道有没有成功上锁，而synchronized不行</li>
<li>lock可以提高多个线程读操作的效率。</li>
</ol>
<h3 id="ReentrantLock可重入锁"><a href="#ReentrantLock可重入锁" class="headerlink" title="ReentrantLock可重入锁"></a>ReentrantLock可重入锁</h3><p><strong>代码实现</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

import java.util.concurrent.locks.ReentrantLock;

&#x2F;&#x2F; 第一步：创建资源类，别写属性和操作方法
class LTicket&#123;
    private int number &#x3D; 30;
    &#x2F;&#x2F; 卖票：不用synchronized，用ReentrantLock
    ReentrantLock lock &#x3D; new ReentrantLock();
    public void sale()&#123;
        &#x2F;&#x2F; 为了让释放锁无论怎么都执行，所以代码有try finally包裹起来
        try &#123;
            &#x2F;&#x2F; 上锁
            lock.lock();
           if(number &gt; 0)&#123;
               System.out.println(Thread.currentThread().getName() + &quot; : 卖出了：&quot; + (number--) + &quot; 剩余：&quot; + number);
           &#125;
        &#125; finally &#123;
            &#x2F;&#x2F; 释放锁
            lock.unlock();
        &#125;
    &#125;
&#125;
public class LSaleTicket &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 第二步：创建多线程，调用操作方法
        LTicket lTicket &#x3D; new LTicket();
        &#x2F;&#x2F; 使用Lambda
        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                lTicket.sale();
            &#125;
        &#125;,&quot;AA&quot;).start();
        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                lTicket.sale();
            &#125;
        &#125;,&quot;BB&quot;).start();
        new Thread(() -&gt; &#123;
            for (int i &#x3D; 0; i &lt; 40; i++) &#123;
                lTicket.sale();
            &#125;
        &#125;,&quot;CC&quot;).start();
    &#125;
&#125;</code></pre></div>



<h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><h2 id="多线程编程步骤（中、下）"><a href="#多线程编程步骤（中、下）" class="headerlink" title="多线程编程步骤（中、下）"></a>多线程编程步骤（中、下）</h2><p>第一步 创建资源类，在资源类中创建属性和编写操作方法</p>
<p>第二步 在资源类中操作方法</p>
<ol>
<li>判断</li>
<li>干活</li>
<li>通知</li>
</ol>
<p>第三步 创建多个线程，调用资源类的操作方法。</p>
<p>第四步 <strong>防止虚假唤醒问题</strong></p>
<h2 id="利用synchronized"><a href="#利用synchronized" class="headerlink" title="利用synchronized"></a>利用synchronized</h2><p>实现如下。</p>
<p><strong>测试代码</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.sync;

&#x2F;&#x2F; 第一步：创建资源类，编写属性和操作方法
class Share &#123;
    private int number &#x3D; 0;
    &#x2F;&#x2F; 定义两个方法，一个加一，一个减一
    public synchronized void incr() throws InterruptedException &#123;
        &#x2F;&#x2F; 判断
        if(number !&#x3D; 0)&#123;
            this.wait();    &#x2F;&#x2F; 如果不等于0，则等待，wait特点在哪里等待就在哪里开始执行
        &#125;
        &#x2F;&#x2F; 干活
        &#x2F;&#x2F; 如果等于0了，加一
        number++;
        System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);
        &#x2F;&#x2F; 通知
        this.notifyAll();
    &#125;
    &#x2F;&#x2F; 减一
    public synchronized void decr() throws InterruptedException &#123;
        &#x2F;&#x2F; 判断
        if (number !&#x3D; 1)&#123;
            this.wait();
        &#125;
        &#x2F;&#x2F; 干活
        number--;
        System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);
        &#x2F;&#x2F; 通知
        this.notifyAll();
    &#125;
&#125;
public class TheadDemo1 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 第二步：创建多线程，调用操作资源
        Share share &#x3D; new Share();
        new Thread(() -&gt; &#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;
                try &#123;
                    share.incr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;AA&quot;).start();

        new Thread(() -&gt; &#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;
                try &#123;
                    share.decr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;BB&quot;).start();
    &#125;
&#125;</code></pre></div>

<p><strong>如果把上述的代码的多线程，再加两个CC和DD，则会出现不是1,0的结果。原因就是wait的特点是在哪里开始等待的就在哪里开始，wait需要用到循环中，即把if改成while循环，这个过程就是虚假唤醒。</strong></p>
<h2 id="用LOCK实现代码"><a href="#用LOCK实现代码" class="headerlink" title="用LOCK实现代码"></a><strong>用LOCK实现代码</strong></h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Share &#123;
    private int number &#x3D; 0;
    &#x2F;&#x2F; 利用LOCK实现
    private Lock lock &#x3D; new ReentrantLock();
    private Condition condition &#x3D; lock.newCondition();
    &#x2F;&#x2F; +1
    public void incr() throws InterruptedException &#123;
        &#x2F;&#x2F; 上锁
        lock.lock();
        try &#123;
            &#x2F;&#x2F; 判断 干活 通知
            while (number !&#x3D; 0)&#123;
                condition.await();
            &#125;
            number++;
            System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);
            condition.signalAll();
        &#125; finally &#123;
            &#x2F;&#x2F; 解锁
            lock.unlock();
        &#125;
    &#125;
    &#x2F;&#x2F; -1
    public void decr() throws InterruptedException &#123;
        &#x2F;&#x2F; 上锁
        lock.lock();
        try &#123;
            &#x2F;&#x2F; 判断 干活 通知
            while (number !&#x3D; 1)&#123;
                condition.await();
            &#125;
            number--;
            System.out.println(Thread.currentThread().getName() + &quot;当前number为 &quot; + number);
            condition.signalAll();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

public class ThreadDemo2 &#123;
    public static void main(String[] args) &#123;
        Share share &#x3D; new Share();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;
                try &#123;
                    share.incr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;AA&quot;).start();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;
                try &#123;
                    share.decr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;BB&quot;).start();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;
                try &#123;
                    share.incr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;CC&quot;).start();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;
                try &#123;
                    share.decr();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;DD&quot;).start();
    &#125;
&#125;</code></pre></div>



<h1 id="线程间定制化通信"><a href="#线程间定制化通信" class="headerlink" title="线程间定制化通信"></a>线程间定制化通信</h1><p> <img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304115504390.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220304115504390"></p>
<p>实现代码如下</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

&#x2F;&#x2F; 第一步：创建资源类
class ShareResource &#123;
    &#x2F;&#x2F; 标志位
    private int flag &#x3D; 1;   &#x2F;&#x2F; 1:AA,2:BB,3:CC

    &#x2F;&#x2F; 创建LOCK
    private Lock lock &#x3D; new ReentrantLock();

    &#x2F;&#x2F; 创建三个condition
    private Condition c1 &#x3D;lock.newCondition();
    private Condition c2 &#x3D;lock.newCondition();
    private Condition c3 &#x3D;lock.newCondition();

    &#x2F;&#x2F; 输出5次，loop为轮数
    public void print5(int loop) throws InterruptedException &#123;
        &#x2F;&#x2F; 上锁
        lock.lock();
        try &#123;
            &#x2F;&#x2F; 判断 干活 通知
            while (flag !&#x3D; 1)&#123;
                c1.await();
            &#125;
            for (int i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i+ &quot;: 轮数：&quot; +loop);
            &#125;
            &#x2F;&#x2F; 通知之前先修改标志位
            flag &#x3D; 2;
            &#x2F;&#x2F; 通知BB
            c2.signal();
        &#125; finally &#123;
            &#x2F;&#x2F; 解锁
            lock.unlock();
        &#125;
    &#125;
    &#x2F;&#x2F; 输出10次，loop为轮数
    public void print10(int loop) throws InterruptedException &#123;
        lock.lock();
        try &#123;
            &#x2F;&#x2F; 判断 干活 通知
            while (flag !&#x3D; 2)&#123;
                c2.await();
            &#125;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i + &quot;: 轮数：&quot; +loop);
            &#125;
            &#x2F;&#x2F; 通知之前先修改标志位
            flag &#x3D; 3;
            &#x2F;&#x2F; 通知CC
            c3.signal();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
    &#x2F;&#x2F; 输出15次，loop为轮数
    public void print15(int loop) throws InterruptedException &#123;
        lock.lock();
        try &#123;
            &#x2F;&#x2F; 判断 干活 通知
            while (flag !&#x3D; 3)&#123;
                c3.await();
            &#125;
            for (int i &#x3D; 1; i &lt;&#x3D; 15; i++) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;::&quot; +i + &quot;: 轮数：&quot; +loop);
            &#125;
            &#x2F;&#x2F; 通知之前先修改标志位
            flag &#x3D; 1;
            &#x2F;&#x2F; 通知AA
            c1.signal();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;
public class ThreadDemo3 &#123;
    public static void main(String[] args) &#123;
        ShareResource shareResource &#x3D; new ShareResource();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;
                try &#123;
                    shareResource.print5(i);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;AA&quot;).start();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;
                try &#123;
                    shareResource.print10(i);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;BB&quot;).start();
        new Thread(()-&gt;&#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 10; i++)&#123;
                try &#123;
                    shareResource.print15(i);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;,&quot;CC&quot;).start();
    &#125;
&#125;</code></pre></div>



<h1 id="集合的线程安全"><a href="#集合的线程安全" class="headerlink" title="集合的线程安全"></a>集合的线程安全</h1><h2 id="ArrayList异常演示"><a href="#ArrayList异常演示" class="headerlink" title="ArrayList异常演示"></a>ArrayList异常演示</h2><p>下面以list集合演示线程不安全的情况，会出现ConcurrentModificationException并发修改异常。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

&#x2F;**
 * list线程不安全的演示
 *&#x2F;
public class ThreadDemo4 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建list集合
        List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        for (int i &#x3D; 0; i &lt; 30; i++)&#123;
            new Thread(() -&gt;&#123;
                &#x2F;&#x2F; 生成随机数并添加到集合
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<p>为什么会出现这个异常，通过观察list.add的源码可以发现，list.add方没有synchronized修饰，即没有加锁。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;)
 *&#x2F;
public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!
    elementData[size++] &#x3D; e;
    return true;
&#125;</code></pre></div>



<h3 id="解决方案-Vector"><a href="#解决方案-Vector" class="headerlink" title="解决方案-Vector"></a>解决方案-Vector</h3><p>将上述的 List<String> list = new ArrayList&lt;&gt;();换成List<String> list = new Vector&lt;&gt;(); 再次进行测试，就不会报错了。通过观察Vector的源代码可以发现，add方法是有synchronized关键字修饰的，所以可以多线程修改。</String></String></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public synchronized void addElement(E obj) &#123;
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] &#x3D; obj;
&#125;</code></pre></div>

<h3 id="解决方案-Collections"><a href="#解决方案-Collections" class="headerlink" title="解决方案-Collections"></a>解决方案-Collections</h3><p>将list集合换成List<String> list = Collections.synchronizedList(new ArrayList&lt;&gt;()); 再次进行测试也可以实现，但是以上两种都是比较古老的实现方式，实际上不经常用。</String></p>
<h3 id="解决方案-CopyOnWriteArrayList"><a href="#解决方案-CopyOnWriteArrayList" class="headerlink" title="解决方案-CopyOnWriteArrayList"></a>解决方案-CopyOnWriteArrayList</h3><p>比较常用的多线程数组就是CopyOnWriteArrayList，他的实现的原理就是并发读，写的时候复制旧的数组内容，写完的时候再合并在一起。他的源码如下。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)
 *&#x2F;
public boolean add(E e) &#123;
    final ReentrantLock lock &#x3D; this.lock;
    lock.lock();	&#x2F;&#x2F; 上锁
    try &#123;
        Object[] elements &#x3D; getArray();		&#x2F;&#x2F; 获取数组
        int len &#x3D; elements.length;			&#x2F;&#x2F; 数组长度
        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);	&#x2F;&#x2F; 创建新的数组
        newElements[len] &#x3D; e;				&#x2F;&#x2F; 写入新元素
        setArray(newElements);				&#x2F;&#x2F; 合并
        return true;
    &#125; finally &#123;
        lock.unlock();						&#x2F;&#x2F; 解锁
    &#125;
&#125;</code></pre></div>

<p><strong>上述三种方案的所有代码</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

&#x2F;**
 * list线程不安全的演示
 *&#x2F;
public class ThreadDemo4 &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建list集合
        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();
        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; new Vector&lt;&gt;();   &#x2F;&#x2F; 利用Vector解决
        &#x2F;&#x2F;List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());  &#x2F;&#x2F; 用Collections解决
        List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();   &#x2F;&#x2F; 用CopyOnWriteArrayList解决
        for (int i &#x3D; 0; i &lt; 30; i++)&#123;
            new Thread(() -&gt;&#123;
                &#x2F;&#x2F; 生成随机数并添加到集合
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>

<h2 id="HashSet异常演示"><a href="#HashSet异常演示" class="headerlink" title="HashSet异常演示"></a>HashSet异常演示</h2><p>以下代码也产生了并发修改异常</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 演示HashSet线程不安全问题
Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();
for (int i &#x3D; 0; i &lt; 30; i++) &#123;
    new Thread(() -&gt; &#123;
        &#x2F;&#x2F; 生成随机数并添加到集合
        set.add(UUID.randomUUID().toString().substring(0, 8));
        System.out.println(set);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<h3 id="解决方案-CopyOnWriteArraySet"><a href="#解决方案-CopyOnWriteArraySet" class="headerlink" title="解决方案-CopyOnWriteArraySet"></a>解决方案-CopyOnWriteArraySet</h3><p>把set集合换成这个Set<String> set = new CopyOnWriteArraySet&lt;&gt;();就可以解决了</String></p>
<h2 id="HashMap异常演示"><a href="#HashMap异常演示" class="headerlink" title="HashMap异常演示"></a>HashMap异常演示</h2><p>以下代码也产生了并发修改异常</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 演示HashMap线程不安全问题
Map&lt;String,String&gt; map &#x3D; new HashMap&lt;&gt;();
for (int i &#x3D; 0; i &lt; 30; i++) &#123;
    String key &#x3D; String.valueOf(i);
    new Thread(() -&gt; &#123;
        &#x2F;&#x2F; 生成随机数并添加到集合
        map.put(key,UUID.randomUUID().toString().substring(0, 8));
        System.out.println(map);
    &#125;, String.valueOf(i)).start();
&#125;</code></pre></div>

<h3 id="解决方案-ConcurrentHashMap"><a href="#解决方案-ConcurrentHashMap" class="headerlink" title="解决方案-ConcurrentHashMap"></a>解决方案-ConcurrentHashMap</h3><p>将Map&lt;String,String&gt; map = new HashMap&lt;&gt;();换成Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;&gt;(); 利用ConcurrentHashMap解决。</p>
<h1 id="多线程锁"><a href="#多线程锁" class="headerlink" title="多线程锁"></a>多线程锁</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><strong>synchronized</strong></p>
<p>锁的是当前对象this</p>
<p><strong>static synchronized</strong></p>
<p>锁的是当前的Class。</p>
<p><strong>synchronized实现同步的基础</strong>：Java中的每一个对象都可以作为锁，具体表现为以下3中形式。</p>
<p>对于普通同步方法，锁是当前实例对象。</p>
<p>对于静态同步方法，锁是当前类的Class对象。</p>
<p>对于同步方法快，锁是synchronized括号里配置的对象。</p>
<h2 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h2><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>非公平锁可能会出现线程饿死的情况，它的效率高。</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁阳光普照，不会出现线程饿死的情况，但是它每次都要询问是否有人占用资源，所以它的效率较低。</p>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>通过查看ReentrantLock的源代码可以发现，在创建ReentrantLock的时候传入一个Boolean类型的参数即可，true为公平锁，false为非公平锁。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Creates an instance of &#123;@code ReentrantLock&#125;.
 * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.
 *&#x2F;
public ReentrantLock() &#123;
    sync &#x3D; new NonfairSync();
&#125;

&#x2F;**
 * Creates an instance of &#123;@code ReentrantLock&#125; with the
 * given fairness policy.
 *
 * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy
 *&#x2F;
public ReentrantLock(boolean fair) &#123;
    sync &#x3D; fair ? new FairSync() : new NonfairSync();
&#125;</code></pre></div>



<h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁也叫做<strong>递归锁</strong>，synchronized和lock都是可重入锁，<strong>synchronized</strong>是<strong>隐式</strong>的，<strong>lock</strong>是<strong>显式</strong>的。</p>
<h3 id="synchronized-1"><a href="#synchronized-1" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized的实现代码如下，外层开锁，里面的随便进入。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.lock;

public class SyncLockDemo &#123;
	&#x2F;&#x2F;public synchronized void add()&#123;
    &#x2F;&#x2F;    add();
   &#x2F;&#x2F; &#125;
    public static void main(String[] args) &#123;
      &#x2F;&#x2F;  new SyncLockDemo().add();
        Object o &#x3D; new Object();
        new Thread(() -&gt; &#123;
            synchronized (o) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;外层&quot;);
                synchronized (o) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;中层&quot;);
                    synchronized (o) &#123;
                        System.out.println(Thread.currentThread().getName() + &quot;内层&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;, &quot;t1&quot;).start();
    &#125;
&#125;</code></pre></div>

<h3 id="LOCK实现"><a href="#LOCK实现" class="headerlink" title="LOCK实现"></a>LOCK实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SyncLockDemo &#123;

    public static void main(String[] args) &#123;
        Lock lock &#x3D; new ReentrantLock();
        new Thread(()-&gt;&#123;
            try &#123;
                &#x2F;&#x2F; 上锁
                lock.lock();
                System.out.println(Thread.currentThread().getName()+&quot;外层&quot;);
                try &#123;
                    &#x2F;&#x2F; 上锁
                    lock.lock();
                    System.out.println(Thread.currentThread().getName()+&quot;内层&quot;);
                &#125; finally &#123;
                    &#x2F;&#x2F; 解锁
                    lock.unlock();
                &#125;
            &#125; finally &#123;
                &#x2F;&#x2F; 解锁
                lock.unlock();
            &#125;
        &#125;,&quot;AA&quot;).start();
    &#125;
&#125;</code></pre></div>

<p>所有的锁操作都要上锁和解锁，如果上述代码中的内层只上锁，没有解锁，只有他一个线程也可以运行，但是如果再加一个线程就不可以了，原因就是内层的锁没有释放，另一个线程继续等待锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>两个或者两个以上的进程在执行过程中，因为争夺资源而造成的一种相互等待的现象，如果没有外力干涉，他们无法在继续执行下去。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304150459745.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220304150459745"></p>
<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>系统资源不足</li>
<li>进程推进顺序不合适</li>
<li>资源分配不当</li>
</ol>
<h3 id="验证是否是死锁"><a href="#验证是否是死锁" class="headerlink" title="验证是否是死锁"></a>验证是否是死锁</h3><p>使用以下命令</p>
<ol>
<li><strong>jps -l</strong>：查出线程号，类似Linux的 ps -ef</li>
<li><strong>jstack+线程号</strong>：jvm自带堆栈跟踪工具</li>
</ol>
<div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">E:\IdeaProject_code\juc&gt;jps -l
11776 sun.tools.jps.Jps
8704 com.ten.juc.sync.DeadLock
11420
14572 org.jetbrains.jps.cmdline.Launcher

E:\IdeaProject_code\juc&gt;jstack 8704
2022-03-04 15:26:01
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):

&quot;DestroyJavaVM&quot; #14 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00000000032a2800 nid&#x3D;0x3a88 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

&quot;A&quot; #13 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001aa58000 nid&#x3D;0x368c waiting for monitor entry [0x000000001b43f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.ten.juc.sync.DeadLock.lambda$main$1(DeadLock.java:35)
        - waiting to lock &lt;0x00000000d9560470&gt; (a java.lang.Object)
        - locked &lt;0x00000000d9560480&gt; (a java.lang.Object)
        at com.ten.juc.sync.DeadLock$$Lambda$2&#x2F;1078694789.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

&quot;A&quot; #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x000000001aa51800 nid&#x3D;0x36b8 waiting for monitor entry [0x000000001b33f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.ten.juc.sync.DeadLock.lambda$main$0(DeadLock.java:22)
        - waiting to lock &lt;0x00000000d9560480&gt; (a java.lang.Object)
        - locked &lt;0x00000000d9560470&gt; (a java.lang.Object)
        at com.ten.juc.sync.DeadLock$$Lambda$1&#x2F;1324119927.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

...........


Found one Java-level deadlock:
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&quot;A&quot;:
  waiting to lock monitor 0x000000000339bd48 (object 0x00000000d9560470, a java.lang.Object),
  which is held by &quot;A&quot;
&quot;A&quot;:
  waiting to lock monitor 0x000000000339e3c8 (object 0x00000000d9560480, a java.lang.Object),
  which is held by &quot;A&quot;

Java stack information for the threads listed above:
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;
&quot;A&quot;:
        at com.ten.juc.sync.DeadLock.lambda$main$1(DeadLock.java:35)
        - waiting to lock &lt;0x00000000d9560470&gt; (a java.lang.Object)
        - locked &lt;0x00000000d9560480&gt; (a java.lang.Object)
        at com.ten.juc.sync.DeadLock$$Lambda$2&#x2F;1078694789.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)
&quot;A&quot;:
        at com.ten.juc.sync.DeadLock.lambda$main$0(DeadLock.java:22)
        - waiting to lock &lt;0x00000000d9560480&gt; (a java.lang.Object)
        - locked &lt;0x00000000d9560470&gt; (a java.lang.Object)
        at com.ten.juc.sync.DeadLock$$Lambda$1&#x2F;1324119927.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.
</code></pre></div>



<h1 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h1><h2 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h2><ol>
<li>继承Thead类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>线程池</li>
</ol>
<h2 id="Runnable和Callable的不同"><a href="#Runnable和Callable的不同" class="headerlink" title="Runnable和Callable的不同"></a>Runnable和Callable的不同</h2><ol>
<li>是否有返回值，Runnable没有返回值，Callable有返回值</li>
<li>没有结果是否会出现异常，Runnable不会，Callable会抛出异常</li>
<li>需要重写的方法不同，Runnable是run方法，Callable是call方法</li>
</ol>
<p>Callable不能直接使用，需要寻找一个类来作为中间商，这个中间商就是FutureTask实现类（未来任务）</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304170030914.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220304170030914"></p>
<h2 id="创建线程代码"><a href="#创建线程代码" class="headerlink" title="创建线程代码"></a>创建线程代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.callable;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

&#x2F;&#x2F; 用Runnable实现
class MyThread1 implements Runnable&#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;MyThread1&quot;);
    &#125;
&#125;
&#x2F;&#x2F; 用Callable实现
class MyThread2 implements Callable&lt;Integer&gt; &#123;

    @Override
    public Integer call() throws Exception &#123;
        return 200;
    &#125;
&#125;
public class CallableDemo &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        &#x2F;&#x2F; 使用Runnable方式
        new Thread(new MyThread1(),&quot;AA&quot;).start();

        &#x2F;&#x2F; 使用FutureTask 未来任务，返回值只计算一次，后面有用到就直接返回
        FutureTask&lt;Integer&gt; futureTask1 &#x3D; new FutureTask&lt;&gt;(new MyThread2());
        &#x2F;&#x2F; 使用lombda表达式
        FutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(()-&gt;&#123;
            return 1024;
        &#125;);

        new Thread(futureTask2,&quot;BB&quot;).start();
        while (!futureTask2.isDone())&#123;
            System.out.println(&quot;wait...&quot;);
        &#125;
        System.out.println(futureTask2.get());
        System.out.println(futureTask2.get());  &#x2F;&#x2F; 第二次直接返回结果，不用进行计算
        System.out.println(Thread.currentThread().getName() + &quot; come over&quot;);

    &#125;
&#125;</code></pre></div>



<h1 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h1><h2 id="减少计数CountDownLatch"><a href="#减少计数CountDownLatch" class="headerlink" title="减少计数CountDownLatch"></a>减少计数CountDownLatch</h2><p>CountDownLatch类可以设置一个计算器，通过countDown方法来减一，使用await方法等待计数器不大于0，然后继续执行await方法之后的语句。具体实现代码如下。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;

import java.util.concurrent.CountDownLatch;

&#x2F;&#x2F; 演示CountDownLatch
public class CountDownLatchDemo &#123;
    &#x2F;&#x2F; 6个同学陆续离开教室之后，班长锁门
    public static void main(String[] args) throws InterruptedException &#123;
        &#x2F;&#x2F; 创建CountDownLatch对象，设置初始值
        CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);
        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;
            new Thread(() -&gt;&#123;
                System.out.println(Thread.currentThread().getName() + &quot; 号 离开了教室&quot;);
                &#x2F;&#x2F; 操作一次就减一
                countDownLatch.countDown();
            &#125;,String.valueOf(i)).start();
        &#125;
        &#x2F;&#x2F; 如果不为0，就继续等待，如果为0了，就执行下面的输出
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + &quot;  over&quot;);
    &#125;
&#125;</code></pre></div>



<h2 id="循环栅栏CyclicBarrier"><a href="#循环栅栏CyclicBarrier" class="headerlink" title="循环栅栏CyclicBarrier"></a>循环栅栏CyclicBarrier</h2><p>CyclicBarrier的意思是循环阻塞的意思，在使用中CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后的语句。可以将CyclicBarrier理解为+1的操作。</p>
<p>实现代码如下</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;

import java.util.concurrent.CyclicBarrier;

&#x2F;&#x2F; 演示 CyclicBarrier 循环栅栏
public class CyclicBarrierDemo &#123;
    &#x2F;&#x2F; 定义常量
    private static final int NUMBER &#x3D; 7;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建CyclicBarrier对象
        CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(NUMBER,()-&gt;&#123;
            System.out.println(&quot;******7颗龙珠已集齐！！&quot;);
        &#125;);
        &#x2F;&#x2F; 收集七颗龙珠过程
        for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) &#123;
            new Thread(()-&gt;&#123;
                try &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;星龙珠已经收集了&quot;);
                    &#x2F;&#x2F; 等待
                    cyclicBarrier.await();
                &#125; catch (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>



<h2 id="信号灯Semaphore"><a href="#信号灯Semaphore" class="headerlink" title="信号灯Semaphore"></a>信号灯Semaphore</h2><p>当我们创建一个可扩展大小的线程池，并且需要在线程池内同时让有限数目的线程并发运行时，就需要用到Semaphore（信号灯机制），Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目，它是一个计数信号量，从概念上讲，信号量维护了一个许可集合，如有必要，在许可可用前会阻塞每一个acquire()，然后再获取该许可，每个release() 添加一个许可，从而可能释放一个正在阻塞的获取者。</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.juc;

import java.util.Random;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

&#x2F;&#x2F; 6辆汽车，停3个车位
public class SemaphoreDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 创建Semaphore，设置许可数量
        Semaphore semaphore &#x3D; new Semaphore(3);
        for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;
            new Thread(()-&gt;&#123;

                try &#123;
                    &#x2F;&#x2F; 占位
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot; 抢占了车位&quot;);

                    &#x2F;&#x2F; 等待
                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));

                    System.out.println(Thread.currentThread().getName() + &quot;----------离开了车位&quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    &#x2F;&#x2F; 释放
                    semaphore.release();
                &#125;
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>



<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>读写锁：一个资源可以被多个读线程访问，或者可以被一个写线程访问，但是不能同时存在读写线程，读写互斥，读读共享。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220304202147809.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220304202147809"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.readwrite;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

&#x2F;&#x2F; 创建资源类
class MyCatch&#123;
    &#x2F;&#x2F; 定义一个map，由于存储数据   因为涉及到取和读的次数比较多，所以用volatile
    private volatile Map&lt;String,Object&gt; map &#x3D; new HashMap&lt;&gt;();
    &#x2F;&#x2F; 定义读写锁
    private ReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();
    &#x2F;&#x2F; 存数据
    public void put(String key, Object value) &#123;
        &#x2F;&#x2F; 添加写锁
        readWriteLock.writeLock().lock();
        &#x2F;&#x2F; 暂停一会
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; 正在写数据&quot; + key);
            TimeUnit.MILLISECONDS.sleep(300);
            &#x2F;&#x2F; 写入
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + &quot; 已写完&quot; + key);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            &#x2F;&#x2F; 释放写锁
            readWriteLock.writeLock().unlock();
        &#125;

    &#125;
    &#x2F;&#x2F; 取数据
    public Object get(String key)  &#123;
        Object result &#x3D; null;
        &#x2F;&#x2F; 添加读锁
        readWriteLock.readLock().lock();
        &#x2F;&#x2F; 暂停一会
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot; 正在读取数据&quot; + key);
            TimeUnit.MILLISECONDS.sleep(300);
            &#x2F;&#x2F; 取数据
            result &#x3D; map.get(key);
            System.out.println(Thread.currentThread().getName() + &quot; 已读完&quot; + key);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            &#x2F;&#x2F; 释放读锁
            readWriteLock.readLock().unlock();
        &#125;
        return result;
    &#125;
&#125;
public class ReadWriteLockDemo &#123;
    public static void main(String[] args) &#123;
        MyCatch myCatch &#x3D; new MyCatch();
        &#x2F;&#x2F; 先存5个
        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;
            final int num &#x3D; i;
            new Thread(() -&gt;&#123;
                myCatch.put(num+&quot;&quot;,num);
            &#125;,String.valueOf(i)).start();
        &#125;
        &#x2F;&#x2F; 读取5个
        for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)&#123;
            final int num &#x3D; i;
            new Thread(() -&gt;&#123;
                myCatch.get(num+&quot;&quot;);
            &#125;,String.valueOf(i)).start();
        &#125;
    &#125;
&#125;</code></pre></div>



<h2 id="读写锁的演变"><a href="#读写锁的演变" class="headerlink" title="读写锁的演变"></a>读写锁的演变</h2><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132103446.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305132103446"></p>
<h2 id="读写锁的降级"><a href="#读写锁的降级" class="headerlink" title="读写锁的降级"></a>读写锁的降级</h2><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305132643455.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305132643455"></p>
<h2 id="读写锁降级代码演示"><a href="#读写锁降级代码演示" class="headerlink" title="读写锁降级代码演示"></a><strong>读写锁降级代码演示</strong></h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.readwrite;

import java.util.concurrent.locks.ReentrantReadWriteLock;

&#x2F;&#x2F; 读写锁的降级
public class Demotion &#123;
    public static void main(String[] args) &#123;
        ReentrantReadWriteLock readWriteLock &#x3D; new ReentrantReadWriteLock();
        ReentrantReadWriteLock.WriteLock writeLock &#x3D; readWriteLock.writeLock(); &#x2F;&#x2F; 写锁
        ReentrantReadWriteLock.ReadLock readLock &#x3D; readWriteLock.readLock();    &#x2F;&#x2F; 读锁

        &#x2F;&#x2F; 写锁
        writeLock.lock();
        System.out.println(&quot;write----------&quot;);

        &#x2F;&#x2F; 读锁
        readLock.lock();
        System.out.println(&quot;read&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);

        &#x2F;&#x2F; 释放写锁
        writeLock.unlock();
        &#x2F;&#x2F; 释放读锁
        readLock.unlock();
    &#125;
&#125;</code></pre></div>



<h1 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h1><h2 id="概述和架构"><a href="#概述和架构" class="headerlink" title="概述和架构"></a>概述和架构</h2><p>阻塞队列是一个共享队列，先进先出。当队列是空的时候，从队列中取元素会被阻塞，当队列满了，从队列中添加元素会别阻塞。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305134836146.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305134836146"></p>
<h2 id="分类和核心方法介绍"><a href="#分类和核心方法介绍" class="headerlink" title="分类和核心方法介绍"></a>分类和核心方法介绍</h2><h3 id="ArrayBlockiingQueue（常用）"><a href="#ArrayBlockiingQueue（常用）" class="headerlink" title="ArrayBlockiingQueue（常用）"></a>ArrayBlockiingQueue（常用）</h3><p>由数组结构组成的有界阻塞队列</p>
<h3 id="LinkedBlockingQueue（常用）"><a href="#LinkedBlockingQueue（常用）" class="headerlink" title="LinkedBlockingQueue（常用）"></a>LinkedBlockingQueue（常用）</h3><p>由链表结构组成的阻塞队列。大小默认为integer.MAX_VALUE</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>使用优先级队列实现的延迟无界阻塞队列。</p>
<h3 id="PrioriityBlockingQueue"><a href="#PrioriityBlockingQueue" class="headerlink" title="PrioriityBlockingQueue"></a>PrioriityBlockingQueue</h3><p>支持优先级排序的无界阻塞队列。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>不存储元素的阻塞队列，也即单个元素的队列。</p>
<h3 id="LinkedTranferQueue"><a href="#LinkedTranferQueue" class="headerlink" title="LinkedTranferQueue"></a>LinkedTranferQueue</h3><p>由链表组成的无界阻塞队列。</p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>有链表组成的双向阻塞队列。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305164446445.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305164446445"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动唤起。</li>
</ol>
<h1 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池 ThreadPool"></a>线程池 ThreadPool</h1><h2 id="概述和架构-1"><a href="#概述和架构-1" class="headerlink" title="概述和架构"></a>概述和架构</h2><p>线程池，是一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护者多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建于销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>
<p><strong>线程池优势</strong>：线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创将后自动启动这些线程任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会销毁系统资源，还回降低系统的稳定性，使用线程池可以统一的分配，调优和监控。</li>
<li>java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</li>
</ul>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305171806962.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305171806962"></p>
<h2 id="使用方式和底层原理"><a href="#使用方式和底层原理" class="headerlink" title="使用方式和底层原理"></a>使用方式和底层原理</h2><h3 id="newFixedThreadPoll（常用）"><a href="#newFixedThreadPoll（常用）" class="headerlink" title="newFixedThreadPoll（常用）"></a>newFixedThreadPoll（常用）</h3><p><strong>作用：</strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。</p>
<p><strong>特征：</strong></p>
<ul>
<li>线程池中的线程处于一定的量，可以很好的控制线程的并发量。</li>
<li>线程可以重复被使用，在显示关闭之前，都将一直存在。</li>
<li>超出一定量的线程被提交时候需要在队列中等待。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.pool;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

&#x2F;&#x2F; 常见的创建线程池
public class ThreadPoolDemo &#123;
    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 一池多线程
        &#x2F;&#x2F;ExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(5);

        &#x2F;&#x2F; 一池一线程
        &#x2F;&#x2F;ExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();

        &#x2F;&#x2F; 可扩容线程池
        ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();
        try &#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;
                &#x2F;&#x2F; 执行
                threadPool3.execute(()-&gt;&#123;
                    System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);
                &#125;);
            &#125;
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            &#x2F;&#x2F; 释放资源
            threadPool3.shutdown();
        &#125;
    &#125;
&#125;</code></pre></div>



<p>通过观察这三种创建线程池方式源码可以发现，底层都是由ThreadPoolExecutor创建的。</p>
<h3 id="ThreadPoolExecutor的7个参数"><a href="#ThreadPoolExecutor的7个参数" class="headerlink" title="ThreadPoolExecutor的7个参数"></a>ThreadPoolExecutor的7个参数</h3><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191058548.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305191058548"></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>主线程启动后，执行execute()方法，创建线程池（执行executor()之后才创建），假设最大线程数是5个，常住线程数是2，阻塞队列是3个。当常驻线程数1，2满了，后面来的3,4,5的就被安排到阻塞队列，如果这时还来了第6,7,8个，则启动线程池的其他三个没用的线程，直接给他们用，如果第9个来了，这个时候所有的线程和阻塞队列都满了，则执行handler的拒绝策略。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305191838834.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305191838834"></p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305192917090.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305192917090"></p>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>实际上都会用自定义线程池。</p>
<p><img src="/myBlog/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220305193328989.png" srcset="/myBlog/img/loading.gif" lazyload alt="image-20220305193328989"></p>
<p><strong>代码演示</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.pool;

import java.util.concurrent.*;

&#x2F;&#x2F; 自定义线程池
public class ThreadPoolDemo2 &#123;
    public static void main(String[] args) &#123;
        ExecutorService threadPool &#x3D; new ThreadPoolExecutor(
                2,
                5,
                2L,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(3),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        try &#123;
            for (int i &#x3D; 1; i &lt;&#x3D; 20; i++) &#123;
                &#x2F;&#x2F; 执行
                threadPool.execute(()-&gt;&#123;
                    System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);
                &#125;);
            &#125;
        &#125; catch (Exception e)&#123;
            e.printStackTrace();
        &#125; finally &#123;
            &#x2F;&#x2F; 释放资源
            threadPool.shutdown();
        &#125;
    &#125;
&#125;</code></pre></div>



<h1 id="Fork-Join-分支合并框架"><a href="#Fork-Join-分支合并框架" class="headerlink" title="Fork/Join 分支合并框架"></a>Fork/Join 分支合并框架</h1><p>Fork/Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork/Join框架要完成两件事情：</p>
<p>Fork：把一个复杂任务进行分拆，大事化小。</p>
<p>Join：把拆分任务的结果进行合并</p>
<p><strong>代码演示</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.forkjoin;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

&#x2F;&#x2F; 演示分支合并
class MyTask extends RecursiveTask&lt;Integer&gt;&#123;
    private static final  int VALUE &#x3D; 10;    &#x2F;&#x2F; 定义一个常量，用于判断两个数相加是否大于10
    private int begin;  &#x2F;&#x2F; 开始的
    private int end;    &#x2F;&#x2F; 结束的
    private int result; &#x2F;&#x2F; 返回的结果

    &#x2F;&#x2F; 构造方法
    public MyTask(int begin,int end)&#123;
        this.begin &#x3D; begin;
        this.end &#x3D; end;
    &#125;
    @Override
    protected Integer compute() &#123;
        &#x2F;&#x2F; 如果他们相减小于10，则直接相加
        if((end - begin) &lt;&#x3D; VALUE)&#123;
            for (int i &#x3D; begin; i &lt;&#x3D; end; i++)&#123;
                result &#x3D; result + i;
            &#125;
        &#125; else &#123;
            &#x2F;&#x2F; 否则拆分
            &#x2F;&#x2F; 计算中间的值
            int middle &#x3D; (begin + end) &#x2F; 2;
            &#x2F;&#x2F; 向左拆分
            MyTask task1 &#x3D; new MyTask(begin, middle);
            &#x2F;&#x2F; 向右拆分
            MyTask task2 &#x3D; new MyTask(middle + 1, end);
            &#x2F;&#x2F; 拆分
            task1.fork();
            task2.fork();

            &#x2F;&#x2F; 合并
            result &#x3D; task1.join() + task2.join();
        &#125;
        return result;
    &#125;
&#125;
public class ForkJoinDemo &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        &#x2F;&#x2F; 创建任务对象
        MyTask myTask &#x3D; new MyTask(0, 100);
        &#x2F;&#x2F; 创建ForkJoinPool对象
        ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();
        ForkJoinTask&lt;Integer&gt; forkJoinTask &#x3D; forkJoinPool.submit(myTask);
        &#x2F;&#x2F; 获取最终合并到的结果
        Integer result &#x3D; forkJoinTask.get();
        System.out.println(result);
        &#x2F;&#x2F; 关闭池对象
        forkJoinPool.shutdown();

    &#125;
&#125;</code></pre></div>



<h1 id="CompletableFuture-异步回调"><a href="#CompletableFuture-异步回调" class="headerlink" title="CompletableFuture 异步回调"></a>CompletableFuture 异步回调</h1><p>runAsync： 没有返回值</p>
<p>supplyAsync：有返回值</p>
<p>代码演示</p>
<div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.ten.juc.completable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
&#x2F;&#x2F; 异步调用
public class CompletableFutureDemo &#123;
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        &#x2F;&#x2F; 异步调用 没有返回值
        CompletableFuture&lt;Void&gt; completableFuture1 &#x3D; CompletableFuture.runAsync(()-&gt;&#123;
            System.out.println(Thread.currentThread().getName() + &quot; --- completableFuture1&quot;);
        &#125;);
        completableFuture1.get();

        &#x2F;&#x2F; 异步调用 有返回值
        CompletableFuture&lt;Integer&gt; completableFuture2 &#x3D; CompletableFuture.supplyAsync(() -&gt;&#123;
            System.out.println(Thread.currentThread().getName() + &quot; --- completableFuture2&quot;);
            &#x2F;&#x2F; 模拟异常
            int i &#x3D; 1 &#x2F; 0;
            return 1024;
        &#125;);
        completableFuture2.whenComplete((t,u) -&gt; &#123;
            System.out.println(&quot;--------t&#x3D;&quot; +t);    &#x2F;&#x2F; 返回值
            System.out.println(&quot;--------u&#x3D;&quot; +u);    &#x2F;&#x2F; 异常
        &#125;).get();
    &#125;
&#125;</code></pre></div>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/myBlog/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="category-chain-item">JUC并发编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/myBlog/tags/JUC/">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JUC并发编程</div>
      <div>https://no-ten.github.io/JUC并发编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Ten</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月5日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/myBlog/postgresql%E7%AC%94%E8%AE%B0/" title="postgresql笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">postgresql笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/myBlog/SpringSecurity%E7%AC%94%E8%AE%B0/" title="SpringSecurity笔记">
                        <span class="hidden-mobile">SpringSecurity笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/myBlog/js/events.js" ></script>
<script  src="/myBlog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/myBlog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.26.0/components/prism-core.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.26.0/plugins/autoloader/prism-autoloader.min.js" ></script>

  <script  src="https://lib.baomitu.com/prism/1.26.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/myBlog/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/myBlog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
